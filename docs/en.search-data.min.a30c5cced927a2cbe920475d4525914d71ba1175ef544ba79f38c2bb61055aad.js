'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/ldsctrlest/docs/','title':"LDS C+E Documentation",'section':"LDS Control \u0026 Estimation",'content':"LDS Control \u0026amp; Estimation Documentation #  "});index.add({'id':1,'href':'/ldsctrlest/docs/tutorials/','title':"LDS C+E Examples",'section':"LDS C+E Documentation",'content':"Examples #  "});index.add({'id':2,'href':'/ldsctrlest/acknowledgements/','title':"Acknowledgements",'section':"LDS Control \u0026 Estimation",'content':"Acknowledgements #  Development and publication of this library was supported in part by the NIH/NINDS Collaborative Research in Computational Neuroscience (CRCNS)/BRAIN Grant 5R01NS115327-02.\n"});index.add({'id':3,'href':'/ldsctrlest/docs/getting-started/','title':"Getting Started",'section':"LDS C+E Documentation",'content':"Downloading the Library #  The source code for this library can be downloaded from stanley-rozell/ldsCtrlEst either by downloading a snapshot or cloning the repository via git.\ngit clone https://github.com/stanley-rozell/ldsCtrlEst.git By default, this would check out the master branch. In most cases, we suggest downloading or checking out the latest release instead.\ncd /path/to/ldsCtrlEst git checkout 0.5.0 Dependencies #  Note that the primary dependencies of this project listed below must be installed along with their header files and with CMake config files or pkg-config files. The latter files are used to configure this project\u0026rsquo;s build. It is strongly encouraged to install the dependencies below using a package manager (e.g., apt, pacman, macports).\n For project configuration, install cmake as well as pkg-config. The latter is optional. The linear algebra library armadillo is used throughout this repository. The HDF5 library is used to save output from example test programs. For use of this library in Matlab executables (mex) on Linux operating systems, you will need OpenBlas, ensuring the static library libopenblas.a is installed. You will also need to install gfortran.  Compilation + Installation #  This project is configured/compiled/installed by way of CMake and (on Unix-based operating systems) GNU Make. For configuration with CMake, there are three available options.\n LDSCTRLEST_BUILD_EXAMPLES : [default= ON] whether to build example programs located under examples/ in the source tree LDSCTRLEST_BUILD_FIT : [default=OFF] whether to build the auxiliary fitting portion of the source code that is not pertinent to control implementation LDSCTRLEST_BUILD_STATIC : [default=OFF] whether to statically link against OpenBLAS and create a static ldsCtrlEst library for future use  n.b., If both options 2 and 3 are enabled, Matlab/Octave mex functions will be compiled for exposing some of the fitting functionality to Matlab/Octave.\nBelow are example usages of cmake/make to configure/build the library.\n  For basic project build \u0026amp; install\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake .. #configure build make #build the project sudo make install #[optional] installs to default location (OS-specific)   To set the install prefix\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DCMAKE_INSTALL_PREFIX=/your/install/prefix .. #configure build with chosen install location make #build the project make install #install to /your/install/prefix   To build the entire project including fit code, a static library for Matlab compatibility, and the included Matlab mex functions for fitting GLDS/PLDS models.\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DLDSCTRLEST_BUILD_FIT=1 -DLDSCTRLEST_STATIC_OPENBLAS=1 .. #configure to build the fitting portion of library and statically link openblas and ldsCtrlEst to mex files make #build the project n.b., If you choose not to install the library or install it to the non-default location, ensure you have updated the following environment variables on Unix-based operating systems.\n LD_LIBRARY_PATH: search path for dynamically loaded libraries PKG_CONFIG_PATH: search path for pkg-config tool CMAKE_PREFIX_PATH: search path of prefix where CMake will look for package config files  e.g., Assuming you set -DCMAKE_INSTALL_PREFIX=/your/install/prefix during project configuration and your login shell uses the ~/.profile startup file, open ~/.profile in a text editor and add \u0026hellip;\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/your/install/prefix/lib export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix/lib/pkgconfig export CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix   Common issues #   \u0026ldquo;I have installed all the dependencies including gfortran with a package manager as suggested; however, cmake complains it cannot find the gfortran library.\u0026rdquo;  When gfortran is installed, its library is usually not installed in a standard location like /usr/lib. gfortran is part of the gcc suite, so their libraries are organized together. e.g., When you install gfortran on Ubuntu using apt, its location is /usr/lib/gcc/x86_64-linux-gnu/9, in the case that gcc version 9 is installed. The build configuration script in ldsCtrlEst is written to add LD_LIBRARY_PATH (Unix) or PATH (Windows) to the CMake library search path on Unix or Windows systems, respectively. Therefore, to fix this issue, simply add the directory in which libgfortran was installed to the OS-appropriate environment variable. Continuing with the Ubuntu example above and assuming a Unix login shell whose startup file is ~/.profile, add the following to the file.\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/gcc/x86_64-linux-gnu/9 \u0026ldquo;I have built the library and installed it in a non-default location. In building my own project linking against ldsCtrlEst, cmake or pkg-config cannot find the library or its configuration information.\u0026rdquo;  If cmake and/or pkg-config cannot find the required configuration files for your project to link against ldsCtrlEst, make sure that these utilities know to look for them in the non-default location where you installed the library. For cmake this means adding your chosen install prefix to the environment variable CMAKE_PREFIX_PATH. Similarly, for pkg-config you need to add your/install/prefix/lib/pkgconfig to its search path, PKG_CONFIG_PATH. Assuming a Unix shell whose login startup file is ~/.profile and ldsCtrlEst was installed using prefix your/install/prefix, add the following to .profile.\nexport CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix "});index.add({'id':4,'href':'/ldsctrlest/docs/terminology/model/','title':"Model",'section':"LDS C+E Documentation",'content':"Model Definitions #  This library provides methods for control and estimation of linear dynamical systems (LDS) of the following form:   \\[\\mathbf{x}_{t\u0026#43;1} = f\\left( \\mathbf{x}_{t}, \\mathbf{v}_{t} \\right) = \\mathbf{A} \\mathbf{x}_{t} \u0026#43; \\mathbf{B} \\mathbf{v}_{t} \u0026#43; \\mathbf{m}_{t} \u0026#43; \\mathbf{w}_{t}\\]   \\[\\mathbf{y}_{t} = h\\left( \\mathbf{x}_{t} \\right)\\]  t : time index x : system state v = g%u : input (e.g., in physical units used for model fit) u : control signal sent to actuator (e.g., in Volts) y : system output m : process disturbance w ~ N(0, Q) : process noise/disturbance A : state matrix B : input coupling matrix g : input gain (e.g., for converting to control signal actuator voltage) n.b., assumes this conversion is linear Q : process noise covariance % : element-wise multiplication  LDS with Gaussian Observations #  For linear dynamical systems whose outputs are assumed to be corrupted by additive Gaussian noise before measurement (Gaussian LDS models), the output function takes the following form.\n \\[\\mathbf{y}_{t} = \\mathbf{C} \\mathbf{x}_{t} \u0026#43; \\mathbf{d}\\]   \\[\\mathbf{z}_{t} \\sim \\mathcal{N}\\left(\\mathbf{y}_{t} , \\mathbf{R} \\right)\\]  z : measurement C : output matrix d : output bias R : measurement noise covariance  LDS with Poisson Observations #  For linear dynamical systems whose outputs are assumed to be rates underlying measured count data derived from a Poisson distribution (Poisson LDS models), the output function takes the following form. Note an element-wise exponentiation is used to rectify the linear dynamics for the rate of the Poisson process.\n \\[y_{t}^{i} = \\exp \\left(\\mathbf{c}^i \\mathbf{x}_{t} \u0026#43; d^i\\right)\\]   \\[z_{t}^i \\sim \\rm{Poisson} \\left(y_{t}^i \\right)\\]  i : output index z : measurement (count data) c : i^th row of output matrix d : output bias  "});index.add({'id':5,'href':'/ldsctrlest/issues-contributing/','title':"Issues Contributing",'section':"LDS Control \u0026 Estimation",'content':"Reporting Issues #  If you encounter bugs when using this library or have specific feature requests that you believe fall within the stated scope of this project, please open an issue on GitHub and use an appropriate issue template where possible. You may also fork the repository and submit pull-requests with your suggested changes.\nContributing #  We welcome any community contributions to this project. Please fork the repository and if possible use clang-format and clang-tidy to conform to the coding format/style of this repository.\n"});index.add({'id':6,'href':'/ldsctrlest/docs/api/namespaces/namespacearmamexc/','title':"armamexc",'section':"Namespaces",'content':"armamexc #  arma/mex interface using Matlab C API More\u0026hellip; Functions #      Name     template \u0026lt;class T \u0026gt; auto m2T_scalar(const mxArray * matlab_scalar)\nConvert Matlab mxArray to scalar of type T.   template \u0026lt;class T \u0026gt; auto m2a_mat(const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true)\nConvert matlab matrix to armadillo.   auto a2m_mat(arma::Mat\u0026lt; double \u0026gt; const \u0026amp; arma_mat)\nConvert armadillo to matlab matrix.   auto a2m_vec(arma::Col\u0026lt; double \u0026gt; const \u0026amp; arma_vec)\nConvert armadillo to matlab vector.    Detailed Description #  Utilities for arma/mex interface using Matlab C API\nFunction Details #  m2T_scalar #  template \u0026lt;class T \u0026gt; inline auto m2T_scalar( const mxArray * matlab_scalar ) Parameters:\n matlab_scalar matlab scalar  Template Parameters:\n T type  Return: scalar of type T\nm2a_mat #  template \u0026lt;class T \u0026gt; inline auto m2a_mat( const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true ) Parameters:\n matlab_mat matlab matrix copy_aux_mem [optional] whether to copy auxiliary memory strict [optional] strictly enforce the above  Template Parameters:\n T type  Return: armadillo matrix of type T\na2m_mat #  inline auto a2m_mat( arma::Mat\u0026lt; double \u0026gt; const \u0026amp; arma_mat ) Parameters:\n arma_mat armadillo matrix  Return: matlab matrix\na2m_vec #  inline auto a2m_vec( arma::Col\u0026lt; double \u0026gt; const \u0026amp; arma_vec ) Parameters:\n arma_vec armadillo vector  Return: matlab vector\n Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':7,'href':'/ldsctrlest/docs/api/namespaces/namespacearmamexcpp/','title':"armamexcpp",'section':"Namespaces",'content':"armamexcpp #  arma/mex interface using Matlab C++ API More\u0026hellip; Functions #      Name     template \u0026lt;class T \u0026gt; auto m2a_cellmat(matlab::data::CellArray \u0026amp; matlab_cell)\nConvert matlab cell array to vector of armadillo matrices.   template \u0026lt;class T \u0026gt; auto m2s_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array)\nConvert matlab matrix to a vector of scalars.   template \u0026lt;class T \u0026gt; auto m2a_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo vector.   template \u0026lt;class T \u0026gt; auto m2a_mat(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo matrix.   template \u0026lt;class T \u0026gt; auto a2m_mat(arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab matrix.   template \u0026lt;class T \u0026gt; auto a2m_vec(arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab vector.   template \u0026lt;class T \u0026gt; auto s2m_vec(std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert vector of scalar T to matlab matrix.    Detailed Description #  utilities for arma/mex interface using Matlab C++ API\nFunction Details #  m2a_cellmat #  template \u0026lt;class T \u0026gt; auto m2a_cellmat( matlab::data::CellArray \u0026amp; matlab_cell ) Parameters:\n matlab_cell matlab cell  Template Parameters:\n T type  Return: vector of armadillo matrices of type T\nm2s_vec #  template \u0026lt;class T \u0026gt; auto m2s_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array ) Parameters:\n matlab_array matlab array  Template Parameters:\n T type  Return: vector of type T\nm2a_vec #  template \u0026lt;class T \u0026gt; auto m2a_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\n matlab_array matlab array  Template Parameters:\n T type  Return: armadillo vector of type T\nm2a_mat #  template \u0026lt;class T \u0026gt; auto m2a_mat( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\n matlab_array matlab matrix  Template Parameters:\n T type  Return: armadillo matrix of type T\na2m_mat #  template \u0026lt;class T \u0026gt; auto a2m_mat( arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n arma_mat arma matrix factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\na2m_vec #  template \u0026lt;class T \u0026gt; auto a2m_vec( arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n arma_vec armadillo vector factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\ns2m_vec #  template \u0026lt;class T \u0026gt; auto s2m_vec( std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n std_vec standard vector factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\n Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':8,'href':'/ldsctrlest/docs/api/files/dir_4fef79e7177ba769987a8da36c892c5f/','title':"build",'section':"Files",'content':"build #  Directories #     Name     include     Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':9,'href':'/ldsctrlest/docs/api/classes/','title':"Classes",'section':"LDS C+E Documentation",'content':"Classes #    lds::fit_t LDS Fit Type.\n  lds::gaussian::ctrl_t GLDS Controller Type.\n  lds::gaussian::emFit_t GLDS E-M Fit Type.\n  lds::gaussian::fit_t GLDS Fit Type.\n  lds::gaussian::sctrl_t Switched GLDS Controller Type.\n  lds::gaussian::ssidFit_t GLDS SSID Fit Type.\n  lds::gaussian::sys_t Gaussian LDS Type.\n  lds::poisson::ctrl_t PLDS Controller Type.\n  lds::poisson::fit_t PLDS Fit Type.\n  lds::poisson::sctrl_t Switched PLDS Controller Type.\n  lds::poisson::ssidFit_t GLDS SSID Fit Type.\n  lds::poisson::sys_t Poisson LDS Type.\n  lds::sys_t Linear Dynamical System Type.\n   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':10,'href':'/ldsctrlest/docs/api/modules/group__control__masks/','title':"Control Mode Bit Masks",'section':"Modules",'content':"Control Mode Bit Masks #  \nMore\u0026hellip; Attributes #      Name     const std::size_t CONTROL_TYPE_U   const std::size_t CONTROL_TYPE_INTY   const std::size_t CONTROL_TYPE_ADAPT_M Control setpoint adapted with (re-estimated) process disturbance m.    Detailed Description #  Control mode bit masks. These can be bit-wise OR\u0026rsquo;d to use in combination.\nAttribute Details #  CONTROL_TYPE_U #  static const std::size_t CONTROL_TYPE_U = 0x1; Control was designed to penalize change in input (i.e., the state was augmented with input u)\nCONTROL_TYPE_INTY #  static const std::size_t CONTROL_TYPE_INTY = CONTROL_TYPE_U \u0026lt;\u0026lt; 1; Control using integral action (i.e., the state was augmented with output y during design)\nCONTROL_TYPE_ADAPT_M #  static const std::size_t CONTROL_TYPE_ADAPT_M = CONTROL_TYPE_U \u0026lt;\u0026lt; 2;  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':11,'href':'/ldsctrlest/docs/api/modules/group__defaults/','title':"Defaults",'section':"Modules",'content':"Defaults #  \nMore\u0026hellip; Attributes #      Name     data_t DEFAULT_P0   data_t DEFAULT_Q0   data_t DEFAULT_R0   std::vector\u0026lt; data_t \u0026gt; DEFAULT_T0   data_t DATA_T_ZERO   data_t DATA_T_ONE   data_t DEFAULT_SOFTSTART   bool FALSE   bool TRUE    Detailed Description #  Default values for common variables (e.g., default diagonal elements of covariances in case there is need to resolve dimension mismatch)\nAttribute Details #  DEFAULT_P0 #  static data_t DEFAULT_P0 = 1e-6; DEFAULT_Q0 #  static data_t DEFAULT_Q0 = 1e-6; DEFAULT_R0 #  static data_t DEFAULT_R0 = 1e-2; DEFAULT_T0 #  static std::vector\u0026lt; data_t \u0026gt; DEFAULT_T0 = std::vector\u0026lt;data_t\u0026gt;(1, 0.0); DATA_T_ZERO #  static data_t DATA_T_ZERO = (data_t)0; DATA_T_ONE #  static data_t DATA_T_ONE = (data_t)1; DEFAULT_SOFTSTART #  static data_t DEFAULT_SOFTSTART = (data_t)0; FALSE #  static bool FALSE = false; TRUE #  static bool TRUE = true;  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':12,'href':'/ldsctrlest/docs/api/examples/eg_glds_ctrl_8cpp-example/','title':"eg_glds_ctrl.cpp",'section':"Examples",'content':"eg_glds_ctrl.cpp #  example GLDS control\n//===-- eg_glds_ctrl.cpp - Example GLDS Control ---------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS Control ********** \\n\\n\u0026#34;; bool do_adaptive_set_point = false; // adapts set point with re-estimated process disturbance  // Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30.0/dt); // no time steps for simulation.  // Control variables: Reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  vector\u0026lt;data_t\u0026gt; y_ref0(n_y, 20.0 * dt); // (Can either use arma::Mat or mats flattened into std::vector)  vector\u0026lt;data_t\u0026gt; kx(n_u * n_x, 100); // gains on state error  vector\u0026lt;data_t\u0026gt; kinty(n_u * n_y, 1e3); // gains on integrated output err  // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); armaMat b_true = armaMat(n_x, n_u, arma::fill::zeros); b_true[0] = 5e-4; size_t which_m = 0; //\u0026lt; whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; //\u0026lt; probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; vector\u0026lt;data_t\u0026gt; m0_true(n_y, m_low); // initially let m be low  vector\u0026lt;data_t\u0026gt; g_true(n_y, 10.0); // input unit conversion e.g., V -\u0026gt; mW/mm2  // output noise covariance  armaMat r_true(n_y, n_y, arma::fill::eye); r_true *= 1e-4; // construct grouth truth system to be controlled...  lds::gaussian::sys_t controlled_system(n_u, n_x, n_y, dt); // Assign params.  controlled_system.setA(a_true); controlled_system.setB(b_true); controlled_system.setM(m0_true); controlled_system.setG(g_true); controlled_system.setR(r_true); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  // Like before, these params can either be arma matrices/vectors or can be  // (flattened) std vectors  armaMat b_controller = armaMat(n_x, n_u, arma::fill::zeros).fill(4e-4); armaVec g_controller = armaVec(n_u, arma::fill::ones).fill(10); // V -\u0026gt; mW/mm2  // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  armaVec g_design = armaVec(n_u, arma::fill::ones).fill(9); armaVec m_controller = armaVec(n_x, arma::fill::zeros); // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  glds::ctrl_t controller(n_u, n_x, n_y, u_lb, u_ub, dt); // Adaptively re-estimate process disturance (m)  controller.adaptM = true; // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::CONTROL_TYPE_ADAPT_M; } else { // use integral action to minimize DC error  control_type = control_type | lds::CONTROL_TYPE_INTY; } controller.setControlType(control_type); // Assign params.  // **n.b. using arbitrary defaults for Q, R in this example. Really,  // these should be set by users.**  controller.setYRef(y_ref0); controller.setKc_x(kx); controller.setKc_inty(kinty); controller.setA(a_true); controller.setB(b_controller); controller.setM(m_controller); controller.setG(g_controller); controller.setGDesign(g_design); // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-8; controller.setQ_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // get initial val  y_hat.submat(0, 0, n_y - 1, 0) = controller.getY(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.getY(); x_hat.submat(0, 0, n_x - 1, 0) = controller.getX(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.getX(); m_hat.submat(0, 0, n_x - 1, 0) = controller.getM(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.getM(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.setM(m0_true); // input  armaVec u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_t(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_t); // This method uses a steady-state solution to control problem to calculate  // xRef, uRef from reference output yRef. Therefore, it is only applicable  // to regulation problems or cases where reference trajectory changes slowly  // compared to system dynamics.  controller.steadyState_fbCtrl(z_t); // save the signals  y_true.col(t) = controlled_system.getY(); x_true.col(t) = controlled_system.getX(); m_true.col(t) = controlled_system.getM(); y_hat.col(t) = controller.getY(); x_hat.col(t) = controller.getX(); m_hat.col(t) = controller.getM(); u.col(t) = controller.getU(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; } Filename: eg_glds_ctrl.cpp\n Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':13,'href':'/ldsctrlest/docs/api/examples/','title':"Examples",'section':"LDS C+E Documentation",'content':"Examples #   eg_glds_ctrl.cpp example GLDS control   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':14,'href':'/ldsctrlest/docs/api/files/dir_d28a4824dc47e487b107a5db32ef43c4/','title':"examples",'section':"Files",'content':"examples #  Files #     Name     examples/eg_glds_ctrl.cpp   examples/eg_plds_est.cpp   examples/eg_plds_logLinCtrl.cpp   examples/eg_plds_switched_logLinCtrl.cpp     Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':15,'href':'/ldsctrlest/docs/api/files/eg__glds__ctrl_8cpp/','title':"examples/eg_glds_ctrl.cpp",'section':"Files",'content':"examples/eg_glds_ctrl.cpp #  Functions #      Name     auto main()    Function Details #  main #  auto main() Going to simulate a switching disturbance (m) acting on system\nSource code #  //===-- eg_glds_ctrl.cpp - Example GLDS Control ---------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS Control ********** \\n\\n\u0026#34;; bool do_adaptive_set_point = false; // adapts set point with re-estimated process disturbance  // Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30.0/dt); // no time steps for simulation.  // Control variables: Reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  vector\u0026lt;data_t\u0026gt; y_ref0(n_y, 20.0 * dt); // (Can either use arma::Mat or mats flattened into std::vector)  vector\u0026lt;data_t\u0026gt; kx(n_u * n_x, 100); // gains on state error  vector\u0026lt;data_t\u0026gt; kinty(n_u * n_y, 1e3); // gains on integrated output err  // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); armaMat b_true = armaMat(n_x, n_u, arma::fill::zeros); b_true[0] = 5e-4; size_t which_m = 0; //\u0026lt; whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; //\u0026lt; probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; vector\u0026lt;data_t\u0026gt; m0_true(n_y, m_low); // initially let m be low  vector\u0026lt;data_t\u0026gt; g_true(n_y, 10.0); // input unit conversion e.g., V -\u0026gt; mW/mm2  // output noise covariance  armaMat r_true(n_y, n_y, arma::fill::eye); r_true *= 1e-4; // construct grouth truth system to be controlled...  lds::gaussian::sys_t controlled_system(n_u, n_x, n_y, dt); // Assign params.  controlled_system.setA(a_true); controlled_system.setB(b_true); controlled_system.setM(m0_true); controlled_system.setG(g_true); controlled_system.setR(r_true); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  // Like before, these params can either be arma matrices/vectors or can be  // (flattened) std vectors  armaMat b_controller = armaMat(n_x, n_u, arma::fill::zeros).fill(4e-4); armaVec g_controller = armaVec(n_u, arma::fill::ones).fill(10); // V -\u0026gt; mW/mm2  // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  armaVec g_design = armaVec(n_u, arma::fill::ones).fill(9); armaVec m_controller = armaVec(n_x, arma::fill::zeros); // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  glds::ctrl_t controller(n_u, n_x, n_y, u_lb, u_ub, dt); // Adaptively re-estimate process disturance (m)  controller.adaptM = true; // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::CONTROL_TYPE_ADAPT_M; } else { // use integral action to minimize DC error  control_type = control_type | lds::CONTROL_TYPE_INTY; } controller.setControlType(control_type); // Assign params.  // **n.b. using arbitrary defaults for Q, R in this example. Really,  // these should be set by users.**  controller.setYRef(y_ref0); controller.setKc_x(kx); controller.setKc_inty(kinty); controller.setA(a_true); controller.setB(b_controller); controller.setM(m_controller); controller.setG(g_controller); controller.setGDesign(g_design); // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-8; controller.setQ_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // get initial val  y_hat.submat(0, 0, n_y - 1, 0) = controller.getY(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.getY(); x_hat.submat(0, 0, n_x - 1, 0) = controller.getX(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.getX(); m_hat.submat(0, 0, n_x - 1, 0) = controller.getM(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.getM(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.setM(m0_true); // input  armaVec u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_t(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_t); // This method uses a steady-state solution to control problem to calculate  // xRef, uRef from reference output yRef. Therefore, it is only applicable  // to regulation problems or cases where reference trajectory changes slowly  // compared to system dynamics.  controller.steadyState_fbCtrl(z_t); // save the signals  y_true.col(t) = controlled_system.getY(); x_true.col(t) = controlled_system.getX(); m_true.col(t) = controlled_system.getM(); y_hat.col(t) = controller.getY(); x_hat.col(t) = controller.getX(); m_hat.col(t) = controller.getM(); u.col(t) = controller.getU(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;test_glds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; }  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':16,'href':'/ldsctrlest/docs/api/files/eg__plds__est_8cpp/','title':"examples/eg_plds_est.cpp",'section':"Files",'content':"examples/eg_plds_est.cpp #  Functions #      Name     auto smooth(armaMat \u0026amp; x, data_t tau, data_t dt)   auto armaVec2stdVec(armaVec x)   int main(void )    Function Details #  smooth #  auto smooth( armaMat \u0026amp; x, data_t tau, data_t dt ) armaVec2stdVec #  auto armaVec2stdVec( armaVec x ) main #  int main( void ) Source code #  #include \u0026lt;iostream\u0026gt;#include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace plds; // for smoothing things.. auto smooth(armaMat\u0026amp; x, data_t tau, data_t dt) -\u0026gt; armaMat; auto armaVec2stdVec(armaVec x) -\u0026gt; stdVec { return arma::conv_to\u0026lt;stdVec\u0026gt;::from(x); }; int main(void) { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Estimation ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t nU = 1; size_t nX = 1; size_t nY = 1; data_t q0_true = 1e-10; data_t q0 = 1e-10; data_t p0 = 1e-9; armaMat aArma_true = armaMat(nX, nX, fill::eye); aArma_true[0] = exp(-dt / 0.075); armaMat bArma_true = armaMat(nX, nU, fill::eye); bArma_true[0] = 5e-2; armaMat cArma_true = armaMat(nY, nX, fill::zeros); cArma_true[0] = 1; armaVec x0Arma_true = armaVec(nX, fill::zeros); x0Arma_true.fill(-7); data_t m = -7e-2; armaVec mArma_true = armaVec(nX, fill::zeros); mArma_true.fill(m); size_t K = (size_t)180.0 / dt; // time steps for simulation.  // true system...  sys_t sys_true(nU, nX, nY, dt, p0, q0_true); // test the re-assignment method..  sys_true = sys_t(nU, nX, nY, dt, p0, q0_true); // Assign params.  sys_true.setA(aArma_true); sys_true.setB(bArma_true); sys_true.setC(cArma_true); sys_true.setX0(x0Arma_true); sys_true.setM(mArma_true); sys_true.reset(); // augment sys_true to let params vary  // sys_true.augment();  // Fake measurements  armaMat z(nY, K, fill::zeros); // Fake stimlus.  armaMat u(nU, K, arma::fill::zeros); // randu);  // u.randu(); //For some reason, bus error.  u.randn(); // need to do this first.  u.randu(nU, K); data_t tau_u = 0.002; u = smooth(u, tau_u, dt); sys_t sys(nU, nX, nY, dt, p0, q0); // Create *incorrect* model.  armaVec gSys = sys_true.getG(); armaVec mSys = sys_true.getM() * 1.25; sys.setG(gSys); sys.setM(mSys); sys.reset(); sys.adaptM = true; armaMat Q = sys.getQ(); Q.diag().fill(1e-8); sys.setQ(Q); armaMat Q_m = sys.getQ_m(); Q_m.diag().fill(1e-8); sys.setQ_m(Q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys_hat:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create vectors  stdVec aVec = armaVec2stdVec(vectorise(sys_true.getA())); stdVec bVec = armaVec2stdVec(vectorise(sys_true.getB())); stdVec cVec = armaVec2stdVec(vectorise(sys_true.getC())); stdVec qVec = armaVec2stdVec(vectorise(Q)); stdVec x0Vec = armaVec2stdVec(sys_true.getX0()); stdVec gVec = armaVec2stdVec(sys.getG()); stdVec mVec = armaVec2stdVec(sys.getM()); // assign params.  sys.setDims(nU, nX, nY); sys.setA(aVec); sys.setB(bVec); sys.setQ(qVec); sys.setX0(x0Vec); sys.setC(cVec); sys.setM(mVec); sys.setG(gVec); sys.reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys_hat:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create matrix to save outputs in...  armaMat lambda_hat = armaMat(nY, K, fill::zeros); armaMat lambda_true = armaMat(nY, K, fill::zeros); // states and gain/bias params  armaMat x_hat = armaMat(nX, K, fill::zeros); armaMat m_hat = armaMat(nX, K, fill::zeros); armaMat x_true = armaMat(nX, K, fill::zeros); armaMat m_true = armaMat(nY, K, fill::zeros); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; K * dt \u0026lt;\u0026lt; \u0026#34; sec simlation ... \\n\u0026#34;; auto start = chrono::high_resolution_clock::now(); for (size_t k = 0; k \u0026lt; K; k++) { // Assign params (uncomment to simlate online conditions)  sys.setDims(nU, nX, nY); sys.setA(aVec); sys.setB(bVec); sys.setQ(qVec); sys.setX0(x0Vec); sys.setC(cVec); sys.setM(mVec); sys.setG(gVec); //  // input  armaVec u_k = armaVec(u.colptr(k), u.n_rows, false, false); // Simlate the true system.  sys_true.setU(u_k); sys_true.simPredict(); // generate a measurement  armaVec z_k = armaVec(z.colptr(k), z.n_rows, false, false); sys_true.simMeasurement(z_k); // filter (predict -\u0026gt; update)  sys.filter(z_k); lambda_hat.submat(0, k, nY - 1, k) = sys.getY(); lambda_true.submat(0, k, nY - 1, k) = sys_true.getY(); x_true.submat(0, k, nX - 1, k) = sys_true.getX(); m_true.submat(0, k, nY - 1, k) = sys_true.getM(); x_hat.submat(0, k, nX - 1, k) = sys.getX(); m_hat.submat(0, k, nY - 1, k) = sys.getM(); // for next time.  sys.setU(u_k); } auto finish = chrono::high_resolution_clock::now(); chrono::duration\u0026lt;data_t, milli\u0026gt; simTime_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simlation in \u0026#34; \u0026lt;\u0026lt; simTime_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (simTime_ms.count() / K) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;test_plds_est.h5\u0026#34;, \u0026#34;dt\u0026#34;)); u.save(arma::hdf5_name(\u0026#34;test_plds_est.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;test_plds_est.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;test_plds_est.h5\u0026#34;, \u0026#34;xTrue\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;test_plds_est.h5\u0026#34;, \u0026#34;mTrue\u0026#34;, replace)); lambda_true.save(arma::hdf5_name(\u0026#34;test_plds_est.h5\u0026#34;, \u0026#34;lambdaTrue\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;test_plds_est.h5\u0026#34;, \u0026#34;xHat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;test_plds_est.h5\u0026#34;, \u0026#34;mHat\u0026#34;, replace)); lambda_hat.save(arma::hdf5_name(\u0026#34;test_plds_est.h5\u0026#34;, \u0026#34;lambdaHat\u0026#34;, replace)); return 0; } auto smooth(armaMat\u0026amp; x, data_t tau, data_t dt) -\u0026gt; armaMat { size_t K = x.n_cols; data_t a = exp(-dt / tau); data_t b = 1.0 - a; armaMat y = armaMat(size(x), fill::zeros); y.col(K - 1) = x.col(K - 1); for (size_t k = (K - 2); k == 0; k--) { y.col(k) = a * y.col(k + 1) + b * x.col(k); } for (size_t k = 1; k \u0026lt; K; k++) { y.col(k) = a * y.col(k - 1) + b * x.col(k); } return y; }  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':17,'href':'/ldsctrlest/docs/api/files/eg__plds__log_lin_ctrl_8cpp/','title':"examples/eg_plds_logLinCtrl.cpp",'section':"Files",'content':"examples/eg_plds_logLinCtrl.cpp #  Functions #      Name     auto armaVec2stdVec(armaVec x)   auto main(void )    Function Details #  armaVec2stdVec #  auto armaVec2stdVec( armaVec x ) main #  auto main( void ) Source code #  #include \u0026lt;chrono\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace plds; auto armaVec2stdVec(armaVec x) -\u0026gt; stdVec { return arma::conv_to\u0026lt;stdVec\u0026gt;::from(x); }; auto main(void) -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34;********** Testing LDS C++ library. ********** \\n\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;********** Poisson ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t nU = 1; size_t nX = 1; size_t nY = 1; data_t q0_true = 1e-12; data_t q0 = 1e-10; data_t p0 = 1e-9; // Going to hard-code values from a real fit (pooled 9/16/16 + 9/20/16 rat  // data)  armaMat aArma_true = armaMat(nX, nX, fill::eye); aArma_true[0] = 0.986; // exp(-dt/0.075);  armaMat bArma_true = armaMat(nX, nU, fill::eye); bArma_true[0] = 0.027 * 2; // simulate switching fr  size_t frState = 0; data_t mLo_true = log(1 * dt) * (1 - aArma_true[0]); data_t prLo2Hi = 1e-3; data_t mHi_true = log(20 * dt) * (1 - aArma_true[0]); data_t prHi2Lo = prLo2Hi / 2; stdVec mVec_true = stdVec(nY, mLo_true); stdVec gVec_true = stdVec(nY, 1.0); size_t K = (size_t)30.0 / dt; // time steps for simulation.  // true system...  sys_t sys_true(nU, nX, nY, dt, p0, q0_true); // test the re-assignment method..  sys_true = sys_t(nU, nX, nY, dt, p0, q0_true); // Assign params.  sys_true.setA(aArma_true); sys_true.setB(bArma_true); sys_true.setM(mVec_true); sys_true.setG(gVec_true); // armaVec x0_true = inv(armaMat(nX,nX,fill::eye) -  // sys_true.getA())*sys_true.getM();  armaVec x0_true(nX); x0_true.fill(log(20 * dt)); sys_true.setX0(x0_true); sys_true.reset(); // control vars  // Going to take the steady-state vals...  stdVec Kc_xVec = stdVec(nU * nX, 1); stdVec Kc_intyVec = stdVec(nU * nY, 25); stdVec xRefVec = stdVec(nX, log(20.0 * dt)); stdVec yRefVec = stdVec(nY, 20.0 * dt); // the more uncorrelated noise, the less biased parameter estiarmaMates will  // be...  data_t uSigma = 0e-3; // Fake measurements  armaMat z(nY, K, fill::zeros); // Will later contain control.  armaMat u(nU, K, fill::zeros); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys_true:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys_true.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create *incorrect* model.  armaVec gSys = armaVec(nU, fill::zeros).fill(gVec_true[0]); armaVec mSys = armaVec(nY, fill::zeros).fill(mLo_true); data_t uLB = 0.0; data_t uUB = 5.0; ctrl_t sys(nU, nX, nY, uLB, uUB, dt, p0, q0); // go ahead and set it to the wrong vals...  sys.setG(gSys); sys.setM(mSys); size_t controlType = CONTROL_TYPE_INTY; sys.setControlType(controlType); sys.adaptM = true; armaMat Q = sys.getQ(); Q.diag().fill(1e-8); sys.setQ(Q); armaMat Q_m = sys.getQ_m(); Q_m.diag().fill(1e-6); sys.setQ_m(Q_m); // Create vectors  stdVec aVec = armaVec2stdVec(vectorise(sys_true.getA())); stdVec bVec = armaVec2stdVec(vectorise(sys_true.getB())); stdVec dVec = armaVec2stdVec(vectorise(sys_true.getD())); stdVec qVec = armaVec2stdVec(vectorise(Q)); stdVec x0Vec = armaVec2stdVec(x0_true); stdVec gVec = armaVec2stdVec(sys.getG()); stdVec mVec = armaVec2stdVec(sys.getM()); // assign params.  sys.setDims(nU, nX, nY); sys.setA(aVec); sys.setB(bVec); sys.setQ(qVec); sys.setD(dVec); sys.setM(mVec); sys.setG(gVec); sys.setX0(x0Vec); sys.reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys_hat:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create armaMatrix to save outputs in...  armaMat lambda_hat = armaMat(nY, K, fill::zeros); armaMat lambda_true = armaMat(nY, K, fill::zeros); armaMat lambda_ref = armaMat(nY, K, fill::ones) * yRefVec[0]; // states and gain/disturbance params  armaMat x_hat = armaMat(nX, K, fill::zeros); armaMat m_hat = armaMat(nY, K, fill::zeros); armaMat x_true = armaMat(nX, K, fill::zeros); armaMat m_true = armaMat(nY, K, fill::zeros); sys_true.reset(); sys.reset(); // set initial val  lambda_hat.submat(0, 0, nY - 1, 0) = sys.getY(); lambda_true.submat(0, 0, nY - 1, 0) = sys_true.getY(); x_hat.submat(0, 0, nX - 1, 0) = sys.getX(); x_true.submat(0, 0, nX - 1, 0) = sys_true.getX(); m_hat.submat(0, 0, nX - 1, 0) = sys.getM(); m_true.submat(0, 0, nX - 1, 0) = sys_true.getM(); bool gateCtrl = true; bool gateLock = false; // test constructor pass by ref:  // make uLB something else...  uLB = 0.01; // always keep estimator enabled...  bool gateEst = true; // tau antiWindup  data_t tauAntiWindup = 1e6; sys.setTauAntiWindup(tauAntiWindup); data_t sigma_softStart = 0.1; cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; K * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = chrono::high_resolution_clock::now(); for (size_t k = 1; k \u0026lt; K; k++) { armaVec chance(1, fill::randu); bool doSwitch = false; if (frState == 0) // low state  { if (chance[0] \u0026lt; prLo2Hi) { mVec_true = stdVec(nY, mHi_true); frState = 1; // cout \u0026lt;\u0026lt; \u0026#34;Switching low -\u0026gt; high FR...\\n\u0026#34;;  } } else { // high state  if (chance[0] \u0026lt; prHi2Lo) { mVec_true = stdVec(nY, mLo_true); frState = 0; // cout \u0026lt;\u0026lt; \u0026#34;Switching high -\u0026gt; low FR...\\n\u0026#34;;  } } sys_true.setM(mVec_true); // Assign params (uncomment to simulate online conditions)  // /*  sys.setDims(nU, nX, nY); sys.setA(aVec); sys.setB(bVec); sys.setQ(qVec); sys.setD(dVec); sys.setM(mVec); sys.setG(gVec); sys.setX0(x0Vec); // */  // Assign control params  // /*  sys.setXRef(xRefVec); sys.setYRef(yRefVec); sys.setKc_x(Kc_xVec); sys.setKc_inty(Kc_intyVec); // */  // input  armaVec u_km1 = armaVec(u.colptr(k - 1), u.n_rows, false, false); // Simulate the true system.  sys_true.setU(u_km1); sys_true.simPredict(); armaVec z_k = armaVec(z.colptr(k), z.n_rows, false, false); sys_true.simMeasurement(z_k); // update prev. prediction  sys.steadyState_logLin_fbCtrl(z_k, gateCtrl, gateEst, gateLock, sigma_softStart, uSigma); lambda_ref.submat(0, k, nY - 1, k) = armaMat(yRefVec.data(), nY, 1); lambda_true.submat(0, k, nY - 1, k) = sys_true.getY(); x_true.submat(0, k, nX - 1, k) = sys_true.getX(); m_true.submat(0, k, nY - 1, k) = sys_true.getM(); lambda_hat.submat(0, k, nY - 1, k) = sys.getY(); x_hat.submat(0, k, nX - 1, k) = sys.getX(); m_hat.submat(0, k, nY - 1, k) = sys.getM(); // write control to u  armaVec u_k = armaVec(u.colptr(k), u.n_rows, false, false); u_k = sys.getU(); } auto finish = chrono::high_resolution_clock::now(); chrono::duration\u0026lt;data_t, milli\u0026gt; simTime_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; simTime_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (simTime_ms.count() / K) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys_hat (post-sim): \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); lambda_ref.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;lambdaRef\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;xTrue\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;mTrue\u0026#34;, replace)); lambda_true.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;lambdaTrue\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;xHat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;mHat\u0026#34;, replace)); lambda_hat.save(arma::hdf5_name(\u0026#34;test_plds_ctrl.h5\u0026#34;, \u0026#34;lambdaHat\u0026#34;, replace)); return 0; }  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':18,'href':'/ldsctrlest/docs/api/files/eg__plds__switched__log_lin_ctrl_8cpp/','title':"examples/eg_plds_switched_logLinCtrl.cpp",'section':"Files",'content':"examples/eg_plds_switched_logLinCtrl.cpp #  Functions #      Name     auto main(void )    Function Details #  main #  auto main( void ) Source code #  #include \u0026lt;chrono\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace plds; auto main(void) -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34;********** Testing LDS C++ library. ********** \\n\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;********** Switched Poisson ********** \\n\\n\u0026#34;; bool doSwitchCtrl = true; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t nU = 1; size_t nX = 1; size_t nY = 1; // Scale factor between switched systems.  // System 1 should be more sensitive than system 2 for AAW study.  data_t scale_sysB = 2; armaMat A_true(nX, nX, fill::eye); A_true[0] = 0.98; armaMat B_true2 = armaMat(nX, nU).fill(0.03); armaMat B_true1 = armaMat(nX, nU).fill(scale_sysB * B_true2[0]); armaMat C_true(nY, nX, fill::eye); armaVec d_true = armaVec(nY, fill::zeros).fill(log(1 * dt)); size_t T = (size_t)30.0 / dt; // time steps for simulation.  // simulate switching  size_t gainState = 0; data_t pr21 = 1e-3; data_t pr12 = pr21; // true system...  sys_t sys_true(nU, nX, nY, dt); sys_true.setA(A_true); sys_true.setB(B_true1); sys_true.setC(C_true); sys_true.setD(d_true); sys_true.reset(); // control vars  // Going to take the steady-state vals...  armaMat Kc_x1(nU, nX, fill::ones); armaMat Kc_x2 = scale_sysB * Kc_x1; // system2 is x-times less sensitive.  armaVec yRef = armaVec(nY).fill(20.0 * dt); // AAW does not use integral action  // size_t controlType = CONTROL_TYPE_INTY;  // sys1.setControlType(controlType);  // stdVec Kc_intyVec = stdVec(nU*nY, 25);  data_t uLB = 0.0; data_t uUB = 5.0; ctrl_t sys1(nU, nX, nY, uLB, uUB, dt); sys1.setA(A_true); sys1.setB(B_true1); sys1.setC(C_true); sys1.setD(d_true); sys1.setKc_x(Kc_x1); sys1.reset(); // set Q for filter...  armaMat Q = sys1.getQ(); Q.diag().fill(1e-2); sys1.setQ(Q); sys1.reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys1.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; ctrl_t sys2 = sys1; sys2.setB(B_true2); sys2.setKc_x(Kc_x2); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys2.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create 2-system composite switched-state controller.  sctrl_t sys(2, nU, nX, nY, uLB, uUB, dt); sys.setYRef(yRef); sys.setSystem(0, sys1); sys.setSystem(1, sys2); sys.switchSystem(0); sys.reset(); // Fake measurements  armaMat z(nY, T, fill::zeros); // Will later contain control.  armaMat u(nU, T, fill::zeros); // create armaMatrix to save outputs in...  armaMat lambda_hat = armaMat(nY, T, fill::zeros); armaMat lambda_true = armaMat(nY, T, fill::zeros); armaMat lambda_ref = armaMat(nY, T, fill::ones) * yRef[0]; // states and gain/disturbance params  armaMat x_hat = armaMat(nX, T, fill::zeros); armaMat x_true = armaMat(nX, T, fill::zeros); armaMat state = armaMat(1, T, fill::zeros); // set initial val  lambda_hat.submat(0, 0, nY - 1, 0) = sys1.getY(); lambda_true.submat(0, 0, nY - 1, 0) = sys_true.getY(); x_hat.submat(0, 0, nX - 1, 0) = sys1.getX(); x_true.submat(0, 0, nX - 1, 0) = sys_true.getX(); // some params.  uLB = 0.01; bool gateEst = true; bool gateCtrl = true; cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; T * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; T; t++) { armaVec chance(1, fill::randu); if (gainState == 0) // state1  { if (chance[0] \u0026lt; pr21) { gainState = 1; sys_true.setB(B_true2); if (doSwitchCtrl) sys.switchSystem(1); } } else { // state2  if (chance[0] \u0026lt; pr12) { gainState = 0; sys_true.setB(B_true1); if (doSwitchCtrl) sys.switchSystem(0); } } // input  armaVec u_tm1 = armaVec(u.colptr(t - 1), u.n_rows, false, false); // Simulate the true system.  sys_true.setU(u_tm1); sys_true.simPredict(); armaVec z_k = armaVec(z.colptr(t), z.n_rows, false, false); sys_true.simMeasurement(z_k); // perform control  sys.steadyState_logLin_fbCtrl(z_k, gateCtrl, gateEst); state.submat(0, t, 0, t) = gainState + 1; lambda_ref.submat(0, t, nY - 1, t) = yRef; lambda_true.submat(0, t, nY - 1, t) = sys_true.getY(); x_true.submat(0, t, nX - 1, t) = sys_true.getX(); lambda_hat.submat(0, t, nY - 1, t) = sys.getY(); x_hat.submat(0, t, nX - 1, t) = sys.getX(); // write control to u  armaVec u_t = armaVec(u.colptr(t), u.n_rows, false, false); u_t = sys.getU(); } auto finish = chrono::high_resolution_clock::now(); chrono::duration\u0026lt;data_t, milli\u0026gt; simTime_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; simTime_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (simTime_ms.count() / T) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;test_plds_switched_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); lambda_ref.save( arma::hdf5_name(\u0026#34;test_plds_switched_ctrl.h5\u0026#34;, \u0026#34;lambdaRef\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;test_plds_switched_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;test_plds_switched_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;test_plds_switched_ctrl.h5\u0026#34;, \u0026#34;xTrue\u0026#34;, replace)); lambda_true.save( arma::hdf5_name(\u0026#34;test_plds_switched_ctrl.h5\u0026#34;, \u0026#34;lambdaTrue\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;test_plds_switched_ctrl.h5\u0026#34;, \u0026#34;xHat\u0026#34;, replace)); lambda_hat.save( arma::hdf5_name(\u0026#34;test_plds_switched_ctrl.h5\u0026#34;, \u0026#34;lambdaHat\u0026#34;, replace)); state.save(arma::hdf5_name(\u0026#34;test_plds_switched_ctrl.h5\u0026#34;, \u0026#34;state\u0026#34;, replace)); return 0; }  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':19,'href':'/ldsctrlest/docs/api/files/','title':"Files",'section':"LDS C+E Documentation",'content':"Files #    ldsCtrlEst_h/lds.h lds namespace\n  ldsCtrlEst_h/lds_fit.h LDS base fit type.\n  ldsCtrlEst_h/lds_gaussian.h glds namespace\n  ldsCtrlEst_h/lds_gaussian_ctrl.h GLDS controller type.\n  ldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type.\n  ldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type.\n  ldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type.\n  ldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type.\n  ldsCtrlEst_h/lds_gaussian_sys.h GLDS base type.\n  ldsCtrlEst_h/lds_poisson.h plds namespace\n  ldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type.\n  ldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type.\n  ldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type.\n  ldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type.\n  ldsCtrlEst_h/lds_poisson_sys.h PLDS base type.\n  ldsCtrlEst_h/lds_sys.h LDS base type.\n  ldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API)\n  ldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API)\n  examples/eg_glds_ctrl.cpp\n  examples/eg_plds_est.cpp\n  examples/eg_plds_logLinCtrl.cpp\n  examples/eg_plds_switched_logLinCtrl.cpp\n  src/lds_gaussian_ctrl.cpp GLDS controller type.\n  src/lds_gaussian_sctrl.cpp GLDS switched controller type.\n  src/lds_gaussian_sys.cpp GLDS base type.\n  src/lds_poisson_ctrl.cpp PLDS controller type.\n  src/lds_poisson_sctrl.cpp PLDS switched controller type.\n  src/lds_poisson_sys.cpp PLDS base type.\n  src/lds_sys.cpp LDS base type.\n   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':20,'href':'/ldsctrlest/docs/api/namespaces/namespaceglds/','title':"glds",'section':"Namespaces",'content':"glds #   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':21,'href':'/ldsctrlest/docs/api/files/dir_8f2980731aba7ec7b9fcae5764f196e3/','title':"include",'section':"Files",'content':"include #  Directories #     Name     ldsCtrlEst_h     Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':22,'href':'/ldsctrlest/docs/api/namespaces/namespacelds/','title':"lds",'section':"Namespaces",'content':"lds #  Linear Dynamical Systems (LDS) namespace. Namespaces #     Name     lds::gaussian Linear Dynamical Systems with Gaussian observations.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::fit_t LDS Fit Type.   class lds::sys_t Linear Dynamical System Type.    Types #      Name     enum ssidWt { NONE, MOESP, CVA}   typedef double data_t   typedef std::vector\u0026lt; data_t \u0026gt; stdVec provides fill types for constructing new armadillo vectors, matrices   typedef arma::Col\u0026lt; data_t \u0026gt; armaVec   typedef arma::Mat\u0026lt; data_t \u0026gt; armaMat   typedef arma::Cube\u0026lt; data_t \u0026gt; armaCube   typedef arma::subview_col\u0026lt; data_t \u0026gt; armaSubVec   typedef arma::subview\u0026lt; data_t \u0026gt; armaSubMat    Attributes #      Name     const std::size_t CONTROL_TYPE_U   const std::size_t CONTROL_TYPE_INTY   const std::size_t CONTROL_TYPE_ADAPT_M Control setpoint adapted with (re-estimated) process disturbance m.   data_t inf Some useful numbers.   data_t neginf   const data_t pi   data_t DEFAULT_P0   data_t DEFAULT_Q0   data_t DEFAULT_R0   std::vector\u0026lt; data_t \u0026gt; DEFAULT_T0   data_t DATA_T_ZERO   data_t DATA_T_ONE   data_t DEFAULT_SOFTSTART   bool FALSE   bool TRUE    Type Details #  ssidWt #     Enumerator Value Description     NONE     MOESP     CVA      Weighting options for singular value decomposition performed during subspace identification (SSID): None, MOESP \u0026ldquo;robust method\u0026rdquo;, CVA \u0026ldquo;Canonical Variate Analysis\u0026rdquo;)\ndata_t #  typedef double lds::data_t; Precision/type of all data in library. If need 32b, change double to float.\nstdVec #  typedef std::vector\u0026lt;data_t\u0026gt; lds::stdVec; armaVec #  typedef arma::Col\u0026lt;data_t\u0026gt; lds::armaVec; armaMat #  typedef arma::Mat\u0026lt;data_t\u0026gt; lds::armaMat; armaCube #  typedef arma::Cube\u0026lt;data_t\u0026gt; lds::armaCube; armaSubVec #  typedef arma::subview_col\u0026lt;data_t\u0026gt; lds::armaSubVec; armaSubMat #  typedef arma::subview\u0026lt;data_t\u0026gt; lds::armaSubMat; Attribute Details #  CONTROL_TYPE_U #  static const std::size_t CONTROL_TYPE_U = 0x1; Control was designed to penalize change in input (i.e., the state was augmented with input u)\nCONTROL_TYPE_INTY #  static const std::size_t CONTROL_TYPE_INTY = CONTROL_TYPE_U \u0026lt;\u0026lt; 1; Control using integral action (i.e., the state was augmented with output y during design)\nCONTROL_TYPE_ADAPT_M #  static const std::size_t CONTROL_TYPE_ADAPT_M = CONTROL_TYPE_U \u0026lt;\u0026lt; 2; inf #  static data_t inf = std::numeric_limits\u0026lt;[data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t)\u0026gt;::infinity(); neginf #  static data_t neginf = -inf; pi #  static const data_t pi = arma::datum::pi; DEFAULT_P0 #  static data_t DEFAULT_P0 = 1e-6; DEFAULT_Q0 #  static data_t DEFAULT_Q0 = 1e-6; DEFAULT_R0 #  static data_t DEFAULT_R0 = 1e-2; DEFAULT_T0 #  static std::vector\u0026lt; data_t \u0026gt; DEFAULT_T0 = std::vector\u0026lt;[data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t)\u0026gt;(1, 0.0); DATA_T_ZERO #  static data_t DATA_T_ZERO = ([data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t))0; DATA_T_ONE #  static data_t DATA_T_ONE = ([data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t))1; DEFAULT_SOFTSTART #  static data_t DEFAULT_SOFTSTART = ([data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t))0; FALSE #  static bool FALSE = false; TRUE #  static bool TRUE = true;  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':23,'href':'/ldsctrlest/docs/api/classes/classlds_1_1fit__t/','title':"lds::fit_t",'section':"Classes",'content':"lds::fit_t #  LDS Fit Type. #include \u0026lt;lds_fit.h\u0026gt;\nInherited by lds::gaussian::fit_t, lds::poisson::fit_t\nPublic Functions #      Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes #      Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  fit_t #  inline fit_t()  fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate dt { parameter_description }   Public Attribute Details #  A #  armaMat A;  B #  armaMat B;  g #  armaVec g;  m #  armaVec m;  Q #  armaMat Q;  x0 #  armaVec x0;  P0 #  armaMat P0;  dt #  data_t dt;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':24,'href':'/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/','title':"lds::gaussian",'section':"Namespaces",'content':"lds::gaussian #  Linear Dynamical Systems with Gaussian observations. Classes #      Name     class lds::gaussian::ctrl_t GLDS Controller Type.   class lds::gaussian::fit_t GLDS Fit Type.   class lds::gaussian::emFit_t GLDS E-M Fit Type.   class lds::gaussian::ssidFit_t GLDS SSID Fit Type.   class lds::gaussian::sctrl_t Switched GLDS Controller Type.   class lds::gaussian::sys_t Gaussian LDS Type.    Types #      Name     typedef lds::data_t data_t   typedef lds::stdVec stdVec   typedef lds::armaVec armaVec   typedef lds::armaMat armaMat   typedef lds::armaSubVec armaSubVec   typedef lds::armaSubMat armaSubMat    Functions #      Name     emFit_t emFit_x_equals_y(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain, data_t dt, std::size_t maxIter =100, data_t tol =1e-3, data_t q0 =1e-6, bool calcAB =true, bool calcQ =true, bool calcR =true)\nPerform EM for special system where y = x + noise.   ssidFit_t ssidFit(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-inf), bool force_unitNormC =false, ssidWt wt =NONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =DEFAULT_T0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity())\nFit a GLDS model using subspace identification (SSID)   armaVec calcD_silence(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, data_t dt, data_t tSilence =0.1, data_t threshSilence =0.001)\nUsing periods of silence in inputs (u), calculates the output \\ bias.   void createHankelMat_n4sid(armaMat \u0026amp; u, armaMat \u0026amp; z, std::size_t \u0026amp; nH, armaMat \u0026amp; D)\nCreate block-hankel data matrix for N4SID method.   void ssid_n4sid(std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; m, armaVec \u0026amp; d, armaVec \u0026amp; s, bool force_unitNormC, ssidWt wt, data_t wtG0)\nN4SID method of SSID.   void ssid_n4sid_vanOverschee(std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; s, ssidWt wt)\nN4SID method of SSID.   void recompute_extObs(armaMat \u0026amp; extObs, armaMat \u0026amp; A, armaMat \u0026amp; C, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH)\nRecompute extended observability matrix, given A, C.   void lq(armaMat \u0026amp; L, armaMat \u0026amp; Qt, armaMat \u0026amp; X)\nLQ decomposition.   armaMat calcCov(armaMat \u0026amp; A, armaMat \u0026amp; B)\nCalculate covariance matrix.   armaMat sqrtmat_svd(armaMat \u0026amp; X)    Attributes #      Name     const std::size_t CONTROL_TYPE_U   const std::size_t CONTROL_TYPE_INTY   const std::size_t CONTROL_TYPE_ADAPT_M   data_t DATA_T_ZERO   data_t DATA_T_ONE   data_t DEFAULT_SOFTSTART   bool FALSE   bool TRUE   const data_t pi   data_t inf   data_t neginf    Type Details #  data_t #  typedef lds::data_t lds::gaussian::data_t; stdVec #  typedef lds::stdVec lds::gaussian::stdVec; armaVec #  typedef lds::armaVec lds::gaussian::armaVec; armaMat #  typedef lds::armaMat lds::gaussian::armaMat; armaSubVec #  typedef lds::armaSubVec lds::gaussian::armaSubVec; armaSubMat #  typedef lds::armaSubMat lds::gaussian::armaSubMat; Function Details #  emFit_x_equals_y #  emFit_t emFit_x_equals_y( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain, data_t dt, std::size_t maxIter =100, data_t tol =1e-3, data_t q0 =1e-6, bool calcAB =true, bool calcQ =true, bool calcR =true ) Parameters:\n uTrain training input data zTrain training measurement data dt sample period maxIter [optional] maximum number of iterations tol [optional] convergence tolerance q0 [optional] initial diagonal elements of process noise covariance calcAB [optional] whether to calculate dynamics (A, B) calcQ [optional] whether to calculate process noise covariance calcR [optional] whether to calculate output noise covariance  Return: EM fit\nssidFit #  ssidFit_t ssidFit( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-inf), bool force_unitNormC =false, ssidWt wt =NONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =DEFAULT_T0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity() ) Parameters:\n u inputs z measurements dt sample period nX number of states nH block-Hankel data matrix size d0 previous estimate of output bias (d) force_unitNormC force fitting where C has unit norm wt chosen weighting for SSID singular value \\ decomposition (NONE, MOESP, CVA) wtG0 chosen weighting for minimizing model error at \\ DC t0 start times for each trial of input/output data t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID  Return: the SSID-fit GLDS model.\nFit a GLDS model using subspace identification (SSID)\nReferences:\nvan Overschee P, de Moor B. (1996) Subspace Identification for Linear Systems.\ncalcD_silence #  armaVec calcD_silence( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, data_t dt, data_t tSilence =0.1, data_t threshSilence =0.001 ) Parameters:\n n measurements u inputs dt sample period tSilence threshold on period of time that qualifies as \u0026ldquo;silence\u0026rdquo; threshSilence threshold on input amplitude u that qualifies as \u0026ldquo;silence\u0026rdquo;  Return: d estimated output bias.\ncreateHankelMat_n4sid #  void createHankelMat_n4sid( armaMat \u0026amp; u, armaMat \u0026amp; z, std::size_t \u0026amp; nH, armaMat \u0026amp; D ) Parameters:\n u input data z measurement data nH block-Hankel matrix size D block-Hankel data matrix  ssid_n4sid #  void ssid_n4sid( std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; m, armaVec \u0026amp; d, armaVec \u0026amp; s, bool force_unitNormC, ssidWt wt, data_t wtG0 ) Parameters:\n nX number of states nU number of inputs nY number of outputs nH block-Hankel matrix size uSSID input data zSSID measurement data A state matrix B input matrix C output matrix D feedthrough matrix Q process noise covariance R output noise covariance m process disturbance d output bias s singular values force_unitNormC whether to force C to be unit-norm wt weighting method for SVD (NONE, MOESP, CVA) wtG0 weight put on minimizing error at DC  ssid_n4sid_vanOverschee #  void ssid_n4sid_vanOverschee( std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; s, ssidWt wt ) Parameters:\n nX number of state nU number of inputs nY number of outputs nH block-Hankel data matrix size uSSID input data zSSID measurement data A state matrix B input matrix C output matrix D feedthrough matrix Q process noise covariance R output noise covariance s singular values wt weighting method for SVD (NONE, MOESP, CVA)  N4SID method of SSID\nThis is a more direct implementation of van Overschee, de Moor (1996)\nrecompute_extObs #  void recompute_extObs( armaMat \u0026amp; extObs, armaMat \u0026amp; A, armaMat \u0026amp; C, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH ) Parameters:\n extObs Extended observability matrix A state matrix C output matrix nY number of outputs nH block-Hankel data matrix size  lq #  void lq( armaMat \u0026amp; L, armaMat \u0026amp; Qt, armaMat \u0026amp; X ) Parameters:\n L lower triangle matrix Qt orthonormal matrix (transposed cf QR decomp) X matrix being decomposed  calcCov #  armaMat calcCov( armaMat \u0026amp; A, armaMat \u0026amp; B ) Parameters:\n A some matrix B some other matrix  Return: covariance\nsqrtmat_svd #  armaMat sqrtmat_svd( armaMat \u0026amp; X ) Parameters:\n X some matrix  Return: approximate sqrtmat(X)\nApproximate sqrtmat by singular value decomposition.\nsvd(X) \u0026ndash;\u0026gt; U * sqrt(s) * V' ~= sqrtmat(X)\nAttribute Details #  CONTROL_TYPE_U #  static const std::size_t CONTROL_TYPE_U = lds::CONTROL_TYPE_U; CONTROL_TYPE_INTY #  static const std::size_t CONTROL_TYPE_INTY = lds::CONTROL_TYPE_INTY; CONTROL_TYPE_ADAPT_M #  static const std::size_t CONTROL_TYPE_ADAPT_M = lds::CONTROL_TYPE_ADAPT_M; DATA_T_ZERO #  static data_t DATA_T_ZERO = lds::DATA_T_ZERO; DATA_T_ONE #  static data_t DATA_T_ONE = lds::DATA_T_ZERO; DEFAULT_SOFTSTART #  static data_t DEFAULT_SOFTSTART = lds::DEFAULT_SOFTSTART; FALSE #  static bool FALSE = lds::FALSE; TRUE #  static bool TRUE = lds::TRUE; pi #  static const data_t pi = lds::pi; inf #  static data_t inf = lds::inf; neginf #  static data_t neginf = lds::neginf;  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':25,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ctrl__t/','title':"lds::gaussian::ctrl_t",'section':"Classes",'content':"lds::gaussian::ctrl_t #  GLDS Controller Type. #include \u0026lt;lds_gaussian_ctrl.h\u0026gt;\nInherits from lds::gaussian::sys_t, lds::sys_t\nInherited by lds::gaussian::sctrl_t\nPublic Functions #      Name      ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0)\nConstructs a new GLDS controller.   ctrl_t \u0026amp; operator=(const ctrl_t \u0026amp; sys)   void fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE)\nfeedback control (single step)   void steadyState_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE)\nsteady-state control (single step)   void calc_ssSetPt()   void printSys()\nPrint system variables to stdout.   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY)\nSet dimensions of system.   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setGDesign(stdVec \u0026amp; gVec)\nSet input gain used in controller design (gDesign)   void setGDesign(armaVec \u0026amp; g)\nSet input gain used in controller design (gDesign)   void setURef(stdVec \u0026amp; uRefVec)\nSet reference input (uRef)   void setURef(armaVec \u0026amp; uRef)\nSet reference input (uRef)   void setXRef(stdVec \u0026amp; xRefVec)\nSet reference state (xRef)   void setXRef(armaVec \u0026amp; xRef)\nSet reference state (xRef)   void setYRef(stdVec \u0026amp; yRefVec)\nSet reference output (yRef)   void setYRef(armaVec \u0026amp; yRef)\nSet reference output (yRef)   void setKc_x(stdVec \u0026amp; Kc_x_vec)\nSet state controller gain (Kc_x)   void setKc_x(armaMat \u0026amp; Kc_x)\nSet state controller gain (Kc_x)   void setKc_u(stdVec \u0026amp; Kc_u_vec)\nSet input controller gain (Kc_u)   void setKc_u(armaMat \u0026amp; Kc_u)\nSet input controller gain (Kc_u)   void setKc_inty(stdVec \u0026amp; Kc_inty_vec)\nSet integral controller gain (Kc_inty)   void setKc_inty(armaMat \u0026amp; Kc_inty)\nSet integral controller gain (Kc_inty)   void setControlType(size_t controlType)\nSet controller type.   void setTauAntiWindup(data_t \u0026amp; tau)\nSet time constant of anti-integral-windup.   armaMat getKc_u() const\nGet input controller gain (Kc_u)   armaMat getKc_x() const\nGet state controller gain (Kc_x)   armaMat getKc_inty() const\nGet integral controller gain (Kc_inty)   armaVec getGDesign() const\nGet input gain used in controller design (gDesign)   armaVec getURef() const\nGet reference input (uRef)   armaVec getXRef() const\nGet reference state (xRef)   armaVec getYRef() const\nGet reference output (yRef)   armaVec getIntE() const\nGet integrated error (intE)   size_t getControlType() const\nGet controller type.   void reset()\nReset system variables.    Protected Functions #      Name     void antiWindup()\nProtect against integral windup.    Protected Attributes #      Name     armaVec gDesign input gain of the system used for controller design   armaVec uRef reference input   armaVec uRef_prev reference input at previous time step   armaVec xRef reference state   armaVec yRef reference output   armaMat Kc_x state controller gain   armaMat Kc_u input controller gain (when control aims to minimize deltaU)   armaMat Kc_inty integral controller gain   armaVec duRef   armaVec dvRef   armaVec vRef   armaVec dv   armaVec v Control after g inversion (e.g., control in physical units)   armaVec intE integrated error   armaVec intE_awuAdjust anti-windup adjustment to intE   armaVec uSat control signal after saturation (for antiWindup)   bool gateCtrl_prev   bool gateLock_prev   bool uSaturated whether control signal has reached saturation limits   data_t \u0026amp; uLB lower bound on control   data_t \u0026amp; uUB upper bound on control   data_t tauAntiWindup antiwindup time constant   data_t kAntiWindup   data_t t_since_ctrl_onset time since control epoch onset   size_t controlType controller type    Additional inherited members #  Public Functions inherited from lds::gaussian::sys_t\n    Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate system measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0)\nConstructs a new GLDS.   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (d)   armaVec getR() const\nGet output noise covariance (R)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   armaMat getKe() const\nGet estimator gain (Ke)   armaMat getKe_m() const\nGet estimator gain for process disturbance (Ke_m)   void setC(stdVec \u0026amp; cVec)\nSet output matrix (C)   void setC(armaMat \u0026amp; C)\nSet output matrix (C)   void setD(stdVec \u0026amp; dVec)\nSet output bias (d)   void setD(armaVec \u0026amp; d)\nSet output bias (d)   void setR(stdVec \u0026amp; rVec)\nSet output noise covariance (R)   void setR(armaMat \u0026amp; R)\nSet output noise covariance (R)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void setKe(stdVec \u0026amp; keVec)\nSet estimator gain (Ke)   void setKe(armaMat \u0026amp; Ke)\nSet estimator gain (Ke)   void setKe_m(stdVec \u0026amp; kemVec)\nSet disturbance estimator gain (Ke_m)   void setKe_m(armaMat \u0026amp; Ke_m)\nSet disturbance estimator gain (Ke_m)    Protected Functions inherited from lds::gaussian::sys_t\n    Name     void recurse_Ke()\nRecursively recalculate Kalman estimator gain (Ke)   void predict()\nOne-step prediction.   void h()\nSystem output function.   void defaultR()\nReset to default R (identity matrix with diagonal elements r0)    Protected Attributes inherited from lds::gaussian::sys_t\n    Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaMat R covariance of output noise   data_t \u0026amp; r0 default values for R   armaVec y output   armaVec z measurement   armaMat Ke state estimator gain   armaMat Ke_m disturbance estimator gain    Public Functions inherited from lds::sys_t\n    Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)    Protected Functions inherited from lds::sys_t\n    Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  ctrl_t #  ctrl_t( std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0 ) Parameters:\n nU number of inputs nX number of states nY number of outputs uLB lower bound on control (u) uUB upper bound on control (u) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) r0 [optional] initial diagonal elements of output noise covariance (R) controlType [optional] control type bit mask   operator= #  ctrl_t \u0026amp; operator=( const ctrl_t \u0026amp; sys )  fbCtrl #  void fbCtrl( armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE ) Parameters:\n z measurement gateCtrl [optional] logical gate of control (high=enabled; low=disabled) gateLock [optional] logical gate of control signal lock (if high, locks control at current value) sigma_softStart [optional] standard deviation (sigma) of a Gaussian soft-start to control sigma_uNoise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal resetAtCtrlOnset [optional] whether to reset controller at onset of a new control epoch (gateCtrl from low to high) doRecurse_Ke [optional] whether to recalculate state estimator gain (Ke) recursively  Perform a single step of feedback control. This is the most flexible option, but requires user to have set the controller\u0026rsquo;s xRef and uRef variables.\n steadyState_fbCtrl #  void steadyState_fbCtrl( armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE ) Parameters:\n z measurement gateCtrl [optional] logical gate of control (high=enabled; low=disabled) gateEst [optional] logical gate of estimator (high=enabled; low=disabled) gateLock [optional] logical gate of control signal lock (if high, locks control at current value) sigma_softStart [optional] standard deviation (sigma) of a Gaussian soft-start to control sigma_uNoise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal resetAtCtrlOnset [optional] whether to reset controller at onset of a new control epoch (gateCtrl from low to high) doRecurse_Ke [optional] whether to recalculate state estimator gain (Ke) recursively  Assuming the objective is to track a reference output (yRef) at steady state, perform a single step of control. Requires user to have set the controller\u0026rsquo;s yRef variable. If control is enabled (gateCtrl=true) but estimator is disabled (gateEst=true), this function provides the calculated steady-state input uRef in open loop.\n calc_ssSetPt #  void calc_ssSetPt() Calculate steady-state setpoint [xRef; uRef], given an output reference yRef.\n printSys #  void printSys()  setDims #  void setDims( std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY )  setU #  void setU( stdVec \u0026amp; uVec )  setU #  void setU( armaVec \u0026amp; u )  setG #  void setG( stdVec \u0026amp; gVec )  setG #  void setG( armaVec \u0026amp; g )  setGDesign #  void setGDesign( stdVec \u0026amp; gVec )  setGDesign #  void setGDesign( armaVec \u0026amp; g )  setURef #  void setURef( stdVec \u0026amp; uRefVec )  setURef #  void setURef( armaVec \u0026amp; uRef )  setXRef #  void setXRef( stdVec \u0026amp; xRefVec )  setXRef #  void setXRef( armaVec \u0026amp; xRef )  setYRef #  void setYRef( stdVec \u0026amp; yRefVec )  setYRef #  void setYRef( armaVec \u0026amp; yRef )  setKc_x #  void setKc_x( stdVec \u0026amp; Kc_x_vec )  setKc_x #  void setKc_x( armaMat \u0026amp; Kc_x )  setKc_u #  void setKc_u( stdVec \u0026amp; Kc_u_vec )  setKc_u #  void setKc_u( armaMat \u0026amp; Kc_u )  setKc_inty #  void setKc_inty( stdVec \u0026amp; Kc_inty_vec )  setKc_inty #  void setKc_inty( armaMat \u0026amp; Kc_inty )  setControlType #  void setControlType( size_t controlType )  setTauAntiWindup #  void setTauAntiWindup( data_t \u0026amp; tau )  getKc_u #  inline armaMat getKc_u() const  getKc_x #  inline armaMat getKc_x() const  getKc_inty #  inline armaMat getKc_inty() const  getGDesign #  inline armaVec getGDesign() const  getURef #  inline armaVec getURef() const  getXRef #  inline armaVec getXRef() const  getYRef #  inline armaVec getYRef() const  getIntE #  inline armaVec getIntE() const  getControlType #  inline size_t getControlType() const  reset #  void reset()  Protected Function Details #  antiWindup #  void antiWindup() Protect against integral windup\nReference:\nAstroem KJ, Rundqwist L. (1989) Integrator Windup and How to Avoid It. 1989 ACC.\n Protected Attribute Details #  gDesign #  armaVec gDesign;  uRef #  armaVec uRef;  uRef_prev #  armaVec uRef_prev;  xRef #  armaVec xRef;  yRef #  armaVec yRef;  Kc_x #  armaMat Kc_x;  Kc_u #  armaMat Kc_u;  Kc_inty #  armaMat Kc_inty;  duRef #  armaVec duRef;  dvRef #  armaVec dvRef;  vRef #  armaVec vRef;  dv #  armaVec dv;  v #  armaVec v;  intE #  armaVec intE;  intE_awuAdjust #  armaVec intE_awuAdjust;  uSat #  armaVec uSat;  gateCtrl_prev #  bool gateCtrl_prev;  gateLock_prev #  bool gateLock_prev;  uSaturated #  bool uSaturated;  uLB #  data_t \u0026amp; uLB;  uUB #  data_t \u0026amp; uUB;  tauAntiWindup #  data_t tauAntiWindup;  kAntiWindup #  data_t kAntiWindup;  t_since_ctrl_onset #  data_t t_since_ctrl_onset;  controlType #  size_t controlType;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':26,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1em_fit__t/','title':"lds::gaussian::emFit_t",'section':"Classes",'content':"lds::gaussian::emFit_t #  GLDS E-M Fit Type. More\u0026hellip;\n\n#include \u0026lt;lds_gaussian_fit_em.h\u0026gt;\nInherits from lds::gaussian::fit_t, lds::fit_t\nPublic Functions #      Name      emFit_t()    emFit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new EM Fit Type.    emFit_t(data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new EM Fit Type.    emFit_t(ssidFit_t \u0026amp; fit0)   void reset(void )\nReset EM fit.   void runEM(bool calcAB =true, bool calcQ =true, bool calcInitial =true, bool calcC =true, bool calcd =true, bool calcR =true)\nRun Expectation-Maximization algorithm.   std::vector\u0026lt; armaMat \u0026gt; getX()\nGet state estimate.   std::vector\u0026lt; armaMat \u0026gt; getY()\nGet output estimate.   armaMat get_sum_E_xu_tm1_xu_tm1()   armaMat get_sum_E_xu_t_xu_tm1()   armaMat get_sum_E_xu_t_xu_t()   size_t getT()   void setY(std::vector\u0026lt; armaMat \u0026gt; yHat)\nSet output.    Protected Functions #      Name     armaVec getTheta()\nGet recalculated parameters (packed into vector)   void kalmanFilt()   void kalmanSmooth(bool forceCommonInitial)\nKalman smooth dataset (fixed-interval smoothing)   void Estep(bool forceCommonInitial =false)\nExpectation step.   void Mstep(bool calcAB =true, bool calcQ =true, bool calcInitial =false, bool calcC =false, bool calcd =false, bool calcR =true)\nMaximization step.    Public Attributes #      Name     data_t tol tolerance for convergence   size_t maxIter maximum number of EM iterations    Protected Attributes #      Name     std::vector\u0026lt; armaMat \u0026gt; xHat state estimate   std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P state estimate covariance   std::vector\u0026lt; armaMat \u0026gt; yHat output estimate   std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P_t_tm1 single-lag state covariance   armaMat sum_E_xu_t_xu_t state-input covariance (current time)   armaMat sum_E_xu_tm1_xu_tm1 state-input covariance (t-minus-1)   armaMat sum_E_xu_t_xu_tm1 single lag state-input covariance   size_t T    Additional inherited members #  Public Functions inherited from lds::gaussian::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit.    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit type.    Public Attributes inherited from lds::gaussian::fit_t\n    Name     armaMat C output matrix   armaMat D feedthrough matrix   armaVec d output bias   armaMat R output noise cov   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Public Functions inherited from lds::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period    Detailed Description #  class lds::gaussian::emFit_t;  This type is used in the process of fitting GLDS models by expectation-maximization (EM).   Public Function Details #  emFit_t #  inline emFit_t()  emFit_t #  emFit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias R output noise covariance dt sample period uTrain training input data zTrain training measurement data   emFit_t #  emFit_t( data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n dt sample period uTrain training input data zTrain training measurement data  Constructs a new EM Fit Type.\nInitializes the model to a random walk.\n emFit_t #  emFit_t( ssidFit_t \u0026amp; fit0 )  reset #  void reset( void )  runEM #  void runEM( bool calcAB =true, bool calcQ =true, bool calcInitial =true, bool calcC =true, bool calcd =true, bool calcR =true ) Parameters:\n calcAB [optional] whether to caclulate dynamics (A, B) calcQ [optional] whether to calculate process noise covariance calcInitial [optional] whether to calculate initial conditions calcC [optional] whether to calculate output matrix calcd [optional] whether to calculate output bias calcR [optional] whether to calculate output noise covariance   getX #  inline std::vector\u0026lt; armaMat \u0026gt; getX()  getY #  inline std::vector\u0026lt; armaMat \u0026gt; getY()  get_sum_E_xu_tm1_xu_tm1 #  inline armaMat get_sum_E_xu_tm1_xu_tm1()  get_sum_E_xu_t_xu_tm1 #  inline armaMat get_sum_E_xu_t_xu_tm1()  get_sum_E_xu_t_xu_t #  inline armaMat get_sum_E_xu_t_xu_t()  getT #  inline size_t getT()  setY #  inline void setY( std::vector\u0026lt; armaMat \u0026gt; yHat )  Protected Function Details #  getTheta #  armaVec getTheta()  kalmanFilt #  void kalmanFilt() Kalman filter dataset Estimate x[t] | z[0\u0026hellip;t]\n kalmanSmooth #  void kalmanSmooth( bool forceCommonInitial ) Parameters:\n forceCommonInitial whether to force common initial condition for all trials  Kalman smooth dataset (fixed-interval smoothing)\nEstimate x[t] | z[0\u0026hellip;T]\n Estep #  void Estep( bool forceCommonInitial =false ) Parameters:\n forceCommonInitial whether to force common initial condition for all trials   Mstep #  void Mstep( bool calcAB =true, bool calcQ =true, bool calcInitial =false, bool calcC =false, bool calcd =false, bool calcR =true ) Parameters:\n calcAB [optional] whether to caclulate dynamics (A, B) calcQ [optional] whether to calculate process noise covariance calcInitial [optional] whether to calculate initial conditions calcC [optional] whether to calculate output matrix calcd [optional] whether to calculate output bias calcR [optional] whether to calculate output noise covariance   Public Attribute Details #  tol #  data_t tol = 1e-3;  maxIter #  size_t maxIter = 100;  Protected Attribute Details #  xHat #  std::vector\u0026lt; armaMat \u0026gt; xHat;  P #  std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P;  yHat #  std::vector\u0026lt; armaMat \u0026gt; yHat;  P_t_tm1 #  std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P_t_tm1;  sum_E_xu_t_xu_t #  armaMat sum_E_xu_t_xu_t;  sum_E_xu_tm1_xu_tm1 #  armaMat sum_E_xu_tm1_xu_tm1;  sum_E_xu_t_xu_tm1 #  armaMat sum_E_xu_t_xu_tm1;  T #  size_t T;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':27,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1fit__t/','title':"lds::gaussian::fit_t",'section':"Classes",'content':"lds::gaussian::fit_t #  GLDS Fit Type. #include \u0026lt;lds_gaussian_fit.h\u0026gt;\nInherits from lds::fit_t\nInherited by lds::gaussian::emFit_t, lds::gaussian::ssidFit_t\nPublic Functions #      Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit.    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit type.    Public Attributes #      Name     armaMat C output matrix   armaMat D feedthrough matrix   armaVec d output bias   armaMat R output noise cov   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Additional inherited members #  Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  fit_t #  inline fit_t()  fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix D feedthrough matrix d output bias R covariance of output noise dt sample period uTrain input training data zTrain measurement training data   fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias R covariance of output noise dt sample period uTrain input training data zTrain measurement training data   Public Attribute Details #  C #  armaMat C;  D #  armaMat D;  d #  armaVec d;  R #  armaMat R;  uTrain #  std::vector\u0026lt; armaMat \u0026gt; uTrain;  zTrain #  std::vector\u0026lt; armaMat \u0026gt; zTrain;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':28,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sctrl__t/','title':"lds::gaussian::sctrl_t",'section':"Classes",'content':"lds::gaussian::sctrl_t #  Switched GLDS Controller Type. #include \u0026lt;lds_gaussian_sctrl.h\u0026gt;\nInherits from lds::gaussian::ctrl_t, lds::gaussian::sys_t, lds::sys_t\nPublic Functions #      Name      sctrl_t(std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0)\nConstructs a new switched GLDS controller.   void setSystem(size_t sysIdx, ctrl_t \u0026amp; sys)   void switchSystem(size_t sysIdx)\nSwitch to a different underlying sub-system.   size_t getSysIdx() const\nGet the index of currently active sub-system.    Protected Attributes #      Name     size_t nSys number of systems   std::vector\u0026lt; ctrl_t \u0026gt; systems underlying sub-systems which are toggled between   size_t sysIdx current system index.    Additional inherited members #  Public Functions inherited from lds::gaussian::ctrl_t\n    Name      ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0)\nConstructs a new GLDS controller.   ctrl_t \u0026amp; operator=(const ctrl_t \u0026amp; sys)   void fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE)\nfeedback control (single step)   void steadyState_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE)\nsteady-state control (single step)   void calc_ssSetPt()   void printSys()\nPrint system variables to stdout.   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setGDesign(stdVec \u0026amp; gVec)\nSet input gain used in controller design (gDesign)   void setGDesign(armaVec \u0026amp; g)\nSet input gain used in controller design (gDesign)   void setURef(stdVec \u0026amp; uRefVec)\nSet reference input (uRef)   void setURef(armaVec \u0026amp; uRef)\nSet reference input (uRef)   void setXRef(stdVec \u0026amp; xRefVec)\nSet reference state (xRef)   void setXRef(armaVec \u0026amp; xRef)\nSet reference state (xRef)   void setYRef(stdVec \u0026amp; yRefVec)\nSet reference output (yRef)   void setYRef(armaVec \u0026amp; yRef)\nSet reference output (yRef)   void setTauAntiWindup(data_t \u0026amp; tau)\nSet time constant of anti-integral-windup.   armaMat getKc_u() const\nGet input controller gain (Kc_u)   armaMat getKc_x() const\nGet state controller gain (Kc_x)   armaMat getKc_inty() const\nGet integral controller gain (Kc_inty)   armaVec getGDesign() const\nGet input gain used in controller design (gDesign)   armaVec getURef() const\nGet reference input (uRef)   armaVec getXRef() const\nGet reference state (xRef)   armaVec getYRef() const\nGet reference output (yRef)   armaVec getIntE() const\nGet integrated error (intE)   size_t getControlType() const\nGet controller type.   void reset()\nReset system variables.    Protected Functions inherited from lds::gaussian::ctrl_t\n    Name     void antiWindup()\nProtect against integral windup.    Protected Attributes inherited from lds::gaussian::ctrl_t\n    Name     armaVec gDesign input gain of the system used for controller design   armaVec uRef reference input   armaVec uRef_prev reference input at previous time step   armaVec xRef reference state   armaVec yRef reference output   armaMat Kc_x state controller gain   armaMat Kc_u input controller gain (when control aims to minimize deltaU)   armaMat Kc_inty integral controller gain   armaVec duRef   armaVec dvRef   armaVec vRef   armaVec dv   armaVec v Control after g inversion (e.g., control in physical units)   armaVec intE integrated error   armaVec intE_awuAdjust anti-windup adjustment to intE   armaVec uSat control signal after saturation (for antiWindup)   bool gateCtrl_prev   bool gateLock_prev   bool uSaturated whether control signal has reached saturation limits   data_t \u0026amp; uLB lower bound on control   data_t \u0026amp; uUB upper bound on control   data_t tauAntiWindup antiwindup time constant   data_t kAntiWindup   data_t t_since_ctrl_onset time since control epoch onset   size_t controlType controller type    Public Functions inherited from lds::gaussian::sys_t\n    Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate system measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0)\nConstructs a new GLDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (d)   armaVec getR() const\nGet output noise covariance (R)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   armaMat getKe() const\nGet estimator gain (Ke)   armaMat getKe_m() const\nGet estimator gain for process disturbance (Ke_m)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions inherited from lds::gaussian::sys_t\n    Name     void recurse_Ke()\nRecursively recalculate Kalman estimator gain (Ke)   void predict()\nOne-step prediction.   void h()\nSystem output function.   void defaultR()\nReset to default R (identity matrix with diagonal elements r0)    Protected Attributes inherited from lds::gaussian::sys_t\n    Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaMat R covariance of output noise   data_t \u0026amp; r0 default values for R   armaVec y output   armaVec z measurement   armaMat Ke state estimator gain   armaMat Ke_m disturbance estimator gain    Public Functions inherited from lds::sys_t\n    Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions inherited from lds::sys_t\n    Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  sctrl_t #  sctrl_t( std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0 ) Parameters:\n nSys number of systems nU number of inputs nX number of states nY number of outputs uLB lower bound on control (u) uUB upper bound on control (u) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) r0 [optional] initial diagonal elements of output noise covariance (R) controlType [optional] control type bit mask   setSystem #  void setSystem( size_t sysIdx, ctrl_t \u0026amp; sys ) Set the parameters of selected sub-system using previously instantiated GLDS controllers.\n switchSystem #  void switchSystem( size_t sysIdx ) Switch to a different underlying sub-system by reassiging parameters at switch.\n getSysIdx #  inline size_t getSysIdx() const  Protected Attribute Details #  nSys #  size_t nSys;  systems #  std::vector\u0026lt; ctrl_t \u0026gt; systems;  sysIdx #  size_t sysIdx;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':29,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ssid_fit__t/','title':"lds::gaussian::ssidFit_t",'section':"Classes",'content':"lds::gaussian::ssidFit_t #  GLDS SSID Fit Type. More\u0026hellip;\n\n#include \u0026lt;lds_gaussian_fit_ssid.h\u0026gt;\nInherits from lds::gaussian::fit_t, lds::fit_t\nPublic Functions #      Name      ssidFit_t()    ssidFit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS SSID fit type.    Public Attributes #      Name     std::vector\u0026lt; data_t \u0026gt; t0   data_t t_startSSID   data_t t_stopSSID   armaVec singVals    Additional inherited members #  Public Functions inherited from lds::gaussian::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit.    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit type.    Public Attributes inherited from lds::gaussian::fit_t\n    Name     armaMat C output matrix   armaMat D feedthrough matrix   armaVec d output bias   armaMat R output noise cov   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Public Functions inherited from lds::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period    Detailed Description #  class lds::gaussian::ssidFit_t;  This type is used in the process of fitting GLDS models by subspace identification (SSID).   Public Function Details #  ssidFit_t #  inline ssidFit_t()  ssidFit_t #  ssidFit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix D feedthrough matrix d output bias R output noise covariance dt sample period t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID singVals singular values from SSID SVD step t0 start times for each trial of input/output data uTrain training input data zTrain training measurement data   Public Attribute Details #  t0 #  std::vector\u0026lt; data_t \u0026gt; t0;  t_startSSID #  data_t t_startSSID;  t_stopSSID #  data_t t_stopSSID;  singVals #  armaVec singVals;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':30,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/','title':"lds::gaussian::sys_t",'section':"Classes",'content':"lds::gaussian::sys_t #  Gaussian LDS Type. #include \u0026lt;lds_gaussian_sys.h\u0026gt;\nInherits from lds::sys_t\nInherited by lds::gaussian::ctrl_t\nPublic Functions #      Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate system measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0)\nConstructs a new GLDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (d)   armaVec getR() const\nGet output noise covariance (R)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   armaMat getKe() const\nGet estimator gain (Ke)   armaMat getKe_m() const\nGet estimator gain for process disturbance (Ke_m)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY)\nSet dimensions of system.   void setC(stdVec \u0026amp; cVec)\nSet output matrix (C)   void setC(armaMat \u0026amp; C)\nSet output matrix (C)   void setD(stdVec \u0026amp; dVec)\nSet output bias (d)   void setD(armaVec \u0026amp; d)\nSet output bias (d)   void setR(stdVec \u0026amp; rVec)\nSet output noise covariance (R)   void setR(armaMat \u0026amp; R)\nSet output noise covariance (R)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void setKe(stdVec \u0026amp; keVec)\nSet estimator gain (Ke)   void setKe(armaMat \u0026amp; Ke)\nSet estimator gain (Ke)   void setKe_m(stdVec \u0026amp; kemVec)\nSet disturbance estimator gain (Ke_m)   void setKe_m(armaMat \u0026amp; Ke_m)\nSet disturbance estimator gain (Ke_m)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions #      Name     void recurse_Ke()\nRecursively recalculate Kalman estimator gain (Ke)   void predict()\nOne-step prediction.   void h()\nSystem output function.   void defaultR()\nReset to default R (identity matrix with diagonal elements r0)    Protected Attributes #      Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaMat R covariance of output noise   data_t \u0026amp; r0 default values for R   armaVec y output   armaVec z measurement   armaMat Ke state estimator gain   armaMat Ke_m disturbance estimator gain    Additional inherited members #  Public Functions inherited from lds::sys_t\n    Name     void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)    Protected Functions inherited from lds::sys_t\n    Name     void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  filter #  void filter( armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t, bool doRecurse_Ke =true ) Parameters:\n u_tm1 input at t-minus-1 z_t current measurement doRecurse_Ke whether to calculate the Kalman estimator gain (Ke) recursively  Given current measurment and input, filter data to produce causal state estimates using Kalman filtering, which procedes by predicting the state and subsequently updating.\n filter #  void filter( armaVec \u0026amp; z, bool doRecurse_Ke =true ) Parameters:\n z current measurement doRecurse_Ke whether to calculate the Kalman estimator gain (Ke) recursively  Given current measurment, filter data to produce causal state estimates using Kalman filtering, which procedes by predicting the state and subsequently updating.\n simMeasurement #  void simMeasurement( armaVec \u0026amp; z ) Parameters:\n z measurement  Simulate system measurement: z ~ Poisson(y)\nn.b., In reality, this is only Poisson where rate y and sample period dt are sufficiently small there is only ever 0 or 1 events in a period. If either of those is violated, results will be innacurate.\n sys_t #  sys_t( std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0 ) Parameters:\n nU number of inputs (u) nX number of states (x) nY number of outputs (y) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) r0 [optional] initial diagonal elements of output noise covariance (R)   operator= #  sys_t \u0026amp; operator=( const sys_t \u0026amp; sys )  getNy #  inline size_t getNy() const  getC #  inline armaMat getC() const  getD #  inline armaVec getD() const  getR #  inline armaVec getR() const  getY #  inline armaVec getY() const  getZ #  inline armaVec getZ() const  getKe #  inline armaMat getKe() const  getKe_m #  inline armaMat getKe_m() const  setDims #  void setDims( std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY )  setC #  void setC( stdVec \u0026amp; cVec )  setC #  void setC( armaMat \u0026amp; C )  setD #  void setD( stdVec \u0026amp; dVec )  setD #  void setD( armaVec \u0026amp; d )  setR #  void setR( stdVec \u0026amp; rVec )  setR #  void setR( armaMat \u0026amp; R )  setZ #  void setZ( stdVec \u0026amp; zVec )  setZ #  void setZ( armaVec \u0026amp; z )  setKe #  void setKe( stdVec \u0026amp; keVec )  setKe #  void setKe( armaMat \u0026amp; Ke )  setKe_m #  void setKe_m( stdVec \u0026amp; kemVec )  setKe_m #  void setKe_m( armaMat \u0026amp; Ke_m )  reset #  void reset()  printSys #  void printSys()  Protected Function Details #  recurse_Ke #  void recurse_Ke()  predict #  void predict()  h #  void h()  defaultR #  void defaultR()  Protected Attribute Details #  nY #  std::size_t nY;  C #  armaMat C;  d #  armaVec d;  R #  armaMat R;  r0 #  data_t \u0026amp; r0;  y #  armaVec y;  z #  armaVec z;  Ke #  armaMat Ke;  Ke_m #  armaMat Ke_m;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':31,'href':'/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/','title':"lds::poisson",'section':"Namespaces",'content':"lds::poisson #  Linear Dynamical Systems with Poisson observations. Classes #      Name     class lds::poisson::ctrl_t PLDS Controller Type.   class lds::poisson::fit_t PLDS Fit Type.   class lds::poisson::ssidFit_t GLDS SSID Fit Type.   class lds::poisson::sctrl_t Switched PLDS Controller Type.   class lds::poisson::sys_t Poisson LDS Type.    Types #      Name     typedef lds::data_t data_t   typedef lds::stdVec stdVec   typedef lds::armaVec armaVec   typedef lds::armaMat armaMat   typedef lds::armaSubVec armaSubVec   typedef lds::armaSubMat armaSubMat    Functions #      Name     std::tuple\u0026lt; ssidFit_t, lds::gaussian::ssidFit_t \u0026gt; ssidFit(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-inf), ssidWt wt =NONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =DEFAULT_T0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), bool assumeGaussian =true)\nFit a PLDS model using subspace identification (SSID)   void newtonSolveC_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nSolve for output matrix by Poisson MLE.   data_t newtonSolve_rescaleC_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nSolve for rescaled output matrix by Poisson MLE.   void calcD_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nCalculates output bias by Poisson MLE.   data_t calcD_newtonSolve_rescaleC_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nCalculates output bias and rescaled output matrix by Poisson MLE.   void fitOutput_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nCalculates exponential output function by Poisson MLE.    Attributes #      Name     const std::size_t CONTROL_TYPE_U   const std::size_t CONTROL_TYPE_INTY   const std::size_t CONTROL_TYPE_ADAPT_M   data_t DATA_T_ZERO   data_t DATA_T_ONE   data_t DEFAULT_SOFTSTART   bool FALSE   bool TRUE   const data_t pi   data_t inf   data_t neginf    Type Details #  data_t #  typedef lds::data_t lds::poisson::data_t; stdVec #  typedef lds::stdVec lds::poisson::stdVec; armaVec #  typedef lds::armaVec lds::poisson::armaVec; armaMat #  typedef lds::armaMat lds::poisson::armaMat; armaSubVec #  typedef lds::armaSubVec lds::poisson::armaSubVec; armaSubMat #  typedef lds::armaSubMat lds::poisson::armaSubMat; Function Details #  ssidFit #  std::tuple\u0026lt; ssidFit_t, lds::gaussian::ssidFit_t \u0026gt; ssidFit( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-inf), ssidWt wt =NONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =DEFAULT_T0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), bool assumeGaussian =true ) Parameters:\n u inputs n { parameter_description } dt sample period nX number of states nH block-Hankel data matrix size d0 previous estimate of output bias (d) wt chosen weighting for SSID singular value \\ decomposition (NONE, MOESP, CVA) wtG0 chosen weighting for minimizing model error at \\ DC t0 start times for each trial of input/output data t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID assumeGaussian [NONFUNCTIONAL] whether to assume Gaussian observation model and fit by linear SSID first, then fit output nonlinearity by Poisson MLE z measurements  Return: tuple\u0026lt;PLDS fit, GLDS fit\u0026gt;\nFit PLDS model by subspace identification (SSID). System matrices (A,B,C) are fit by SSID assuming gaussian observations. Iteratively refits output function parameters (C, d) by Poisson MLE using Newton\u0026rsquo;s method.\nnewtonSolveC_mle #  void newtonSolveC_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Given dynamics and initial guess of output, solves for output matrix (C) by maximizing Poisson maximum likelihood using Newton\u0026rsquo;s method.\nnewtonSolve_rescaleC_mle #  data_t newtonSolve_rescaleC_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Return: negative log-likelihood\nGiven dynamics and initial guess of output, solves for a scaling factor to apply to output matrix (C) by maximizing Poisson maximum likelihood using Newton\u0026rsquo;s method.\nn.b., see Bussgang theorem (1952)\ncalcD_mle #  void calcD_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  calcD_newtonSolve_rescaleC_mle #  data_t calcD_newtonSolve_rescaleC_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Return: negative log-likelihood\nfitOutput_mle #  void fitOutput_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Attribute Details #  CONTROL_TYPE_U #  static const std::size_t CONTROL_TYPE_U = lds::CONTROL_TYPE_U; CONTROL_TYPE_INTY #  static const std::size_t CONTROL_TYPE_INTY = lds::CONTROL_TYPE_INTY; CONTROL_TYPE_ADAPT_M #  static const std::size_t CONTROL_TYPE_ADAPT_M = lds::CONTROL_TYPE_ADAPT_M; DATA_T_ZERO #  static data_t DATA_T_ZERO = lds::DATA_T_ZERO; DATA_T_ONE #  static data_t DATA_T_ONE = lds::DATA_T_ZERO; DEFAULT_SOFTSTART #  static data_t DEFAULT_SOFTSTART = lds::DEFAULT_SOFTSTART; FALSE #  static bool FALSE = lds::FALSE; TRUE #  static bool TRUE = lds::TRUE; pi #  static const data_t pi = lds::pi; inf #  static data_t inf = lds::inf; neginf #  static data_t neginf = lds::neginf;  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':32,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1ctrl__t/','title':"lds::poisson::ctrl_t",'section':"Classes",'content':"lds::poisson::ctrl_t #  PLDS Controller Type. #include \u0026lt;lds_poisson_ctrl.h\u0026gt;\nInherits from lds::poisson::sys_t, lds::sys_t\nInherited by lds::poisson::sctrl_t\nPublic Functions #      Name      ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0)\nConstructs a new PLDS controller.   ctrl_t \u0026amp; operator=(const ctrl_t \u0026amp; sys)   void logLin_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE)   void steadyState_logLin_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE)\nsteady-state log-linear control (single step)   void calc_ssSetPt()   void printSys()\nPrint system variables.   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setGDesign(stdVec \u0026amp; gVec)\nSet input gain used in controller design (gDesign)   void setGDesign(armaVec \u0026amp; g)\nSet input gain used in controller design (gDesign)   void setURef(stdVec \u0026amp; uRefVec)\nSet reference input (uRef)   void setURef(armaVec \u0026amp; uRef)\nSet reference input (uRef)   void setXRef(stdVec \u0026amp; xRefVec)\nSet reference state (xRef)   void setXRef(armaVec \u0026amp; xRef)\nSet reference state (xRef)   void setYRef(stdVec \u0026amp; yRefVec)\nSet reference output (yRef)   void setYRef(armaVec \u0026amp; yRef)\nSet reference output (yRef)   void setKc_x(stdVec \u0026amp; Kc_xVec)\nSet state controller gain (Kc_x)   void setKc_x(armaMat \u0026amp; Kc_x)\nSet state controller gain (Kc_x)   void setKc_u(stdVec \u0026amp; Kc_uVec)\nSet input controller gain (Kc_u)   void setKc_u(armaMat \u0026amp; Kc_u)\nSet input controller gain (Kc_u)   void setKc_inty(stdVec \u0026amp; Kc_intyVec)\nSet integral controller gain (Kc_inty)   void setKc_inty(armaMat \u0026amp; Kc_inty)\nSet integral controller gain (Kc_inty)   void setControlType(size_t controlType)\nSet controller type.   void setTauAntiWindup(data_t \u0026amp; tau)\nSet time constant of anti-integral-windup.   armaMat getKc_u() const\nGet input controller gain (Kc_u)   armaMat getKc_x() const\nGet input controller gain (Kc_u)   armaMat getKc_inty() const\nGet integral controller gain (Kc_inty)   armaVec getGDesign() const\nGet input gain used in controller design (gDesign)   armaVec getURef() const\nGet reference input (uRef)   armaVec getXRef() const\nGet reference state (xRef)   armaVec getLogYRef() const\nGet reference log-output (logyRef)   armaVec getYRef() const\nGet reference output (yRef)   armaVec getLogY() const\nGet log-output (logy)   armaVec getIntE() const\nGet integrated error (intE)   size_t getControlType() const\nGet controller type.   void reset()\nReset system variables.    Protected Functions #      Name     void antiWindup()\nProtect against integral windup.    Protected Attributes #      Name     armaVec gDesign input gain of the system used for controller design   armaVec uRef reference input   armaVec uRef_prev reference input at previous time step   armaVec xRef reference state   armaVec logyRef reference log-output   armaVec yRef reference output   armaMat Kc_x state controller gain   armaMat Kc_u input controller gain (when control aims to minimize deltaU)   armaMat Kc_inty integral controller gain (log-linear)   armaVec duRef   armaVec dvRef   armaVec vRef   armaVec dv   armaVec v Control after g inversion (e.g., control in physical units)   armaVec intE integrated error (log-output)   armaVec intE_awuAdjust anti-windup adjustment to intE   armaVec uSat control signal after saturation (for antiWindup)   bool gateCtrl_prev   bool gateLock_prev   data_t yRefLB lower bound on yRef (to avoid numerical log(0) issue)   bool uSaturated whether control signal has reached saturation limits   data_t \u0026amp; uLB lower bound on control   data_t \u0026amp; uUB upper bound on control   data_t tauAntiWindup antiwindup time constant   data_t kAntiWindup   data_t t_since_ctrl_onset time since control epoch onset   size_t controlType controller type    Additional inherited members #  Public Functions inherited from lds::poisson::sys_t\n    Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate one step of the model and produce a measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new PLDS.   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (D)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY)\nSet dimensions of sytem.   void setC(stdVec \u0026amp; cVec)\nSet output matrix (C)   void setC(armaMat \u0026amp; C)\nSet output matrix (C)   void setD(stdVec \u0026amp; dVec)\nSet output bias (d)   void setD(armaVec \u0026amp; d)\nSet output bias (d)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)    Protected Functions inherited from lds::poisson::sys_t\n    Name     void predict()\nOne-step prediction.   void h()\nSystem output function.    Protected Attributes inherited from lds::poisson::sys_t\n    Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaVec y output   armaVec logy logarithm of output   armaVec z measurement   armaMat diag_y diagonal matrix with elements y   armaVec chance p.r. number for rolling dice if simulating data    Public Functions inherited from lds::sys_t\n    Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX)\nSet dimensions of system.   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)    Protected Functions inherited from lds::sys_t\n    Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  ctrl_t #  ctrl_t( std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0 ) Parameters:\n nU number of inputs nX number of states nY number of outputs uLB lower bound on control (u) uUB upper bound on control (u) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) controlType [optional] control type bit mask   operator= #  ctrl_t \u0026amp; operator=( const ctrl_t \u0026amp; sys )  logLin_fbCtrl #  void logLin_fbCtrl( armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE )  steadyState_logLin_fbCtrl #  void steadyState_logLin_fbCtrl( armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE ) Parameters:\n z measurement gateCtrl [optional] logical gate of control (high=enabled; low=disabled) gateEst [optional] logical gate of estimator (high=enabled; low=disabled) gateLock [optional] logical gate of control signal lock (if high, locks control at current value) sigma_softStart [optional] standard deviation (sigma) of a Gaussian soft-start to control sigma_uNoise [optional] standard deviation (sigma) of Gaussian noise added on top of control resetAtCtrlOnset [optional] whether to reset controller at onset of a new control epoch (gateCtrl from low to high)  Assuming the objective is to track a reference output (yRef) at steady state, perform a single step of control in the log-output space, which is linear given the assumed exponential output nonlinearity.\nn.b., Requires user to have set the controller\u0026rsquo;s yRef variable.\nn.b., If control is enabled (gateCtrl=true) but estimator is disabled (gateEst=true), this function provides the calculated steady-state input uRef in open loop.\n calc_ssSetPt #  void calc_ssSetPt() Calculate steady-state setpoint [xRef; uRef], given an output reference yRef.\n printSys #  void printSys()  setU #  void setU( stdVec \u0026amp; uVec )  setU #  void setU( armaVec \u0026amp; u )  setG #  void setG( stdVec \u0026amp; gVec )  setG #  void setG( armaVec \u0026amp; g )  setGDesign #  void setGDesign( stdVec \u0026amp; gVec )  setGDesign #  void setGDesign( armaVec \u0026amp; g )  setURef #  void setURef( stdVec \u0026amp; uRefVec )  setURef #  void setURef( armaVec \u0026amp; uRef )  setXRef #  void setXRef( stdVec \u0026amp; xRefVec )  setXRef #  void setXRef( armaVec \u0026amp; xRef )  setYRef #  void setYRef( stdVec \u0026amp; yRefVec )  setYRef #  void setYRef( armaVec \u0026amp; yRef )  setKc_x #  void setKc_x( stdVec \u0026amp; Kc_xVec )  setKc_x #  void setKc_x( armaMat \u0026amp; Kc_x )  setKc_u #  void setKc_u( stdVec \u0026amp; Kc_uVec )  setKc_u #  void setKc_u( armaMat \u0026amp; Kc_u )  setKc_inty #  void setKc_inty( stdVec \u0026amp; Kc_intyVec )  setKc_inty #  void setKc_inty( armaMat \u0026amp; Kc_inty )  setControlType #  void setControlType( size_t controlType )  setTauAntiWindup #  void setTauAntiWindup( data_t \u0026amp; tau )  getKc_u #  inline armaMat getKc_u() const  getKc_x #  inline armaMat getKc_x() const  getKc_inty #  inline armaMat getKc_inty() const  getGDesign #  inline armaVec getGDesign() const  getURef #  inline armaVec getURef() const  getXRef #  inline armaVec getXRef() const  getLogYRef #  inline armaVec getLogYRef() const  getYRef #  inline armaVec getYRef() const  getLogY #  inline armaVec getLogY() const  getIntE #  inline armaVec getIntE() const  getControlType #  inline size_t getControlType() const  reset #  void reset()  Protected Function Details #  antiWindup #  void antiWindup() Protect against integral windup\nReference:\nAstroem KJ, Rundqwist L. (1989) Integrator Windup and How to Avoid It. 1989 ACC.\n Protected Attribute Details #  gDesign #  armaVec gDesign;  uRef #  armaVec uRef;  uRef_prev #  armaVec uRef_prev;  xRef #  armaVec xRef;  logyRef #  armaVec logyRef;  yRef #  armaVec yRef;  Kc_x #  armaMat Kc_x;  Kc_u #  armaMat Kc_u;  Kc_inty #  armaMat Kc_inty;  duRef #  armaVec duRef;  dvRef #  armaVec dvRef;  vRef #  armaVec vRef;  dv #  armaVec dv;  v #  armaVec v;  intE #  armaVec intE;  intE_awuAdjust #  armaVec intE_awuAdjust;  uSat #  armaVec uSat;  gateCtrl_prev #  bool gateCtrl_prev;  gateLock_prev #  bool gateLock_prev;  yRefLB #  data_t yRefLB;  uSaturated #  bool uSaturated;  uLB #  data_t \u0026amp; uLB;  uUB #  data_t \u0026amp; uUB;  tauAntiWindup #  data_t tauAntiWindup;  kAntiWindup #  data_t kAntiWindup;  t_since_ctrl_onset #  data_t t_since_ctrl_onset;  controlType #  size_t controlType;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':33,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1fit__t/','title':"lds::poisson::fit_t",'section':"Classes",'content':"lds::poisson::fit_t #  PLDS Fit Type. #include \u0026lt;lds_poisson_fit.h\u0026gt;\nInherits from lds::fit_t\nInherited by lds::poisson::ssidFit_t\nPublic Functions #      Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new PLDS fit.    Public Attributes #      Name     armaMat C output matrix   armaVec d output bias   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Additional inherited members #  Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  fit_t #  inline fit_t()  fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias dt sample period uTrain input training data zTrain measurement training data   Public Attribute Details #  C #  armaMat C;  d #  armaVec d;  uTrain #  std::vector\u0026lt; armaMat \u0026gt; uTrain;  zTrain #  std::vector\u0026lt; armaMat \u0026gt; zTrain;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':34,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sctrl__t/','title':"lds::poisson::sctrl_t",'section':"Classes",'content':"lds::poisson::sctrl_t #  Switched PLDS Controller Type. #include \u0026lt;lds_poisson_sctrl.h\u0026gt;\nInherits from lds::poisson::ctrl_t, lds::poisson::sys_t, lds::sys_t\nPublic Functions #      Name      sctrl_t(std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0)\nConstructs a new switched PLDS controller.   void setSystem(size_t sysIdx, ctrl_t \u0026amp; sys)   void switchSystem(size_t sysIdx)\nSwitch to a different underlying sub-system.   size_t getSysIdx() const\nGet the index of currently active sub-system.    Protected Attributes #      Name     size_t nSys number of systems   std::vector\u0026lt; ctrl_t \u0026gt; systems underlying sub-systems which are toggled between   size_t sysIdx current system index    Additional inherited members #  Public Functions inherited from lds::poisson::ctrl_t\n    Name      ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0)\nConstructs a new PLDS controller.   ctrl_t \u0026amp; operator=(const ctrl_t \u0026amp; sys)   void logLin_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE)   void steadyState_logLin_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE)\nsteady-state log-linear control (single step)   void calc_ssSetPt()   void printSys()\nPrint system variables.   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setGDesign(stdVec \u0026amp; gVec)\nSet input gain used in controller design (gDesign)   void setGDesign(armaVec \u0026amp; g)\nSet input gain used in controller design (gDesign)   void setURef(stdVec \u0026amp; uRefVec)\nSet reference input (uRef)   void setURef(armaVec \u0026amp; uRef)\nSet reference input (uRef)   void setXRef(stdVec \u0026amp; xRefVec)\nSet reference state (xRef)   void setXRef(armaVec \u0026amp; xRef)\nSet reference state (xRef)   void setYRef(stdVec \u0026amp; yRefVec)\nSet reference output (yRef)   void setYRef(armaVec \u0026amp; yRef)\nSet reference output (yRef)   void setTauAntiWindup(data_t \u0026amp; tau)\nSet time constant of anti-integral-windup.   armaMat getKc_u() const\nGet input controller gain (Kc_u)   armaMat getKc_x() const\nGet input controller gain (Kc_u)   armaMat getKc_inty() const\nGet integral controller gain (Kc_inty)   armaVec getGDesign() const\nGet input gain used in controller design (gDesign)   armaVec getURef() const\nGet reference input (uRef)   armaVec getXRef() const\nGet reference state (xRef)   armaVec getLogYRef() const\nGet reference log-output (logyRef)   armaVec getYRef() const\nGet reference output (yRef)   armaVec getLogY() const\nGet log-output (logy)   armaVec getIntE() const\nGet integrated error (intE)   size_t getControlType() const\nGet controller type.   void reset()\nReset system variables.    Protected Functions inherited from lds::poisson::ctrl_t\n    Name     void antiWindup()\nProtect against integral windup.    Protected Attributes inherited from lds::poisson::ctrl_t\n    Name     armaVec gDesign input gain of the system used for controller design   armaVec uRef reference input   armaVec uRef_prev reference input at previous time step   armaVec xRef reference state   armaVec logyRef reference log-output   armaVec yRef reference output   armaMat Kc_x state controller gain   armaMat Kc_u input controller gain (when control aims to minimize deltaU)   armaMat Kc_inty integral controller gain (log-linear)   armaVec duRef   armaVec dvRef   armaVec vRef   armaVec dv   armaVec v Control after g inversion (e.g., control in physical units)   armaVec intE integrated error (log-output)   armaVec intE_awuAdjust anti-windup adjustment to intE   armaVec uSat control signal after saturation (for antiWindup)   bool gateCtrl_prev   bool gateLock_prev   data_t yRefLB lower bound on yRef (to avoid numerical log(0) issue)   bool uSaturated whether control signal has reached saturation limits   data_t \u0026amp; uLB lower bound on control   data_t \u0026amp; uUB upper bound on control   data_t tauAntiWindup antiwindup time constant   data_t kAntiWindup   data_t t_since_ctrl_onset time since control epoch onset   size_t controlType controller type    Public Functions inherited from lds::poisson::sys_t\n    Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate one step of the model and produce a measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new PLDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (D)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions inherited from lds::poisson::sys_t\n    Name     void predict()\nOne-step prediction.   void h()\nSystem output function.    Protected Attributes inherited from lds::poisson::sys_t\n    Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaVec y output   armaVec logy logarithm of output   armaVec z measurement   armaMat diag_y diagonal matrix with elements y   armaVec chance p.r. number for rolling dice if simulating data    Public Functions inherited from lds::sys_t\n    Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions inherited from lds::sys_t\n    Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  sctrl_t #  sctrl_t( std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0 ) Parameters:\n nSys number of systems nU number of inputs nX number of states nY number of outputs uLB lower bound on control (u) uUB upper bound on control (u) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) controlType [optional] control type bit mask   setSystem #  void setSystem( size_t sysIdx, ctrl_t \u0026amp; sys ) Set the parameters of selected sub-system using previously instantiated GLDS controllers.\n switchSystem #  void switchSystem( size_t sysIdx ) Switch to a different underlying sub-system by reassiging parameters at switch.\n getSysIdx #  inline size_t getSysIdx() const  Protected Attribute Details #  nSys #  size_t nSys;  systems #  std::vector\u0026lt; ctrl_t \u0026gt; systems;  sysIdx #  size_t sysIdx;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':35,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1ssid_fit__t/','title':"lds::poisson::ssidFit_t",'section':"Classes",'content':"lds::poisson::ssidFit_t #  GLDS SSID Fit Type. #include \u0026lt;lds_poisson_fit_ssid.h\u0026gt;\nInherits from lds::poisson::fit_t, lds::fit_t\nPublic Functions #      Name      ssidFit_t()    ssidFit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new PLDS SSID fit.    Public Attributes #      Name     std::vector\u0026lt; data_t \u0026gt; t0   data_t t_startSSID   data_t t_stopSSID   armaVec singVals    Additional inherited members #  Public Functions inherited from lds::poisson::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new PLDS fit.    Public Attributes inherited from lds::poisson::fit_t\n    Name     armaMat C output matrix   armaVec d output bias   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Public Functions inherited from lds::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  ssidFit_t #  inline ssidFit_t()  ssidFit_t #  ssidFit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias dt sample period t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID singVals singular values from SSID SVD step t0 start times for each trial of input/output data uTrain training input data zTrain training measurement data   Public Attribute Details #  t0 #  std::vector\u0026lt; data_t \u0026gt; t0;  t_startSSID #  data_t t_startSSID;  t_stopSSID #  data_t t_stopSSID;  singVals #  armaVec singVals;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':36,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/','title':"lds::poisson::sys_t",'section':"Classes",'content':"lds::poisson::sys_t #  Poisson LDS Type. #include \u0026lt;lds_poisson_sys.h\u0026gt;\nInherits from lds::sys_t\nInherited by lds::poisson::ctrl_t\nPublic Functions #      Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate one step of the model and produce a measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new PLDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (D)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY)\nSet dimensions of sytem.   void setC(stdVec \u0026amp; cVec)\nSet output matrix (C)   void setC(armaMat \u0026amp; C)\nSet output matrix (C)   void setD(stdVec \u0026amp; dVec)\nSet output bias (d)   void setD(armaVec \u0026amp; d)\nSet output bias (d)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions #      Name     void predict()\nOne-step prediction.   void h()\nSystem output function.    Protected Attributes #      Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaVec y output   armaVec logy logarithm of output   armaVec z measurement   armaMat diag_y diagonal matrix with elements y   armaVec chance p.r. number for rolling dice if simulating data    Additional inherited members #  Public Functions inherited from lds::sys_t\n    Name     void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)    Protected Functions inherited from lds::sys_t\n    Name     void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  filter #  void filter( armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t ) Parameters:\n u_tm1 input at t-minus-1 z_t current measurement  Given current measurment and input, filter data to produce causal state estimates using a point-process filter, which procedes by predicting the state and subsequently updating.\nReferences:\nSmith AC, Brown EN. (2003) Estimating a State-Space Model from Point Process Observations. Neural Computation 15.\nEden UT, \u0026hellip;, Brown EN. (2004) Dynamic Analysis of Neural Encoding by Point Process Adaptive Filtering Neural Computation 16.\n filter #  void filter( armaVec \u0026amp; z ) Parameters:\n z current measurement  Given current measurment and input, filter data to produce causal state estimates using a point-process filter, which procedes by predicting the state and subsequently updating.\nReferences:\nSmith AC, Brown EN. (2003) Estimating a State-Space Model from Point Process Observations. Neural Computation 15.\nEden UT, \u0026hellip;, Brown EN. (2004) Dynamic Analysis of Neural Encoding by Point Process Adaptive Filtering Neural Computation 16.\n simMeasurement #  void simMeasurement( armaVec \u0026amp; z ) Parameters:\n z measurement   sys_t #  sys_t( std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0 ) Parameters:\n nU number of inputs nX number of states nY number of outputs dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q)   operator= #  sys_t \u0026amp; operator=( const sys_t \u0026amp; sys )  getNy #  inline size_t getNy() const  getC #  inline armaMat getC() const  getD #  inline armaVec getD() const  getY #  inline armaVec getY() const  getZ #  inline armaVec getZ() const  setDims #  void setDims( std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY )  setC #  void setC( stdVec \u0026amp; cVec )  setC #  void setC( armaMat \u0026amp; C )  setD #  void setD( stdVec \u0026amp; dVec )  setD #  void setD( armaVec \u0026amp; d )  setZ #  void setZ( stdVec \u0026amp; zVec )  setZ #  void setZ( armaVec \u0026amp; z )  reset #  void reset()  printSys #  void printSys()  Protected Function Details #  predict #  void predict()  h #  void h()  Protected Attribute Details #  nY #  std::size_t nY;  C #  armaMat C;  d #  armaVec d;  y #  armaVec y;  logy #  armaVec logy;  z #  armaVec z;  diag_y #  armaMat diag_y;  chance #  armaVec chance;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':37,'href':'/ldsctrlest/docs/api/classes/classlds_1_1sys__t/','title':"lds::sys_t",'section':"Classes",'content':"lds::sys_t #  Linear Dynamical System Type. #include \u0026lt;lds_sys.h\u0026gt;\nInherited by lds::gaussian::sys_t, lds::poisson::sys_t\nPublic Functions #      Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX)\nSet dimensions of system.   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions #      Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes #      Name     bool adaptM    Protected Attributes #      Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  sys_t #  sys_t( std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0 ) Parameters:\n nU number if inputs (u) nX number of state (x) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q)   operator= #  sys_t \u0026amp; operator=( const sys_t \u0026amp; sys )  simPredict #  void simPredict()  getNx #  inline size_t getNx() const  getNu #  inline size_t getNu() const  getU #  inline armaVec getU() const  getX #  inline armaVec getX()  getG #  inline armaVec getG() const  getM #  inline armaVec getM() const  getA #  inline armaMat getA() const  getB #  inline armaMat getB() const  getQ #  inline armaMat getQ() const  getQ_m #  inline armaMat getQ_m() const  getP #  inline armaMat getP() const  getP_m #  inline armaMat getP_m() const  getX0 #  inline armaVec getX0() const  getP0 #  inline armaMat getP0() const  getM0 #  inline armaVec getM0() const  getP0_m #  inline armaMat getP0_m() const  setDims #  void setDims( std::size_t \u0026amp; nU, std::size_t \u0026amp; nX )  setU #  void setU( stdVec \u0026amp; uVec )  setU #  void setU( armaVec \u0026amp; u )  setA #  void setA( stdVec \u0026amp; aVec )  setA #  void setA( armaMat \u0026amp; A )  setB #  void setB( stdVec \u0026amp; bVec )  setB #  void setB( armaMat \u0026amp; B )  setM #  void setM( stdVec \u0026amp; mVec )  setM #  void setM( armaVec \u0026amp; m )  setG #  void setG( stdVec \u0026amp; gVec )  setG #  void setG( armaVec \u0026amp; g )  setQ #  void setQ( stdVec \u0026amp; qVec )  setQ #  void setQ( armaMat \u0026amp; Q )  setQ_m #  void setQ_m( stdVec \u0026amp; qmVec )  setQ_m #  void setQ_m( armaMat \u0026amp; Q_m )  setX0 #  void setX0( stdVec \u0026amp; x0Vec )  setX0 #  void setX0( armaVec \u0026amp; x0 )  setP0 #  void setP0( stdVec \u0026amp; p0Vec )  setP0 #  void setP0( armaMat \u0026amp; P0 )  setP0_m #  void setP0_m( stdVec \u0026amp; p0mVec )  setP0_m #  void setP0_m( armaMat \u0026amp; P0_m )  reset #  void reset()  printSys #  void printSys()  Protected Function Details #  predict #  void predict()  reassign #  void reassign( armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0 )  limit #  void limit( stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub )  limit #  void limit( armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub )  limit #  void limit( armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub )  defaultQ #  void defaultQ()  checkP #  void checkP()  Public Attribute Details #  adaptM #  bool adaptM;  Protected Attribute Details #  u #  armaVec u;  x #  armaVec x;  P #  armaMat P;  m #  armaVec m;  P_m #  armaMat P_m;  x0 #  armaVec x0;  P0 #  armaMat P0;  m0 #  armaVec m0;  P0_m #  armaMat P0_m;  A #  armaMat A;  B #  armaMat B;  g #  armaVec g;  Q #  armaMat Q;  Q_m #  armaMat Q_m;  dt #  data_t \u0026amp; dt;  q0 #  data_t \u0026amp; q0;  p0 #  data_t \u0026amp; p0;  nX #  std::size_t nX;  nU #  std::size_t nU;  szChanged #  bool szChanged;  plim #  const data_t plim = 1e2;   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':38,'href':'/ldsctrlest/docs/api/files/dir_2755d76cbd49ca86cc5d9263eb253d5e/','title':"ldsCtrlEst_h",'section':"Files",'content':"ldsCtrlEst_h #  Files #     Name     ldsCtrlEst_h/lds.h lds namespace   ldsCtrlEst_h/lds_fit.h LDS base fit type.   ldsCtrlEst_h/lds_gaussian.h glds namespace   ldsCtrlEst_h/lds_gaussian_ctrl.h GLDS controller type.   ldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type.   ldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type.   ldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type.   ldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type.   ldsCtrlEst_h/lds_gaussian_sys.h GLDS base type.   ldsCtrlEst_h/lds_poisson.h plds namespace   ldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type.   ldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type.   ldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type.   ldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type.   ldsCtrlEst_h/lds_poisson_sys.h PLDS base type.   ldsCtrlEst_h/lds_sys.h LDS base type.   ldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API)   ldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API)     Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':39,'href':'/ldsctrlest/docs/api/files/lds_8h/','title':"ldsCtrlEst_h/lds.h",'section':"Files",'content':"ldsCtrlEst_h/lds.h #  lds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Detailed Description #  This file defines the lds namespace, which will be an umbrella for linear dynamical systems with Gaussian ([lds::gaussian](/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/)) or Poisson ([lds::poisson](/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/)) observations.\nSource code #  //===-- ldsCtrlEst_h/lds.h - Linear Dynmical System Namespace ---*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_H #define LDSCTRLEST_LDS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { typedef double data_t; namespace fill = arma::fill; typedef std::vector\u0026lt;data_t\u0026gt; stdVec; typedef arma::Col\u0026lt;data_t\u0026gt; armaVec; typedef arma::Mat\u0026lt;data_t\u0026gt; armaMat; typedef arma::Cube\u0026lt;data_t\u0026gt; armaCube; typedef arma::subview_col\u0026lt;data_t\u0026gt; armaSubVec; typedef arma::subview\u0026lt;data_t\u0026gt; armaSubMat; static const std::size_t CONTROL_TYPE_U = 0x1; static const std::size_t CONTROL_TYPE_INTY = CONTROL_TYPE_U \u0026lt;\u0026lt; 1; static const std::size_t CONTROL_TYPE_ADAPT_M = CONTROL_TYPE_U \u0026lt;\u0026lt; 2; static data_t inf = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(); static data_t neginf = -inf; static const data_t pi = arma::datum::pi; static data_t DEFAULT_P0 = 1e-6; static data_t DEFAULT_Q0 = 1e-6; static data_t DEFAULT_R0 = 1e-2; static std::vector\u0026lt;data_t\u0026gt; DEFAULT_T0 = std::vector\u0026lt;data_t\u0026gt;(1, 0.0); // Ideally these should be const, but trying to pass reference which means its // val implicitly must be allowed to change. hopefully no one will try to // reassign their vals... static data_t DATA_T_ZERO = (data_t)0; static data_t DATA_T_ONE = (data_t)1; static data_t DEFAULT_SOFTSTART = (data_t)0; static bool FALSE = false; static bool TRUE = true; enum ssidWt { NONE, MOESP, CVA }; } // namespace lds  // fit and sys with dynamics only #include \u0026#34;lds_sys.h\u0026#34;#ifdef LDSCTRLEST_BUILD_FIT #include \u0026#34;lds_fit.h\u0026#34;#endif  // Pull in output equation variants #include \u0026#34;lds_gaussian.h\u0026#34;#include \u0026#34;lds_poisson.h\u0026#34; #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':40,'href':'/ldsctrlest/docs/api/files/lds__fit_8h/','title':"ldsCtrlEst_h/lds_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_fit.h #  LDS base fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::fit_t LDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a linear dynamical system. It is expounded upon by variants with Gaussian and Poisson observation assumptions for fitting.\nSource code #  //===-- ldsCtrlEst_h/lds_fit.h - Fit Type for LDS ---------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDS_FIT_HPP #define LDS_FIT_HPP  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { class fit_t { public: fit_t(){}; fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, data_t\u0026amp; dt); // Dynamics  armaMat A; armaMat B; armaVec g; armaVec m; armaMat Q; armaVec x0; armaMat P0; data_t dt; }; } // namespace lds #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':41,'href':'/ldsctrlest/docs/api/files/lds__gaussian_8h/','title':"ldsCtrlEst_h/lds_gaussian.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian.h #  glds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Detailed Description #  This file declares and partially defines the namespace for linear dynamical systems with Gaussian observations ([lds::gaussian](/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian.h - LDS with Gaussian Output --*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_H #define LDSCTRLEST_LDS_GAUSSIAN_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { typedef lds::data_t data_t; typedef lds::stdVec stdVec; typedef lds::armaVec armaVec; typedef lds::armaMat armaMat; typedef lds::armaSubVec armaSubVec; typedef lds::armaSubMat armaSubMat; namespace fill = lds::fill; // CONTROL BIT MASKS static const std::size_t CONTROL_TYPE_U = lds::CONTROL_TYPE_U; static const std::size_t CONTROL_TYPE_INTY = lds::CONTROL_TYPE_INTY; static const std::size_t CONTROL_TYPE_ADAPT_M = lds::CONTROL_TYPE_ADAPT_M; // default values static data_t DATA_T_ZERO = lds::DATA_T_ZERO; static data_t DATA_T_ONE = lds::DATA_T_ZERO; static data_t DEFAULT_SOFTSTART = lds::DEFAULT_SOFTSTART; static bool FALSE = lds::FALSE; static bool TRUE = lds::TRUE; // static const data_t inf = lds::inf; static const data_t pi = lds::pi; static data_t inf = lds::inf; static data_t neginf = lds::neginf; } // namespace gaussian } // namespace lds  #include \u0026#34;lds_gaussian_sys.h\u0026#34;#ifdef LDSCTRLEST_BUILD_FIT #include \u0026#34;lds_gaussian_fit.h\u0026#34;#endif  #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':42,'href':'/ldsctrlest/docs/api/files/lds__gaussian__ctrl_8h/','title':"ldsCtrlEst_h/lds_gaussian_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_ctrl.h #  GLDS controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::ctrl_t GLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for feedback control of a gaussian-output linear dynamical system ([lds::gaussian::ctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ctrl__t/)). It inherits functionality from the underlying GLDS model type ([lds::gaussian::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/)), including state estimation.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_ctrl.h - GLDS Controller ------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_CTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class ctrl_t : public sys_t { public: ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, data_t\u0026amp; r0 = DEFAULT_R0, size_t controlType = 0); ctrl_t\u0026amp; operator=(const ctrl_t\u0026amp; sys); // These are the workhorse functions:  void fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE, bool\u0026amp; doRecurse_Ke = TRUE); void steadyState_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateEst = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE, bool\u0026amp; doRecurse_Ke = TRUE); void calc_ssSetPt(); void printSys(); // set methods  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX, std::size_t\u0026amp; nY); // make sure to override the setU behavior inherited from sys_t!  // cannot set u for a controller, as it generates its own.  void setU(stdVec\u0026amp; uVec); void setU(armaVec\u0026amp; u); void setG(stdVec\u0026amp; gVec); void setG(armaVec\u0026amp; g); void setGDesign(stdVec\u0026amp; gVec); void setGDesign(armaVec\u0026amp; g); void setURef(stdVec\u0026amp; uRefVec); void setURef(armaVec\u0026amp; uRef); void setXRef(stdVec\u0026amp; xRefVec); void setXRef(armaVec\u0026amp; xRef); void setYRef(stdVec\u0026amp; yRefVec); void setYRef(armaVec\u0026amp; yRef); void setKc_x(stdVec\u0026amp; Kc_x_vec); void setKc_x(armaMat\u0026amp; Kc_x); void setKc_u(stdVec\u0026amp; Kc_u_vec); void setKc_u(armaMat\u0026amp; Kc_u); void setKc_inty(stdVec\u0026amp; Kc_inty_vec); void setKc_inty(armaMat\u0026amp; Kc_inty); void setControlType(size_t controlType); void setTauAntiWindup(data_t\u0026amp; tau); armaMat getKc_u() const { return Kc_u; }; armaMat getKc_x() const { return Kc_x; }; armaMat getKc_inty() const { return Kc_inty; }; armaVec getGDesign() const { return gDesign; }; armaVec getURef() const { return uRef; }; armaVec getXRef() const { return xRef; }; armaVec getYRef() const { return yRef; }; armaVec getIntE() const { return intE; }; size_t getControlType() const { return controlType; }; void reset(); protected: armaVec gDesign; // reference signals  armaVec uRef; // create no set method for this:  armaVec uRef_prev; armaVec xRef; armaVec yRef; // Controller gains  armaMat Kc_x; armaMat Kc_u; armaMat Kc_inty; // control after g inversion  // do not need set methods for these.  armaVec duRef; armaVec dvRef; armaVec vRef; armaVec dv; armaVec v; // integral error  // do not need set method for this  armaVec intE; armaVec intE_awuAdjust; armaVec uSat; bool gateCtrl_prev; bool gateLock_prev; // whether the g of system has become inverted from what you think it is  // (gainRef)  bool uSaturated; // should be safe to have references here bc nothing needs to be done  // (like reset vars) when it changes...  data_t\u0026amp; uLB; data_t\u0026amp; uUB; data_t tauAntiWindup; data_t kAntiWindup; void antiWindup(); data_t t_since_ctrl_onset; size_t controlType; private: void calc_ctrl(bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateEst = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE); }; } // namespace gaussian } // namespace lds  #include \u0026#34;lds_gaussian_sctrl.h\u0026#34; #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':43,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit.h #  GLDS fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::fit_t GLDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit.h - Fit Type for GLDS -----*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class fit_t : public lds::fit_t { public: fit_t(){}; fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaMat\u0026amp; D, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); // Output  armaMat C; armaMat D; armaVec d; armaMat R; // input/output training data  std::vector\u0026lt;armaMat\u0026gt; uTrain; std::vector\u0026lt;armaMat\u0026gt; zTrain; }; }; // namespace gaussian } // namespace lds  // subspace identification #include \u0026#34;lds_gaussian_fit_ssid.h\u0026#34; // expectation maximization #include \u0026#34;lds_gaussian_fit_em.h\u0026#34; #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':44,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit__em_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit_em.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit_em.h #  GLDS E-M fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::emFit_t GLDS E-M Fit Type.    Detailed Description #  This file declares and partially defines a type by which Gaussian-output LDS models are fit by the expectation-maximization (EM) algorithm ([lds::gaussian::emFit_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1em_fit__t/)).\nReferences: [1] Shumway RH, Stoffer DS. (1982) An Approach to Time Series Smoothing and Forecasting Using the EM Algorithm.Journal of Time Series Analysis 3(2).\n[2] Ghahramani Z, Hinton GE. (1996) Parameter Estimation for Linear Dynamical Systems. Technical Report CRG-TR-96-2.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit_em.h - GLDS Fit (EM) ------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class emFit_t : public fit_t { public: emFit_t() : fit_t(){}; emFit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); emFit_t(data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); emFit_t(ssidFit_t\u0026amp; fit0); void reset(void); void runEM(bool calcAB = true, bool calcQ = true, bool calcInitial = true, bool calcC = true, bool calcd = true, bool calcR = true); data_t tol = 1e-3; size_t maxIter = 100; // get methods  std::vector\u0026lt;armaMat\u0026gt; getX() { return xHat; }; std::vector\u0026lt;armaMat\u0026gt; getY() { return yHat; }; // these are covariances that can be useful to the end-user  armaMat get_sum_E_xu_tm1_xu_tm1() { return sum_E_xu_tm1_xu_tm1; }; armaMat get_sum_E_xu_t_xu_tm1() { return sum_E_xu_t_xu_tm1; }; armaMat get_sum_E_xu_t_xu_t() { return sum_E_xu_t_xu_t; }; size_t getT() { return T; }; void setY(std::vector\u0026lt;armaMat\u0026gt; yHat) { this-\u0026gt;yHat = yHat; }; protected: armaVec getTheta(); void kalmanFilt(); void kalmanSmooth(bool forceCommonInitial); void Estep(bool forceCommonInitial = false); void Mstep(bool calcAB = true, bool calcQ = true, bool calcInitial = false, bool calcC = false, bool calcd = false, bool calcR = true); std::vector\u0026lt;armaMat\u0026gt; xHat; std::vector\u0026lt;arma::Cube\u0026lt;data_t\u0026gt;\u0026gt; P; std::vector\u0026lt;armaMat\u0026gt; yHat; std::vector\u0026lt;arma::Cube\u0026lt;data_t\u0026gt;\u0026gt; P_t_tm1; armaMat sum_E_xu_t_xu_t; armaMat sum_E_xu_tm1_xu_tm1; armaMat sum_E_xu_t_xu_tm1; size_t T; }; emFit_t emFit_x_equals_y(std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain, data_t dt, std::size_t maxIter = 100, data_t tol = 1e-3, data_t q0 = 1e-6, bool calcAB = true, bool calcQ = true, bool calcR = true); }; // namespace gaussian } // namespace lds  #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':45,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit__ssid_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit_ssid.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit_ssid.h #  GLDS SSID fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::ssidFit_t GLDS SSID Fit Type.    Detailed Description #  This file declares and partially defines a type by which Gaussian-output LDS models are fit by a subspace identification (SSID) algorithm ([lds::gaussian::ssidFit_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ssid_fit__t/)).\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit_ssid.h - GLDS Fit (SSID) --*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class ssidFit_t : public fit_t { public: ssidFit_t() : fit_t(){}; ssidFit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaMat\u0026amp; D, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec\u0026amp; singVals, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); std::vector\u0026lt;data_t\u0026gt; t0; data_t t_startSSID; data_t t_stopSSID; armaVec singVals; }; ssidFit_t ssidFit(std::vector\u0026lt;armaMat\u0026gt;\u0026amp; u, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; z, data_t dt, size_t nX, size_t nH = 25, armaVec d0 = armaVec(1).fill(-inf), bool force_unitNormC = false, ssidWt wt = NONE, data_t wtG0 = 0.0, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0 = DEFAULT_T0, data_t t_startSSID = -std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(), data_t t_stopSSID = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity()); armaVec calcD_silence(std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; u, data_t dt, data_t tSilence = 0.1, data_t threshSilence = 0.001); void createHankelMat_n4sid(armaMat\u0026amp; u, armaMat\u0026amp; z, std::size_t\u0026amp; nH, armaMat\u0026amp; D); void ssid_n4sid(std::size_t\u0026amp; nX, std::size_t\u0026amp; nU, std::size_t\u0026amp; nY, std::size_t\u0026amp; nH, armaMat\u0026amp; uSSID, armaMat\u0026amp; zSSID, armaMat\u0026amp; A, armaMat\u0026amp; B, armaMat\u0026amp; C, armaMat\u0026amp; D, armaMat\u0026amp; Q, armaMat\u0026amp; R, armaVec\u0026amp; m, armaVec\u0026amp; d, armaVec\u0026amp; s, bool force_unitNormC, ssidWt wt, data_t wtG0); void ssid_n4sid_vanOverschee(std::size_t\u0026amp; nX, std::size_t\u0026amp; nU, std::size_t\u0026amp; nY, std::size_t\u0026amp; nH, armaMat\u0026amp; uSSID, armaMat\u0026amp; zSSID, armaMat\u0026amp; A, armaMat\u0026amp; B, armaMat\u0026amp; C, armaMat\u0026amp; D, armaMat\u0026amp; Q, armaMat\u0026amp; R, armaVec\u0026amp; s, ssidWt wt); void recompute_extObs(armaMat\u0026amp; extObs, armaMat\u0026amp; A, armaMat\u0026amp; C, std::size_t\u0026amp; nY, std::size_t\u0026amp; nH); void lq(armaMat\u0026amp; L, armaMat\u0026amp; Qt, armaMat\u0026amp; X); armaMat calcCov(armaMat\u0026amp; A, armaMat\u0026amp; B); armaMat sqrtmat_svd(armaMat\u0026amp; X); } // namespace gaussian } // namespace lds #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':46,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sctrl_8h/','title':"ldsCtrlEst_h/lds_gaussian_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_sctrl.h #  GLDS switched controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::sctrl_t Switched GLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Gaussian-output linear dynamical systems ([lds::gaussian::sctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sctrl__t/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_sctrl.h - Switched Controller -*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class sctrl_t : public ctrl_t { public: sctrl_t(std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, data_t\u0026amp; r0 = DEFAULT_R0, size_t controlType = 0); void setSystem(size_t sysIdx, ctrl_t\u0026amp; sys); // TODO(mfbolus):  // This switchSystem(sysIdx) approach is wasteful but simple.  // Would be faster to toggle between ctrl_t\u0026#39;s and replace wrapper u, x, P, m,  // P_m. However, would have to override or rewrite most controller  // functionality.  void switchSystem(size_t sysIdx); size_t getSysIdx() const { return sysIdx; }; protected: size_t nSys; std::vector\u0026lt;ctrl_t\u0026gt; systems; size_t sysIdx; private: // make all parameter set* methods private and define them to do nothing.  // force users to use setSystem, with pre-defined systems.  // from lds_t:  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX){}; void setU(stdVec\u0026amp; uVec){}; void setU(armaVec\u0026amp; u){}; void setA(stdVec\u0026amp; aVec){}; void setA(armaMat\u0026amp; A){}; void setB(stdVec\u0026amp; bVec){}; void setB(armaMat\u0026amp; B){}; void setM(stdVec\u0026amp; mVec){}; void setM(armaVec\u0026amp; m){}; // void setG(stdVec\u0026amp; gVec) {};  // void setG(armaVec\u0026amp; g) {};  void setQ(stdVec\u0026amp; qVec){}; void setQ(armaMat\u0026amp; Q){}; void setQ_m(stdVec\u0026amp; qmVec){}; void setQ_m(armaMat\u0026amp; Q_m){}; void setX0(stdVec\u0026amp; x0Vec){}; void setX0(armaVec\u0026amp; x0){}; void setP0(stdVec\u0026amp; p0Vec){}; void setP0(armaMat\u0026amp; P0){}; void setP0_m(stdVec\u0026amp; p0mVec){}; void setP0_m(armaMat\u0026amp; P0_m){}; // from sys_t  void setC(stdVec\u0026amp; cVec){}; void setC(armaMat\u0026amp; C){}; void setD(stdVec\u0026amp; dVec){}; void setD(armaVec\u0026amp; d){}; void setR(stdVec\u0026amp; rVec){}; void setR(armaMat\u0026amp; R){}; void setKe(stdVec\u0026amp; keVec){}; void setKe(armaMat\u0026amp; Ke){}; void setKe_m(stdVec\u0026amp; kemVec){}; void setKe_m(armaMat\u0026amp; Ke_m){}; // from ctrl_t  // void setGDesign(stdVec\u0026amp; gVec) {};  // void setGDesign(armaVec\u0026amp; g) {};  void setKc_x(stdVec\u0026amp; Kc_xVec){}; void setKc_x(armaVec\u0026amp; Kc_x){}; void setKc_u(stdVec\u0026amp; Kc_uVec){}; void setKc_u(armaVec\u0026amp; Kc_u){}; void setKc_inty(stdVec\u0026amp; Kc_intyVec){}; void setKc_inty(armaVec\u0026amp; Kc_inty){}; void setControlType(size_t controlType); // {};  // assuming I *want* to maintain same references  // void setURef(stdVec\u0026amp; uRefVec) {};  // void setURef(armaVec\u0026amp; uRef) {};  // void setXRef(stdVec\u0026amp; xRefVec) {};  // void setXRef(armaVec\u0026amp; xRef) {};  // void setYRef(stdVec\u0026amp; yRefVec) {};  // void setYRef(armaVec\u0026amp; yRef) {}; }; } // namespace gaussian } // namespace lds  #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':47,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sys_8h/','title':"ldsCtrlEst_h/lds_gaussian_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_sys.h #  GLDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::sys_t Gaussian LDS Type.    Detailed Description #  This file declares and partially defines the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems ([lds::gaussian::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/)). It inherits functionality from the underlying linear dynamical system ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_sys.h - GLDS ------------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_SYS_H #define LDSCTRLEST_LDS_GAUSSIAN_SYS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class sys_t : public lds::sys_t { public: void filter(armaVec\u0026amp; u_tm1, armaVec\u0026amp; z_t, bool doRecurse_Ke = true); void filter(armaVec\u0026amp; z, bool doRecurse_Ke = true); void simMeasurement(armaVec\u0026amp; z); sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, data_t\u0026amp; r0 = DEFAULT_R0); sys_t\u0026amp; operator=(const sys_t\u0026amp; sys); // get methods  size_t getNy() const { return nY; }; armaMat getC() const { return C; }; armaVec getD() const { return d; }; armaVec getR() const { return R; }; armaVec getY() const { return y; }; armaVec getZ() const { return z; }; armaMat getKe() const { return Ke; }; armaMat getKe_m() const { return Ke_m; }; // set methods  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX, std::size_t\u0026amp; nY); void setC(stdVec\u0026amp; cVec); void setC(armaMat\u0026amp; C); void setD(stdVec\u0026amp; dVec); void setD(armaVec\u0026amp; d); void setR(stdVec\u0026amp; rVec); void setR(armaMat\u0026amp; R); void setZ(stdVec\u0026amp; zVec); void setZ(armaVec\u0026amp; z); void setKe(stdVec\u0026amp; keVec); void setKe(armaMat\u0026amp; Ke); void setKe_m(stdVec\u0026amp; kemVec); void setKe_m(armaMat\u0026amp; Ke_m); void reset(); void printSys(); protected: void recurse_Ke(); void predict(); void h(); void defaultR(); // output-specific stuff  std::size_t nY; armaMat C; armaVec d; armaMat R; data_t\u0026amp; r0; armaVec y; armaVec z; armaMat Ke; armaMat Ke_m; }; // sys_t } // namespace gaussian } // namespace lds  #include \u0026#34;lds_gaussian_ctrl.h\u0026#34; #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':48,'href':'/ldsctrlest/docs/api/files/lds__poisson_8h/','title':"ldsCtrlEst_h/lds_poisson.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson.h #  plds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Detailed Description #  This file declares and partially defines the namespace for linear dynamical systems with Poisson observations ([lds::poisson](/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson.h - LDS with Poisson Output ----*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_H #define LDSCTRLEST_LDS_POISSON_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { typedef lds::data_t data_t; typedef lds::stdVec stdVec; typedef lds::armaVec armaVec; typedef lds::armaMat armaMat; typedef lds::armaSubVec armaSubVec; typedef lds::armaSubMat armaSubMat; namespace fill = lds::fill; // CONTROL BIT MASKS static const std::size_t CONTROL_TYPE_U = lds::CONTROL_TYPE_U; static const std::size_t CONTROL_TYPE_INTY = lds::CONTROL_TYPE_INTY; static const std::size_t CONTROL_TYPE_ADAPT_M = lds::CONTROL_TYPE_ADAPT_M; // default values static data_t DATA_T_ZERO = lds::DATA_T_ZERO; static data_t DATA_T_ONE = lds::DATA_T_ZERO; static data_t DEFAULT_SOFTSTART = lds::DEFAULT_SOFTSTART; static bool FALSE = lds::FALSE; static bool TRUE = lds::TRUE; // static const data_t inf = lds::inf; static const data_t pi = lds::pi; static data_t inf = lds::inf; static data_t neginf = lds::neginf; } // namespace poisson } // namespace lds  #include \u0026#34;lds_poisson_sys.h\u0026#34;#ifdef LDSCTRLEST_BUILD_FIT #include \u0026#34;lds_poisson_fit.h\u0026#34;#endif  #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':49,'href':'/ldsctrlest/docs/api/files/lds__poisson__ctrl_8h/','title':"ldsCtrlEst_h/lds_poisson_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_ctrl.h #  PLDS controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::ctrl_t PLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for feedback control of a Poisson-output linear dynamical system ([lds::poisson::ctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1ctrl__t/)). It inherits functionality from the underlying PLDS model type ([lds::poisson::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/)), including state estimation.\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_ctrl.h - PLDS Controller -------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_CTRL_H #define LDSCTRLEST_LDS_POISSON_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class ctrl_t : public sys_t { public: ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, size_t controlType = 0); ctrl_t\u0026amp; operator=(const ctrl_t\u0026amp; sys); /* * Perform a single step of feedback control. Note that this performs control * in the log-output space which is linear given the choice of exponential * nonlinearity. * * n.b., Requires user to have set the controller\u0026#39;s `xRef` and `uRef` * variables. * * @brief log-linear feedback control (single-step) * * @param z measurement * @param gateCtrl [optional] logical gate of control * (high=enabled; low=disabled) * @param gateLock [optional] logical gate of control signal * lock (if high, locks control at current * value) * @param sigma_softStart [optional] standard deviation (sigma) of a * Gaussian soft-start to control * @param sigma_uNoise [optional] standard deviation (sigma) of * Gaussian noise added on top of control signal * @param resetAtCtrlOnset [optional] whether to reset controller at * onset of a new control epoch (gateCtrl from * low to high) */ void logLin_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE); // Steady-state solution to log-linear control problem. Given user-supplied  // yRef --\u0026gt; steady state sol\u0026#39;z [xRef, uRef] --\u0026gt; control  void steadyState_logLin_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateEst = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE); void calc_ssSetPt(); void printSys(); // set methods  // make sure to override the setU behavior inherited from sys_t!  // cannot set u for a controller, as it generates its own.  void setU(stdVec\u0026amp; uVec); void setU(armaVec\u0026amp; u); void setG(stdVec\u0026amp; gVec); void setG(armaVec\u0026amp; g); void setGDesign(stdVec\u0026amp; gVec); void setGDesign(armaVec\u0026amp; g); void setURef(stdVec\u0026amp; uRefVec); void setURef(armaVec\u0026amp; uRef); void setXRef(stdVec\u0026amp; xRefVec); void setXRef(armaVec\u0026amp; xRef); void setYRef(stdVec\u0026amp; yRefVec); void setYRef(armaVec\u0026amp; yRef); void setKc_x(stdVec\u0026amp; Kc_xVec); void setKc_x(armaMat\u0026amp; Kc_x); void setKc_u(stdVec\u0026amp; Kc_uVec); void setKc_u(armaMat\u0026amp; Kc_u); void setKc_inty(stdVec\u0026amp; Kc_intyVec); void setKc_inty(armaMat\u0026amp; Kc_inty); void setControlType(size_t controlType); void setTauAntiWindup(data_t\u0026amp; tau); armaMat getKc_u() const { return Kc_u; }; armaMat getKc_x() const { return Kc_x; }; armaMat getKc_inty() const { return Kc_inty; }; armaVec getGDesign() const { return gDesign; }; armaVec getURef() const { return uRef; }; armaVec getXRef() const { return xRef; }; armaVec getLogYRef() const { return logyRef; }; armaVec getYRef() const { return yRef; }; armaVec getLogY() const { return logy; }; armaVec getIntE() const { return intE; }; size_t getControlType() const { return controlType; }; void reset(); protected: armaVec gDesign; // reference signals  armaVec uRef; armaVec uRef_prev; armaVec xRef; armaVec logyRef; armaVec yRef; // Controller gains  armaMat Kc_x; armaMat Kc_u; armaMat Kc_inty; // control after g inversion (partial fb linearization)  // do not need set methods for these.  armaVec duRef; armaVec dvRef; armaVec vRef; armaVec dv; armaVec v; // integral error  // do not need set method for this  armaVec intE; armaVec intE_awuAdjust; armaVec uSat; bool gateCtrl_prev; bool gateLock_prev; data_t yRefLB; // I think it should be safe to have references here bc there is nothing I  // need to do (like reset vars) when it changes...  bool uSaturated; data_t\u0026amp; uLB; data_t\u0026amp; uUB; data_t tauAntiWindup; data_t kAntiWindup; void antiWindup(); data_t t_since_ctrl_onset; size_t controlType; private: void calc_logLinCtrl(bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset); }; } // namespace poisson } // namespace lds  #include \u0026#34;lds_poisson_sctrl.h\u0026#34; #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':50,'href':'/ldsctrlest/docs/api/files/lds__poisson__fit_8h/','title':"ldsCtrlEst_h/lds_poisson_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_fit.h #  PLDS base fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::fit_t PLDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_fit.h - Fit Type for PLDS ------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_FIT_H #define LDSCTRLEST_LDS_POISSON_FIT_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class fit_t : public lds::fit_t { public: fit_t(){}; fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); // Output  armaMat C; armaVec d; // input/output training data  std::vector\u0026lt;armaMat\u0026gt; uTrain; std::vector\u0026lt;armaMat\u0026gt; zTrain; }; }; // namespace poisson } // namespace lds  #include \u0026#34;lds_poisson_fit_ssid.h\u0026#34; #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':51,'href':'/ldsctrlest/docs/api/files/lds__poisson__fit__ssid_8h/','title':"ldsCtrlEst_h/lds_poisson_fit_ssid.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_fit_ssid.h #  PLDS SSID fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::ssidFit_t GLDS SSID Fit Type.    Detailed Description #  This file declares and partially defines a type by which Poisson-output LDS models are fit by a subspace identification (SSID) algorithm ([lds::gaussian::ssidFit_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ssid_fit__t/)). Currently, these models are fit assuming linear/Gaussian output, and then an exponential output is fit by maximum likelihood under the Poisson assumption. Future work should implement SSID after Poisson\u0026lt;-\u0026gt;Gaussian moment conversions as outlined in [2].\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer. [2] Buesing L, Macke JH, Sahani M. (2012) Spectral learning of linear dynamics from generalised-linear observations with application to neural population data. NIPS 25.\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_fit_ssid.h - PLDS Fit (SSID) ---*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_FIT_SSID_H #define LDSCTRLEST_LDS_POISSON_FIT_SSID_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class ssidFit_t : public fit_t { public: ssidFit_t() : fit_t(){}; ssidFit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec\u0026amp; singVals, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); std::vector\u0026lt;data_t\u0026gt; t0; data_t t_startSSID; data_t t_stopSSID; armaVec singVals; }; std::tuple\u0026lt;ssidFit_t, lds::gaussian::ssidFit_t\u0026gt; ssidFit( std::vector\u0026lt;armaMat\u0026gt;\u0026amp; u, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t dt, size_t nX, size_t nH = 25, armaVec d0 = armaVec(1).fill(-inf), ssidWt wt = NONE, data_t wtG0 = 0.0, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0 = DEFAULT_T0, data_t t_startSSID = -std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(), data_t t_stopSSID = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(), bool assumeGaussian = true); void newtonSolveC_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); data_t newtonSolve_rescaleC_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); void calcD_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); data_t calcD_newtonSolve_rescaleC_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); void fitOutput_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); } // namespace poisson } // namespace lds #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':52,'href':'/ldsctrlest/docs/api/files/lds__poisson__sctrl_8h/','title':"ldsCtrlEst_h/lds_poisson_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_sctrl.h #  PLDS switched controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::sctrl_t Switched PLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Poisson-output linear dynamical systems ([lds::poisson::sctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sctrl__t/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_sctrl.h - Switched Controller --*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H #define LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class sctrl_t : public ctrl_t { public: sctrl_t(std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, size_t controlType = 0); void setSystem(size_t sysIdx, ctrl_t\u0026amp; sys); // TODO(mfbolus):  // This switchSystem(sysIdx) approach is wasteful but simple.  // Would be faster to toggle between ctrl_t\u0026#39;s and replace wrapper u, x, P, m,  // P_m. However, would have to override or rewrite most controller  // functionality.  void switchSystem(size_t sysIdx); size_t getSysIdx() const { return sysIdx; }; protected: size_t nSys; std::vector\u0026lt;ctrl_t\u0026gt; systems; size_t sysIdx; private: // make all parameter set* methods private and define them to do nothing.  // force users to use setSystem, with pre-defined systems.  // from lds_t  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX){}; void setU(stdVec\u0026amp; uVec){}; void setU(armaVec\u0026amp; u){}; void setA(stdVec\u0026amp; aVec){}; void setA(armaMat\u0026amp; A){}; void setB(stdVec\u0026amp; bVec){}; void setB(armaMat\u0026amp; B){}; void setM(stdVec\u0026amp; mVec){}; void setM(armaVec\u0026amp; m){}; // void setG(stdVec\u0026amp; gVec) {};  // void setG(armaVec\u0026amp; g) {};  void setQ(stdVec\u0026amp; qVec){}; void setQ(armaMat\u0026amp; Q){}; void setQ_m(stdVec\u0026amp; qmVec){}; void setQ_m(armaMat\u0026amp; Q_m){}; void setX0(stdVec\u0026amp; x0Vec){}; void setX0(armaVec\u0026amp; x0){}; void setP0(stdVec\u0026amp; p0Vec){}; void setP0(armaMat\u0026amp; P0){}; void setP0_m(stdVec\u0026amp; p0mVec){}; void setP0_m(armaMat\u0026amp; P0_m){}; // from sys_t  void setC(stdVec\u0026amp; cVec){}; void setC(armaMat\u0026amp; C){}; void setD(stdVec\u0026amp; dVec){}; void setD(armaVec\u0026amp; d){}; // from ctrl_t  // void setGDesign(stdVec\u0026amp; gVec) {};  // void setGDesign(armaVec\u0026amp; g) {};  void setKc_x(stdVec\u0026amp; Kc_xVec){}; void setKc_x(armaVec\u0026amp; Kc_x){}; void setKc_u(stdVec\u0026amp; Kc_uVec){}; void setKc_u(armaVec\u0026amp; Kc_u){}; void setKc_inty(stdVec\u0026amp; Kc_intyVec){}; void setKc_inty(armaVec\u0026amp; Kc_inty){}; void setControlType(size_t controlType); // {};  // // assuming I *want* to maintain same references  // void setURef(stdVec\u0026amp; uRefVec) {};  // void setURef(armaVec\u0026amp; uRef) {};  // void setXRef(stdVec\u0026amp; xRefVec) {};  // void setXRef(armaVec\u0026amp; xRef) {};  // void setYRef(stdVec\u0026amp; yRefVec) {};  // void setYRef(armaVec\u0026amp; yRef) {}; }; } // namespace poisson } // namespace lds  #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':53,'href':'/ldsctrlest/docs/api/files/lds__poisson__sys_8h/','title':"ldsCtrlEst_h/lds_poisson_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_sys.h #  PLDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::sys_t Poisson LDS Type.    Detailed Description #  This file declares and partially defines the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems ([lds::poisson::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/)). It inherits functionality from the underlying linear dynamical system ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_sys.h - PLDS -------------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_SYS_H #define LDSCTRLEST_LDS_POISSON_SYS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class sys_t : public lds::sys_t { public: void filter(armaVec\u0026amp; u_tm1, armaVec\u0026amp; z_t); void filter(armaVec\u0026amp; z); void simMeasurement(armaVec\u0026amp; z); sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0); sys_t\u0026amp; operator=(const sys_t\u0026amp; sys); // get methods  size_t getNy() const { return nY; }; armaMat getC() const { return C; }; armaVec getD() const { return d; }; armaVec getY() const { return y; }; armaVec getZ() const { return z; }; // set methods  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX, std::size_t\u0026amp; nY); void setC(stdVec\u0026amp; cVec); void setC(armaMat\u0026amp; C); void setD(stdVec\u0026amp; dVec); void setD(armaVec\u0026amp; d); void setZ(stdVec\u0026amp; zVec); void setZ(armaVec\u0026amp; z); void reset(); void printSys(); protected: void predict(); void h(); // output nonlinearity  // output-specific stuff  std::size_t nY; armaMat C; armaVec d; armaVec y; armaVec logy; armaVec z; armaMat diag_y; armaVec chance; }; // sys_t } // namespace poisson } // namespace lds  #include \u0026#34;lds_poisson_ctrl.h\u0026#34; #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':54,'href':'/ldsctrlest/docs/api/files/lds__sys_8h/','title':"ldsCtrlEst_h/lds_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_sys.h #  LDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::sys_t Linear Dynamical System Type.    Detailed Description #  This file declares and partially defines the base type for linear dynamical systems ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code #  //===-- ldsCtrlEst_h/lds_sys.h - LDS ----------------------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_SYS_H #define LDSCTRLEST_LDS_SYS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { class sys_t { public: sys_t(std::size_t nU, std::size_t nX, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0); sys_t\u0026amp; operator=(const sys_t\u0026amp; sys); void simPredict(); size_t getNx() const { return nX; }; size_t getNu() const { return nU; }; armaVec getU() const { return u; }; armaVec getX() { return x; }; armaVec getG() const { return g; }; armaVec getM() const { return m; }; armaMat getA() const { return A; }; armaMat getB() const { return B; }; armaMat getQ() const { return Q; }; armaMat getQ_m() const { return Q_m; }; armaMat getP() const { return P; }; armaMat getP_m() const { return P_m; }; armaVec getX0() const { return x0; }; armaMat getP0() const { return P0; }; armaVec getM0() const { return m0; }; armaMat getP0_m() const { return P0_m; }; void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX); void setU(stdVec\u0026amp; uVec); void setU(armaVec\u0026amp; u); void setA(stdVec\u0026amp; aVec); void setA(armaMat\u0026amp; A); void setB(stdVec\u0026amp; bVec); void setB(armaMat\u0026amp; B); void setM(stdVec\u0026amp; mVec); void setM(armaVec\u0026amp; m); void setG(stdVec\u0026amp; gVec); void setG(armaVec\u0026amp; g); void setQ(stdVec\u0026amp; qVec); void setQ(armaMat\u0026amp; Q); void setQ_m(stdVec\u0026amp; qmVec); void setQ_m(armaMat\u0026amp; Q_m); void setX0(stdVec\u0026amp; x0Vec); void setX0(armaVec\u0026amp; x0); void setP0(stdVec\u0026amp; p0Vec); void setP0(armaMat\u0026amp; P0); void setP0_m(stdVec\u0026amp; p0mVec); void setP0_m(armaMat\u0026amp; P0_m); void reset(); void printSys(); bool adaptM; protected: armaVec u; armaVec x; armaMat P; armaVec m; armaMat P_m; // Parameters:  armaVec x0; armaMat P0; armaVec m0; armaMat P0_m; armaMat A; armaMat B; armaVec g; armaMat Q; armaMat Q_m; // it should be safe for dt to be a reference. I should not need to control  // what the set behavior is.  data_t\u0026amp; dt; data_t\u0026amp; q0; data_t\u0026amp; p0; // dimensions  std::size_t nX; std::size_t nU; bool szChanged; // max val for elements of P before reset for numerical reasons...  const data_t plim = 1e2; void predict(); // TODO(mfbolus): these are very redundant.  // Should be able to use templates in some way to make this less type-specific  void reassign(armaVec\u0026amp; oldVar, armaVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaVec\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaSubVec\u0026amp; oldVar, armaVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaSubVec\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaMat\u0026amp; oldVar, armaMat\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaMat\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaSubMat\u0026amp; oldVar, armaMat\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaSubMat\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal = 0); void limit(stdVec\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub); void limit(armaVec\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub); void limit(armaMat\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub); void defaultQ(); void checkP(); }; // sys_t } // namespace lds  #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':55,'href':'/ldsctrlest/docs/api/files/mex__c__util_8h/','title':"ldsCtrlEst_h/mex_c_util.h",'section':"Files",'content':"ldsCtrlEst_h/mex_c_util.h #  arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API) More\u0026hellip;\nNamespaces #     Name     armamexc arma/mex interface using Matlab C API    Detailed Description #  This file defines utility functions for interoperability between armadillo and Matlab/Octave\u0026rsquo;s C mex API.\nSource code #  //===-- ldsCtrlEst_h/mex_c_util.h - Mex C API Utilities ---------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_MEXC_UTIL_H #define LDSCTRLEST_MEXC_UTIL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;mex.h\u0026#34; // // If Matlab_FOUND, include matrix.h. // // (Octave does not need/have it.) // #ifdef Matlab_FOUND // #include \u0026#34;matrix.h\u0026#34; // #endif  namespace armamexc { template \u0026lt;class T\u0026gt; inline auto m2T_scalar(const mxArray *matlab_scalar) -\u0026gt; T { if (mxGetData(matlab_scalar)) { return static_cast\u0026lt;T\u0026gt;(mxGetScalar(matlab_scalar)); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return 0; } template \u0026lt;class T\u0026gt; inline auto m2a_mat(const mxArray *matlab_mat, bool copy_aux_mem = false, bool strict = true) -\u0026gt; arma::Mat\u0026lt;T\u0026gt; { if (mxGetData(matlab_mat)) { const mwSize n_dim = mxGetNumberOfDimensions(matlab_mat); if (n_dim == 2) { return arma::Mat\u0026lt;T\u0026gt;(static_cast\u0026lt;double *\u0026gt;(mxGetData(matlab_mat)), mxGetM(matlab_mat), mxGetN(matlab_mat), copy_aux_mem, strict); } mexErrMsgTxt(\u0026#34;Number of dimensions must be 2.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } // TODO(mfbolus): make these templated.  inline auto a2m_mat(arma::Mat\u0026lt;double\u0026gt; const \u0026amp;arma_mat) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_mat.n_rows, arma_mat.n_cols, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;double *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;double *\u0026gt;(arma_mat.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy.  std::memcpy(dst_pointer, src_pointer, sizeof(double) * arma_mat.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Mat.\u0026#34;); return nullptr; } inline auto a2m_vec(arma::Col\u0026lt;double\u0026gt; const \u0026amp;arma_vec) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_vec.n_elem, 1, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;double *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;double *\u0026gt;(arma_vec.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy.  std::memcpy(dst_pointer, src_pointer, sizeof(double) * arma_vec.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Col.\u0026#34;); return nullptr; } } // namespace armamexc  #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':56,'href':'/ldsctrlest/docs/api/files/mex__cpp__util_8h/','title':"ldsCtrlEst_h/mex_cpp_util.h",'section':"Files",'content':"ldsCtrlEst_h/mex_cpp_util.h #  arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API) More\u0026hellip;\nNamespaces #     Name     armamexcpp arma/mex interface using Matlab C++ API    Detailed Description #  This file defines utility functions for interoperability between armadillo and Matlab\u0026rsquo;s C++ mex API.\nSource code #  //===-- ldsCtrlEst_h/mex_cpp_util.h - Mex C++ API Utilities -----*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_MEXCPP_UTIL_H #define LDSCTRLEST_MEXCPP_UTIL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;mex.hpp\u0026#34;#include \u0026#34;mexAdapter.hpp\u0026#34; namespace armamexcpp { template \u0026lt;class T\u0026gt; auto m2a_cellmat(matlab::data::CellArray\u0026amp; matlab_cell) -\u0026gt; std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; { size_t n_cells = matlab_cell.getNumberOfElements(); std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; arma_mat(n_cells, arma::mat(1, 1, arma::fill::zeros)); for (size_t k = 0; k \u0026lt; n_cells; k++) { matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = matlab_cell[k]; auto dims = matlab_mat.getDimensions(); arma_mat[k] = arma::Mat\u0026lt;T\u0026gt;(matlab_mat.release().get(), dims[0], dims[1]); } return arma_mat; }; template \u0026lt;class T\u0026gt; auto m2s_vec(matlab::data::TypedArray\u0026lt;T\u0026gt;\u0026amp; matlab_array) -\u0026gt; std::vector\u0026lt;T\u0026gt; { size_t n_elem = matlab_array.getNumberOfElements(); double* ptr = matlab_array.release().get(); std::vector\u0026lt;T\u0026gt; vec(ptr, ptr + n_elem); return vec; }; template \u0026lt;class T\u0026gt; auto m2a_vec(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) -\u0026gt; arma::Col\u0026lt;T\u0026gt; { size_t n_elem = matlab_array.getNumberOfElements(); T* ptr = matlab_array.release().get(); arma::Col\u0026lt;T\u0026gt; vec(ptr, n_elem); //, false);  return vec; }; template \u0026lt;class T\u0026gt; auto m2a_mat(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) -\u0026gt; arma::Mat\u0026lt;T\u0026gt; { // ArrayDimensions == std::vector\u0026lt;size_t\u0026gt;  auto dims = matlab_array.getDimensions(); T* ptr = matlab_array.release().get(); // mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false)  arma::Mat\u0026lt;T\u0026gt; mat(ptr, dims[0], dims[1]); //, false);  return mat; }; template \u0026lt;class T\u0026gt; auto a2m_mat(arma::Mat\u0026lt;T\u0026gt;\u0026amp; arma_mat, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {arma_mat.n_rows, arma_mat.n_cols}, arma_mat.memptr(), arma_mat.memptr() + arma_mat.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; auto a2m_vec(arma::Col\u0026lt;T\u0026gt;\u0026amp; arma_vec, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;({arma_vec.n_elem, 1}, arma_vec.memptr(), arma_vec.memptr() + arma_vec.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; auto s2m_vec(std::vector\u0026lt;T\u0026gt;\u0026amp; std_vec, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {std_vec.size(), 1}, std_vec.data(), std_vec.data() + std_vec.size()); return matlab_mat; }; } // namespace armamexcpp  #endif  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':57,'href':'/ldsctrlest/docs/api/modules/','title':"Modules",'section':"LDS C+E Documentation",'content':"Modules #    Control Mode Bit Masks\n  Defaults\n   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':58,'href':'/ldsctrlest/docs/api/namespaces/','title':"Namespaces",'section':"LDS C+E Documentation",'content':"Namespaces #    armamexc arma/mex interface using Matlab C API\n  armamexcpp arma/mex interface using Matlab C++ API\n  glds\n  lds::gaussian Linear Dynamical Systems with Gaussian observations.\n  lds::poisson Linear Dynamical Systems with Poisson observations.\n  plds\n  std\n   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':59,'href':'/ldsctrlest/docs/api/pages/','title':"Pages",'section':"LDS C+E Documentation",'content':"Pages #   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':60,'href':'/ldsctrlest/docs/api/namespaces/namespaceplds/','title':"plds",'section':"Namespaces",'content':"plds #   Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':61,'href':'/ldsctrlest/docs/api/files/dir_68267d1309a1af8e8297ef4c3efbcdba/','title':"src",'section':"Files",'content':"src #  Files #     Name     src/lds_gaussian_ctrl.cpp GLDS controller type.   src/lds_gaussian_sctrl.cpp GLDS switched controller type.   src/lds_gaussian_sys.cpp GLDS base type.   src/lds_poisson_ctrl.cpp PLDS controller type.   src/lds_poisson_sctrl.cpp PLDS switched controller type.   src/lds_poisson_sys.cpp PLDS base type.   src/lds_sys.cpp LDS base type.     Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':62,'href':'/ldsctrlest/docs/api/files/lds__gaussian__ctrl_8cpp/','title':"src/lds_gaussian_ctrl.cpp",'section':"Files",'content':"src/lds_gaussian_ctrl.cpp #  GLDS controller type. More\u0026hellip;\nNamespaces #     Name     std   glds    Detailed Description #  This file implements the type for feedback control of a gaussian-output linear dynamical system ([lds::gaussian::ctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ctrl__t/)). It inherits functionality from the underlying GLDS model type ([lds::gaussian::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/)), including state estimation.\nSource code #  //===-- lds_gaussian_ctrl.cpp - GLDS Controller ---------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace glds; // Constructor(s) for sys class glds::ctrl_t::ctrl_t(size_t nU, size_t nX, size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, data_t\u0026amp; r0, size_t controlType) : glds::sys_t(nU, nX, nY, dt, p0, q0, r0), uLB(uLB), uUB(uUB), gateCtrl_prev(false), gateLock_prev(false), uSaturated(false), tauAntiWindup(lds::inf), t_since_ctrl_onset(0.0) { // initialize to default values  uRef = armaVec(nU, fill::zeros); uRef_prev = armaVec(nU, fill::zeros); xRef = armaVec(nX, fill::zeros); yRef = armaVec(nY, fill::zeros); uSat = armaVec(nU, fill::zeros); // Might not need all these, so zero elements until later.  Kc_x = armaMat(nU, nX, fill::zeros); Kc_u = armaMat(0, 0, fill::zeros); Kc_inty = armaMat(0, 0, fill::zeros); gDesign = g; dv = armaVec(nU, fill::zeros); v = armaVec(nU, fill::zeros); duRef = armaVec(nU, fill::zeros); dvRef = armaVec(nU, fill::zeros); vRef = armaVec(nU, fill::zeros); intE = armaVec(0, fill::zeros); intE_awuAdjust = armaVec(0, fill::zeros); kAntiWindup = dt / tauAntiWindup; setControlType(controlType); } void glds::ctrl_t::fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset, bool\u0026amp; doRecurse_Ke) { // update state estimates, given latest measurement  filter(z, doRecurse_Ke); bool gateEst = true; // always have estimator on in this case  // calculate control signal  calc_ctrl(gateCtrl, gateEst, gateLock, sigma_softStart, sigma_uNoise, resetAtCtrlOnset); } void glds::ctrl_t::steadyState_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset, bool\u0026amp; doRecurse_Ke) { // update state estimates, given latest measurement  if (gateEst) { filter(z, doRecurse_Ke); } else { predict(); } // calculate the set point @ steady state.  if (gateCtrl) calc_ssSetPt(); // calculate control signal  calc_ctrl(gateCtrl, gateEst, gateLock, sigma_softStart, sigma_uNoise, resetAtCtrlOnset); } // steadyState_fbCtrl  // private method for meat of control logic void glds::ctrl_t::calc_ctrl(bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset) { if (gateCtrl \u0026amp;\u0026amp; gateEst) { if (!gateCtrl_prev) { if (resetAtCtrlOnset) { reset(); } t_since_ctrl_onset = 0.0; } else { t_since_ctrl_onset += dt; } // enforce softstart on control vars.  if (sigma_softStart \u0026gt; 0) { // half-Gaussian soft-start scaling factor  data_t softStart_sf = 1 - exp(-pow(t_since_ctrl_onset, 2) / (2 * pow(sigma_softStart, 2))); uRef *= softStart_sf; // TODO(mfbolus): May be appropriate to soft-start set point xRef, yRef  // too  // xRef *= softStart_sf;  // yRef *= softStart_sf;  } if (!gateLock) { duRef = uRef - uRef_prev; // first do u -\u0026gt; v change of vars. (v = g.*u)  // e.g., convert into physical units (e.g., v[=] mW/mm2 rather than driver  // control voltage u[=]V)  vRef = gDesign % uRef; dvRef = gDesign % duRef; // Given FB, calc. the change in control  if (controlType \u0026amp; CONTROL_TYPE_U) { // if control designed to minimize not u but deltaU (i.e. state aug with  // u):  dv = dvRef; // nominally-optimal.  dv -= Kc_x * (getX() - xRef); // instantaneous state error  dv -= Kc_u * (v - vRef); // penalty on changes in u  if (controlType \u0026amp; CONTROL_TYPE_INTY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if(!uSaturated)  intE += (y - yRef) * dt; // integrated error  dv -= Kc_inty * intE; // control for integrated error  } // update the control  v += dv; } else { v = vRef; // nominally-optimal.  v -= Kc_x * (getX() - xRef); // instantaneous state error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if (!uSaturated)  intE += (y - yRef) * dt; // integrated error  v -= Kc_inty * intE; // control for integrated error  } } // convert back to control voltage u[=]V  u = v / getG(); } // else do nothing until lock is low  // It may be desireable to make inputs more variable.  if (sigma_uNoise \u0026gt; 0.0) u += sigma_uNoise * armaVec(nU, fill::randn); } else { // if not control  // feed through uRef in open loop  u = uRef % gDesign / getG(); uRef.zeros(); intE.zeros(); intE_awuAdjust.zeros(); uSat.zeros(); } // ends gateCtrl  // enforce box constraints (and antiwindup)  antiWindup(); gateCtrl_prev = gateCtrl; gateLock_prev = gateLock; } // ends calc_ctrl  void glds::ctrl_t::setControlType(size_t controlType) { if (this-\u0026gt;controlType == controlType) return; // creating a blank slate... (perhaps unnecessary)  this-\u0026gt;controlType = 0; Kc_u.zeros(0, 0); Kc_inty.zeros(0, 0); intE.zeros(0, 0); intE_awuAdjust.zeros(0, 0); // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (controlType \u0026amp; CONTROL_TYPE_U) { Kc_u.zeros(nU, nU); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_U; } // controller was designed to minimize integral error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { Kc_inty.zeros(nU, nY); intE.zeros(nY); intE_awuAdjust.zeros(nY); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_INTY; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) { if (this-\u0026gt;adaptM) // only if adapting M...  this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_ADAPT_M; } } // set methods: // make sure cannot user-define value of u. void glds::ctrl_t::setU(stdVec\u0026amp; uVec) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot assign a value to `u` in GLDS controller.\\n\u0026#34;; } void glds::ctrl_t::setU(armaVec\u0026amp; u) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot assign a value to `u` in GLDS controller.\\n\u0026#34;; } void glds::ctrl_t::setG(stdVec\u0026amp; gVec) { glds::sys_t::setG(gVec); } void glds::ctrl_t::setG(armaVec\u0026amp; g) { glds::sys_t::setG(g); } void glds::ctrl_t::setGDesign(stdVec\u0026amp; gVec) { reassign(gDesign, gVec); } void glds::ctrl_t::setGDesign(armaVec\u0026amp; g) { reassign(gDesign, g); } void glds::ctrl_t::setURef(stdVec\u0026amp; uRefVec) { uRef_prev = uRef; reassign(uRef, uRefVec); } void glds::ctrl_t::setURef(armaVec\u0026amp; uRef) { uRef_prev = this-\u0026gt;uRef; reassign(this-\u0026gt;uRef, uRef); } void glds::ctrl_t::setXRef(stdVec\u0026amp; xRefVec) { reassign(xRef, xRefVec); } void glds::ctrl_t::setXRef(armaVec\u0026amp; xRef) { reassign(this-\u0026gt;xRef, xRef); } void glds::ctrl_t::setYRef(stdVec\u0026amp; yRefVec) { reassign(yRef, yRefVec); } void glds::ctrl_t::setYRef(armaVec\u0026amp; yRef) { reassign(this-\u0026gt;yRef, yRef); } void glds::ctrl_t::setKc_x(stdVec\u0026amp; Kc_x_vec) { reassign(Kc_x, Kc_x_vec); } void glds::ctrl_t::setKc_x(armaMat\u0026amp; Kc_x) { reassign(this-\u0026gt;Kc_x, Kc_x); } void glds::ctrl_t::setKc_u(stdVec\u0026amp; Kc_u_vec) { if (controlType \u0026amp; CONTROL_TYPE_U) reassign(Kc_u, Kc_u_vec); } void glds::ctrl_t::setKc_u(armaMat\u0026amp; Kc_u) { if (controlType \u0026amp; CONTROL_TYPE_U) reassign(this-\u0026gt;Kc_u, Kc_u); } void glds::ctrl_t::setKc_inty(stdVec\u0026amp; Kc_inty_vec) { if (controlType \u0026amp; CONTROL_TYPE_INTY) reassign(Kc_inty, Kc_inty_vec); } void glds::ctrl_t::setKc_inty(armaMat\u0026amp; Kc_inty) { if (controlType \u0026amp; CONTROL_TYPE_INTY) reassign(this-\u0026gt;Kc_inty, Kc_inty); } void glds::ctrl_t::setTauAntiWindup(data_t\u0026amp; tau) { tauAntiWindup = tau; kAntiWindup = dt / tauAntiWindup; } void glds::ctrl_t::calc_ssSetPt() { // Linearly-constrained least squares (ls).  //  // Reference:  // Boyd \u0026amp; Vandenberghe (2018) Introduction to Applied Linear Algebra  //  armaMat A_ls = join_horiz(C, armaMat(nY, nU, fill::zeros)); armaVec b_ls = yRef - d; armaMat C_ls = join_horiz(A - armaMat(nX, nX, fill::eye), B * arma::diagmat(g)); armaVec d_ls = -m0; if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) d_ls = -m; // adapt setpoint calc with disturbance?  armaMat A_ls_t = A_ls.t(); // TODO(mfbolus): not sure why but causes seg  // fault if I do not do this.  armaMat phi_ls = join_vert(join_horiz(2 * A_ls_t * A_ls, C_ls.t()), join_horiz(C_ls, armaMat(nX, nX, fill::zeros))); armaMat inv_phi = pinv( phi_ls); // TODO(mfbolus): should be actual inverse, rather than pseudo-  armaVec xulam = inv_phi * join_vert(2 * A_ls_t * b_ls, d_ls); xRef = xulam.subvec(0, nX - 1); uRef = xulam.subvec(nX, nX + nU - 1); yRef = C * xRef + d; // the least-squares solution } void glds::ctrl_t::antiWindup() { uSaturated = false; uSat = u; // limit u and flag whether saturated  for (size_t k = 0; k \u0026lt; u.n_elem; k++) { if (u[k] \u0026lt; uLB) { uSat[k] = uLB; uSaturated = true; } if (u[k] \u0026gt; uUB) { uSat[k] = uUB; uSaturated = true; } } if ((controlType \u0026amp; CONTROL_TYPE_INTY) \u0026amp;\u0026amp; (tauAntiWindup\u0026lt;lds::inf)) { // one-step back-calculation  // (Astroem, Rundqwist 1989 warn against using this...)  //  // armaVec delta_intE = solve(Kc_inty, (u-uSat)); //pinv(Kc_inty) *  // (u-uSat);  //  // intE += delta_intE;  // gradual: see Astroem, Rundqwist 1989  // this is a fudge for doing MIMO gradual  // n.b., went ahead and multiplied 1/T by dt so don\u0026#39;t have to do that here.  intE_awuAdjust += kAntiWindup * (sign(Kc_inty).t() / nU) * (u - uSat); intE += intE_awuAdjust; } // set u to saturated version  u = uSat; } void glds::ctrl_t::reset() { glds::sys_t::reset(); uRef.zeros(); uRef_prev.zeros(); intE.zeros(); intE_awuAdjust.zeros(); uSat.zeros(); uSaturated = false; t_since_ctrl_onset = 0.0; } void glds::ctrl_t::printSys() { glds::sys_t::printSys(); std::cout \u0026lt;\u0026lt; \u0026#34;gDesign : \u0026#34; \u0026lt;\u0026lt; gDesign \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;uLB : \u0026#34; \u0026lt;\u0026lt; uLB \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;uUB : \u0026#34; \u0026lt;\u0026lt; uUB \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } glds::ctrl_t\u0026amp; glds::ctrl_t::operator=(const glds::ctrl_t\u0026amp; sys) { // TODO(mfbolus): would love to be able to re-use the lds code:  //  // (*this) = lds::sys_t::operator=(sys);  //  // but this does not work bc the input is glds::sys_t which is a subclass of  // lds::sys_t. Need to figure out if there is a way to write functions to  // apply to all subclasses (e.g., \u0026lt;lds::sys_t\u0026amp; sys)  // FROM LDS  this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; // END FROM LDS  // from GLDS  this-\u0026gt;C = sys.C; this-\u0026gt;d = sys.d; this-\u0026gt;R = sys.R; this-\u0026gt;r0 = sys.r0; this-\u0026gt;Ke = sys.Ke; this-\u0026gt;Ke_m = sys.Ke_m; this-\u0026gt;adaptM = sys.adaptM; this-\u0026gt;y = sys.y; this-\u0026gt;z = sys.z; this-\u0026gt;nY = sys.nY; // end from GLDS  // additional ctrl_t stuff  this-\u0026gt;gDesign = sys.gDesign; this-\u0026gt;uRef = sys.uRef; this-\u0026gt;uRef_prev = sys.uRef_prev; this-\u0026gt;xRef = sys.xRef; this-\u0026gt;yRef = sys.yRef; this-\u0026gt;Kc_x = sys.Kc_x; this-\u0026gt;Kc_u = sys.Kc_u; this-\u0026gt;Kc_inty = sys.Kc_inty; this-\u0026gt;duRef = sys.duRef; this-\u0026gt;dvRef = sys.dvRef; this-\u0026gt;vRef = sys.vRef; this-\u0026gt;dv = sys.dv; this-\u0026gt;v = sys.v; this-\u0026gt;intE = sys.intE; this-\u0026gt;intE_awuAdjust = sys.intE_awuAdjust; this-\u0026gt;uLB = sys.uLB; this-\u0026gt;uUB = sys.uUB; this-\u0026gt;uSat = sys.uSat; this-\u0026gt;uSaturated = sys.uSaturated; this-\u0026gt;t_since_ctrl_onset = sys.t_since_ctrl_onset; this-\u0026gt;controlType = sys.controlType; return *this; } void glds::ctrl_t::setDims(size_t\u0026amp; nU, size_t\u0026amp; nX, size_t\u0026amp; nY) { // If dimensions are changed, need to resize object and reset.  if (nU != this-\u0026gt;nU) { szChanged = true; this-\u0026gt;nU = nU; } if (nX != this-\u0026gt;nX) { szChanged = true; this-\u0026gt;nX = nX; } if (nY != this-\u0026gt;nY) { szChanged = true; this-\u0026gt;nY = nY; } // this seems a bit heavy-handed, but if any of the dimensions are changed,  // reset everything.  if (szChanged) { cout \u0026lt;\u0026lt; \u0026#34;System dimensions were changed. Resetting object.\\n\u0026#34;; (*this) = glds::ctrl_t(nU, nX, nY, uLB, uUB, dt, p0, q0, r0, controlType); szChanged = false; } }  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':63,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sctrl_8cpp/','title':"src/lds_gaussian_sctrl.cpp",'section':"Files",'content':"src/lds_gaussian_sctrl.cpp #  GLDS switched controller type. More\u0026hellip;\nDetailed Description #  This file implements the type for switched feedback control of a system approximated as multiple discrete Gaussian-output linear dynamical systems ([lds::gaussian::sctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sctrl__t/)).\nSource code #  //===-- lds_gaussian_sctrl.cpp - Switched Controller ----------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace glds; glds::sctrl_t::sctrl_t(size_t nSys, size_t nU, size_t nX, size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, data_t\u0026amp; r0, size_t controlType) : glds::ctrl_t(nU, nX, nY, uLB, uUB, dt, p0, q0, r0, controlType), nSys(nSys), sysIdx(0) { // initial wrapper controller  // (will hold parameters of toggled underlying systems set by `setSystem`)  ctrl_t sys0(nU, nX, nY, uLB, uUB, dt, p0, q0, r0, controlType); systems = std::vector\u0026lt;ctrl_t\u0026gt;(nSys, sys0); adaptM = false; } void glds::sctrl_t::setSystem(size_t sysIdx, ctrl_t\u0026amp; sys) { // Make sure system Idx in bounds  if ((sysIdx + 1) \u0026gt; nSys) { cerr \u0026lt;\u0026lt; \u0026#34;Provided system index is not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; return; } // check to make sure dimensions correct.  if ((sys.getNx() == nX) \u0026amp; (sys.getNu() == nU) \u0026amp; (sys.getNy() == nY)) systems[sysIdx] = sys; else cerr \u0026lt;\u0026lt; \u0026#34;System dimensions are not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; // assign to parent  this-\u0026gt;sysIdx = sysIdx + 1; // this forces switchSystem call to switch  switchSystem(sysIdx); } void glds::sctrl_t::switchSystem(size_t sysIdx) { // Make sure system Idx in bounds  if ((sysIdx + 1) \u0026gt; nSys) { cerr \u0026lt;\u0026lt; \u0026#34;Provided system index is not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; return; } if (sysIdx == this-\u0026gt;sysIdx) return; // already there.  if (adaptM) { // Need to recalc equivalent disturbance for new dynamics [A]  // TODO(mfbolus): This is a fudge. It is the disturbance such that the next  // time step prediction should be the same for both systems.  m += (A - systems[sysIdx].getA()) * x; } else m = systems[sysIdx].getM0(); // Necessary params.  A = systems[sysIdx].getA(); B = systems[sysIdx].getB(); Q = systems[sysIdx].getQ(); Q_m = systems[sysIdx].getQ_m(); C = systems[sysIdx].getC(); d = systems[sysIdx].getD(); x0 = systems[sysIdx].getX0(); m0 = systems[sysIdx].getM0(); P0 = systems[sysIdx].getP0(); P0_m = systems[sysIdx].getP0_m(); R = systems[sysIdx].getR(); Ke = systems[sysIdx].getKe(); Ke_m = systems[sysIdx].getKe_m(); size_t controlType = systems[sysIdx].getControlType(); setControlType(controlType); Kc_u = systems[sysIdx].getKc_u(); Kc_x = systems[sysIdx].getKc_x(); Kc_inty = systems[sysIdx].getKc_inty(); // TODO(mfbolus): Keep the below commented out. Currently references and input  // gains are set at the parent system level and not switched between systems.  // It is conceivable input gains should be varied between systems, but that  // can be accounted for in `B`, so keeping this a parent-level parameter for  // now.  // g = systems[sysIdx].getG();  // gDesign = systems[sysIdx].getGDesign();  this-\u0026gt;sysIdx = sysIdx; } void glds::sctrl_t::setControlType(size_t controlType) { if (this-\u0026gt;controlType == controlType) return; // creating a blank slate... (perhaps unnecessary)  this-\u0026gt;controlType = 0; Kc_u.zeros(0, 0); Kc_inty.zeros(0, 0); intE.zeros(0, 0); intE_awuAdjust.zeros(0, 0); // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (controlType \u0026amp; CONTROL_TYPE_U) { Kc_u.zeros(nU, nU); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_U; } // controller was designed to minimize integral error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { Kc_inty.zeros(nU, nY); intE.zeros(nY); intE_awuAdjust.zeros(nY); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_INTY; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) { if (this-\u0026gt;adaptM) // only if adapting M...  this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_ADAPT_M; } }  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':64,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sys_8cpp/','title':"src/lds_gaussian_sys.cpp",'section':"Files",'content':"src/lds_gaussian_sys.cpp #  GLDS base type. More\u0026hellip;\nDetailed Description #  This file implements the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems ([lds::gaussian::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/)). It inherits functionality from the underlying linear dynamical system ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)).\nSource code #  //===-- lds_gaussian_sys.cpp - GLDS ---------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace glds; glds::sys_t::sys_t(size_t nU, size_t nX, size_t nY, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, data_t\u0026amp; r0) : lds::sys_t(nU, nX, dt, p0, q0), r0(r0) { this-\u0026gt;nY = nY; y = armaVec(nY, fill::zeros); z = armaVec(nY, fill::zeros); d = armaVec(nY, fill::zeros); C = armaMat(nY, nX, fill::eye); // each state will map to an output by  // default (as many as possible)  Ke = armaMat(nX, nY, fill::zeros); // estimator gain.  Ke_m = armaMat(nX, nY, fill::zeros); // estimator gain for m adaptation.  defaultR(); }; void glds::sys_t::predict() { lds::sys_t::predict(); h(); } // Filter: Given measurement (`z`) and previous input (`u_tm1`), predict state // and update estimate of the state, covar, output using Kalman filter void glds::sys_t::filter(armaVec\u0026amp; u_tm1, armaVec\u0026amp; z_t, bool doRecurse_Ke) { setU(u_tm1); // set u  filter(z_t, doRecurse_Ke); } // Filter: Given measurement (`z`) and previous input (`u_tm1`), predict state // and update estimate of the state, covar, output using Kalman filter // (assumes u was previously set or was set internall, e.g. during control) void glds::sys_t::filter(armaVec\u0026amp; z, bool doRecurse_Ke) { // predict mean  predict(); // assign the measurement internal variable.  setZ(z); // recursively calculate esimator gains (or just keep existing values)  if (doRecurse_Ke) recurse_Ke(); // update  x += Ke * (this-\u0026gt;z - y); if (adaptM) m += Ke_m * (this-\u0026gt;z - y); // adaptively estimating disturbance  // With new state, estimate output.  h(); // --\u0026gt; posterior } // recursively estimate Ke void glds::sys_t::recurse_Ke() { // predict covariance  P = A * P * A.t() + Q; // calc Kalman gain  Ke = P * C.t() * inv_sympd(C * P * C.t() + R); // update covariance  // Reference: Ghahramani et Hinton (1996)  P = P - Ke * C * P; if (adaptM) { P_m += Q_m; // A_m = I (i.e., random walk)  Ke_m = P_m * C.t() * inv_sympd(C * P_m * C.t() + R); P_m = P_m - Ke_m * C * P_m; } } // Output: y_{k} = h(x_{k}) void glds::sys_t::h() { y = C * x + d; } // Measurement: z ~ N(y,R) void glds::sys_t::simMeasurement(armaVec\u0026amp; z) { h(); z = y + arma::mvnrnd(armaVec(y.n_elem).fill(0), R); } void glds::sys_t::reset() { lds::sys_t::reset(); h(); } // Fall back to default value for R void glds::sys_t::defaultR() { R.zeros(nY, nY); R.diag().fill(r0); } void glds::sys_t::setDims(size_t\u0026amp; nU, size_t\u0026amp; nX, size_t\u0026amp; nY) { if (nU != this-\u0026gt;nU) { szChanged = true; this-\u0026gt;nU = nU; } if (nX != this-\u0026gt;nX) { szChanged = true; this-\u0026gt;nX = nX; } if (nY != this-\u0026gt;nY) { szChanged = true; this-\u0026gt;nY = nY; } // this seems a bit heavy-handed, but if any of the dimensions are changed,  // reset everything.  if (szChanged) { cout \u0026lt;\u0026lt; \u0026#34;System dimensions were changed. Resetting object.\\n\u0026#34;; (*this) = glds::sys_t(nU, nX, nY, dt, p0, q0, r0); szChanged = false; } } // output-specific set methods void glds::sys_t::setC(stdVec\u0026amp; cVec) { reassign(C, cVec); } void glds::sys_t::setC(armaMat\u0026amp; C) { reassign(this-\u0026gt;C, C); } void glds::sys_t::setR(stdVec\u0026amp; rVec) { reassign(R, rVec); } void glds::sys_t::setR(armaMat\u0026amp; R) { reassign(this-\u0026gt;R, R); } void glds::sys_t::setD(stdVec\u0026amp; dVec) { reassign(d, dVec); } void glds::sys_t::setD(armaVec\u0026amp; d) { reassign(this-\u0026gt;d, d); } void glds::sys_t::setZ(stdVec\u0026amp; zVec) { reassign(z, zVec); } void glds::sys_t::setZ(armaVec\u0026amp; z) { reassign(this-\u0026gt;z, z); } void glds::sys_t::setKe(stdVec\u0026amp; keVec) { reassign(Ke, keVec); } void glds::sys_t::setKe(armaMat\u0026amp; Ke) { reassign(this-\u0026gt;Ke, Ke); } void glds::sys_t::setKe_m(stdVec\u0026amp; kemVec) { reassign(Ke_m, kemVec); } void glds::sys_t::setKe_m(armaMat\u0026amp; Ke_m) { reassign(this-\u0026gt;Ke_m, Ke_m); } void glds::sys_t::printSys() { lds::sys_t::printSys(); cout \u0026lt;\u0026lt; \u0026#34;d: \\n\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;C: \\n\u0026#34; \u0026lt;\u0026lt; C \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;R: \\n\u0026#34; \u0026lt;\u0026lt; R \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;y: \\n\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } glds::sys_t\u0026amp; glds::sys_t::operator=(const glds::sys_t\u0026amp; sys) { // TODO(mfbolus): would love to be able to re-use the lds code:  //  // (*this) = lds::sys_t::operator=(sys);  //  // but this does not work bc the input is glds::sys_t which is a subclass of  // lds::sys_t. Need to figure out if there is a way to write functions to  // apply to all subclasses (e.g., \u0026lt;lds::sys_t\u0026amp; sys)  // FROM LDS  this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; // END FROM LDS  this-\u0026gt;C = sys.C; this-\u0026gt;d = sys.d; this-\u0026gt;R = sys.R; this-\u0026gt;r0 = sys.r0; this-\u0026gt;Ke = sys.Ke; this-\u0026gt;Ke_m = sys.Ke_m; this-\u0026gt;adaptM = sys.adaptM; this-\u0026gt;y = sys.y; this-\u0026gt;z = sys.z; this-\u0026gt;nY = sys.nY; return *this; }  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':65,'href':'/ldsctrlest/docs/api/files/lds__poisson__ctrl_8cpp/','title':"src/lds_poisson_ctrl.cpp",'section':"Files",'content':"src/lds_poisson_ctrl.cpp #  PLDS controller type. More\u0026hellip;\nNamespaces #     Name     plds    Detailed Description #  This file implements the type for feedback control of a Poisson-output linear dynamical system ([lds::poisson::ctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1ctrl__t/)). It inherits functionality from the underlying PLDS model type ([lds::poisson::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/)), including state estimation.\nSource code #  //===-- lds_poisson_ctrl.cpp - PLDS Controller //--------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace plds; // Constructor(s) for sys class plds::ctrl_t::ctrl_t(size_t nU, size_t nX, size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, size_t controlType) : plds::sys_t(nU, nX, nY, dt, p0, q0), uLB(uLB), uUB(uUB), gateCtrl_prev(false), gateLock_prev(false), uSaturated(false), yRefLB(0.1 * dt), tauAntiWindup(lds::inf), t_since_ctrl_onset(0.0) { // initialize to default values  uRef = armaVec(nU, fill::zeros); uRef_prev = armaVec(nU, fill::zeros); xRef = armaVec(nX, fill::zeros); logyRef = armaVec(nY, fill::zeros); yRef = armaVec(nY, fill::zeros); uSat = armaVec(nU, fill::zeros); // Might not need all these, so zero elements until later.  Kc_x = armaMat(nU, nX, fill::zeros); Kc_u = armaMat(0, 0, fill::zeros); Kc_inty = armaMat(0, 0, fill::zeros); gDesign = g; dv = armaVec(nU, fill::zeros); v = armaVec(nU, fill::zeros); duRef = armaVec(nU, fill::zeros); dvRef = armaVec(nU, fill::zeros); vRef = armaVec(nU, fill::zeros); intE = armaVec(0, fill::zeros); intE_awuAdjust = armaVec(0, fill::zeros); kAntiWindup = dt / tauAntiWindup; setControlType(controlType); } // private meat of ctrl around log-linear system void plds::ctrl_t::calc_logLinCtrl(bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset) { if (gateCtrl \u0026amp;\u0026amp; gateEst) { if (!gateCtrl_prev) { if (resetAtCtrlOnset) { reset(); } t_since_ctrl_onset = 0.0; } else { t_since_ctrl_onset += dt; } // enforce softstart on control vars.  if (sigma_softStart \u0026gt; 0) { // halg-gaussian soft-start scaling factor  data_t softStart_sf = 1 - exp(-pow(t_since_ctrl_onset, 2) / (2 * pow(sigma_softStart, 2))); uRef *= softStart_sf; // TODO(mfbolus): May be appropriate to soft-start set point xRef, yRef  // too  // xRef *= softStart_sf;  // yRef *= softStart_sf;  } duRef = uRef - uRef_prev; uRef_prev = uRef; if (!gateLock) { // first do u -\u0026gt; v change of vars. (v = g.*u)  // e.g., convert into physical units (e.g., v[=] mW/mm2 rather than driver  // control voltage u[=]V)  vRef = gDesign % uRef; dvRef = gDesign % duRef; // Given FB, calc. the change in control  if (controlType \u0026amp; CONTROL_TYPE_U) { // if control designed to minimize not u but deltaU (i.e. state aug with  // u):  dv = dvRef; // nominally-optimal.  dv -= Kc_x * (getX() - xRef); // instantaneous state error  dv -= Kc_u * (v - vRef); // penalty on changes in u  if (controlType \u0026amp; CONTROL_TYPE_INTY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if (!uSaturated)  intE += (logy - logyRef) * dt; // integrated error  dv -= Kc_inty * intE; // control for integrated error  } // update the control  v += dv; } else { v = vRef; // nominally-optimal.  v -= Kc_x * (getX() - xRef); // instantaneous state error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if (!uSaturated)  intE += (logy - logyRef) * dt; // integrated error (log-\u0026gt;linear)  v -= Kc_inty * intE; // control for integrated error  } } // convert back to control voltage u[=]V  u = v / getG(); } // else do nothing until lock is low  } else { // if not FB control  // feed through uRef in open loop  u = uRef % gDesign / getG(); uRef.zeros(); intE.zeros(); intE_awuAdjust.zeros(); uSat.zeros(); h(); } // ends gateCtrl  // it may be desireable to make inputs more variable.  if (sigma_uNoise \u0026gt; 0.0) u += sigma_uNoise * armaVec(nU, fill::randn); // enforce box constraints (and antiwindup)  antiWindup(); gateCtrl_prev = gateCtrl; gateLock_prev = gateLock; } // ends calc_logLinCtrl  void plds::ctrl_t::logLin_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset) { // update state estimates, given latest measurement  filter(z); bool gateEst = true; // always have estimator on in this case  // calculate control signal  calc_logLinCtrl(gateCtrl, gateEst, gateLock, sigma_softStart, sigma_uNoise, resetAtCtrlOnset); } void plds::ctrl_t::steadyState_logLin_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset) { // update state estimates, given latest measurement  if (gateEst) { filter(z); } else { predict(); } // calculate the set point @ steady state.  if (gateCtrl) { calc_ssSetPt(); } // calculate control signal  calc_logLinCtrl(gateCtrl, gateEst, gateLock, sigma_softStart, sigma_uNoise, resetAtCtrlOnset); } void plds::ctrl_t::setControlType(size_t controlType) { if (this-\u0026gt;controlType == controlType) return; // creating a blank slate... (perhaps unnecessary)  this-\u0026gt;controlType = 0; Kc_u.zeros(0, 0); Kc_inty.zeros(0, 0); intE.zeros(0, 0); intE_awuAdjust.zeros(0, 0); // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (controlType \u0026amp; CONTROL_TYPE_U) { Kc_u.zeros(nU, nU); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_U; } // controller was designed to minimize integral error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { Kc_inty.zeros(nU, nY); intE.zeros(nY); intE_awuAdjust.zeros(nY); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_INTY; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) { if (this-\u0026gt;adaptM) // only if adapting M...  this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_ADAPT_M; } } // set methods // make sure cannot user-define value of u. void plds::ctrl_t::setU(stdVec\u0026amp; uVec) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot assign a value to `u` in GLDS controller.\\n\u0026#34;; } void plds::ctrl_t::setU(armaVec\u0026amp; u) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot assign a value to `u` in GLDS controller.\\n\u0026#34;; } void plds::ctrl_t::setG(stdVec\u0026amp; gVec) { plds::sys_t::setG(gVec); } void plds::ctrl_t::setG(armaVec\u0026amp; g) { plds::sys_t::setG(g); } void plds::ctrl_t::setGDesign(stdVec\u0026amp; gVec) { reassign(gDesign, gVec); } void plds::ctrl_t::setGDesign(armaVec\u0026amp; g) { reassign(gDesign, g); } void plds::ctrl_t::setURef(stdVec\u0026amp; uRefVec) { uRef_prev = uRef; reassign(uRef, uRefVec); } void plds::ctrl_t::setURef(armaVec\u0026amp; uRef) { uRef_prev = this-\u0026gt;uRef; reassign(this-\u0026gt;uRef, uRef); } void plds::ctrl_t::setXRef(stdVec\u0026amp; xRefVec) { reassign(xRef, xRefVec); } void plds::ctrl_t::setXRef(armaVec\u0026amp; xRef) { reassign(this-\u0026gt;xRef, xRef); } void plds::ctrl_t::setYRef(stdVec\u0026amp; yRefVec) { reassign(yRef, yRefVec); // make sure to enforce lower limit on yRef  limit(yRef, yRefLB, inf); logyRef = log(yRef); } void plds::ctrl_t::setYRef(armaVec\u0026amp; yRef) { reassign(this-\u0026gt;yRef, yRef); // make sure to enforce lower limit on yRef  limit(this-\u0026gt;yRef, yRefLB, inf); logyRef = log(this-\u0026gt;yRef); } void plds::ctrl_t::setKc_x(stdVec\u0026amp; Kc_xVec) { reassign(Kc_x, Kc_xVec); } void plds::ctrl_t::setKc_x(armaMat\u0026amp; Kc_x) { reassign(this-\u0026gt;Kc_x, Kc_x); } void plds::ctrl_t::setKc_u(stdVec\u0026amp; Kc_uVec) { if (controlType \u0026amp; CONTROL_TYPE_U) reassign(Kc_u, Kc_uVec); } void plds::ctrl_t::setKc_u(armaMat\u0026amp; Kc_u) { if (controlType \u0026amp; CONTROL_TYPE_U) reassign(this-\u0026gt;Kc_u, Kc_u); } // void plds::ctrl_t::setKc_y(stdVec\u0026amp; Kc_yVec) { // reassign(Kc_y, Kc_yVec); // } // void plds::ctrl_t::setKc_y(armaMat\u0026amp; Kc_y) { // reassign(this-\u0026gt;Kc_y, Kc_y); // }  void plds::ctrl_t::setKc_inty(stdVec\u0026amp; Kc_intyVec) { if (controlType \u0026amp; CONTROL_TYPE_INTY) reassign(Kc_inty, Kc_intyVec); } void plds::ctrl_t::setKc_inty(armaMat\u0026amp; Kc_inty) { if (controlType \u0026amp; CONTROL_TYPE_INTY) reassign(this-\u0026gt;Kc_inty, Kc_inty); } void plds::ctrl_t::setTauAntiWindup(data_t\u0026amp; tau) { tauAntiWindup = tau; kAntiWindup = dt / tauAntiWindup; } void plds::ctrl_t::calc_ssSetPt() { // Linearly-constrained least squares (ls).  //  // Reference:  // Boyd \u0026amp; Vandenberghe (2018) Introduction to Applied Linear Algebra  //  armaMat A_ls = join_horiz(C, armaMat(nY, nU, fill::zeros)); armaVec b_ls = logyRef - d; armaMat C_ls = join_horiz(A - armaMat(nX, nX, fill::eye), B * arma::diagmat(g)); armaVec d_ls = -m0; if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) d_ls = -m; // adapt setpoint calc with disturbance?  armaMat A_ls_t = A_ls.t(); // TODO(mfbolus): not sure why but causes seg  // fault if I do not do this.  armaMat phi_ls = join_vert(join_horiz(2 * A_ls_t * A_ls, C_ls.t()), join_horiz(C_ls, armaMat(nX, nX, fill::zeros))); // armaMat inv_phi = inv(phi_ls);  armaMat inv_phi = pinv( phi_ls); // TODO(mfbolus): should be actual inverse, rather than pseudo-  armaVec xulam = inv_phi * join_vert(2 * A_ls_t * b_ls, d_ls); xRef = xulam.subvec(0, nX - 1); uRef = xulam.subvec(nX, nX + nU - 1); logyRef = C * xRef.subvec(0, nX - 1) + d; // the least-squares solution  yRef = exp(logyRef); } void plds::ctrl_t::antiWindup() { uSaturated = false; uSat = u; // limit u and flag whether saturated  for (size_t k = 0; k \u0026lt; u.n_elem; k++) { if (u[k] \u0026lt; uLB) { uSat[k] = uLB; uSaturated = true; } if (u[k] \u0026gt; uUB) { uSat[k] = uUB; uSaturated = true; } } if ((controlType \u0026amp; CONTROL_TYPE_INTY) \u0026amp;\u0026amp; (tauAntiWindup\u0026lt;lds::inf)) { // one-step back-calculation  // (Astroem, Rundqwist 1989 warn against using this...)  //  // armaVec delta_intE = solve(Kc_inty, (u-uSat)); //pinv(Kc_inty) *  // (u-uSat);  //  // intE += delta_intE;  // gradual: see Astroem, Rundqwist 1989  // this is a fudge for doing MIMO gradual  // n.b., went ahead and multiplied 1/T by dt so don\u0026#39;t have to do that here.  intE_awuAdjust += kAntiWindup * (sign(Kc_inty).t() / nU) * (u - uSat); intE += intE_awuAdjust; } // set u to saturated version  u = uSat; } void plds::ctrl_t::reset() { plds::sys_t::reset(); uRef.zeros(); uRef_prev.zeros(); intE.zeros(); intE_awuAdjust.zeros(); uSat.zeros(); uSaturated = false; t_since_ctrl_onset = 0.0; } void plds::ctrl_t::printSys() { plds::sys_t::printSys(); std::cout \u0026lt;\u0026lt; \u0026#34;gDesign : \u0026#34; \u0026lt;\u0026lt; gDesign \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;uLB : \u0026#34; \u0026lt;\u0026lt; uLB \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;uUB : \u0026#34; \u0026lt;\u0026lt; uUB \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } plds::ctrl_t\u0026amp; plds::ctrl_t::operator=(const plds::ctrl_t\u0026amp; sys) { // TODO(mfbolus): would love to be able to re-use the lds code:  //  // (*this) = lds::sys_t::operator=(sys);  //  // but this does not work bc the input is glds::sys_t which is a subclass of  // lds::sys_t. Need to figure out if there is a way to write functions to  // apply to all subclasses (e.g., \u0026lt;lds::sys_t\u0026amp; sys)  // FROM LDS  this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; // END FROM LDS  // PLDS  this-\u0026gt;C = sys.C; this-\u0026gt;d = sys.d; this-\u0026gt;logy = sys.logy; this-\u0026gt;y = sys.y; this-\u0026gt;z = sys.z; this-\u0026gt;nY = sys.nY; this-\u0026gt;diag_y = sys.diag_y; this-\u0026gt;chance = sys.chance; // END FROM PLDS  // additional ctrl_t stuff  this-\u0026gt;gDesign = sys.gDesign; this-\u0026gt;uRef = sys.uRef; this-\u0026gt;uRef_prev = sys.uRef_prev; this-\u0026gt;xRef = sys.xRef; this-\u0026gt;logyRef = sys.logyRef; this-\u0026gt;yRef = sys.yRef; this-\u0026gt;Kc_x = sys.Kc_x; this-\u0026gt;Kc_u = sys.Kc_u; this-\u0026gt;Kc_inty = sys.Kc_inty; this-\u0026gt;duRef = sys.duRef; this-\u0026gt;dvRef = sys.dvRef; this-\u0026gt;vRef = sys.vRef; this-\u0026gt;dv = sys.dv; this-\u0026gt;v = sys.v; this-\u0026gt;intE = sys.intE; this-\u0026gt;intE_awuAdjust = sys.intE_awuAdjust; this-\u0026gt;uLB = sys.uLB; this-\u0026gt;uUB = sys.uUB; this-\u0026gt;uSat = sys.uSat; this-\u0026gt;uSaturated = sys.uSaturated; this-\u0026gt;t_since_ctrl_onset = sys.t_since_ctrl_onset; this-\u0026gt;controlType = sys.controlType; return *this; }  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':66,'href':'/ldsctrlest/docs/api/files/lds__poisson__sctrl_8cpp/','title':"src/lds_poisson_sctrl.cpp",'section':"Files",'content':"src/lds_poisson_sctrl.cpp #  PLDS switched controller type. More\u0026hellip;\nDetailed Description #  This file implements the type for switched feedback control of a system approximated as multiple discrete Poisson-output linear dynamical systems ([lds::poisson::sctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sctrl__t/)).\nSource code #  //===-- lds_poisson_sctrl.cpp - Switched Controller -----------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace plds; plds::sctrl_t::sctrl_t(size_t nSys, size_t nU, size_t nX, size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, size_t controlType) : plds::ctrl_t(nU, nX, nY, uLB, uUB, dt, p0, q0, controlType), nSys(nSys), sysIdx(0) { ctrl_t sys0(nU, nX, nY, uLB, uUB, dt, p0, q0, controlType); systems = std::vector\u0026lt;ctrl_t\u0026gt;(nSys, sys0); adaptM = false; } void plds::sctrl_t::setSystem(size_t sysIdx, ctrl_t\u0026amp; sys) { // Make sure system Idx in bounds  if ((sysIdx + 1) \u0026gt; nSys) { cerr \u0026lt;\u0026lt; \u0026#34;Provided system index is not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; return; } // check to make sure dimensions correct.  if ((sys.getNx() == nX) \u0026amp; (sys.getNu() == nU) \u0026amp; (sys.getNy() == nY)) systems[sysIdx] = sys; else cerr \u0026lt;\u0026lt; \u0026#34;System dimensions are not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; // assign to parent  this-\u0026gt;sysIdx = sysIdx + 1; // this forces switchSystem call to switch  switchSystem(sysIdx); } void plds::sctrl_t::switchSystem(size_t sysIdx) { // Make sure system Idx in bounds  if ((sysIdx + 1) \u0026gt; nSys) { cerr \u0026lt;\u0026lt; \u0026#34;Provided system index is not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; return; } if (sysIdx == this-\u0026gt;sysIdx) return; // already there.  if (adaptM) { // Need to recalc equivalent disturbance for new dynamics [A]  // TODO: This is a fudge. It is the disturbance such that the next time step  // prediction should be the same for both systems.  m += (A - systems[sysIdx].getA()) * x; } else m = systems[sysIdx].getM0(); // Necessary params.  A = systems[sysIdx].getA(); B = systems[sysIdx].getB(); Q = systems[sysIdx].getQ(); Q_m = systems[sysIdx].getQ_m(); C = systems[sysIdx].getC(); d = systems[sysIdx].getD(); x0 = systems[sysIdx].getX0(); m0 = systems[sysIdx].getM0(); P0 = systems[sysIdx].getP0(); P0_m = systems[sysIdx].getP0_m(); size_t controlType = systems[sysIdx].getControlType(); setControlType(controlType); Kc_u = systems[sysIdx].getKc_u(); Kc_x = systems[sysIdx].getKc_x(); Kc_inty = systems[sysIdx].getKc_inty(); // TODO(mfbolus): Keep the below commented out. Currently references and input  // gains are set at the parent system level and not switched between systems.  // It is conceivable input gains should be varied between systems, but that  // can be accounted for in `B`, so keeping this a parent-level parameter for  // now.  // g = systems[sysIdx].getG();  // gDesign = systems[sysIdx].getGDesign();  this-\u0026gt;sysIdx = sysIdx; } void plds::sctrl_t::setControlType(size_t controlType) { if (this-\u0026gt;controlType == controlType) return; // creating a blank slate... (perhaps unnecessary)  this-\u0026gt;controlType = 0; Kc_u.zeros(0, 0); Kc_inty.zeros(0, 0); intE.zeros(0, 0); intE_awuAdjust.zeros(0, 0); // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (controlType \u0026amp; CONTROL_TYPE_U) { Kc_u.zeros(nU, nU); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_U; } // controller was designed to minimize integral error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { Kc_inty.zeros(nU, nY); intE.zeros(nY); intE_awuAdjust.zeros(nY); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_INTY; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) { if (this-\u0026gt;adaptM) // only if adapting M...  this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_ADAPT_M; } }  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':67,'href':'/ldsctrlest/docs/api/files/lds__poisson__sys_8cpp/','title':"src/lds_poisson_sys.cpp",'section':"Files",'content':"src/lds_poisson_sys.cpp #  PLDS base type. More\u0026hellip;\nDetailed Description #  This file implements the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems ([lds::poisson::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/)). It inherits functionality from the underlying linear dynamical system ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)).\nSource code #  //===-- lds_poisson_sys.cpp - PLDS ----------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace plds; plds::sys_t::sys_t(size_t nU, size_t nX, size_t nY, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0) : lds::sys_t(nU, nX, dt, p0, q0) { this-\u0026gt;nY = nY; y = armaVec(nY, fill::zeros); logy = armaVec(nY, fill::zeros); z = armaVec(nY, fill::zeros); d = armaVec(nY, fill::zeros); C = armaMat(nY, nX, fill::eye); // each state will map to an output by  // default (as many as possible)  diag_y = diagmat(y); // TODO(mfbolus): for some reason, on my mac, initializing with randu results  // in bus error!  //  // chance = armaVec(nY, fill::randu);  chance = armaVec(nY, fill::zeros); }; // predict: Given input, predict the state, covar void plds::sys_t::predict() { lds::sys_t::predict(); h(); } // Correct: Given measurement (z) and current input (u), update estimate of the // state, covar, output. // // see Eden et al. 2004 void plds::sys_t::filter(armaVec\u0026amp; z) { predict(); diag_y.diag() = y; // need this for covariance update below  // assign the measurement internal variable.  setZ(z); // predict covariance (took this out of generic predict step...)  P = A * P * A.t() + Q; // update cov  P = pinv(pinv(P) + C.t() * diag_y * C); x = x + P * C.t() * (z - y); // posterior  if (adaptM) { P_m += Q_m; // A_m = I  P_m = pinv(pinv(P_m) + C.t() * diag_y * C); m = m + P_m * C.t() * (z - y); } h(); // posterior } // Output: y_{k} = h(x_{k}) = exp(C * x_{k} + d) void plds::sys_t::h() { logy = C * x + d; y = exp(logy); } // Measurement: z ~ Poisson(y) // n.b., In reality, this is only Poisson where rate `y` and sample period `dt` // are sufficiently small there is only ever 0 or 1 events in a period. If // either of those is violated, results will be innacurate. void plds::sys_t::simMeasurement(armaVec\u0026amp; z) { h(); // roll the dice.  chance.randu(y.n_elem); // Compare.  z.zeros(); for (std::size_t k = 0; k \u0026lt; y.n_elem; k++) { if ((y[k]) \u0026gt; chance[k]) z[k] = 1.0; } } void plds::sys_t::reset() { lds::sys_t::reset(); h(); diag_y = diagmat(y); } void plds::sys_t::setDims(size_t\u0026amp; nU, size_t\u0026amp; nX, size_t\u0026amp; nY) { if (nU != this-\u0026gt;nU) { szChanged = true; this-\u0026gt;nU = nU; } if (nX != this-\u0026gt;nX) { szChanged = true; this-\u0026gt;nX = nX; } if (nY != this-\u0026gt;nY) { szChanged = true; this-\u0026gt;nY = nY; } // this seems a bit heavy-handed, but if any of the dimensions are changed,  // reset everything.  if (szChanged) { cout \u0026lt;\u0026lt; \u0026#34;System dimensions were changed. Resetting object.\\n\u0026#34;; (*this) = plds::sys_t(nU, nX, nY, dt, p0, q0); szChanged = false; } } void plds::sys_t::setC(stdVec\u0026amp; cVec) { reassign(C, cVec); } void plds::sys_t::setC(armaMat\u0026amp; C) { reassign(this-\u0026gt;C, C); } void plds::sys_t::setD(stdVec\u0026amp; dVec) { reassign(d, dVec); } void plds::sys_t::setD(armaVec\u0026amp; d) { reassign(this-\u0026gt;d, d); } void plds::sys_t::setZ(stdVec\u0026amp; zVec) { reassign(z, zVec); } void plds::sys_t::setZ(armaVec\u0026amp; z) { reassign(this-\u0026gt;z, z); } void plds::sys_t::printSys() { lds::sys_t::printSys(); cout \u0026lt;\u0026lt; \u0026#34;d: \\n\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;C: \\n\u0026#34; \u0026lt;\u0026lt; C \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;y: \\n\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } plds::sys_t\u0026amp; plds::sys_t::operator=(const plds::sys_t\u0026amp; sys) { // TODO(mfbolus): would love to be able to re-use the lds code:  //  // (*this) = lds::sys_t::operator=(sys);  //  // but this does not work bc the input is glds::sys_t which is a subclass of  // lds::sys_t. Need to figure out if there is a way to write functions to  // apply to all subclasses (e.g., \u0026lt;lds::sys_t\u0026amp; sys)  // FROM LDS  this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; // END FROM LDS  // PLDS  this-\u0026gt;C = sys.C; this-\u0026gt;d = sys.d; this-\u0026gt;logy = sys.logy; this-\u0026gt;y = sys.y; this-\u0026gt;z = sys.z; this-\u0026gt;nY = sys.nY; this-\u0026gt;diag_y = sys.diag_y; this-\u0026gt;chance = sys.chance; // END FROM PLDS  return *this; } // ******************* SYS_T *******************  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':68,'href':'/ldsctrlest/docs/api/files/lds__sys_8cpp/','title':"src/lds_sys.cpp",'section':"Files",'content':"src/lds_sys.cpp #  LDS base type. More\u0026hellip;\nDetailed Description #  This file implements the base type for linear dynamical systems ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code #  //===-- lds_sys.cpp - LDS -------------------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace lds; lds::sys_t::sys_t(size_t nU, size_t nX, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0) : dt(dt), p0(p0), q0(q0) { this-\u0026gt;nU = nU; this-\u0026gt;nX = nX; u = armaVec(nU, fill::zeros); // initial conditions.  x0 = armaVec(nX, fill::zeros); // includes bias (nY) and g (nU)  x = x0; P0 = armaMat(nX, nX, fill::zeros); P = P0; m0 = x0; m = m0; P0_m = P0; P_m = P0_m; g = armaVec(nU, fill::ones); // By default, random walk where each state is independent  // In this way, provides independent estimates of rate per channel of output.  A = armaMat(nX, nX, fill::eye); B = armaMat(nX, nU, fill::zeros); Q = q0 * armaMat(nX, nX, fill::eye); Q_m = Q; adaptM = false; szChanged = false; }; // predict: Given input, predict the state void lds::sys_t::predict() { // Dynamics: x_{k+1} = f(x_{k},u_{k},w_{k})  x = A * x + B * (g % u) + m; // predict estimate **covariance** during the filter step  // (unnecessary if not filtering) } // predict: Given input, predict the state, including simulated process noise void lds::sys_t::simPredict() { // Dynamics: x_{k+1} = f(x_{k},u_{k},w_{k})  x = A * x + B * (g % u) + m; x += arma::mvnrnd( armaVec(x.n_elem).fill(0), Q ); } void lds::sys_t::reset() { // reset to initial conditions  x = x0; // mean  P = P0; // cov of state estimate  m = m0; // process disturbance  P_m = P0_m; // cov of disturbance estimate  szChanged = false; } void lds::sys_t::setDims(size_t\u0026amp; nU, size_t\u0026amp; nX) { if (nU != this-\u0026gt;nU) { szChanged = true; this-\u0026gt;nU = nU; } if (nX != this-\u0026gt;nX) { szChanged = true; this-\u0026gt;nX = nX; } // this seems a bit heavy-handed, but if any of the dimensions are changed,  // reset everything.  if (szChanged) { cout \u0026lt;\u0026lt; \u0026#34;System dimensions were changed. Resetting object.\\n\u0026#34;; (*this) = lds::sys_t(nU, nX, dt, p0, q0); szChanged = false; } } // setting input void lds::sys_t::setU(stdVec\u0026amp; uVec) { reassign(u, uVec); } void lds::sys_t::setU(armaVec\u0026amp; u) { reassign(this-\u0026gt;u, u); } // Fall back to default value for Q and reset P void lds::sys_t::defaultQ() { Q.zeros(); Q.diag().fill(q0); Q_m.zeros(); Q_m.diag().fill(q0); // for good measure...  P = P0; P_m = P0; } // Setting parameter values... void lds::sys_t::setA(stdVec\u0026amp; aVec) { reassign(A, aVec); } void lds::sys_t::setA(armaMat\u0026amp; A) { reassign(this-\u0026gt;A, A); } void lds::sys_t::setB(stdVec\u0026amp; bVec) { reassign(B, bVec); } void lds::sys_t::setB(armaMat\u0026amp; B) { reassign(this-\u0026gt;B, B); } void lds::sys_t::setQ(stdVec\u0026amp; qVec) { reassign(Q, qVec); } void lds::sys_t::setQ(armaMat\u0026amp; Q) { reassign(this-\u0026gt;Q, Q); } void lds::sys_t::setP0(stdVec\u0026amp; p0Vec) { reassign(P0, p0Vec); } void lds::sys_t::setP0(armaMat\u0026amp; P0) { reassign(this-\u0026gt;P0, P0); P = this-\u0026gt;P0; } void lds::sys_t::setX0(stdVec\u0026amp; x0Vec) { reassign(x0, x0Vec); } void lds::sys_t::setX0(armaVec\u0026amp; x0) { reassign(this-\u0026gt;x0, x0); } void lds::sys_t::setG(stdVec\u0026amp; gVec) { reassign(g, gVec); } void lds::sys_t::setG(armaVec\u0026amp; g) { reassign(this-\u0026gt;g, g); } void lds::sys_t::setM(stdVec\u0026amp; mVec) { reassign(m0, mVec); if (!adaptM) m = m0; } void lds::sys_t::setM(armaVec\u0026amp; m) { reassign(m0, m); if (!adaptM) this-\u0026gt;m = m0; } void lds::sys_t::setP0_m(stdVec\u0026amp; p0mVec) { reassign(P0_m, p0mVec); } void lds::sys_t::setP0_m(armaMat\u0026amp; P0_m) { reassign(this-\u0026gt;P0_m, P0_m); } void lds::sys_t::setQ_m(stdVec\u0026amp; qmVec) { reassign(Q_m, qmVec); } void lds::sys_t::setQ_m(armaMat\u0026amp; Q_m) { reassign(this-\u0026gt;Q_m, Q_m); } // Generic functions for re-assigning elements. void lds::sys_t::reassign(armaVec\u0026amp; oldVar, armaVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.n_elem \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaVec\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.size() \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaMat\u0026amp; oldVar, armaMat\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.n_elem \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaMat\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.size() \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } // subviews.. void lds::sys_t::reassign(armaSubVec\u0026amp; oldVar, armaVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.n_elem \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaSubVec\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.size() \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaSubMat\u0026amp; oldVar, armaMat\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.n_elem \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaSubMat\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.size() \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::printSys() { cout \u0026lt;\u0026lt; \u0026#34;\\n********** SYSTEM ********** \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;x: \\n\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;P: \\n\u0026#34; \u0026lt;\u0026lt; P \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;A: \\n\u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;B: \\n\u0026#34; \u0026lt;\u0026lt; B \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Q: \\n\u0026#34; \u0026lt;\u0026lt; Q \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;m: \\n\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;g: \\n\u0026#34; \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl; } lds::sys_t\u0026amp; lds::sys_t::operator=(const lds::sys_t\u0026amp; sys) { this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; return *this; } void lds::sys_t::limit(stdVec\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub) { for (size_t k = 0; k \u0026lt; x.size(); k++) { x[k] = x[k] \u0026lt; lb ? lb : x[k]; x[k] = x[k] \u0026gt; ub ? ub : x[k]; } } void lds::sys_t::limit(armaVec\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub) { for (size_t k = 0; k \u0026lt; x.n_elem; k++) { x[k] = x[k] \u0026lt; lb ? lb : x[k]; x[k] = x[k] \u0026gt; ub ? ub : x[k]; } } void lds::sys_t::limit(armaMat\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub) { for (size_t k = 0; k \u0026lt; x.n_elem; k++) { x[k] = x[k] \u0026lt; lb ? lb : x[k]; x[k] = x[k] \u0026gt; ub ? ub : x[k]; } } void lds::sys_t::checkP() { for (size_t k = 0; k \u0026lt; P.n_elem; k++) { if (abs(P[k]) \u0026gt; plim) { cerr \u0026lt;\u0026lt; \u0026#34;\\n\\nP GOT HIGHER THAN PLIM! RESETTING TO P0... \\n\\n\u0026#34;; P = P0; return; } } for (size_t k = 0; k \u0026lt; P_m.n_elem; k++) { if (abs(P_m[k]) \u0026gt; plim) { cerr \u0026lt;\u0026lt; \u0026#34;\\n\\nP_m GOT HIGHER THAN PLIM! RESETTING TO P0... \\n\\n\u0026#34;; P_m = P0_m; return; } } } //******************* SYS_T *******************  Updated on 1 March 2021 at 19:04:47 CST\n"});index.add({'id':69,'href':'/ldsctrlest/docs/api/namespaces/namespacestd/','title':"std",'section':"Namespaces",'content':"std #   Updated on 1 March 2021 at 19:04:47 CST\n"});})();