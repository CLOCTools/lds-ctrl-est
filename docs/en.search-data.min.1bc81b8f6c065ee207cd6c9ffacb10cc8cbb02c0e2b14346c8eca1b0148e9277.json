[{"id":0,"href":"/lds-ctrl-est/docs/","title":"LDS C+E Documentation","section":"LDS Control \u0026 Estimation","content":" LDS Control \u0026amp; Estimation Documentation # "},{"id":1,"href":"/lds-ctrl-est/docs/tutorials/","title":"LDS C+E Examples","section":"LDS C+E Documentation","content":" Examples # "},{"id":2,"href":"/lds-ctrl-est/acknowledgements/","title":"Acknowledgements","section":"LDS Control \u0026 Estimation","content":" Acknowledgements # Development and publication of this library was supported in part by the NIH/NINDS Collaborative Research in Computational Neuroscience (CRCNS)/BRAIN Grant 5R01NS115327-02.\n"},{"id":3,"href":"/lds-ctrl-est/docs/getting-started/getting-started/","title":"Getting Started","section":"LDS C+E Documentation","content":" Getting Started # This library uses the cross-platform tool CMake to orchestrate the building and testing process on Linux, MacOS, and Windows.\nldsCtrlEst requires Armadillo for linear algebra as well as HDF5 for saving output. vcpkg is a cross-platform C++ package manager which allows us to easily install and use the dependencies in isolation.\nTested Configurations # Building C++ libraries with complex dependencies can be tricky business—in our experience builds have inexplicably worked in one environment and failed in another. To save you time, sweat, and tears, we suggest you simply use one of the following setups we know work fairly reliably, using the RelWithDebInfo build type in the CMake configure command (-DCMAKE_BUILD_TYPE:STRING=RelWithDebInfo):\nUbuntu 18.04 with GCC 7.5 compiler macOS 11 (Big Sur) with Apple Clang 12 compiler Windows 10 with Visual Studio 16.11 (2019 release) and Clang 12 compiler That being said, if you want to debug a build for a single platform, here are some things you can try:\nUse different compilers (or even different versions of a single compiler) Use different versions of vcpkg (which you can control by checking out a different commit in the vcpkg submodule) Mac Pre-requisities # Xcode Command Line Tools will get you clang, gcc, make, and git:\nxcode-select --install Homebrew is \u0026ldquo;The Missing Package Manager for macOS\u0026rdquo; which will make installing lots of things easy. Install like this:\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; You can then use it to install CMake, gfortran, and pkg-config:\nbrew install cmake gfortran pkg-config Linux Pre-requisites # You\u0026rsquo;ll need Git, CMake, GCC, gfortran, etc.\nsudo apt install git cmake pkg-config gfortran curl zip unzip tar build-essential ninja-build Windows Installation # Look here for Windows-specific instructions.\nDownloading the Library # First, clone the repository along with submodules:\ngit clone https://github.com/cloctools/lds-ctrl-est.git cd lds-ctrl-est\rgit submodule update --init Compilation + Installation # Now generate the cache and build using your IDE or from the command line as follows.\nmkdir build \u0026amp;\u0026amp; cd build\rcmake ..\rcmake --build . The first time, vcpkg will automatically install dependencies into [build directory]/vcpkg_installed/, which will likely take about 10-20 minutes.\nIf you want to use vcpkg set up somewhere besides this repo\u0026rsquo;s submodule, add -DCMAKE_TOOLCHAIN_FILE=[path to vcpkg]/scripts/buildsystems/vcpkg.cmake to the cmake command directly or through your IDE\u0026rsquo;s settings.\nYou can verify the build is working by running ctest from the build folder, which runs all the example scripts.\nOptions # This project is configured/compiled/installed by way of CMake and (on Unix-based operating systems) GNU Make. For configuration with CMake, there are three available options.\nLDSCTRLEST_BUILD_EXAMPLES : [default=ON] whether to build example programs located under examples/ in the source tree LDSCTRLEST_BUILD_FIT : [default=ON] whether to build the auxiliary fitting portion of the source code that is not pertinent to control implementation LDSCTRLEST_BUILD_STATIC : [default=ON] whether to statically link against OpenBLAS and create a static ldsCtrlEst library for future use n.b., If both options 2 and 3 are enabled, Matlab/Octave mex functions will be compiled for exposing some of the fitting functionality to Matlab/Octave, assuming these programs are installed.\nBelow are example usages of cmake to configure/build the library.\nFor basic project build \u0026amp; install\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake .. #configure build cmake --build #build the project sudo make install #[optional] installs to default location (OS-specific) To set the install prefix\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DCMAKE_INSTALL_PREFIX=/your/install/prefix .. #configure build with chosen install location cmake --build #build the project make install #install to /your/install/prefix To build the bare bones project, excluding fit code and Matlab mex code.\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DLDSCTRLEST_BUILD_FIT=0 .. #configure not to build the fitting portion of library make #build the project n.b., If you choose not to install the library or install it to the non-default location, ensure you have updated the following environment variables on Unix-based operating systems.\nLD_LIBRARY_PATH: search path for dynamically loaded libraries PKG_CONFIG_PATH: search path for pkg-config tool On Windows, you may need to add the build location to the PATH environment variable for the library to be used elsewhere.\nPython bindings package ldsctrlest # With the LDSCTRLEST_BUILD_PYTHON setting (off by default) and the pybind11 submodule initialized, you can build Python bindings. You will probably want to specify the installation of Python to use by adding a -DPython3_ROOT_DIR=[path/to/install/dir] argument to the CMake cache generation command (the first one) so CMake doesn\u0026rsquo;t use an undesired version. That environment needs to have NumPy installed.\ncmake --build . --target python_modules The bindings need to be generated just once per Python version. Once the build is complete, navigate to the [build location]/python folder and run pip install . to make it importable anywhere for your current environment. The file structure only works correctly for this if you use a single-config generator like Ninja or Make, though. You can verify the installation was successful by running pytest from the build/python directory (pip install pytest matplotlib first if you need to).\nSee python/ldsctrlest/README.md for usage details.\nAlso, beware that a single build will probably not work for both the standalone library and the Python package, since the conversion between NumPy and Armadillo alters the way Armadillo allocates memory. In this case you may want to build once with -DLDSCTRLEST_BUILD_PYTHON=ON, install the package, then again with -DLDSCTRLEST_BUILD_PYTHON=OFF for the pure C++ build to work correctly.\nCommon issues # \u0026ldquo;I have built the library and installed it in a non-default location. In building my own project linking against ldsCtrlEst, cmake or pkg-config cannot find the library or its configuration information.\u0026rdquo; If cmake and/or pkg-config cannot find the required configuration files for your project to link against ldsCtrlEst, make sure that these utilities know to look for them in the non-default location where you installed the library. For cmake this means adding your chosen install prefix to the environment variable CMAKE_PREFIX_PATH. Similarly, for pkg-config you need to add your/install/prefix/lib/pkgconfig to its search path, PKG_CONFIG_PATH. Assuming a Unix shell whose login startup file is ~/.profile and ldsCtrlEst was installed using prefix your/install/prefix, add the following to .profile.\nexport CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix vcpkg fails on configuration Try running ./bootstrap-vcpkg from the vcpkg folder and try again. If that doesn\u0026rsquo;t work, try updating vcpkg to a newer version (in the source control tab, click on the commit hash by the vcpkg repo then select from the dropdown) and running boostsrap-vcpkg again. You can also try upgrading your system (e.g., apt update, apt upgrade).\nCould not find Python3 (missing: Python3_NumPy_INCLUDE_DIRS NumPy)\nMake sure NumPy is installed in the Python environment you specified. If CMake still can\u0026rsquo;t find it, you may need to tell CMake exactly where to find it by adding an argument to the configure command: -DPython3_NumPy_INCLUDE_DIR=.... You can find that location like this: python -c 'import numpy; print(numpy.get_include())'\n"},{"id":4,"href":"/lds-ctrl-est/docs/getting-started/windows/","title":"Windows","section":"LDS C+E Documentation","content":" Windows Installation # Windows Pre-requisites # Scoop is a very handy tool for easily installing all sorts of command-line applications. Install like this:\nSet-ExecutionPolicy RemoteSigned -Scope CurrentUser # Optional: Needed to run a remote script the first time iwr get.scoop.sh | Invoke-Expression Install Git and CMake if you don\u0026rsquo;t already have them:\nscoop install git cmake If that didn\u0026rsquo;t work, follow more detailed instructions here.\nThe easiest way to compile C++ project on Windows is with Visual Studio\u0026rsquo;s build tools, which you can download here (or here for the 2019 release which we tested—make sure you get the most recent one, e.g., 16.11 at time of writing). In the installer, click on \u0026ldquo;Desktop development with C++.\u0026rdquo; If you want to build Python bindings, you will need to use the Clang compiler, which you can add on the \u0026ldquo;Installation details\u0026rdquo; sidebar under optional features.\nAnd the easiest way to use Visual Studio\u0026rsquo;s build tools is with VS Code, along with the CMake Tools extension. Install them and you should be ready to go.\nDownloading the Library # First, clone the repository, either from VS Code or the command line:\ngit clone https://github.com/cloctools/lds-ctrl-est.git cd lds-ctrl-est You\u0026rsquo;ll need to initialize the submodules from the command line after the repo is cloned:\ngit submodule update --init Installation # When you open the folder in VS Code, you will like be prompted by the CMake Tools extension to configure the project. Make sure you select the kit (you\u0026rsquo;ll be prompted when you configure\u0026ndash;else there\u0026rsquo;s an icon in the bar on the bottom of the window or type Ctrl+Shift+P, then \u0026ldquo;cmake select kit\u0026rdquo;). Choose Clang [latest version] with GNU CLI ... amd64 assuming you are running a 64-bit OS. (MSVC may work okay too if you don\u0026rsquo;t need to build Python bindings.)\nFollow along with the \u0026ldquo;Getting Started\u0026rdquo; instructions, but where you see config options specified as -DLDSCTREST_BUILD_STATIC=OFF or -DPython3_ROOT_DIR=..., you will enter those in settings: open with Ctrl+,, click \u0026ldquo;workspace\u0026rdquo;, then search for \u0026ldquo;CMake: Configure Args\u0026rdquo; and enter each of your desired arguments as a separate item.\nTo configure, use Ctrl+Shift+P and search for the \u0026ldquo;CMake: Configure\u0026rdquo; command. To build, click the \u0026ldquo;Build\u0026rdquo; button on the bottom bar. Then click the \u0026ldquo;CTest\u0026rdquo; button to run the example scripts.\nConsiderations # Development on Windows has been more prone to bugs than on Unix systems, so if you encounter many problems, consider switching—WSL (Windows Subsystem for Linux) is a good option for Windows users who don\u0026rsquo;t want to work on a different machine.\nCompilation has been successfully tested in VS Code using the following kit, using the \u0026ldquo;RelWithDebInfo\u0026rdquo; config:\nClang 12.0.0 (GNU CLI) for MSVC 16.11.31702.278 (Visual Studio Community 2019 Release - amd64) Troubleshooting # The build appears to work, but tests fail with code 0xc0000135 OR \u0026ldquo;I have built the library and installed it in a non-default location. In building my own project linking against ldsCtrlEst, cmake or pkg-config cannot find the library or its configuration information.\u0026rdquo; Have you installed the library? In VS Code, use Shift+F7 to build a specific target, in this case INSTALL. If that doesn\u0026rsquo;t solve your problem, you will likely need to add the build or install folder to your PATH environment variable, which you can do using the settings GUI (search for \u0026ldquo;Edit the system environment variables\u0026rdquo;).\nOn Windows, \u0026ldquo;Generate CMake Cache\u0026rdquo; step errs because creating symbolic links is not permitted. Certain source files are sym-linked to the build/install directories during configuration with cmake. As such, your user in Windows must be permitted to do so. Make sure that your user is listed next to Control Panel -\u0026gt; Administrative Tools -\u0026gt; Local Policies -\u0026gt; User Rights Assignment -\u0026gt; Create Symbolic Links.\n"},{"id":5,"href":"/lds-ctrl-est/issues-contributing/","title":"Issues Contributing","section":"LDS Control \u0026 Estimation","content":" Reporting Issues # If you encounter bugs when using this library or have specific feature requests that you believe fall within the stated scope of this project, please open an issue on GitHub and use an appropriate issue template where possible. You may also fork the repository and submit pull-requests with your suggested changes.\nContributing # We welcome any community contributions to this project. Please fork the repository and if possible use clang-format and clang-tidy to conform to the coding format/style of this repository.\n"},{"id":6,"href":"/lds-ctrl-est/docs/api/namespaces/namespacearmamexc/","title":"armamexc","section":"Namespaces","content":" armamexc # arma/mex interface using Matlab C API More\u0026hellip; Functions # Name template \u0026lt;class T \u0026gt; T m2T_scalar(const mxArray * matlab_scalar)\nConvert Matlab mxArray to scalar of type T. template \u0026lt;class T \u0026gt; arma::Mat\u0026lt; T \u0026gt; m2a_mat(const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true)\nConvert matlab matrix to armadillo. template \u0026lt;typename T \u0026gt; mxArray * a2m_mat(arma::Mat\u0026lt; T \u0026gt; const \u0026amp; arma_mat)\nConvert armadillo to matlab matrix. template \u0026lt;typename T \u0026gt; mxArray * a2m_vec(arma::Col\u0026lt; T \u0026gt; const \u0026amp; arma_vec)\nConvert armadillo to matlab vector. Detailed Description # Utilities for arma/mex interface using Matlab C API\nFunction Details # m2T_scalar # template \u0026lt;class T \u0026gt; inline T m2T_scalar( const mxArray * matlab_scalar ) Parameters:\nmatlab_scalar matlab scalar Template Parameters:\nT type Return: scalar of type T\nm2a_mat # template \u0026lt;class T \u0026gt; inline arma::Mat\u0026lt; T \u0026gt; m2a_mat( const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true ) Parameters:\nmatlab_mat matlab matrix copy_aux_mem [optional] whether to copy auxiliary memory strict [optional] strictly enforce the above Template Parameters:\nT type Return: armadillo matrix of type T\na2m_mat # template \u0026lt;typename T \u0026gt; inline mxArray * a2m_mat( arma::Mat\u0026lt; T \u0026gt; const \u0026amp; arma_mat ) Parameters:\narma_mat armadillo matrix Return: matlab matrix\na2m_vec # template \u0026lt;typename T \u0026gt; inline mxArray * a2m_vec( arma::Col\u0026lt; T \u0026gt; const \u0026amp; arma_vec ) Parameters:\narma_vec armadillo vector Return: matlab vector\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":7,"href":"/lds-ctrl-est/docs/api/namespaces/namespacearmamexcpp/","title":"armamexcpp","section":"Namespaces","content":" armamexcpp # arma/mex interface using Matlab C++ API More\u0026hellip; Functions # Name template \u0026lt;class T \u0026gt; std::vector\u0026lt; arma::Mat\u0026lt; T \u0026gt; \u0026gt; m2a_cellmat(matlab::data::CellArray \u0026amp; matlab_cell)\nConvert matlab cell array to vector of armadillo matrices. template \u0026lt;class T \u0026gt; std::vector\u0026lt; T \u0026gt; m2s_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array)\nConvert matlab matrix to a vector of scalars. template \u0026lt;class T \u0026gt; arma::Col\u0026lt; T \u0026gt; m2a_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo vector. template \u0026lt;class T \u0026gt; arma::Mat\u0026lt; T \u0026gt; m2a_mat(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo matrix. template \u0026lt;class T \u0026gt; matlab::data::TypedArray\u0026lt; T \u0026gt; a2m_mat(const arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab matrix. template \u0026lt;class T \u0026gt; matlab::data::TypedArray\u0026lt; T \u0026gt; a2m_vec(const arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab vector. template \u0026lt;class T \u0026gt; matlab::data::TypedArray\u0026lt; T \u0026gt; s2m_vec(const std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert vector of scalar T to matlab matrix. Detailed Description # utilities for arma/mex interface using Matlab C++ API\nFunction Details # m2a_cellmat # template \u0026lt;class T \u0026gt; std::vector\u0026lt; arma::Mat\u0026lt; T \u0026gt; \u0026gt; m2a_cellmat( matlab::data::CellArray \u0026amp; matlab_cell ) Parameters:\nmatlab_cell matlab cell Template Parameters:\nT type Return: vector of armadillo matrices of type T\nm2s_vec # template \u0026lt;class T \u0026gt; std::vector\u0026lt; T \u0026gt; m2s_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array ) Parameters:\nmatlab_array matlab array Template Parameters:\nT type Return: vector of type T\nm2a_vec # template \u0026lt;class T \u0026gt; arma::Col\u0026lt; T \u0026gt; m2a_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\nmatlab_array matlab array Template Parameters:\nT type Return: armadillo vector of type T\nm2a_mat # template \u0026lt;class T \u0026gt; arma::Mat\u0026lt; T \u0026gt; m2a_mat( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\nmatlab_array matlab matrix Template Parameters:\nT type Return: armadillo matrix of type T\na2m_mat # template \u0026lt;class T \u0026gt; matlab::data::TypedArray\u0026lt; T \u0026gt; a2m_mat( const arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\narma_mat arma matrix factory matlab \u0026ldquo;array factory\u0026rdquo; Template Parameters:\nT type Return: matlab matrix\na2m_vec # template \u0026lt;class T \u0026gt; matlab::data::TypedArray\u0026lt; T \u0026gt; a2m_vec( const arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\narma_vec armadillo vector factory matlab \u0026ldquo;array factory\u0026rdquo; Template Parameters:\nT type Return: matlab matrix\ns2m_vec # template \u0026lt;class T \u0026gt; matlab::data::TypedArray\u0026lt; T \u0026gt; s2m_vec( const std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\nstd_vec standard vector factory matlab \u0026ldquo;array factory\u0026rdquo; Template Parameters:\nT type Return: matlab matrix\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":8,"href":"/lds-ctrl-est/docs/terminology/control-estimation/","title":"C\u0026E","section":"LDS C+E Documentation","content":" Control \u0026amp; Estimation # The control system provided by this library is comprised of a state estimator and a controller. The estimator is responsible for estimating the latent state of the system, given measurements up to and including the current time (i.e., filtering). At each time step, the controller then uses the resulting state feedback and an internal model of the system to update the inputs to the process being manipulated.\nState estimation # In general, the filtering performed to estimate the underlying state proceeds recursively by first using the model dynamics to predict the state change at the next time step, followed by updating this prediction when a new measurement is available. For a LDS, this two-step process can be summarized by \\[\\widehat{\\mathbf{x}}_{t|t-1} = \\mathbf{A}\\widehat{\\mathbf{x}}_{t-1|t-1} \u0026#43; \\mathbf{B} u_{t-1} \u0026#43; \\mathbf{m}_{t-1} \\;,\\] \\[\\widehat{\\mathbf{x}}_{t|t} = \\widehat{\\mathbf{x}}_{t|t-1} \u0026#43; \\mathbf{K}^{\\rm e}_t \\left(\\mathbf{z}_t - \\widehat{\\mathbf{y}}_{t|t-1}\\right)\\;,\\] where \\( \\hat{\\left(\\cdot\\right)}_{t|j} \\) indicates an estimate at time \\( t \\) given data up to time \\( j \\) inclusive, \\( \\mathbf{K}^{\\rm e} \\) is the estimator gain, and\n\\[ \\widehat{\\mathbf{y}}_{t|t-1} = h\\left( \\widehat{\\mathbf{x}}_{t|t-1} \\right) \\; .\\] In the case of GLDS models, the estimator gain (called Ke in library) is calculated recursively by Kalman filtering, which requires knowledge of the process noise and measurement noise covariances (Q, R) in addition to the system matrices. For time-invariant GLDS models, the infinite horizon solution is often used, so this gain need not be time-varying. Users may instead set its pre-determined value with the lds::gaussian::System::set_Ke mutator.\nIn the case of PLDS models, there is an analogue of the Kalman filter developed for dynamical systems with point-process observations (Eden et al. 2004). This nonlinear filter recursively updates Ke at each time step and requires an estimate of the process noise covariance (Q) as well.\nAdaptive estimation of process disturbance # Both the Kalman filter and point-process analogue are model-based; therefore, their performance can be sensitive to model mismatch, whether this be imperfect model fitting or true drifts in system behavior. A practical approach to improving robustness is parameter adaptation. To that end, this library provides dual state-parameter estimation. Specifically, an additive process disturbance (m) is adaptively re-estimated when the lds::System::do_adapt_m property is set to true. This effectively provides integral action on minimizing state estimation error that could either be due to model mismatch or a true disturbance.\nWhen parameter adaptation is enabled, this process disturbance is assumed to vary stochastically on a random walk \\[\\mathbf{m}_{t} = \\mathbf{m}_{t-1} \u0026#43; \\mathbf{w}^m_{t-1} \\;,\\] where \\( \\mathbf{w}^m \\sim \\mathcal{N}\\left(0, \\mathbf{Q}_m\\right)\\) . Kalman filtering or the point-process analogue are then used to estimate this disturbance in parallel with the state.\nControl # Given the estimated state, the controller updates the inputs to the system according to the following law: \\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\] where \\( \\left( \\cdot \\right)^{\\rm ref} \\) correspond to reference/target signals and \\( \\mathbf{K}^c_x \\) is the state feedback controller gain. Recall that these controller gains are assumed to have been designed before the experiment using, for example, LQR.\nIf users are employing integral action for more robust tracking at DC and did not use the approach of augmenting the state vector and system matrices accordingly, there is an option to include the integral term as\n\\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right) - \\mathbf{K}^c_{\\rm inty} \\sum_{j=1}^{t}\\left( \\widehat{\\mathbf{y}}_j - \\mathbf{y}^{\\rm ref}_j \\right) \\;.\\] An additional option available to users is a control law that updates the change in u,\n\\[\\Delta\\mathbf{u}_{t} = -\\mathbf{K}^c_u \\left(\\mathbf{u}_{t-1} - \\mathbf{u}^{\\rm ref}_{t-1} \\right) - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\] \\[\\mathbf{u}_{t} = \\mathbf{u}_{t-1} \u0026#43; \\Delta\\mathbf{u}_{t} \\; .\\] Notice that this takes the form of a first-order difference equation for updating control (i.e., \\( \\Delta\\mathbf{u}_{t} = -\\mathbf{K}^c_u \\mathbf{u}_{t-1} \u0026#43; \\epsilon_{t-1} \\) ), effectively low-pass filtering the input depending on the characteristics of \\( \\mathbf{K}^c_u \\) . This can be useful in cases where users have designed the controller gains by LQR to minimize not the amplitude of the input, but the change in input, by augmenting the state vector with the input during LQR design.\nIntegral action and the \\( \\Delta \\mathbf{u} \\) control law can be combined. The library keeps track of the controller type by way of bit masks which can be bit-wise OR\u0026rsquo;d to use in combination.\nCalculating reference state-control from output # In cases where an output reference is supplied and the goal is to track either a static or slowly varying output, users do not have to produce \\( \\mathbf{x}^{\\rm ref} \\) and \\( \\mathbf{u}^{\\rm ref} \\) . Methods are provided for calculating the state and control that would be required to reach the reference output at steady state (lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference). This is achieved by linearly-constrained least squares. For single-output systems, it results in an exact solution; however, for multi-output problems it provides a least squares comprimise across outputs.\n"},{"id":9,"href":"/lds-ctrl-est/docs/api/classes/","title":"Classes","section":"LDS C+E Documentation","content":" Classes # lds::Controller\nlds::EM\nlds::Fit LDS Fit Type.\nlds::SSID\nlds::SwitchedController SwitchedController Type.\nlds::System Linear Dynamical System Type.\nlds::UniformMatrixList\nlds::UniformSystemList\nlds::UniformVectorList\nlds::gaussian::Controller Gaussian-observation Controller Type.\nlds::gaussian::Fit GLDS Fit Type.\nlds::gaussian::FitEM GLDS E-M Fit Type.\nlds::gaussian::FitSSID Subspace Identification (SSID) for GLDS.\nlds::gaussian::SwitchedController Gaussian-observation SwitchedController Type.\nlds::gaussian::System Gaussian LDS Type.\nlds::poisson::Controller PLDS Controller Type.\nlds::poisson::Fit PLDS Fit Type.\nlds::poisson::FitEM PLDS E-M Fit Type.\nlds::poisson::FitSSID Subspace Identification (SSID) for PLDS.\nlds::poisson::SwitchedController Poisson-observation SwitchedController Type.\nlds::poisson::System Poisson System type.\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":10,"href":"/lds-ctrl-est/docs/api/modules/group__control__masks/","title":"Control Mode Bit Masks","section":"Modules","content":" Control Mode Bit Masks # provides fill types for constructing new armadillo vectors, matrices More\u0026hellip; Attributes # Name const std::size_t kControlTypeDeltaU control designed to penalize change in input const std::size_t kControlTypeIntY control using integral action const std::size_t kControlTypeAdaptM adapt control setpoint with re-estimated disturbance m Detailed Description # Control mode bit masks. These can be bit-wise OR\u0026rsquo;d to use in combination.\nAttribute Details # kControlTypeDeltaU # static const std::size_t kControlTypeDeltaU = 0x1; Control was designed to penalize change in input (i.e., the state was augmented with input u)\nkControlTypeIntY # static const std::size_t kControlTypeIntY = kControlTypeDeltaU \u0026lt;\u0026lt; 1; Control using integral action (i.e., the state was augmented with output y during design)\nkControlTypeAdaptM # static const std::size_t kControlTypeAdaptM = kControlTypeDeltaU \u0026lt;\u0026lt; 2; Adapt control setpoint adapted with re-estimated process disturbance m.\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":11,"href":"/lds-ctrl-est/docs/api/modules/group__defaults/","title":"Defaults","section":"Modules","content":" Defaults # More\u0026hellip; Attributes # Name const data_t kDefaultP0 default state estimate covar const data_t kDefaultQ0 default process noise covar const data_t kDefaultR0 default output noise covar Detailed Description # Default values for common variables (e.g., default diagonal elements of covariances)\nAttribute Details # kDefaultP0 # static const data_t kDefaultP0 = 1e-6; kDefaultQ0 # static const data_t kDefaultQ0 = 1e-6; kDefaultR0 # static const data_t kDefaultR0 = 1e-2; Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":12,"href":"/lds-ctrl-est/docs/api/examples/eg_glds_ctrl_8cpp-example/","title":"eg_glds_ctrl.cpp","section":"Examples","content":" eg_glds_ctrl.cpp # Example GLDS Control ```cpp\n//===\u0026ndash; eg_glds_ctrl.cpp - Example GLDS Control \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===// //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===//\n#include using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout;\nauto main() -\u0026gt; int { cout \u0026laquo; \u0026quot; ********** Example Gaussian LDS Control ********** \\n\\n\u0026quot;;\n// Make 1st-order SISO system, sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1;\n// no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt);\n// construct ground truth system to be controlled\u0026hellip; // initializes to random walk model with top-most n_y state observed lds::gaussian::System controlled_system(n_u, n_x, n_y, dt);\n// Ground-truth parameters for the controlled system // (stand-in for physical system to be controlled) Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); Matrix b_true = Matrix(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2: Vector g_true = Vector(n_y).fill(10.0);\n// output noise covariance Matrix r_true = Matrix(n_y, n_y, arma::fill::eye) * 1e-4;\nsize_t which_m = 0; // whether low or high disturbance (0, 1) data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb. data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi;\n// initially let m be low Vector m0_true = Vector(n_x).fill(m_low);\n// Assign params. controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_R(r_true);\ncout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;controlled_system:\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; controlled_system.Print(); cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;;\n// make a controller lds::gaussian::Controller controller; { // Create incorrect model used for control. // (e.g., imperfect model fitting) Matrix b_controller = b_true / 2;\n// let's assume zero process disturbance initially // (will be re-estimating) Vector m_controller = Vector(n_x, arma::fill::zeros); // for this demo, just use arbitrary default R Matrix r_controller = Matrix(n_y, n_y, arma::fill::eye) * lds::kDefaultR0; lds::gaussian::System controller_system(controlled_system); controller_system.set_B(b_controller); controller_system.set_m(m_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m // going to adaptively re-estimate the disturbance controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise // acting on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; controller_system.set_Q_m(q_m); // create controller // lower and upper bounds on control signal (e.g., in Volts) data_t u_lb = 0.0; // [=] V data_t u_ub = 5.0; // [=] V controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); }\n// Control variables: // if following enabled, adapts set point with re-estimated process // disturbance n.b., should not need integral action if this is enabled as the // adaptive estimator minimizes DC error bool do_adaptive_set_point = false;\n// Reference/target output, controller gains Vector y_ref0 = Vector(n_y).fill(20.0 * dt); Matrix k_x = Matrix(n_u, n_x).fill(100); // gains on state error Matrix k_inty = Matrix(n_u, n_y).fill(1e3); // gains on integrated err\n// setting initial state to target to avoid error at onset: Vector x0 = Vector(n_x).fill(y_ref0[0]);\n// set up controller type bit mask so controller knows how to proceed size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance control_type = control_type | lds::kControlTypeAdaptM; } else { // use integral action to minimize DC error control_type = control_type | lds::kControlTypeIntY; }\n// set controller type controller.set_control_type(control_type);\n// Let\u0026rsquo;s say these controller gains were designed assuming g was 9 V/(mW/mm2): Vector g_design = Vector(n_u).fill(9);\n// Set params. // n.b. using arbitrary defaults for Q, R in this example. Really, these // should be set by users, as they tune characteristics of Kalman filter. // Users can also choose not to recursively calculate the estimator gain and // supply it (setKe) instead of covariances. controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_g_design(g_design);\ncout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;control system:\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; controller.Print(); cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;;\n// set up variables for simulation // create Matrix to save outputs in\u0026hellip; Matrix y_ref = Matrix(n_y, n_t, arma::fill::ones) * y_ref0[0];\n// Simulated measurements Matrix z(n_y, n_t, arma::fill::zeros);\n// simulated control signal ([=] V) Matrix u(n_u, n_t, arma::fill::zeros);\n// outputs, states and gain/disturbance params // *_hat indicates online estimates Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_x, n_t, arma::fill::zeros);\n// *_true indicates ground truth (system being controlled) Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_x, n_t, arma::fill::zeros);\n// set initial val y_hat.submat(0, 0, n_y - 1, 0) = controller.sys().y(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.y();\nx_hat.submat(0, 0, n_x - 1, 0) = controller.sys().x(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.x();\nm_hat.submat(0, 0, n_x - 1, 0) = controller.sys().m(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.m();\ncout \u0026laquo; \u0026ldquo;Starting \u0026quot; \u0026laquo; n_t * dt \u0026laquo; \u0026quot; sec simulation \u0026hellip; \\n\u0026rdquo;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance Vector chance = arma::randu(1); if (which_m == 0) // low disturbance { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_high); which_m = 1; } } else { // high disturbance if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_low); which_m = 0; } } controlled_system.set_m(m0_true);\n// input Vector u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system. z.col(t) = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate // x_ref, u_ref from reference output y_ref. Therefore, it is only // applicable to regulation problems or cases where reference trajectory // changes slowly compared to system dynamics. u.col(t) = controller.ControlOutputReference(z.col(t)); // save the signals y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); }\nauto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026laquo; \u0026ldquo;Finished simulation in \u0026quot; \u0026laquo; sim_time_ms.count() \u0026laquo; \u0026quot; ms.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;(app. \u0026quot; \u0026laquo; (sim_time_ms.count() / n_t) * 1e3 \u0026laquo; \u0026quot; us/time-step)\\n\u0026rdquo;;\ncout \u0026laquo; \u0026ldquo;Saving simulation data to disk.\\n\u0026rdquo;;\n// saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue, // xTrue, mTrue saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace;\nauto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;dt\u0026rdquo;)); y_ref.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;y_ref\u0026rdquo;, replace)); u.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;u\u0026rdquo;, replace)); z.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;z\u0026rdquo;, replace)); x_true.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;x_true\u0026rdquo;, replace)); m_true.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;m_true\u0026rdquo;, replace)); y_true.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;y_true\u0026rdquo;, replace)); x_hat.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;x_hat\u0026rdquo;, replace)); m_hat.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;m_hat\u0026rdquo;, replace)); y_hat.save(arma::hdf5_name(\u0026ldquo;eg_glds_ctrl.h5\u0026rdquo;, \u0026ldquo;y_hat\u0026rdquo;, replace));\ncout \u0026laquo; \u0026ldquo;fin.\\n\u0026rdquo;; return 0; }\n_Filename: eg_glds_ctrl.cpp_ ------------------------------- Updated on 5 March 2025 at 16:32:33 EST "},{"id":13,"href":"/lds-ctrl-est/docs/api/examples/eg_glds_du_plds_ctrl_8cpp-example/","title":"eg_glds_du_plds_ctrl.cpp","section":"Examples","content":" eg_glds_du_plds_ctrl.cpp # Example GLDS Control of PLDS where change in control (du) is being updated, rather than amplitude (u). ```cpp\n//===\u0026ndash; eg_glds_du_plds_ctrl.cpp - Example GLDS Delta u Control of PLDS \u0026mdash;===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===// //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===//\n#include using lds::data_t; using lds::Matrix; using lds::Vector; using std::cout;\nauto main() -\u0026gt; int { cout \u0026laquo; \u0026quot; ********** Example Gaussian LDS du Control of PLDS ********** \\n\\n\u0026quot;;\n// Make 1st-order SISO system, sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1;\n// no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt);\n// construct ground truth system to be controlled\u0026hellip; // initializes to random walk model with top-most n_y state observed lds::poisson::System controlled_system(n_u, n_x, n_y, dt);\n// Ground-truth parameters for the controlled system // (stand-in for physical system to be controlled) Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); Matrix b_true = Matrix(n_x, n_u).fill(2.5e-2); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2: Vector g_true = Vector(n_y).fill(10.0);\nsize_t which_m = 0; // whether low or high disturbance (0, 1) data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 0; // 1e-3; // probability of going from low to high disturb. data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi;\n// initially let m be low Vector m0_true = Vector(n_x).fill(m_low); Vector x0_true = Vector(n_x, arma::fill::ones) * log(1 * dt);\n// Assign params. controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_x0(x0_true); controlled_system.Reset();\ncout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;controlled_system:\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; controlled_system.Print(); cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;;\n// make a controller lds::gaussian::Controller controller; { // Create incorrect model used for control. // (e.g., imperfect model fitting) Matrix b_controller = b_true / 50;\n// let's assume zero process disturbance initially // (will be re-estimating) Vector m_controller = Vector(n_x, arma::fill::zeros); // process noise covariance Matrix q_controller = Matrix(n_y, n_y, arma::fill::eye) * 1e-8; // output noise covariance Matrix r_controller = Matrix(n_y, n_y, arma::fill::eye) * 1e-2; lds::gaussian::System controller_system(n_u, n_x, n_y, dt); controller_system.set_A(a_true); controller_system.set_B(b_controller); controller_system.set_g(g_true); controller_system.set_m(m_controller); controller_system.set_Q(q_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m // going to adaptively re-estimate the disturbance controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise // acting on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-8; controller_system.set_Q_m(q_m); // create controller // lower and upper bounds on control signal (e.g., in Volts) data_t u_lb = 0.0; // [=] V data_t u_ub = 5.0; // [=] V controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); }\n// Control variables: // Reference/target output, controller gains Vector y_ref0 = Vector(n_y).fill(20.0 * dt);\n// to design for this example, augmented state with control and made the input // du; cost on output q_y = 1, on integral output = 1e2, on u = 0, on du = // 1e-2. Matrix k_x = Matrix(n_u, n_x).fill(2.44); // gains on state error Matrix k_inty = Matrix(n_u, n_y).fill(97.4); // gains on integrated err Matrix k_u = Matrix(n_u, n_u).fill(5.23e-2); // gains on input amp\n// set up controller type bit mask so controller knows how to proceed size_t control_type = 0; // use integral action to minimize DC error control_type = control_type | lds::kControlTypeIntY; // update change in control (LP filters control) control_type = control_type | lds::kControlTypeDeltaU;\n// set controller type controller.set_control_type(control_type);\n// Let\u0026rsquo;s say these controller gains were designed assuming g was 9 V/(mW/mm2): Vector g_design = Vector(n_u).fill(10);\n// Set params. // n.b. using arbitrary defaults for Q, R in this example. Really, these // should be set by users, as they tune characteristics of Kalman filter. // Users can also choose not to recursively calculate the estimator gain and // supply it (setKe) instead of covariances. controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_Kc_u(k_u); controller.set_g_design(g_design);\ncout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;control system:\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; controller.Print(); cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;;\n// set up variables for simulation // create Matrix to save outputs in\u0026hellip; Matrix y_ref = Matrix(n_y, n_t, arma::fill::ones) * y_ref0[0];\n// Simulated measurements Matrix z(n_y, n_t, arma::fill::zeros);\n// simulated control signal ([=] V) Matrix u(n_u, n_t, arma::fill::zeros);\n// outputs, states and gain/disturbance params // *_hat indicates online estimates Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_x, n_t, arma::fill::zeros);\n// *_true indicates ground truth (system being controlled) Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_x, n_t, arma::fill::zeros);\n// get initial val y_hat.submat(0, 0, n_y - 1, 0) = controller.sys().y(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.y();\nx_hat.submat(0, 0, n_x - 1, 0) = controller.sys().x(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.x();\nm_hat.submat(0, 0, n_x - 1, 0) = controller.sys().m(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.m();\ncout \u0026laquo; \u0026ldquo;Starting \u0026quot; \u0026laquo; n_t * dt \u0026laquo; \u0026quot; sec simulation \u0026hellip; \\n\u0026rdquo;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance Vector chance = arma::randu(1); if (which_m == 0) // low disturbance { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_high); which_m = 1; } } else { // high disturbance if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_low); which_m = 0; } } controlled_system.set_m(m0_true);\n// input Vector u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system. z.col(t) = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate // x_ref, u_ref from reference output y_ref. Therefore, it is only // applicable to regulation problems or cases where reference trajectory // changes slowly compared to system dynamics. u.col(t) = controller.ControlOutputReference(z.col(t)); // save the signals y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); }\nauto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026laquo; \u0026ldquo;Finished simulation in \u0026quot; \u0026laquo; sim_time_ms.count() \u0026laquo; \u0026quot; ms.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;(app. \u0026quot; \u0026laquo; (sim_time_ms.count() / n_t) * 1e3 \u0026laquo; \u0026quot; us/time-step)\\n\u0026rdquo;;\ncout \u0026laquo; \u0026ldquo;Saving simulation data to disk.\\n\u0026rdquo;;\n// saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue, // xTrue, mTrue saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace;\nauto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;dt\u0026rdquo;)); y_ref.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;y_ref\u0026rdquo;, replace)); u.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;u\u0026rdquo;, replace)); z.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;z\u0026rdquo;, replace)); x_true.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;x_true\u0026rdquo;, replace)); m_true.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;m_true\u0026rdquo;, replace)); y_true.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;y_true\u0026rdquo;, replace)); x_hat.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;x_hat\u0026rdquo;, replace)); m_hat.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;m_hat\u0026rdquo;, replace)); y_hat.save(arma::hdf5_name(\u0026ldquo;eg_glds_du_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;y_hat\u0026rdquo;, replace));\ncout \u0026laquo; \u0026ldquo;fin.\\n\u0026rdquo;; return 0; }\n_Filename: eg_glds_du_plds_ctrl.cpp_ ------------------------------- Updated on 5 March 2025 at 16:32:33 EST "},{"id":14,"href":"/lds-ctrl-est/docs/api/examples/eg_plds_ctrl_8cpp-example/","title":"eg_plds_ctrl.cpp","section":"Examples","content":" eg_plds_ctrl.cpp # Example PLDS Control ```cpp\n//===\u0026ndash; eg_plds_ctrl.cpp - Example PLDS Control \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===// //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===//\n#include using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout;\nauto main() -\u0026gt; int { cout \u0026laquo; \u0026quot; ********** Example Poisson LDS Control ********** \\n\\n\u0026quot;;\n// Make SISO system sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1;\n// no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(10.0 / dt);\n// Control variables: _reference/target output, controller gains // n.b., Can either use Vector (arma::Col) or std::vector Vector y_ref0 = Vector(n_y, arma::fill::ones) * 30.0 * dt; Matrix k_x = Matrix(n_u, n_x, arma::fill::zeros) + 1; // gains on state error Matrix k_inty = Matrix(n_u, n_y, arma::fill::zeros) + 10; // gains on integrated output err\n// Set control type bit mask, so controller knows what to do size_t control_type = lds::kControlTypeIntY; // integral action\n// Ground-truth parameters for the controlled system // (stand-in for physical system to be controlled) Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = 0.986; Matrix b_true(n_x, n_u, arma::fill::zeros); b_true[0] = 0.054; Vector x0_true = Vector(n_x, arma::fill::ones) * log(1 * dt);\nsize_t which_m = 0; data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi;\nVector m0_true = Vector(n_x, arma::fill::ones) * m_low; // construct ground truth system to be controlled\u0026hellip; lds::poisson::System controlled_system(n_u, n_x, n_y, dt);\n// Assign params. controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_x0(x0_true); // reset to initial conditions controlled_system.Reset();\ncout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;controlled_system:\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; controlled_system.Print(); cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;;\n// Create the controller lds::poisson::Controller controller; { // Create model used for control. lds::poisson::System controller_system(controlled_system);\n// for this example, assume model correct, except disturbance Vector m0_controller = Vector(n_x, arma::fill::ones) * m_low; Vector x0_controller = arma::log(y_ref0); controller_system.set_m(m0_controller); controller_system.set_x0(x0_controller); controller_system.Reset(); //reset to new init condition // adaptively re-estimate process disturbance (m) controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise // acting on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-5; controller_system.set_Q_m(q_m); data_t u_lb = 0.0; data_t u_ub = 5.0; controller = std::move( lds::poisson::Controller(std::move(controller_system), u_lb, u_ub)); } // set controller type controller.set_control_type(control_type);\n// set controller gains controller.set_Kc(k_x); controller.set_Kc_inty(k_inty);\n// to protect against integral windup when output is consistently above // target: data_t tau_awu(0.1); controller.set_tau_awu(tau_awu);\ncout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;controller:\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; controller.Print(); cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;;\n// create Matrix to save outputs in\u0026hellip; Matrix y_ref = Matrix(n_y, n_t, arma::fill::zeros); y_ref.each_col() += y_ref0;\n// Simulated measurements Matrix z(n_y, n_t, arma::fill::zeros);\n// simulated control signal ([=] V) Matrix u(n_u, n_t, arma::fill::zeros);\n// outputs, states and gain/disturbance params // *_hat indicates online estimates Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_y, n_t, arma::fill::zeros);\n// *_true indicates ground truth (system being controlled) Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_y, n_t, arma::fill::zeros);\n// set initial val y_hat.col(0) = controller.sys().y(); y_true.col(0) = controlled_system.y();\nx_hat.col(0) = controller.sys().x(); x_true.col(0) = controlled_system.x();\nm_hat.col(0) = controller.sys().m(); m_true.col(0) = controlled_system.m();\ncout \u0026laquo; \u0026ldquo;Starting \u0026quot; \u0026laquo; n_t * dt \u0026laquo; \u0026quot; sec simulation \u0026hellip; \\n\u0026rdquo;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance Vector chance = arma::randu(1); if (which_m == 0) // low disturbance { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_high); which_m = 1; } } else { // high disturbance if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_low); which_m = 0; } } controlled_system.set_m(m0_true);\n// e.g., use sinusoidal reference data_t f = 0.5; // freq [=] Hz Vector t_vec = Vector(n_y, arma::fill::ones) * t; y_ref.col(t) += y_ref0 % arma::sin(f * 2 * lds::kPi * dt * t_vec - lds::kPi / 4); // Simulate the true system. z.col(t)=controlled_system.Simulate(u.col(t-1)); // This method uses a steady-state solution to control problem to calculate // x_ref, u_ref from reference output y_ref. Notably, it does this in the // log-linear space (i.e., log(y)). // // Therefore, it is only applicable to regulation problems or cases where // reference trajectory changes slowly compared to system dynamics. controller.set_y_ref(y_ref.col(t)); u.col(t)=controller.ControlOutputReference(z.col(t)); y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); }\nauto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026laquo; \u0026ldquo;Finished simulation in \u0026quot; \u0026laquo; sim_time_ms.count() \u0026laquo; \u0026quot; ms.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;(app. \u0026quot; \u0026laquo; (sim_time_ms.count() / n_t) * 1e3 \u0026laquo; \u0026quot; us/time-step)\\n\u0026rdquo;;\n// saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true, // x_true, m_true saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace;\nauto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;dt\u0026rdquo;)); y_ref.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;y_ref\u0026rdquo;, replace)); u.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;u\u0026rdquo;, replace)); z.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;z\u0026rdquo;, replace)); x_true.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;x_true\u0026rdquo;, replace)); m_true.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;m_true\u0026rdquo;, replace)); y_true.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;y_true\u0026rdquo;, replace)); x_hat.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;x_hat\u0026rdquo;, replace)); m_hat.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;m_hat\u0026rdquo;, replace)); y_hat.save(arma::hdf5_name(\u0026ldquo;eg_plds_ctrl.h5\u0026rdquo;, \u0026ldquo;y_hat\u0026rdquo;, replace));\nreturn 0; }\n_Filename: eg_plds_ctrl.cpp_ ------------------------------- Updated on 5 March 2025 at 16:32:33 EST "},{"id":15,"href":"/lds-ctrl-est/docs/api/examples/eg_plds_est_8cpp-example/","title":"eg_plds_est.cpp","section":"Examples","content":" eg_plds_est.cpp # Example PLDS Estimation ```cpp\n//===\u0026ndash; eg_plds_est.cpp - Example PLDS Estimation \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===// //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===//\n#include using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout;\n// for generating random input Matrix random_walk(size_t n_t, const Matrix\u0026amp; Q, const Vector\u0026amp; x0);\nint main() { cout \u0026laquo; \u0026quot; ********** Example Poisson LDS Estimation ********** \\n\\n\u0026quot;;\n// Make SISO system sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; // no. inputs size_t n_x = 1; // no. states size_t n_y = 1; // no. outputs auto n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation.\n// construct ground truth system\u0026hellip; lds::poisson::System system_true(n_u, n_x, n_y, dt);\n// Model parameters Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); Matrix b_true = Matrix(n_x, n_u).fill(1e-2); Vector m0_true = Vector(n_x, arma::fill::zeros).fill(-7e-2); // disturbance Vector x0_true = m0_true * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state\n// Assign params. system_true.set_A(a_true); system_true.set_B(b_true); system_true.set_x0(x0_true); system_true.set_m(m0_true); system_true.Reset();\n// Construct system for estimation // e.g., will create a model with incorrect disturbance lds::poisson::System system_estimator(n_u, n_x, n_y, dt);\n// Can copy parameters from another system object system_estimator = system_true;\n// wrong disturbance Vector m0_est = m0_true * 2; system_estimator.set_m(m0_est);\n// set new initial conditions Vector x0_est = m0_est * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state system_estimator.set_x0(x0_est); system_estimator.Reset(); // reset to initial condition.\n// turn on adaptive disturbance estimation system_estimator.do_adapt_m = true;\n// set adaptation rate by changing covariance of assumed process noise acting // on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.set_Q_m(q_m);\ncout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;estimator:\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; system_estimator.Print(); cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;;\n// Set up simulation : // Simulated measurements Matrix z(n_y, n_t, arma::fill::zeros);\n// Stimulus (generate random stimulus) Matrix q_u = Matrix(n_u, n_u, arma::fill::eye) * 1e-3; // cov of random walk Matrix u = random_walk(n_t, q_u, Vector(n_u, arma::fill::zeros));\n// create matrix to save outputs in\u0026hellip; Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix y_true(n_y, n_t, arma::fill::zeros);\n// states and disturbance params Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_x, n_t, arma::fill::zeros);\nMatrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_x, n_t, arma::fill::zeros);\n// initial conditions y_hat.col(0) = system_estimator.y(); y_true.col(0) = system_true.y(); x_hat.col(0) = system_estimator.x(); x_true.col(0) = system_true.x(); m_hat.col(0) = system_estimator.m(); m_true.col(0) = system_true.m();\ncout \u0026laquo; \u0026ldquo;Starting \u0026quot; \u0026laquo; n_t * dt \u0026laquo; \u0026quot; sec simlation \u0026hellip; \\n\u0026rdquo;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Simlate the true system. z.col(t) = system_true.Simulate(u.col(t - 1));\n// Filter (predict -\u0026gt; update) system_estimator.Filter(u.col(t - 1), z.col(t)); // save signals y_hat.col(t) = system_estimator.y(); y_true.col(t) = system_true.y(); x_true.col(t) = system_true.x(); m_true.col(t) = system_true.m(); x_hat.col(t) = system_estimator.x(); m_hat.col(t) = system_estimator.m(); }\nauto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026laquo; \u0026ldquo;Finished simlation in \u0026quot; \u0026laquo; sim_time_ms.count() \u0026laquo; \u0026quot; ms.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;(app. \u0026quot; \u0026laquo; (sim_time_ms.count() / n_t) * 1e3 \u0026laquo; \u0026quot; us/time-step)\\n\u0026rdquo;;\n// saved variables: dt, y_hat, x_hat, m_hat, z, u, y_true, // x_true, m_true saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace;\nauto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026ldquo;eg_plds_est.h5\u0026rdquo;, \u0026ldquo;dt\u0026rdquo;)); u.save(arma::hdf5_name(\u0026ldquo;eg_plds_est.h5\u0026rdquo;, \u0026ldquo;u\u0026rdquo;, replace)); z.save(arma::hdf5_name(\u0026ldquo;eg_plds_est.h5\u0026rdquo;, \u0026ldquo;z\u0026rdquo;, replace)); x_true.save(arma::hdf5_name(\u0026ldquo;eg_plds_est.h5\u0026rdquo;, \u0026ldquo;x_true\u0026rdquo;, replace)); m_true.save(arma::hdf5_name(\u0026ldquo;eg_plds_est.h5\u0026rdquo;, \u0026ldquo;m_true\u0026rdquo;, replace)); y_true.save(arma::hdf5_name(\u0026ldquo;eg_plds_est.h5\u0026rdquo;, \u0026ldquo;y_true\u0026rdquo;, replace)); x_hat.save(arma::hdf5_name(\u0026ldquo;eg_plds_est.h5\u0026rdquo;, \u0026ldquo;x_hat\u0026rdquo;, replace)); m_hat.save(arma::hdf5_name(\u0026ldquo;eg_plds_est.h5\u0026rdquo;, \u0026ldquo;m_hat\u0026rdquo;, replace)); y_hat.save(arma::hdf5_name(\u0026ldquo;eg_plds_est.h5\u0026rdquo;, \u0026ldquo;y_hat\u0026rdquo;, replace));\nreturn 0; }\n// for generating random input Matrix random_walk(size_t n_t, const Matrix\u0026amp; Q, const Vector\u0026amp; x0) { size_t n = Q.n_rows;\nif ((n != Q.n_cols) || (Q.n_cols != Q.n_rows)) { throw std::logic_error(\u0026ldquo;Q must be n x n.\u0026rdquo;); }\nMatrix x(n, n_t, arma::fill::zeros); x.col(0) = x0; for (size_t t = 1; t \u0026lt; n_t; t++) { x.col(t) = x.col(t - 1) + arma::mvnrnd(Vector(n, arma::fill::zeros), Q); }\nreturn x; }\n_Filename: eg_plds_est.cpp_ ------------------------------- Updated on 5 March 2025 at 16:32:33 EST "},{"id":16,"href":"/lds-ctrl-est/docs/api/examples/eg_plds_switched_ctrl_8cpp-example/","title":"eg_plds_switched_ctrl.cpp","section":"Examples","content":" eg_plds_switched_ctrl.cpp # Example Switched PLDS Control ```cpp\n//===\u0026ndash; eg_plds_switched_ctrl.cpp - Example Switched PLDS Control \u0026mdash;===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===// //===\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-===//\n#include using lds::data_t; using lds::Matrix; using lds::Vector; using std::cout;\nauto main() -\u0026gt; int { cout \u0026laquo; \u0026quot; ********** Example Switched Poisson LDS Control ********** \\n\\n\u0026quot;;\n// whether to do switched control bool do_switch_ctrl = true;\n// Make SISO system sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1;\n// no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt);\n// for simulating switching size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2 data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1\n// simulated system being controlled lds::poisson::System controlled_system(n_u, n_x, n_y, dt);\n// Assume the system is not well characterized by one LDS, but is well // characterized by two LDS models with different input matrices. data_t scale_sys_b = 2;\nMatrix a(n_x, n_x, arma::fill::eye); a[0] = 0.985; Matrix b1 = Matrix(n_x, n_u).fill(0.05); Vector d = Vector(n_y, arma::fill::zeros).fill(log(1 * dt));\ncontrolled_system.set_A(a); controlled_system.set_B(b1); controlled_system.set_d(d); controlled_system.Reset(); // reset to initial conditions\n// reference Vector y_ref0 = Vector(n_y, arma::fill::zeros).fill(25.0 * dt);\n// Let underlying system 1 be more sensitive than system 2 Matrix b2 = Matrix(n_x, n_u).fill(b1[0] / scale_sys_b);\n// create switched controller lds::poisson::SwitchedController switched_controller; lds::UniformMatrixList\u0026lt;\u0026gt; k_x; // feedback controller gains { // create switched controller sub-systems // system 1 lds::poisson::System sys1(controlled_system);\n// set process noise covariance Matrix q_controller = Matrix(n_x, n_x, arma::fill::eye) * 5e-3; sys1.set_Q(q_controller); // adaptively estimate process disturbance (m) // n.b. using arbitrary default value for process noise if enabled. sys1.do_adapt_m = true; // setting initial mode to target to avoid large error at onset: Vector x0_controller = arma::log(y_ref0) - d; sys1.set_x0(x0_controller); sys1.Reset(); // reset to initial conditions cout \u0026lt;\u0026lt; \u0026quot;.....................................\\n\u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;sys1:\\n\u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;.....................................\\n\u0026quot;; sys1.Print(); cout \u0026lt;\u0026lt; \u0026quot;.....................................\\n\u0026quot;; // system 2 lds::poisson::System sys2 = sys1; // set parameters sys2.set_B(b2); cout \u0026lt;\u0026lt; \u0026quot;.....................................\\n\u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;sys2:\\n\u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;.....................................\\n\u0026quot;; sys2.Print(); cout \u0026lt;\u0026lt; \u0026quot;.....................................\\n\u0026quot;; lds::UniformSystemList\u0026lt;lds::poisson::System\u0026gt; systems({sys1, sys2}); // controller gains for underlying system s: Matrix k_x1(n_u, n_x, arma::fill::ones); Matrix k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive. k_x = lds::UniformMatrixList\u0026lt;\u0026gt;({k_x1, k_x2}); data_t u_lb = 0.0; data_t u_ub = 5.0; switched_controller = std::move( lds::poisson::SwitchedController(std::move(systems), u_lb, u_ub)); } // Control variables size_t control_type = 0; // no integral action, etc switched_controller.set_control_type(control_type); switched_controller.set_Kc(std::move(k_x));\nswitched_controller.set_y_ref(y_ref0);\nstd::vectorlds::poisson::System systems_vec(3, lds::poisson::System()); lds::UniformSystemListlds::poisson::System systems(std::move(systems_vec));\ncout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;switched_controller:\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;; switched_controller.Print(); cout \u0026laquo; \u0026ldquo;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;.\\n\u0026rdquo;;\n// Fake measurements Matrix z(n_y, n_t, arma::fill::zeros);\n// Will later contain control. Matrix u(n_u, n_t, arma::fill::zeros);\n// create Matrix to save outputs in\u0026hellip; Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix y_ref = Matrix(n_y, n_t).fill(y_ref0[0]);\n// modes and gain/disturbance params Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix mode(1, n_t, arma::fill::ones);\n// set initial val y_hat.col(0) = switched_controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = switched_controller.sys().x(); x_true.col(0) = controlled_system.x();\ncout \u0026laquo; \u0026ldquo;Starting \u0026quot; \u0026laquo; n_t * dt \u0026laquo; \u0026quot; sec simulation \u0026hellip; \\n\u0026rdquo;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Let the controlled system stochastically change gain // Assume another algorithm decodes this mode change and signals the // switched_controller Vector chance(1, arma::fill::randu); if (which_mode == 1) // mode1 { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.set_B(b2); if (do_switch_ctrl) { switched_controller.Switch(1); } } } else { // mode2 if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.set_B(b1); if (do_switch_ctrl) { switched_controller.Switch(0); } } }\n// Simulate the true system. z.col(t) = controlled_system.Simulate(u.col(t - 1)); // perform control u.col(t) = switched_controller.ControlOutputReference(z.col(t)); mode.col(t) = which_mode; y_ref.col(t) = y_ref0; y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); y_hat.col(t) = switched_controller.sys().y(); x_hat.col(t) = switched_controller.sys().x(); }\nauto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026laquo; \u0026ldquo;Finished simulation in \u0026quot; \u0026laquo; sim_time_ms.count() \u0026laquo; \u0026quot; ms.\\n\u0026rdquo;; cout \u0026laquo; \u0026ldquo;(app. \u0026quot; \u0026laquo; (sim_time_ms.count() / n_t) * 1e3 \u0026laquo; \u0026quot; us/time-step)\\n\u0026rdquo;;\n// saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true, // x_true, m_true saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace;\nauto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026ldquo;eg_plds_switched_ctrl.h5\u0026rdquo;, \u0026ldquo;dt\u0026rdquo;)); y_ref.save(arma::hdf5_name(\u0026ldquo;eg_plds_switched_ctrl.h5\u0026rdquo;, \u0026ldquo;y_ref\u0026rdquo;, replace)); u.save(arma::hdf5_name(\u0026ldquo;eg_plds_switched_ctrl.h5\u0026rdquo;, \u0026ldquo;u\u0026rdquo;, replace)); z.save(arma::hdf5_name(\u0026ldquo;eg_plds_switched_ctrl.h5\u0026rdquo;, \u0026ldquo;z\u0026rdquo;, replace)); x_true.save(arma::hdf5_name(\u0026ldquo;eg_plds_switched_ctrl.h5\u0026rdquo;, \u0026ldquo;x_true\u0026rdquo;, replace)); y_true.save(arma::hdf5_name(\u0026ldquo;eg_plds_switched_ctrl.h5\u0026rdquo;, \u0026ldquo;y_true\u0026rdquo;, replace)); x_hat.save(arma::hdf5_name(\u0026ldquo;eg_plds_switched_ctrl.h5\u0026rdquo;, \u0026ldquo;x_hat\u0026rdquo;, replace)); y_hat.save(arma::hdf5_name(\u0026ldquo;eg_plds_switched_ctrl.h5\u0026rdquo;, \u0026ldquo;y_hat\u0026rdquo;, replace)); mode.save(arma::hdf5_name(\u0026ldquo;eg_plds_switched_ctrl.h5\u0026rdquo;, \u0026ldquo;mode\u0026rdquo;, replace));\nreturn 0; }\n_Filename: eg_plds_switched_ctrl.cpp_ ------------------------------- Updated on 5 March 2025 at 16:32:33 EST "},{"id":17,"href":"/lds-ctrl-est/docs/api/files/dir_d28a4824dc47e487b107a5db32ef43c4/","title":"examples","section":"Files","content":" examples # Files # Name examples/eg_glds_ctrl.cpp examples/eg_glds_du_plds_ctrl.cpp examples/eg_plds_ctrl.cpp examples/eg_plds_est.cpp examples/eg_plds_switched_ctrl.cpp Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":18,"href":"/lds-ctrl-est/docs/api/examples/","title":"Examples","section":"LDS C+E Documentation","content":" Examples # eg_glds_ctrl.cpp Example GLDS Control.\neg_glds_du_plds_ctrl.cpp Example GLDS Control of PLDS where change in control (du) is being updated, rather than amplitude (u).\neg_plds_ctrl.cpp Example PLDS Control.\neg_plds_est.cpp Example PLDS Estimation.\neg_plds_switched_ctrl.cpp Example Switched PLDS Control.\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":19,"href":"/lds-ctrl-est/docs/api/files/eg__glds__ctrl_8cpp/","title":"examples/eg_glds_ctrl.cpp","section":"Files","content":" examples/eg_glds_ctrl.cpp # Types # Name using arma::Mat\u0026lt; data_t \u0026gt; Matrix using arma::Col\u0026lt; data_t \u0026gt; Vector using double data_t Functions # Name int main() Type Details # Matrix # using lds::Matrix = arma::Mat\u0026lt;data_t\u0026gt;; Vector # using lds::Vector = arma::Col\u0026lt;data_t\u0026gt;; data_t # using lds::data_t = double; Type of all data in library. If need 32b, change double to float. This could be potentially useful for large scale problems where there are memory constraints.\nFunction Details # main # int main() Going to simulate a switching disturbance (m) acting on system\nSource code # //===-- eg_glds_ctrl.cpp - Example GLDS Control ---------------------------===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS Control ********** \\n\\n\u0026#34;; // Make 1st-order SISO system, sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); // construct ground truth system to be controlled... // initializes to random walk model with top-most n_y state observed lds::gaussian::System controlled_system(n_u, n_x, n_y, dt); // Ground-truth parameters for the controlled system // (stand-in for physical system to be controlled) Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); Matrix b_true = Matrix(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2: Vector g_true = Vector(n_y).fill(10.0); // output noise covariance Matrix r_true = Matrix(n_y, n_y, arma::fill::eye) * 1e-4; size_t which_m = 0; // whether low or high disturbance (0, 1) data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb. data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low Vector m0_true = Vector(n_x).fill(m_low); // Assign params. controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_R(r_true); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // make a controller lds::gaussian::Controller controller; { // Create **incorrect** model used for control. // (e.g., imperfect model fitting) Matrix b_controller = b_true / 2; // let\u0026#39;s assume zero process disturbance initially // (will be re-estimating) Vector m_controller = Vector(n_x, arma::fill::zeros); // for this demo, just use arbitrary default R Matrix r_controller = Matrix(n_y, n_y, arma::fill::eye) * lds::kDefaultR0; lds::gaussian::System controller_system(controlled_system); controller_system.set_B(b_controller); controller_system.set_m(m_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m // going to adaptively re-estimate the disturbance controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise // acting on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; controller_system.set_Q_m(q_m); // create controller // lower and upper bounds on control signal (e.g., in Volts) data_t u_lb = 0.0; // [=] V data_t u_ub = 5.0; // [=] V controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); } // Control variables: // if following enabled, adapts set point with re-estimated process // disturbance n.b., should not need integral action if this is enabled as the // adaptive estimator minimizes DC error bool do_adaptive_set_point = false; // Reference/target output, controller gains Vector y_ref0 = Vector(n_y).fill(20.0 * dt); Matrix k_x = Matrix(n_u, n_x).fill(100); // gains on state error Matrix k_inty = Matrix(n_u, n_y).fill(1e3); // gains on integrated err // setting initial state to target to avoid error at onset: Vector x0 = Vector(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance control_type = control_type | lds::kControlTypeAdaptM; } else { // use integral action to minimize DC error control_type = control_type | lds::kControlTypeIntY; } // set controller type controller.set_control_type(control_type); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2): Vector g_design = Vector(n_u).fill(9); // Set params. // **n.b. using arbitrary defaults for Q, R in this example. Really, these // should be set by users, as they tune characteristics of Kalman filter. // Users can also choose not to recursively calculate the estimator gain and // supply it (setKe) instead of covariances.** controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_g_design(g_design); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // set up variables for simulation // create Matrix to save outputs in... Matrix y_ref = Matrix(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements Matrix z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V) Matrix u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params // *_hat indicates online estimates Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_x, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled) Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_x, n_t, arma::fill::zeros); // set initial val y_hat.submat(0, 0, n_y - 1, 0) = controller.sys().y(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.y(); x_hat.submat(0, 0, n_x - 1, 0) = controller.sys().x(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.x(); m_hat.submat(0, 0, n_x - 1, 0) = controller.sys().m(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance Vector chance = arma::randu\u0026lt;Vector\u0026gt;(1); if (which_m == 0) // low disturbance { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_high); which_m = 1; } } else { // high disturbance if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // input Vector u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system. z.col(t) = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate // x_ref, u_ref from reference output y_ref. Therefore, it is only // applicable to regulation problems or cases where reference trajectory // changes slowly compared to system dynamics. u.col(t) = controller.ControlOutputReference(z.col(t)); // save the signals y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue, // xTrue, mTrue saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; } Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":20,"href":"/lds-ctrl-est/docs/api/files/eg__glds__du__plds__ctrl_8cpp/","title":"examples/eg_glds_du_plds_ctrl.cpp","section":"Files","content":" examples/eg_glds_du_plds_ctrl.cpp # Types # Name using double data_t using arma::Mat\u0026lt; data_t \u0026gt; Matrix using arma::Col\u0026lt; data_t \u0026gt; Vector Functions # Name int main() Type Details # data_t # using lds::data_t = double; Type of all data in library. If need 32b, change double to float. This could be potentially useful for large scale problems where there are memory constraints.\nMatrix # using lds::Matrix = arma::Mat\u0026lt;data_t\u0026gt;; Vector # using lds::Vector = arma::Col\u0026lt;data_t\u0026gt;; Function Details # main # int main() Going to simulate a switching disturbance (m) acting on system\nSource code # //===-- eg_glds_du_plds_ctrl.cpp - Example GLDS Delta u Control of PLDS ---===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst\u0026gt; using lds::data_t; using lds::Matrix; using lds::Vector; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS du Control of PLDS ********** \\n\\n\u0026#34;; // Make 1st-order SISO system, sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); // construct ground truth system to be controlled... // initializes to random walk model with top-most n_y state observed lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // Ground-truth parameters for the controlled system // (stand-in for physical system to be controlled) Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); Matrix b_true = Matrix(n_x, n_u).fill(2.5e-2); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2: Vector g_true = Vector(n_y).fill(10.0); size_t which_m = 0; // whether low or high disturbance (0, 1) data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 0; // 1e-3; // probability of going from low to high disturb. data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low Vector m0_true = Vector(n_x).fill(m_low); Vector x0_true = Vector(n_x, arma::fill::ones) * log(1 * dt); // Assign params. controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_x0(x0_true); controlled_system.Reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // make a controller lds::gaussian::Controller controller; { // Create **incorrect** model used for control. // (e.g., imperfect model fitting) Matrix b_controller = b_true / 50; // let\u0026#39;s assume zero process disturbance initially // (will be re-estimating) Vector m_controller = Vector(n_x, arma::fill::zeros); // process noise covariance Matrix q_controller = Matrix(n_y, n_y, arma::fill::eye) * 1e-8; // output noise covariance Matrix r_controller = Matrix(n_y, n_y, arma::fill::eye) * 1e-2; lds::gaussian::System controller_system(n_u, n_x, n_y, dt); controller_system.set_A(a_true); controller_system.set_B(b_controller); controller_system.set_g(g_true); controller_system.set_m(m_controller); controller_system.set_Q(q_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m // going to adaptively re-estimate the disturbance controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise // acting on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-8; controller_system.set_Q_m(q_m); // create controller // lower and upper bounds on control signal (e.g., in Volts) data_t u_lb = 0.0; // [=] V data_t u_ub = 5.0; // [=] V controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); } // Control variables: // Reference/target output, controller gains Vector y_ref0 = Vector(n_y).fill(20.0 * dt); // to design for this example, augmented state with control and made the input // du; cost on output q_y = 1, on integral output = 1e2, on u = 0, on du = // 1e-2. Matrix k_x = Matrix(n_u, n_x).fill(2.44); // gains on state error Matrix k_inty = Matrix(n_u, n_y).fill(97.4); // gains on integrated err Matrix k_u = Matrix(n_u, n_u).fill(5.23e-2); // gains on input amp // set up controller type bit mask so controller knows how to proceed size_t control_type = 0; // use integral action to minimize DC error control_type = control_type | lds::kControlTypeIntY; // update change in control (LP filters control) control_type = control_type | lds::kControlTypeDeltaU; // set controller type controller.set_control_type(control_type); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2): Vector g_design = Vector(n_u).fill(10); // Set params. // **n.b. using arbitrary defaults for Q, R in this example. Really, these // should be set by users, as they tune characteristics of Kalman filter. // Users can also choose not to recursively calculate the estimator gain and // supply it (setKe) instead of covariances.** controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_Kc_u(k_u); controller.set_g_design(g_design); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // set up variables for simulation // create Matrix to save outputs in... Matrix y_ref = Matrix(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements Matrix z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V) Matrix u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params // *_hat indicates online estimates Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_x, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled) Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_x, n_t, arma::fill::zeros); // get initial val y_hat.submat(0, 0, n_y - 1, 0) = controller.sys().y(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.y(); x_hat.submat(0, 0, n_x - 1, 0) = controller.sys().x(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.x(); m_hat.submat(0, 0, n_x - 1, 0) = controller.sys().m(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance Vector chance = arma::randu\u0026lt;Vector\u0026gt;(1); if (which_m == 0) // low disturbance { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_high); which_m = 1; } } else { // high disturbance if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // input Vector u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system. z.col(t) = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate // x_ref, u_ref from reference output y_ref. Therefore, it is only // applicable to regulation problems or cases where reference trajectory // changes slowly compared to system dynamics. u.col(t) = controller.ControlOutputReference(z.col(t)); // save the signals y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue, // xTrue, mTrue saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_glds_du_plds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; } Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":21,"href":"/lds-ctrl-est/docs/api/files/eg__plds__ctrl_8cpp/","title":"examples/eg_plds_ctrl.cpp","section":"Files","content":" examples/eg_plds_ctrl.cpp # Types # Name using arma::Mat\u0026lt; data_t \u0026gt; Matrix using arma::Col\u0026lt; data_t \u0026gt; Vector using double data_t Functions # Name int main() Type Details # Matrix # using lds::Matrix = arma::Mat\u0026lt;data_t\u0026gt;; Vector # using lds::Vector = arma::Col\u0026lt;data_t\u0026gt;; data_t # using lds::data_t = double; Type of all data in library. If need 32b, change double to float. This could be potentially useful for large scale problems where there are memory constraints.\nFunction Details # main # int main() Going to simulate a switching disturbance (m) acting on system\nSource code # //===-- eg_plds_ctrl.cpp - Example PLDS Control ---------------------===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Control ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(10.0 / dt); // Control variables: _reference/target output, controller gains // n.b., Can either use Vector (arma::Col) or std::vector Vector y_ref0 = Vector(n_y, arma::fill::ones) * 30.0 * dt; Matrix k_x = Matrix(n_u, n_x, arma::fill::zeros) + 1; // gains on state error Matrix k_inty = Matrix(n_u, n_y, arma::fill::zeros) + 10; // gains on integrated output err // Set control type bit mask, so controller knows what to do size_t control_type = lds::kControlTypeIntY; // integral action // Ground-truth parameters for the controlled system // (stand-in for physical system to be controlled) Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = 0.986; Matrix b_true(n_x, n_u, arma::fill::zeros); b_true[0] = 0.054; Vector x0_true = Vector(n_x, arma::fill::ones) * log(1 * dt); size_t which_m = 0; data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; Vector m0_true = Vector(n_x, arma::fill::ones) * m_low; // construct ground truth system to be controlled... lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // Assign params. controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_x0(x0_true); // reset to initial conditions controlled_system.Reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create the controller lds::poisson::Controller controller; { // Create model used for control. lds::poisson::System controller_system(controlled_system); // for this example, assume model correct, except disturbance Vector m0_controller = Vector(n_x, arma::fill::ones) * m_low; Vector x0_controller = arma::log(y_ref0); controller_system.set_m(m0_controller); controller_system.set_x0(x0_controller); controller_system.Reset(); //reset to new init condition // adaptively re-estimate process disturbance (m) controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise // acting on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-5; controller_system.set_Q_m(q_m); data_t u_lb = 0.0; data_t u_ub = 5.0; controller = std::move( lds::poisson::Controller(std::move(controller_system), u_lb, u_ub)); } // set controller type controller.set_control_type(control_type); // set controller gains controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); // to protect against integral windup when output is consistently above // target: data_t tau_awu(0.1); controller.set_tau_awu(tau_awu); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create Matrix to save outputs in... Matrix y_ref = Matrix(n_y, n_t, arma::fill::zeros); y_ref.each_col() += y_ref0; // Simulated measurements Matrix z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V) Matrix u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params // *_hat indicates online estimates Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled) Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_y, n_t, arma::fill::zeros); // set initial val y_hat.col(0) = controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = controller.sys().x(); x_true.col(0) = controlled_system.x(); m_hat.col(0) = controller.sys().m(); m_true.col(0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance Vector chance = arma::randu\u0026lt;Vector\u0026gt;(1); if (which_m == 0) // low disturbance { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_high); which_m = 1; } } else { // high disturbance if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance m0_true = std::vector\u0026lt;data_t\u0026gt;(n_x, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // e.g., use sinusoidal reference data_t f = 0.5; // freq [=] Hz Vector t_vec = Vector(n_y, arma::fill::ones) * t; y_ref.col(t) += y_ref0 % arma::sin(f * 2 * lds::kPi * dt * t_vec - lds::kPi / 4); // Simulate the true system. z.col(t)=controlled_system.Simulate(u.col(t-1)); // This method uses a steady-state solution to control problem to calculate // x_ref, u_ref from reference output y_ref. Notably, it does this in the // log-linear space (i.e., log(y)). // // Therefore, it is only applicable to regulation problems or cases where // reference trajectory changes slowly compared to system dynamics. controller.set_y_ref(y_ref.col(t)); u.col(t)=controller.ControlOutputReference(z.col(t)); y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true, // x_true, m_true saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":22,"href":"/lds-ctrl-est/docs/api/files/eg__plds__est_8cpp/","title":"examples/eg_plds_est.cpp","section":"Files","content":" examples/eg_plds_est.cpp # Types # Name using arma::Mat\u0026lt; data_t \u0026gt; Matrix using arma::Col\u0026lt; data_t \u0026gt; Vector using double data_t Functions # Name Matrix random_walk(size_t n_t, const Matrix \u0026amp; Q, const Vector \u0026amp; x0) int main() Type Details # Matrix # using lds::Matrix = arma::Mat\u0026lt;data_t\u0026gt;; Vector # using lds::Vector = arma::Col\u0026lt;data_t\u0026gt;; data_t # using lds::data_t = double; Type of all data in library. If need 32b, change double to float. This could be potentially useful for large scale problems where there are memory constraints.\nFunction Details # random_walk # Matrix random_walk( size_t n_t, const Matrix \u0026amp; Q, const Vector \u0026amp; x0 ) main # int main() Source code # //===-- eg_plds_est.cpp - Example PLDS Estimation -------------------------===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; // for generating random input Matrix random_walk(size_t n_t, const Matrix\u0026amp; Q, const Vector\u0026amp; x0); int main() { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Estimation ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; // no. inputs size_t n_x = 1; // no. states size_t n_y = 1; // no. outputs auto n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation. // construct ground truth system... lds::poisson::System system_true(n_u, n_x, n_y, dt); // Model parameters Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); Matrix b_true = Matrix(n_x, n_u).fill(1e-2); Vector m0_true = Vector(n_x, arma::fill::zeros).fill(-7e-2); // disturbance Vector x0_true = m0_true * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state // Assign params. system_true.set_A(a_true); system_true.set_B(b_true); system_true.set_x0(x0_true); system_true.set_m(m0_true); system_true.Reset(); // Construct system for estimation // e.g., will create a model with incorrect disturbance lds::poisson::System system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object system_estimator = system_true; // wrong disturbance Vector m0_est = m0_true * 2; system_estimator.set_m(m0_est); // set new initial conditions Vector x0_est = m0_est * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state system_estimator.set_x0(x0_est); system_estimator.Reset(); // reset to initial condition. // turn on adaptive disturbance estimation system_estimator.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise acting // on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.set_Q_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;estimator:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; system_estimator.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Set up simulation : // Simulated measurements Matrix z(n_y, n_t, arma::fill::zeros); // Stimulus (generate random stimulus) Matrix q_u = Matrix(n_u, n_u, arma::fill::eye) * 1e-3; // cov of random walk Matrix u = random_walk(n_t, q_u, Vector(n_u, arma::fill::zeros)); // create matrix to save outputs in... Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix y_true(n_y, n_t, arma::fill::zeros); // states and disturbance params Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_x, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_x, n_t, arma::fill::zeros); // initial conditions y_hat.col(0) = system_estimator.y(); y_true.col(0) = system_true.y(); x_hat.col(0) = system_estimator.x(); x_true.col(0) = system_true.x(); m_hat.col(0) = system_estimator.m(); m_true.col(0) = system_true.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simlation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Simlate the true system. z.col(t) = system_true.Simulate(u.col(t - 1)); // Filter (predict -\u0026gt; update) system_estimator.Filter(u.col(t - 1), z.col(t)); // save signals y_hat.col(t) = system_estimator.y(); y_true.col(t) = system_true.y(); x_true.col(t) = system_true.x(); m_true.col(t) = system_true.m(); x_hat.col(t) = system_estimator.x(); m_hat.col(t) = system_estimator.m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simlation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_true, // x_true, m_true saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;dt\u0026#34;)); u.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } // for generating random input Matrix random_walk(size_t n_t, const Matrix\u0026amp; Q, const Vector\u0026amp; x0) { size_t n = Q.n_rows; if ((n != Q.n_cols) || (Q.n_cols != Q.n_rows)) { throw std::logic_error(\u0026#34;Q must be `n` x `n`.\u0026#34;); } Matrix x(n, n_t, arma::fill::zeros); x.col(0) = x0; for (size_t t = 1; t \u0026lt; n_t; t++) { x.col(t) = x.col(t - 1) + arma::mvnrnd(Vector(n, arma::fill::zeros), Q); } return x; } Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":23,"href":"/lds-ctrl-est/docs/api/files/eg__plds__switched__ctrl_8cpp/","title":"examples/eg_plds_switched_ctrl.cpp","section":"Files","content":" examples/eg_plds_switched_ctrl.cpp # Types # Name using double data_t using arma::Mat\u0026lt; data_t \u0026gt; Matrix using arma::Col\u0026lt; data_t \u0026gt; Vector Functions # Name int main() Type Details # data_t # using lds::data_t = double; Type of all data in library. If need 32b, change double to float. This could be potentially useful for large scale problems where there are memory constraints.\nMatrix # using lds::Matrix = arma::Mat\u0026lt;data_t\u0026gt;; Vector # using lds::Vector = arma::Col\u0026lt;data_t\u0026gt;; Function Details # main # int main() Source code # //===-- eg_plds_switched_ctrl.cpp - Example Switched PLDS Control ---===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst\u0026gt; using lds::data_t; using lds::Matrix; using lds::Vector; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Switched Poisson LDS Control ********** \\n\\n\u0026#34;; // whether to do switched control bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); // for simulating switching size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2 data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1 // simulated system being controlled lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well // characterized by two LDS models with different input matrices.** data_t scale_sys_b = 2; Matrix a(n_x, n_x, arma::fill::eye); a[0] = 0.985; Matrix b1 = Matrix(n_x, n_u).fill(0.05); Vector d = Vector(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.set_A(a); controlled_system.set_B(b1); controlled_system.set_d(d); controlled_system.Reset(); // reset to initial conditions // reference Vector y_ref0 = Vector(n_y, arma::fill::zeros).fill(25.0 * dt); // Let underlying system 1 be more sensitive than system 2 Matrix b2 = Matrix(n_x, n_u).fill(b1[0] / scale_sys_b); // create switched controller lds::poisson::SwitchedController switched_controller; lds::UniformMatrixList\u0026lt;\u0026gt; k_x; // feedback controller gains { // create switched controller sub-systems // system 1 lds::poisson::System sys1(controlled_system); // set process noise covariance Matrix q_controller = Matrix(n_x, n_x, arma::fill::eye) * 5e-3; sys1.set_Q(q_controller); // adaptively estimate process disturbance (m) // n.b. using arbitrary default value for process noise if enabled. sys1.do_adapt_m = true; // setting initial mode to target to avoid large error at onset: Vector x0_controller = arma::log(y_ref0) - d; sys1.set_x0(x0_controller); sys1.Reset(); // reset to initial conditions cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys1.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // system 2 lds::poisson::System sys2 = sys1; // set parameters sys2.set_B(b2); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys2.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; lds::UniformSystemList\u0026lt;lds::poisson::System\u0026gt; systems({sys1, sys2}); // controller gains for underlying system s: Matrix k_x1(n_u, n_x, arma::fill::ones); Matrix k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive. k_x = lds::UniformMatrixList\u0026lt;\u0026gt;({k_x1, k_x2}); data_t u_lb = 0.0; data_t u_ub = 5.0; switched_controller = std::move( lds::poisson::SwitchedController(std::move(systems), u_lb, u_ub)); } // Control variables size_t control_type = 0; // no integral action, etc switched_controller.set_control_type(control_type); switched_controller.set_Kc(std::move(k_x)); switched_controller.set_y_ref(y_ref0); std::vector\u0026lt;lds::poisson::System\u0026gt; systems_vec(3, lds::poisson::System()); lds::UniformSystemList\u0026lt;lds::poisson::System\u0026gt; systems(std::move(systems_vec)); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;switched_controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; switched_controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Fake measurements Matrix z(n_y, n_t, arma::fill::zeros); // Will later contain control. Matrix u(n_u, n_t, arma::fill::zeros); // create Matrix to save outputs in... Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix y_ref = Matrix(n_y, n_t).fill(y_ref0[0]); // modes and gain/disturbance params Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix mode(1, n_t, arma::fill::ones); // set initial val y_hat.col(0) = switched_controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = switched_controller.sys().x(); x_true.col(0) = controlled_system.x(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Let the controlled system stochastically change gain // Assume another algorithm decodes this mode change and signals the // switched_controller Vector chance(1, arma::fill::randu); if (which_mode == 1) // mode1 { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.set_B(b2); if (do_switch_ctrl) { switched_controller.Switch(1); } } } else { // mode2 if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.set_B(b1); if (do_switch_ctrl) { switched_controller.Switch(0); } } } // Simulate the true system. z.col(t) = controlled_system.Simulate(u.col(t - 1)); // perform control u.col(t) = switched_controller.ControlOutputReference(z.col(t)); mode.col(t) = which_mode; y_ref.col(t) = y_ref0; y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); y_hat.col(t) = switched_controller.sys().y(); x_hat.col(t) = switched_controller.sys().x(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true, // x_true, m_true saving with hdf5 via armadillo arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); mode.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;mode\u0026#34;, replace)); return 0; } Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":24,"href":"/lds-ctrl-est/docs/api/files/","title":"Files","section":"LDS C+E Documentation","content":" Files # examples/eg_glds_ctrl.cpp\nexamples/eg_glds_du_plds_ctrl.cpp\nexamples/eg_plds_ctrl.cpp\nexamples/eg_plds_est.cpp\nexamples/eg_plds_switched_ctrl.cpp\nldsCtrlEst_h/lds.h lds namespace\nldsCtrlEst_h/lds_ctrl.h Controller.\nldsCtrlEst_h/lds_fit.h LDS base fit type.\nldsCtrlEst_h/lds_fit_em.h subspace identification\nldsCtrlEst_h/lds_fit_ssid.h subspace identification\nldsCtrlEst_h/lds_gaussian.h glds namespace\nldsCtrlEst_h/lds_gaussian_ctrl.h GLDS Controller.\nldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type.\nldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type.\nldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type.\nldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type.\nldsCtrlEst_h/lds_gaussian_sys.h GLDS base type.\nldsCtrlEst_h/lds_poisson.h plds namespace\nldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type.\nldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type.\nldsCtrlEst_h/lds_poisson_fit_em.h PLDS E-M fit type.\nldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type.\nldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type.\nldsCtrlEst_h/lds_poisson_sys.h PLDS base type.\nldsCtrlEst_h/lds_sctrl.h SwitchedController type.\nldsCtrlEst_h/lds_sys.h LDS base type.\nldsCtrlEst_h/lds_uniform_mats.h List of uniformly sized matrices.\nldsCtrlEst_h/lds_uniform_systems.h List of uniformly sized Systems.\nldsCtrlEst_h/lds_uniform_vecs.h List of uniformly sized vectors.\nldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API)\nldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API)\nsrc/lds.cpp misc lds namespace functions\nsrc/lds_gaussian_sys.cpp GLDS base type.\nsrc/lds_poisson_sys.cpp PLDS base type.\nsrc/lds_sys.cpp LDS base type.\nsrc/lds_uniform_vecs.cpp Uniformly sized vectors.\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":25,"href":"/lds-ctrl-est/docs/tutorials/eg_glds_control/","title":"GLDS Control","section":"LDS C+E Examples","content":" GLDS Control Tutorial # This tutorial shows how to use this library to control a system with a Gaussian LDS controller (lds::gaussian::Controller). In place of a physical system, a GLDS model (lds::gaussian::System) receives control inputs and simulates measurements for the feedback control loop. The controller is assumed to have an imperfect model of the system being controlled (here, a gain mismatch), and there is a stochastic, unmeasured disturbance acting on the system. A combination of integral action and adaptive estimation of this process disturbance is used to perform control.\nThe full code for this can be found here.\nPreamble # In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; Note that lds::Matrix and lds::Vector are typedefs for arma::Mat\u0026lt;data_t\u0026gt; and arma::Col\u0026lt;data_t\u0026gt;, where the data type is double by default. May be changed to float in include/ldsCtrlEst_h/lds.h if there are memory constraints (e.g., large-scale MIMO control problems).\nCreating a simulated system # A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 5 seconds.\n// Make 1st-order SISO system, sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); When a system is initialized, rather than requiring all parameters be provided at construction, users may create a default system by setting only the dimensions and sample period.\n// construct ground truth system to be controlled... // initializes to random walk model with top-most n_y state observed lds::gaussian::System controlled_system(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example, \\[\rx_{t\u0026#43;1} = x_t \u0026#43; w_t\r\\] \\[\ry_{t} = x_t\r\\] where \\( w_{t} \\sim \\mathcal{N}\\left( 0, Q \\right) \\) .\nNow, create non-default parameters for this model.\n// Ground-truth parameters for the controlled system // (stand-in for physical system to be controlled) Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); Matrix b_true = Matrix(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2: Vector g_true = Vector(n_y).fill(10.0); // output noise covariance Matrix r_true = Matrix(n_y, n_y, arma::fill::eye) * 1e-4; As mentioned above, this example will feature a stochastic disturbance. More specifically, a process disturbance will randomly change between two values.\n/// Going to simulate a switching disturbance (m) acting on system size_t which_m = 0; // whether low or high disturbance (0, 1) data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb. data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low Vector m0_true = Vector(n_y).fill(m_low); Finally, assign the parameters using corresponding set-methods.\n// Assign params. controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_R(r_true); Creating the controller # Now, create the controller. This requires first constructing the system model that the control uses for estimating state feedback and updating the control signal. A controller is then constructed from this lds::gaussian::System object and upper/lower bounds on the control signal (u_lb, u_ub below), past which the control saturates. Here, the control signal is command voltage sent to an analog driver (e.g., for an LED). Its limits are 0 to 5 V. If your actuator does not saturate somehow, simply set the lower and upper bounds to -lds::kInf and lds::kInf, respectively. Simple saturation is currently the only actuator model in this library.\nFor the sake of this simulation, the system model input matrix is set to an incorrect value. We also assume that the controller feedback gains were designed with an actuator whose conversion factor from volts to physical units (e.g., mW/mm2 optical intensity) differed from the actuator being used in the current experiment.\n// make a controller lds::gaussian::Controller controller; { // Create **incorrect** model used for control. // (e.g., imperfect model fitting) Matrix b_controller = b_true / 2; // let\u0026#39;s assume zero process disturbance initially // (will be re-estimating) Vector m_controller = Vector(n_x, arma::fill::zeros); // for this demo, just use arbitrary default R Matrix r_controller = Matrix(n_y, n_y, arma::fill::eye) * lds::kDefaultR0; lds::gaussian::System controller_system(controlled_system); controller_system.set_B(b_controller); controller_system.set_m(m_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m // going to adaptively re-estimate the disturbance controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise // acting on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; controller_system.set_Q_m(q_m); // create controller // lower and upper bounds on control signal (e.g., in Volts) data_t u_lb = 0.0; // [=] V data_t u_ub = 5.0; // [=] V controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); } Note that the above code block demonstrates how move semantics can be used for assignment/construction. Copy assignment/construction is of course also allowed.\nWith the controller constructed, control variables may be set.\n// Control variables: // if following enabled, adapts set point with re-estimated process // disturbance n.b., should not need integral action if this is enabled as the // adaptive estimator minimizes DC error bool do_adaptive_set_point = false; // Reference/target output, controller gains Vector y_ref0 = Vector(n_y).fill(20.0 * dt); Matrix k_x = Matrix(n_u, n_x).fill(100); // gains on state error Matrix k_inty = Matrix(n_u, n_y).fill(1e3); // gains on integrated err // setting initial state to target to avoid error at onset: Vector x0 = Vector(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance control_type = control_type | lds::kControlTypeAdaptM; } else { // use integral action to minimize DC error control_type = control_type | lds::kControlTypeIntY; } // set controller type controller.set_control_type(control_type); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2): Vector g_design = Vector(n_u).fill(9); // Set params. // **n.b. using arbitrary defaults for Q, R in this example. Really, these // should be set by users, as they tune characteristics of Kalman filter. // Users can also choose not to recursively calculate the estimator gain and // supply it (setKe) instead of covariances.** controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_g_design(g_design); Simulating control # In this demonstration, we will use the ControlOutputReference method which allows users to simply set the reference output and supply the current measurement z. It then calculates the solution for the state/input required to track the reference output at steady state. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system.\nThe control loop is carried out here in a simple for-loop, where a the controlled system is simulated, a measurement taken, and the control signal updated.\n// Simulate the true system. z.col(t) = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate // x_ref, u_ref from reference output y_ref. Therefore, it is only // applicable to regulation problems or cases where reference trajectory // changes slowly compared to system dynamics. u.col(t) = controller.ControlOutputReference(z.col(t)); Example simulation result # Below are example results for this simulation, including outputs, latent states, process disturbance, and the control signal. The controller\u0026rsquo;s online estimates of the output, state, and disturbance are given in purple.\n"},{"id":26,"href":"/lds-ctrl-est/docs/api/files/dir_d44c64559bbebec7f509842c48db8b23/","title":"include","section":"Files","content":" include # Directories # Name ldsCtrlEst_h Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":27,"href":"/lds-ctrl-est/docs/api/namespaces/namespacelds/","title":"lds","section":"Namespaces","content":" lds # Linear Dynamical Systems (LDS) namespace. Namespaces # Name lds::gaussian Linear Dynamical Systems with Gaussian observations. lds::poisson Linear Dynamical Systems with Poisson observations. Classes # Name class lds::Controller class lds::EM class lds::Fit LDS Fit Type. class lds::SSID class lds::SwitchedController SwitchedController Type. class lds::System Linear Dynamical System Type. class lds::UniformMatrixList class lds::UniformSystemList class lds::UniformVectorList Types # Name enum SSIDWt { kSSIDNone, kSSIDMOESP, kSSIDCVA}\nweighting options for SSID enum MatrixListFreeDim { kMatFreeDimNone, kMatFreeDim1, kMatFreeDim2} using double data_t using arma::Col\u0026lt; data_t \u0026gt; Vector using arma::Mat\u0026lt; data_t \u0026gt; Matrix using arma::Cube\u0026lt; data_t \u0026gt; Cube using arma::subview\u0026lt; data_t \u0026gt; View Functions # Name void Limit(std::vector\u0026lt; data_t \u0026gt; \u0026amp; x, data_t lb, data_t ub) void Limit(Vector \u0026amp; x, data_t lb, data_t ub) void Limit(Matrix \u0026amp; x, data_t lb, data_t ub) void Reassign(Vector \u0026amp; some, const Vector \u0026amp; other, const std::string \u0026amp; parenthetical =\u0026ldquo;Reassign\u0026rdquo;)\nreassigns contents of some Vector in place void Reassign(Matrix \u0026amp; some, const Matrix \u0026amp; other, const std::string \u0026amp; parenthetical =\u0026ldquo;Reassign\u0026rdquo;)\nreassigns contents of some Matrix in place void ForceSymPD(Matrix \u0026amp; X)\nforces matrix to be symmetric positive-definite void ForceSymMinEig(Matrix \u0026amp; X, data_t eig_min =0)\nforces matrix to be symmetric and have a minimum eigenvalue void lq(Matrix \u0026amp; L, Matrix \u0026amp; Qt, const Matrix \u0026amp; X)\nLQ decomposition. Matrix calcCov(const Matrix \u0026amp; A, const Matrix \u0026amp; B)\nCalculate covariance matrix. Attributes # Name const data_t kInf Some useful numbers. const data_t kPi Type Details # SSIDWt # Enumerator Value Description kSSIDNone None. kSSIDMOESP MOESP (AKA \u0026ldquo;robust method\u0026rdquo; in van Overschee 1996) kSSIDCVA CVA \u0026ldquo;Canonical Variate Analysis\u0026rdquo;. Weighting options for singular value decomposition performed during subspace identification (SSID)\nReference:\nvan Overschee, de Moor. 1996. Subspace Identification for Linear Systems.\nMatrixListFreeDim # Enumerator Value Description kMatFreeDimNone neither dim free to be hetero in mat list kMatFreeDim1 allow 1st dim of mats in list to be hetero kMatFreeDim2 allow 2nd dim of mats in list to be hetero data_t # using lds::data_t = double; Type of all data in library. If need 32b, change double to float. This could be potentially useful for large scale problems where there are memory constraints.\nVector # using lds::Vector = arma::Col\u0026lt;data_t\u0026gt;; Matrix # using lds::Matrix = arma::Mat\u0026lt;data_t\u0026gt;; Cube # using lds::Cube = arma::Cube\u0026lt;data_t\u0026gt;; View # using lds::View = arma::subview\u0026lt;data_t\u0026gt;; Function Details # Limit # inline void Limit( std::vector\u0026lt; data_t \u0026gt; \u0026amp; x, data_t lb, data_t ub ) Limit # inline void Limit( Vector \u0026amp; x, data_t lb, data_t ub ) Limit # inline void Limit( Matrix \u0026amp; x, data_t lb, data_t ub ) Reassign # inline void Reassign( Vector \u0026amp; some, const Vector \u0026amp; other, const std::string \u0026amp; parenthetical =\u0026#34;Reassign\u0026#34; ) Parameters:\nsome some Vector other other Vector parenthetical optional description provided by caller to ease debugging Reassign # inline void Reassign( Matrix \u0026amp; some, const Matrix \u0026amp; other, const std::string \u0026amp; parenthetical =\u0026#34;Reassign\u0026#34; ) Parameters:\nsome some Matrix other other Matrix parenthetical optional description provided by caller to ease debugging ForceSymPD # void ForceSymPD( Matrix \u0026amp; X ) Parameters:\nX mutated matrix ForceSymMinEig # void ForceSymMinEig( Matrix \u0026amp; X, data_t eig_min =0 ) Parameters:\nX mutated matrix eig_min [optional] minimum eigen value lq # void lq( Matrix \u0026amp; L, Matrix \u0026amp; Qt, const Matrix \u0026amp; X ) Parameters:\nL lower triangle matrix Qt orthonormal matrix (transposed cf QR decomp) X matrix being decomposed calcCov # Matrix calcCov( const Matrix \u0026amp; A, const Matrix \u0026amp; B ) Parameters:\nA some matrix B some other matrix Return: covariance\nAttribute Details # kInf # static const data_t kInf = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(); kPi # static const data_t kPi = arma::datum::pi; Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":28,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1_controller/","title":"lds::Controller","section":"Classes","content":" lds::Controller # More\u0026hellip;\nInherited by lds::SwitchedController\u0026lt; System \u0026gt;, lds::gaussian::Controller, lds::poisson::Controller\nPublic Functions # Name Controller() =default\nConstructs a new Controller. Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller. Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object. const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step) const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step) const System \u0026amp; sys() const const Matrix \u0026amp; Kc() const\nGet state feedback controller gain. const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain. const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain. const Vector \u0026amp; g_design() const\nGet input gain used in controller design. const Vector \u0026amp; u_ref() const\nGet reference input. const Vector \u0026amp; x_ref() const\nGet reference state. const Vector \u0026amp; y_ref() const\nGet reference output. size_t control_type() const\nGet controller type. data_t tau_awu() const\nGet time constant of anti-integral-windup. data_t u_lb() const\nGet control lower bound. data_t u_ub() const\nGet control upper bound. void set_sys(const System \u0026amp; sys)\nSet system. void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design) void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref) void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref) virtual void set_y_ref(const Vector \u0026amp; y_ref)\nSet reference output (y_ref) void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain. void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain. void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain. void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup. void set_control_type(size_t control_type)\nSets the control type. void set_u_lb(data_t u_lb)\nsets control lower bound void set_u_ub(data_t u_ub)\nSets control upper bound. void Reset()\nreset system and control variables. void Print()\nprints variables to stdout Protected Attributes # Name System sys_ underlying LDS Vector u_ control signal Vector u_return_ control signal that is returned to user Vector g_design_ input gain of the system used for controller design Vector u_ref_ reference input Vector u_ref_prev_ reference input at previous time step Vector x_ref_ reference state Vector y_ref_ reference output Vector cx_ref_ Matrix Kc_ state controller gain Matrix Kc_u_ input controller gain (optional when control updates \\deltaU) Matrix Kc_inty_ integral controller gain Vector du_ref_ Vector dv_ref_ Vector v_ref_ Vector dv_ Vector v_ Control after g inversion (e.g., control in physical units) Vector int_e_ integrated error Vector int_e_awu_adjust_ anti-windup adjustment to intE Vector u_sat_ control signal after saturation (for antiWindup) bool do_control_prev_ bool do_lock_control_prev_ bool u_saturated_ whether control signal has reached saturation limits data_t u_lb_ lower bound on control data_t u_ub_ upper bound on control data_t tau_awu_ antiwindup time constant data_t k_awu_ data_t t_since_control_onset_ time since control epoch onset size_t control_type_ controller type Detailed Description # template \u0026lt;typename System \u0026gt; class lds::Controller; Public Function Details # Controller # Controller() =default Controller # inline Controller( const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\nsys System (derived from lds::System) u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask Template Parameters:\nSystem type derived from lds::System Controller # inline Controller( System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\nsys System (derived from lds::System) u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask Template Parameters:\nSystem type derived from lds::System Control # inline const Vector \u0026amp; Control( const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true ) Parameters:\nz measurement do_control [optional] whether to update control (true) or simply feed through u_ref (false) do_lock_control [optional] whether to lock control at its current value sigma_soft_start [optional] standard deviation (sigma) of a Gaussian soft-start to control (do_control from false to true) sigma_u_noise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal do_reset_at_control_onset [optional] whether to reset controller at control epoch onset (i.e., do_control from false to true) Return: updated control signal\nUpdates the control signal (single-step). This is the most flexible option, but requires user to have set the controller\u0026rsquo;s y_ref, x_ref, and u_ref variables.\nControlOutputReference # inline const Vector \u0026amp; ControlOutputReference( const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true ) Parameters:\nz measurement do_control [optional] whether to update control (true) or simply feed through u_ref (false) do_estimation [optional] whether to update state estimate (if false, effectively open-loop control) do_lock_control [optional] whether to lock control at its current value sigma_soft_start [optional] standard deviation (sigma) of a Gaussian soft-start to control (do_control from false to true) sigma_u_noise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal do_reset_at_control_onset [optional] whether to reset controller at control epoch onset (i.e., do_control from false to true) Return: updated control signal\nUpdates the control signal (single-step), given previously-set y_ref. This method calculates the rest of the set point (u_ref, x_ref) that is required to for the system to be at y_ref at steady state. This is accomplished by linearly-constrained least-squares. For a single-output system, the solution should be exact within control saturation limits. For a multi-output system, it provides the least-squares comprimise across the outputs.\nsys # inline const System \u0026amp; sys() const Kc # inline const Matrix \u0026amp; Kc() const Kc_inty # inline const Matrix \u0026amp; Kc_inty() const Kc_u # inline const Matrix \u0026amp; Kc_u() const g_design # inline const Vector \u0026amp; g_design() const u_ref # inline const Vector \u0026amp; u_ref() const x_ref # inline const Vector \u0026amp; x_ref() const y_ref # inline const Vector \u0026amp; y_ref() const control_type # inline size_t control_type() const tau_awu # inline data_t tau_awu() const u_lb # inline data_t u_lb() const u_ub # inline data_t u_ub() const set_sys # inline void set_sys( const System \u0026amp; sys ) set_g_design # inline void set_g_design( const Vector \u0026amp; g_design ) set_u_ref # inline void set_u_ref( const Vector \u0026amp; u_ref ) set_x_ref # inline void set_x_ref( const Vector \u0026amp; x_ref ) set_y_ref # inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) Reimplemented by: lds::gaussian::Controller::set_y_ref, lds::gaussian::SwitchedController::set_y_ref, lds::poisson::Controller::set_y_ref, lds::poisson::SwitchedController::set_y_ref\nset_Kc # inline void set_Kc( const Matrix \u0026amp; Kc ) set_Kc_inty # inline void set_Kc_inty( const Matrix \u0026amp; Kc_inty ) set_Kc_u # inline void set_Kc_u( const Matrix \u0026amp; Kc_u ) set_tau_awu # inline void set_tau_awu( data_t tau ) set_control_type # inline void set_control_type( size_t control_type ) Parameters:\ncontrol_type control type bit mask Template Parameters:\nSystem type derived from lds::System set_u_lb # inline void set_u_lb( data_t u_lb ) Parameters:\nu_lb control lower bound set_u_ub # inline void set_u_ub( data_t u_ub ) Parameters:\nu_ub control upper bound Reset # inline void Reset() Print # inline void Print() Protected Attribute Details # sys_ # System sys_; u_ # Vector u_; u_return_ # Vector u_return_; g_design_ # Vector g_design_; u_ref_ # Vector u_ref_; u_ref_prev_ # Vector u_ref_prev_; x_ref_ # Vector x_ref_; y_ref_ # Vector y_ref_; cx_ref_ # Vector cx_ref_; Kc_ # Matrix Kc_; Kc_u_ # Matrix Kc_u_; Kc_inty_ # Matrix Kc_inty_; du_ref_ # Vector du_ref_; dv_ref_ # Vector dv_ref_; v_ref_ # Vector v_ref_; dv_ # Vector dv_; v_ # Vector v_; int_e_ # Vector int_e_; int_e_awu_adjust_ # Vector int_e_awu_adjust_; u_sat_ # Vector u_sat_; do_control_prev_ # bool do_control_prev_ = false; do_lock_control_prev_ # bool do_lock_control_prev_ = false; u_saturated_ # bool u_saturated_ = false; u_lb_ # data_t u_lb_ {}; u_ub_ # data_t u_ub_ {}; tau_awu_ # data_t tau_awu_ {}; k_awu_ # data_t k_awu_ = 0; t_since_control_onset_ # data_t t_since_control_onset_ = 0; control_type_ # size_t control_type_ {}; Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":29,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1_e_m/","title":"lds::EM","section":"Classes","content":" lds::EM # More\u0026hellip;\nInherited by lds::gaussian::FitEM, lds::poisson::FitEM\nPublic Functions # Name EM() =default\nConstructs a new EMFit type. EM(size_t n_x, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMFit type. EM(const Fit \u0026amp; fit0, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMFit type. virtual ~EM() =default const Fit \u0026amp; Run(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =true, bool calc_output =true, bool calc_measurement =true, size_t max_iter =100, data_t tol =1e-2)\nRuns fitting by Expectation(E)-Maximization(M) std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the input/output data to caller. const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; x() const\ngets estimated state (over time) const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; y() const\ngets estimated output (over time) const Matrix \u0026amp; sum_E_x_t_x_t() const\ngets state-input covariance const Matrix \u0026amp; sum_E_xu_tm1_xu_tm1() const\ngets state-input covariance (t-minus-1) const Matrix \u0026amp; sum_E_xu_t_xu_tm1() const\ngets single lag state-input covariance size_t n_t_tot()\ntotal number of time samples const Vector \u0026amp; theta() const\ngets parameters updated in M step Protected Functions # Name void Expectation(bool force_common_initial =false)\nExpectation step. void Maximization(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =false, bool calc_output =false, bool calc_measurement =false)\nMaximization step. void MaximizeDynamics() void MaximizeQ() void MaximizeInitial() virtual void MaximizeOutput() =0 virtual void MaximizeMeasurement() =0 void Smooth(bool force_common_initial)\nget smoothed estimates virtual void RecurseKe(Matrix \u0026amp; Ke, Cube \u0026amp; P_pre, Cube \u0026amp; P_post, size_t t) =0\nrecursively update estimator gain Ke void Reset()\nreset to initial conditions void InitVars()\nInitializes the variables. Vector UpdateTheta()\nupdates parameter list, theta Protected Attributes # Name UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data std::vector\u0026lt; Matrix \u0026gt; x_ state estimate std::vector\u0026lt; Cube \u0026gt; P_ state estimate cov std::vector\u0026lt; Cube \u0026gt; P_t_tm1_ single-lag state covariance std::vector\u0026lt; Matrix \u0026gt; y_ output estimate Matrix diag_y_ Matrix sum_E_x_t_x_t_ state covariance (current time) Matrix sum_E_xu_tm1_xu_tm1_ state-input covariance (t-minus-1) Matrix sum_E_xu_t_xu_tm1_ single lag state-input covariance Fit fit_ Vector theta_ data_t dt_ sample period size_t n_u_ number of inputs size_t n_x_ number of states size_t n_y_ number of outputs size_t n_trials_ number of input/output data sequences std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps size_t n_t_tot_ total number of time steps across trials Detailed Description # template \u0026lt;typename Fit \u0026gt; class lds::EM; Public Function Details # EM # EM() =default EM # EM( size_t n_x, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train ) Parameters:\nn_x number of states dt sample period u_train input training data z_train measurement training data EM # EM( const Fit \u0026amp; fit0, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train ) Parameters:\nfit0 initial fit u_train input training data z_train measurement training data ~EM # virtual ~EM() =default Run # const Fit \u0026amp; Run( bool calc_dynamics =true, bool calc_Q =true, bool calc_init =true, bool calc_output =true, bool calc_measurement =true, size_t max_iter =100, data_t tol =1e-2 ) Parameters:\ncalc_dynamics [optional] whether to calculate dynamics (A, B) calc_Q [optional] whether to calculate process noise covariance calc_init [optional] whether to calculate initial conditions calc_output [optional] whether to calculate output function calc_measurement [optional] whether to calculate parameters for measurement/observation law max_iter max number of iterations tol convergence tolerance (max fractional abs change) Return: Fit\nReturnData # inline std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData() Return: tuple(input data, output data)\nx # inline const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; x() const y # inline const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; y() const sum_E_x_t_x_t # inline const Matrix \u0026amp; sum_E_x_t_x_t() const sum_E_xu_tm1_xu_tm1 # inline const Matrix \u0026amp; sum_E_xu_tm1_xu_tm1() const sum_E_xu_t_xu_tm1 # inline const Matrix \u0026amp; sum_E_xu_t_xu_tm1() const n_t_tot # inline size_t n_t_tot() theta # inline const Vector \u0026amp; theta() const Protected Function Details # Expectation # void Expectation( bool force_common_initial =false ) Parameters:\nforce_common_initial whether to force common initial condition for all trials Maximization # void Maximization( bool calc_dynamics =true, bool calc_Q =true, bool calc_init =false, bool calc_output =false, bool calc_measurement =false ) Parameters:\ncalc_dynamics [optional] whether to caclulate dynamics (A, B) calc_Q [optional] whether to calculate process noise covariance calc_init [optional] whether to calculate initial conditions calc_output [optional] whether to calculate output function calc_measurement [optional] whether to calculate parameters for measurement/observation law MaximizeDynamics # void MaximizeDynamics() MaximizeQ # void MaximizeQ() MaximizeInitial # void MaximizeInitial() MaximizeOutput # virtual void MaximizeOutput() =0 Reimplemented by: lds::gaussian::FitEM::MaximizeOutput, lds::poisson::FitEM::MaximizeOutput\nMaximizeMeasurement # virtual void MaximizeMeasurement() =0 Reimplemented by: lds::gaussian::FitEM::MaximizeMeasurement, lds::poisson::FitEM::MaximizeMeasurement\nSmooth # void Smooth( bool force_common_initial ) Parameters:\nforce_common_initial whether to force common initial conditions RecurseKe # virtual void RecurseKe( Matrix \u0026amp; Ke, Cube \u0026amp; P_pre, Cube \u0026amp; P_post, size_t t ) =0 Parameters:\nKe estimator gain P_pre cov of predicted state est. P_post cov of postior sate est. t time Reimplemented by: lds::gaussian::FitEM::RecurseKe, lds::poisson::FitEM::RecurseKe\nReset # void Reset() InitVars # void InitVars() UpdateTheta # Vector UpdateTheta() Return: parameter list\nProtected Attribute Details # u_ # UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_; z_ # UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_; x_ # std::vector\u0026lt; Matrix \u0026gt; x_; P_ # std::vector\u0026lt; Cube \u0026gt; P_; P_t_tm1_ # std::vector\u0026lt; Cube \u0026gt; P_t_tm1_; y_ # std::vector\u0026lt; Matrix \u0026gt; y_; diag_y_ # Matrix diag_y_; sum_E_x_t_x_t_ # Matrix sum_E_x_t_x_t_; sum_E_xu_tm1_xu_tm1_ # Matrix sum_E_xu_tm1_xu_tm1_; sum_E_xu_t_xu_tm1_ # Matrix sum_E_xu_t_xu_tm1_; fit_ # Fit fit_; theta_ # Vector theta_; dt_ # data_t dt_ {}; n_u_ # size_t n_u_ {}; n_x_ # size_t n_x_ {}; n_y_ # size_t n_y_ {}; n_trials_ # size_t n_trials_ {}; n_t_ # std::vector\u0026lt; size_t \u0026gt; n_t_; n_t_tot_ # size_t n_t_tot_ {}; Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":30,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1_fit/","title":"lds::Fit","section":"Classes","content":" lds::Fit # LDS Fit Type. #include \u0026lt;lds_fit.h\u0026gt;\nInherited by lds::gaussian::Fit, lds::poisson::Fit\nPublic Functions # Name Fit() =default\nConstructs a new Fit. Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt)\nConstructs a new Fit. virtual ~Fit() =default size_t n_u() const\ngets number of inputs size_t n_x() const\ngets number of states size_t n_y() const\ngets number of outputs data_t dt() const\ngets sample period const Matrix \u0026amp; A() const\ngets state matrix const Matrix \u0026amp; B() const\ngets input matrix const Vector \u0026amp; g() const\ngets input gain const Vector \u0026amp; m() const\ngets process disturbance const Matrix \u0026amp; Q() const\ngets process noise covariance const Vector \u0026amp; x0() const\ngets initial state estimate const Matrix \u0026amp; P0() const\ngets covariance of initial state estimate const Matrix \u0026amp; C() const\ngets output matrix const Vector \u0026amp; d() const\ngets output bias virtual const Matrix \u0026amp; R() const =0 void set_A(const Matrix \u0026amp; A)\nsets state matrix void set_B(const Matrix \u0026amp; B)\nsets input matrix void set_g(const Vector \u0026amp; g)\nsets input gain/conversion factor void set_m(const Vector \u0026amp; m)\nsets process disturbance void set_Q(const Matrix \u0026amp; Q)\nsets process noise covariance virtual void set_R(const Matrix \u0026amp; R) =0\nsets output noise covariance (if any) void set_x0(const Vector \u0026amp; x0)\nsets initial state estimate void set_P0(const Matrix \u0026amp; P0)\nsets initial state estimate covariance void set_C(const Matrix \u0026amp; C)\nsets output matrix void set_d(const Vector \u0026amp; d)\nsets output bias View f(Matrix \u0026amp; x, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function View f(Matrix \u0026amp; x_pre, const Matrix \u0026amp; x_post, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function virtual View h(Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t) =0\noutput function Protected Attributes # Name data_t dt_ sample period Matrix A_ state matrix Matrix B_ input matrix Vector g_ input gain Vector m_ process noise mean Matrix Q_ process noise cov Matrix C_ output matrix Vector d_ output bias Matrix R_ measurement noise Vector x0_ initial state Matrix P0_ initial covar size_t n_u_ number of inputs size_t n_x_ number of states size_t n_y_ number of outputs Public Function Details # Fit # Fit() =default Fit # Fit( size_t n_u, size_t n_x, size_t n_y, data_t dt ) Parameters:\nn_u number of inputs n_x number of states n_y number of outputs dt sample period ~Fit # virtual ~Fit() =default n_u # inline size_t n_u() const n_x # inline size_t n_x() const n_y # inline size_t n_y() const dt # inline data_t dt() const A # inline const Matrix \u0026amp; A() const B # inline const Matrix \u0026amp; B() const g # inline const Vector \u0026amp; g() const m # inline const Vector \u0026amp; m() const Q # inline const Matrix \u0026amp; Q() const x0 # inline const Vector \u0026amp; x0() const P0 # inline const Matrix \u0026amp; P0() const C # inline const Matrix \u0026amp; C() const d # inline const Vector \u0026amp; d() const R # virtual const Matrix \u0026amp; R() const =0 Reimplemented by: lds::gaussian::Fit::R, lds::poisson::Fit::R\nset_A # inline void set_A( const Matrix \u0026amp; A ) set_B # inline void set_B( const Matrix \u0026amp; B ) set_g # inline void set_g( const Vector \u0026amp; g ) set_m # inline void set_m( const Vector \u0026amp; m ) set_Q # inline void set_Q( const Matrix \u0026amp; Q ) set_R # virtual void set_R( const Matrix \u0026amp; R ) =0 Reimplemented by: lds::gaussian::Fit::set_R, lds::poisson::Fit::set_R\nset_x0 # inline void set_x0( const Vector \u0026amp; x0 ) set_P0 # inline void set_P0( const Matrix \u0026amp; P0 ) set_C # inline void set_C( const Matrix \u0026amp; C ) set_d # inline void set_d( const Vector \u0026amp; d ) f # inline View f( Matrix \u0026amp; x, const Matrix \u0026amp; u, size_t t ) Parameters:\nx state estimate (over time) u input (over time) t time index Return: view of updated state\nf # inline View f( Matrix \u0026amp; x_pre, const Matrix \u0026amp; x_post, const Matrix \u0026amp; u, size_t t ) Parameters:\nx_pre predicted state est. x_post posterior state est. u input (over time) t time index Return: view of predicted state\nh # virtual View h( Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t ) =0 Parameters:\ny output estimate (over time) x state estimate (over time) t time index Return: output\nReimplemented by: lds::gaussian::Fit::h, lds::poisson::Fit::h\nProtected Attribute Details # dt_ # data_t dt_ {}; A_ # Matrix A_; B_ # Matrix B_; g_ # Vector g_; m_ # Vector m_; Q_ # Matrix Q_; C_ # Matrix C_; d_ # Vector d_; R_ # Matrix R_; x0_ # Vector x0_; P0_ # Matrix P0_; n_u_ # size_t n_u_ {}; n_x_ # size_t n_x_ {}; n_y_ # size_t n_y_ {}; Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":31,"href":"/lds-ctrl-est/docs/api/namespaces/namespacelds_1_1gaussian/","title":"lds::gaussian","section":"Namespaces","content":" lds::gaussian # Linear Dynamical Systems with Gaussian observations. Classes # Name class lds::gaussian::Controller Gaussian-observation Controller Type. class lds::gaussian::Fit GLDS Fit Type. class lds::gaussian::FitEM GLDS E-M Fit Type. class lds::gaussian::FitSSID Subspace Identification (SSID) for GLDS. class lds::gaussian::SwitchedController Gaussian-observation SwitchedController Type. class lds::gaussian::System Gaussian LDS Type. Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":32,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1gaussian_1_1_controller/","title":"lds::gaussian::Controller","section":"Classes","content":" lds::gaussian::Controller # Gaussian-observation Controller Type. #include \u0026lt;lds_gaussian_ctrl.h\u0026gt;\nInherits from lds::Controller\u0026lt; System \u0026gt;\nPublic Functions # Name virtual void set_y_ref(const Vector \u0026amp; y_ref) override\nsets reference output Additional inherited members # Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\nName Controller() =default\nConstructs a new Controller. Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller. Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object. const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step) const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step) const System \u0026amp; sys() const const Matrix \u0026amp; Kc() const\nGet state feedback controller gain. const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain. const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain. const Vector \u0026amp; g_design() const\nGet input gain used in controller design. const Vector \u0026amp; u_ref() const\nGet reference input. const Vector \u0026amp; x_ref() const\nGet reference state. const Vector \u0026amp; y_ref() const\nGet reference output. size_t control_type() const\nGet controller type. data_t tau_awu() const\nGet time constant of anti-integral-windup. data_t u_lb() const\nGet control lower bound. data_t u_ub() const\nGet control upper bound. void set_sys(const System \u0026amp; sys)\nSet system. void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design) void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref) void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref) void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain. void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain. void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain. void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup. void set_control_type(size_t control_type)\nSets the control type. void set_u_lb(data_t u_lb)\nsets control lower bound void set_u_ub(data_t u_ub)\nSets control upper bound. void Reset()\nreset system and control variables. void Print()\nprints variables to stdout Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\nName System sys_ underlying LDS Vector u_ control signal Vector u_return_ control signal that is returned to user Vector g_design_ input gain of the system used for controller design Vector u_ref_ reference input Vector u_ref_prev_ reference input at previous time step Vector x_ref_ reference state Vector y_ref_ reference output Vector cx_ref_ Matrix Kc_ state controller gain Matrix Kc_u_ input controller gain (optional when control updates \\deltaU) Matrix Kc_inty_ integral controller gain Vector du_ref_ Vector dv_ref_ Vector v_ref_ Vector dv_ Vector v_ Control after g inversion (e.g., control in physical units) Vector int_e_ integrated error Vector int_e_awu_adjust_ anti-windup adjustment to intE Vector u_sat_ control signal after saturation (for antiWindup) bool do_control_prev_ bool do_lock_control_prev_ bool u_saturated_ whether control signal has reached saturation limits data_t u_lb_ lower bound on control data_t u_ub_ upper bound on control data_t tau_awu_ antiwindup time constant data_t k_awu_ data_t t_since_control_onset_ time since control epoch onset size_t control_type_ controller type Public Function Details # set_y_ref # inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":33,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1gaussian_1_1_fit/","title":"lds::gaussian::Fit","section":"Classes","content":" lds::gaussian::Fit # GLDS Fit Type. #include \u0026lt;lds_gaussian_fit.h\u0026gt;\nInherits from lds::Fit\nPublic Functions # Name Fit() =default Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt)\nConstructs a new Fit. virtual const Matrix \u0026amp; R() const override\ngets measurement noise covariance virtual void set_R(const Matrix \u0026amp; R) override\nsets measurement noise covariance virtual View h(Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t) override\noutput function Additional inherited members # Public Functions inherited from lds::Fit\nName virtual ~Fit() =default size_t n_u() const\ngets number of inputs size_t n_x() const\ngets number of states size_t n_y() const\ngets number of outputs data_t dt() const\ngets sample period const Matrix \u0026amp; A() const\ngets state matrix const Matrix \u0026amp; B() const\ngets input matrix const Vector \u0026amp; g() const\ngets input gain const Vector \u0026amp; m() const\ngets process disturbance const Matrix \u0026amp; Q() const\ngets process noise covariance const Vector \u0026amp; x0() const\ngets initial state estimate const Matrix \u0026amp; P0() const\ngets covariance of initial state estimate const Matrix \u0026amp; C() const\ngets output matrix const Vector \u0026amp; d() const\ngets output bias void set_A(const Matrix \u0026amp; A)\nsets state matrix void set_B(const Matrix \u0026amp; B)\nsets input matrix void set_g(const Vector \u0026amp; g)\nsets input gain/conversion factor void set_m(const Vector \u0026amp; m)\nsets process disturbance void set_Q(const Matrix \u0026amp; Q)\nsets process noise covariance void set_x0(const Vector \u0026amp; x0)\nsets initial state estimate void set_P0(const Matrix \u0026amp; P0)\nsets initial state estimate covariance void set_C(const Matrix \u0026amp; C)\nsets output matrix void set_d(const Vector \u0026amp; d)\nsets output bias View f(Matrix \u0026amp; x, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function View f(Matrix \u0026amp; x_pre, const Matrix \u0026amp; x_post, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function Protected Attributes inherited from lds::Fit\nName data_t dt_ sample period Matrix A_ state matrix Matrix B_ input matrix Vector g_ input gain Vector m_ process noise mean Matrix Q_ process noise cov Matrix C_ output matrix Vector d_ output bias Matrix R_ measurement noise Vector x0_ initial state Matrix P0_ initial covar size_t n_u_ number of inputs size_t n_x_ number of states size_t n_y_ number of outputs Public Function Details # Fit # Fit() =default Fit # Fit( size_t n_u, size_t n_x, size_t n_y, data_t dt ) Parameters:\nn_u number of inputs n_x number of states n_y number of outputs dt sample period R # inline virtual const Matrix \u0026amp; R() const override Reimplements: lds::Fit::R\nset_R # inline virtual void set_R( const Matrix \u0026amp; R ) override Reimplements: lds::Fit::set_R\nh # inline virtual View h( Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t ) override Parameters:\ny output estimate (over time) x state estimate (over time) t time index Return: output\nReimplements: lds::Fit::h\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":34,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1gaussian_1_1_fit_e_m/","title":"lds::gaussian::FitEM","section":"Classes","content":" lds::gaussian::FitEM # GLDS E-M Fit Type. More\u0026hellip;\n#include \u0026lt;lds_gaussian_fit_em.h\u0026gt;\nInherits from lds::EM\u0026lt; Fit \u0026gt;\nAdditional inherited members # Public Functions inherited from lds::EM\u0026lt; Fit \u0026gt;\nName EM() =default\nConstructs a new EMFit type. EM(size_t n_x, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMFit type. EM(const Fit \u0026amp; fit0, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMFit type. virtual ~EM() =default const Fit \u0026amp; Run(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =true, bool calc_output =true, bool calc_measurement =true, size_t max_iter =100, data_t tol =1e-2)\nRuns fitting by Expectation(E)-Maximization(M) std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the input/output data to caller. const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; x() const\ngets estimated state (over time) const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; y() const\ngets estimated output (over time) const Matrix \u0026amp; sum_E_x_t_x_t() const\ngets state-input covariance const Matrix \u0026amp; sum_E_xu_tm1_xu_tm1() const\ngets state-input covariance (t-minus-1) const Matrix \u0026amp; sum_E_xu_t_xu_tm1() const\ngets single lag state-input covariance size_t n_t_tot()\ntotal number of time samples const Vector \u0026amp; theta() const\ngets parameters updated in M step Protected Functions inherited from lds::EM\u0026lt; Fit \u0026gt;\nName void Expectation(bool force_common_initial =false)\nExpectation step. void Maximization(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =false, bool calc_output =false, bool calc_measurement =false)\nMaximization step. void MaximizeDynamics() void MaximizeQ() void MaximizeInitial() void Smooth(bool force_common_initial)\nget smoothed estimates void Reset()\nreset to initial conditions void InitVars()\nInitializes the variables. Vector UpdateTheta()\nupdates parameter list, theta Protected Attributes inherited from lds::EM\u0026lt; Fit \u0026gt;\nName UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data std::vector\u0026lt; Matrix \u0026gt; x_ state estimate std::vector\u0026lt; Cube \u0026gt; P_ state estimate cov std::vector\u0026lt; Cube \u0026gt; P_t_tm1_ single-lag state covariance std::vector\u0026lt; Matrix \u0026gt; y_ output estimate Matrix diag_y_ Matrix sum_E_x_t_x_t_ state covariance (current time) Matrix sum_E_xu_tm1_xu_tm1_ state-input covariance (t-minus-1) Matrix sum_E_xu_t_xu_tm1_ single lag state-input covariance Fit fit_ Vector theta_ data_t dt_ sample period size_t n_u_ number of inputs size_t n_x_ number of states size_t n_y_ number of outputs size_t n_trials_ number of input/output data sequences std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps size_t n_t_tot_ total number of time steps across trials Detailed Description # class lds::gaussian::FitEM; This type is used in the process of fitting GLDS models by expectation-maximization (EM). Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":35,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1gaussian_1_1_fit_s_s_i_d/","title":"lds::gaussian::FitSSID","section":"Classes","content":" lds::gaussian::FitSSID # Subspace Identification (SSID) for GLDS. #include \u0026lt;lds_gaussian_fit_ssid.h\u0026gt;\nInherits from lds::SSID\u0026lt; Fit \u0026gt;\nAdditional inherited members # Public Functions inherited from lds::SSID\u0026lt; Fit \u0026gt;\nName SSID() =default\nConstructs a new SSIDFit type. SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train, const Vector \u0026amp; d =Vector(1).fill(-kInf))\nConstructs a new SSIDFit type. std::tuple\u0026lt; Fit, Vector \u0026gt; Run(SSIDWt ssid_wt)\nRuns fitting by subspace identification (SSID) std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the I/O data to caller. Protected Functions inherited from lds::SSID\u0026lt; Fit \u0026gt;\nName void CalcD(data_t t_silence =0.1, data_t thresh_silence =0.001)\nUsing periods of silence in inputs (u), calculates the output \\ bias (d) void CreateHankelDataMat()\nCreates the block-hankel I/O data matrix. void CalcSVD(SSIDWt wt)\nperforms the singular value decomposition (SVD) void Solve(data_t wt_dc)\nsolves for LDS parameters void RecomputeExtObs()\nrecompute extended observability matrix from estimates of A, C Protected Attributes inherited from lds::SSID\u0026lt; Fit \u0026gt;\nName UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data Matrix D_ block-Hankel I/O data matrix Fit fit_ fit Matrix g_dc_ I/O gain @ DC. data_t dt_ sample period size_t n_u_ number of inputs size_t n_x_ number of states size_t n_y_ number of outputs size_t n_h_ size_t n_trials_ number of input/output data sequences std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps size_t n_t_tot_ total number of time steps across trials Matrix L_ lower triangle decomp of covariance matrix Vector s_ singular values Matrix ext_obs_t_ extended observability matrix Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":36,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1gaussian_1_1_switched_controller/","title":"lds::gaussian::SwitchedController","section":"Classes","content":" lds::gaussian::SwitchedController # Gaussian-observation SwitchedController Type. #include \u0026lt;lds_gaussian_sctrl.h\u0026gt;\nInherits from lds::SwitchedController\u0026lt; System \u0026gt;, lds::Controller\u0026lt; System \u0026gt;\nPublic Functions # Name virtual void set_y_ref(const Vector \u0026amp; y_ref) override\nsets reference output Additional inherited members # Public Functions inherited from lds::SwitchedController\u0026lt; System \u0026gt;\nName SwitchedController() =default\nConstructs a new SwitchedController. SwitchedController(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController. SwitchedController(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController (moves systems). void Switch(size_t idx, bool do_force_switch =false)\nSwitch to a different sub-system/controller. void set_Kc(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc)\nsets state feedback gains void set_Kc(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc)\nsets state feedback gains (moving) void set_Kc_inty(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_inty)\nsets integral feedback gains void set_Kc_inty(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_inty)\nsets integral feedback gains (moving) void set_Kc_u(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_u)\nsets input feedback gains void set_Kc_u(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_u)\nsets input feedback gains (moving) void set_g_design(const UniformVectorList \u0026amp; g)\nsets input gain used during controller design void set_g_design(UniformVectorList \u0026amp;\u0026amp; g)\nsets input gain used during controller design (moving) Protected Attributes inherited from lds::SwitchedController\u0026lt; System \u0026gt;\nName std::vector\u0026lt; System \u0026gt; systems_ underlying sub-systems which are switched between size_t n_sys_ number of systems size_t idx_ current system/controller index. UniformMatrixList Kc_list_ UniformMatrixList Kc_inty_list_ UniformMatrixList Kc_u_list_ UniformVectorList g_design_list_ Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\nName Controller() =default\nConstructs a new Controller. Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller. Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object. const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step) const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step) const System \u0026amp; sys() const const Matrix \u0026amp; Kc() const\nGet state feedback controller gain. const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain. const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain. const Vector \u0026amp; g_design() const\nGet input gain used in controller design. const Vector \u0026amp; u_ref() const\nGet reference input. const Vector \u0026amp; x_ref() const\nGet reference state. const Vector \u0026amp; y_ref() const\nGet reference output. size_t control_type() const\nGet controller type. data_t tau_awu() const\nGet time constant of anti-integral-windup. data_t u_lb() const\nGet control lower bound. data_t u_ub() const\nGet control upper bound. void set_sys(const System \u0026amp; sys)\nSet system. void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design) void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref) void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref) void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain. void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain. void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain. void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup. void set_control_type(size_t control_type)\nSets the control type. void set_u_lb(data_t u_lb)\nsets control lower bound void set_u_ub(data_t u_ub)\nSets control upper bound. void Reset()\nreset system and control variables. void Print()\nprints variables to stdout Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\nName System sys_ underlying LDS Vector u_ control signal Vector u_return_ control signal that is returned to user Vector g_design_ input gain of the system used for controller design Vector u_ref_ reference input Vector u_ref_prev_ reference input at previous time step Vector x_ref_ reference state Vector y_ref_ reference output Vector cx_ref_ Matrix Kc_ state controller gain Matrix Kc_u_ input controller gain (optional when control updates \\deltaU) Matrix Kc_inty_ integral controller gain Vector du_ref_ Vector dv_ref_ Vector v_ref_ Vector dv_ Vector v_ Control after g inversion (e.g., control in physical units) Vector int_e_ integrated error Vector int_e_awu_adjust_ anti-windup adjustment to intE Vector u_sat_ control signal after saturation (for antiWindup) bool do_control_prev_ bool do_lock_control_prev_ bool u_saturated_ whether control signal has reached saturation limits data_t u_lb_ lower bound on control data_t u_ub_ upper bound on control data_t tau_awu_ antiwindup time constant data_t k_awu_ data_t t_since_control_onset_ time since control epoch onset size_t control_type_ controller type Public Function Details # set_y_ref # inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":37,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1gaussian_1_1_system/","title":"lds::gaussian::System","section":"Classes","content":" lds::gaussian::System # Gaussian LDS Type. #include \u0026lt;lds_gaussian_sys.h\u0026gt;\nInherits from lds::System\nPublic Functions # Name System() =default\nConstructs a new System. System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0, data_t r0 =kDefaultR0)\nConstructs a new Gaussian System. virtual const Vector \u0026amp; Simulate(const Vector \u0026amp; u_tm1) override\nSimulate system measurement. const Matrix \u0026amp; R() const\nGet output noise covariance. void set_Q(const Matrix \u0026amp; Q) void set_R(const Matrix \u0026amp; R)\nSet output noise covariance. void set_Ke(const Matrix \u0026amp; Ke)\nSet estimator gain. void set_Ke_m(const Matrix \u0026amp; Ke_m)\nSet disturbance estimator gain. void Print()\nPrint system variables to stdout. Protected Functions # Name virtual void h() override\nSystem output function. virtual Vector h_(Vector x) override\nSystem output function: stateless. virtual void RecurseKe() override\nRecursively update estimator gain. Protected Attributes # Name Matrix R_ covariance of output noise bool do_recurse_Ke_ whether to recursively calculate estimator gain Additional inherited members # Public Functions inherited from lds::System\nName virtual ~System() void Filter(const Vector \u0026amp; u_tm1, const Vector \u0026amp; z)\nFilter data to produce causal state estimates. void f(const Vector \u0026amp; u, bool do_add_noise =false)\nsystem dynamics function size_t n_u() const\nGet number of inputs. size_t n_x() const\nGet number of states. size_t n_y() const\nGet number of outputs. data_t dt() const\nGet sample period. const Vector \u0026amp; x() const\nGet current state. const Matrix \u0026amp; P() const\nGet covariance of state estimate. const Vector \u0026amp; m() const\nGet current process disturbance/bias. const Matrix \u0026amp; P_m() const\nGet covariance of process disturbance estimate. const Vector \u0026amp; cx() const\nGet C*x. const Vector \u0026amp; y() const\nGet output. const Vector \u0026amp; x0() const\nGet initial state. const Vector \u0026amp; m0() const\nGet initial disturbance. const Matrix \u0026amp; A() const\nGet state matrix. const Matrix \u0026amp; B() const\nGet input matrix. const Vector \u0026amp; g() const\nGet input gain/conversion factor. const Matrix \u0026amp; C() const\nGet output matrix. const Vector \u0026amp; d() const\nGet output bias. const Matrix \u0026amp; Ke() const\nGet estimator gain. const Matrix \u0026amp; Ke_m() const\nGet estimator gain for process disturbance (m) const Matrix \u0026amp; Q()\nGet process noise covariance. const Matrix \u0026amp; Q_m()\nGet process noise covariance of disturbance evoluation. const Matrix \u0026amp; P0()\nGet covariance of initial state. const Matrix \u0026amp; P0_m()\nGet covariance of initial process disturbance. void set_A(const Matrix \u0026amp; A)\nSet state matrix. void set_B(const Matrix \u0026amp; B)\nSet input matrix. void set_m(const Vector \u0026amp; m, bool do_force_assign =false)\nSet process disturbance. void set_g(const Vector \u0026amp; g)\nSet input gain. void set_Q_m(const Matrix \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation. void set_x0(const Vector \u0026amp; x0)\nSet initial state. void set_P0(const Matrix \u0026amp; P0)\nSet covariance of initial state. void set_P0_m(const Matrix \u0026amp; P0_m)\nSet covariance of initial process disturbance. void set_C(const Matrix \u0026amp; C)\nSet output matrix. void set_d(const Vector \u0026amp; d)\nSet output bias. void set_x(const Vector \u0026amp; x)\nSet state of system. void Reset()\nReset system variables. std::vector\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; nstep_pred_block(UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z, size_t n_pred =1) Protected Functions inherited from lds::System\nName void InitVars(data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0) Public Attributes inherited from lds::System\nName bool do_adapt_m whether to adaptively estimate disturbance m Protected Attributes inherited from lds::System\nName std::size_t n_x_ number of states std::size_t n_u_ number of inputs std::size_t n_y_ number of outputs data_t dt_ sample period Vector x_ state Matrix P_ covariance of state estimate Vector m_ process disturbance Matrix P_m_ covariance of disturbance estimate Vector cx_ C*x. Vector y_ output Vector z_ measurement Vector x0_ initial state Matrix P0_ covariance of initial state estimate Vector m0_ initial process disturbance Matrix P0_m_ covariance of initial disturbance est. Matrix A_ state matrix Matrix B_ input matrix Vector g_ input gain Matrix Q_ covariance of process noise Matrix Q_m_ covariance of disturbance random walk Matrix C_ output matrix Vector d_ output bias Matrix Ke_ estimator gain Matrix Ke_m_ estimator gain for process disturbance Public Function Details # System # System() =default System # System( std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0, data_t r0 =kDefaultR0 ) Parameters:\nn_u number of inputs (u) n_x number of states (x) n_y number of outputs (y) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) r0 [optional] initial diagonal elements of output noise covariance (R) Simulate # virtual const Vector \u0026amp; Simulate( const Vector \u0026amp; u_tm1 ) override Parameters:\nu_tm1 input at t-1 Return: z measurement\nReimplements: lds::System::Simulate\nSimulate system and produce measurement\nR # inline const Matrix \u0026amp; R() const set_Q # inline void set_Q( const Matrix \u0026amp; Q ) set_R # inline void set_R( const Matrix \u0026amp; R ) set_Ke # inline void set_Ke( const Matrix \u0026amp; Ke ) set_Ke_m # inline void set_Ke_m( const Matrix \u0026amp; Ke_m ) Print # void Print() Protected Function Details # h # inline virtual void h() override Reimplements: lds::System::h\nh_ # inline virtual Vector h_( Vector x ) override Reimplements: lds::System::h_\nRecurseKe # virtual void RecurseKe() override Reimplements: lds::System::RecurseKe\nProtected Attribute Details # R_ # Matrix R_; do_recurse_Ke_ # bool do_recurse_Ke_ {}; Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":38,"href":"/lds-ctrl-est/docs/api/namespaces/namespacelds_1_1poisson/","title":"lds::poisson","section":"Namespaces","content":" lds::poisson # Linear Dynamical Systems with Poisson observations. Classes # Name class lds::poisson::Controller PLDS Controller Type. class lds::poisson::Fit PLDS Fit Type. class lds::poisson::FitEM PLDS E-M Fit Type. class lds::poisson::FitSSID Subspace Identification (SSID) for PLDS. class lds::poisson::SwitchedController Poisson-observation SwitchedController Type. class lds::poisson::System Poisson System type. Attributes # Name std::random_device rd random device for simulating poisson data std::mt19937 rng random number generator for simulating poisson data Attribute Details # rd # static std::random_device rd; rng # static std::mt19937 rng = std::mt19937( rd()); Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":39,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1poisson_1_1_controller/","title":"lds::poisson::Controller","section":"Classes","content":" lds::poisson::Controller # PLDS Controller Type. #include \u0026lt;lds_poisson_ctrl.h\u0026gt;\nInherits from lds::Controller\u0026lt; System \u0026gt;\nPublic Functions # Name virtual void set_y_ref(const Vector \u0026amp; y_ref) override\nSet reference output. Additional inherited members # Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\nName Controller() =default\nConstructs a new Controller. Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller. Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object. const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step) const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step) const System \u0026amp; sys() const const Matrix \u0026amp; Kc() const\nGet state feedback controller gain. const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain. const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain. const Vector \u0026amp; g_design() const\nGet input gain used in controller design. const Vector \u0026amp; u_ref() const\nGet reference input. const Vector \u0026amp; x_ref() const\nGet reference state. const Vector \u0026amp; y_ref() const\nGet reference output. size_t control_type() const\nGet controller type. data_t tau_awu() const\nGet time constant of anti-integral-windup. data_t u_lb() const\nGet control lower bound. data_t u_ub() const\nGet control upper bound. void set_sys(const System \u0026amp; sys)\nSet system. void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design) void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref) void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref) void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain. void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain. void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain. void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup. void set_control_type(size_t control_type)\nSets the control type. void set_u_lb(data_t u_lb)\nsets control lower bound void set_u_ub(data_t u_ub)\nSets control upper bound. void Reset()\nreset system and control variables. void Print()\nprints variables to stdout Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\nName System sys_ underlying LDS Vector u_ control signal Vector u_return_ control signal that is returned to user Vector g_design_ input gain of the system used for controller design Vector u_ref_ reference input Vector u_ref_prev_ reference input at previous time step Vector x_ref_ reference state Vector y_ref_ reference output Vector cx_ref_ Matrix Kc_ state controller gain Matrix Kc_u_ input controller gain (optional when control updates \\deltaU) Matrix Kc_inty_ integral controller gain Vector du_ref_ Vector dv_ref_ Vector v_ref_ Vector dv_ Vector v_ Control after g inversion (e.g., control in physical units) Vector int_e_ integrated error Vector int_e_awu_adjust_ anti-windup adjustment to intE Vector u_sat_ control signal after saturation (for antiWindup) bool do_control_prev_ bool do_lock_control_prev_ bool u_saturated_ whether control signal has reached saturation limits data_t u_lb_ lower bound on control data_t u_ub_ upper bound on control data_t tau_awu_ antiwindup time constant data_t k_awu_ data_t t_since_control_onset_ time since control epoch onset size_t control_type_ controller type Public Function Details # set_y_ref # inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":40,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1poisson_1_1_fit/","title":"lds::poisson::Fit","section":"Classes","content":" lds::poisson::Fit # PLDS Fit Type. #include \u0026lt;lds_poisson_fit.h\u0026gt;\nInherits from lds::Fit\nPublic Functions # Name Fit() =default Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt)\nConstructs a new Fit. virtual View h(Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t) override\noutput function virtual void set_R(const Matrix \u0026amp; R) override\nsets output noise covariance (if any) virtual const Matrix \u0026amp; R() const override Additional inherited members # Public Functions inherited from lds::Fit\nName virtual ~Fit() =default size_t n_u() const\ngets number of inputs size_t n_x() const\ngets number of states size_t n_y() const\ngets number of outputs data_t dt() const\ngets sample period const Matrix \u0026amp; A() const\ngets state matrix const Matrix \u0026amp; B() const\ngets input matrix const Vector \u0026amp; g() const\ngets input gain const Vector \u0026amp; m() const\ngets process disturbance const Matrix \u0026amp; Q() const\ngets process noise covariance const Vector \u0026amp; x0() const\ngets initial state estimate const Matrix \u0026amp; P0() const\ngets covariance of initial state estimate const Matrix \u0026amp; C() const\ngets output matrix const Vector \u0026amp; d() const\ngets output bias void set_A(const Matrix \u0026amp; A)\nsets state matrix void set_B(const Matrix \u0026amp; B)\nsets input matrix void set_g(const Vector \u0026amp; g)\nsets input gain/conversion factor void set_m(const Vector \u0026amp; m)\nsets process disturbance void set_Q(const Matrix \u0026amp; Q)\nsets process noise covariance void set_x0(const Vector \u0026amp; x0)\nsets initial state estimate void set_P0(const Matrix \u0026amp; P0)\nsets initial state estimate covariance void set_C(const Matrix \u0026amp; C)\nsets output matrix void set_d(const Vector \u0026amp; d)\nsets output bias View f(Matrix \u0026amp; x, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function View f(Matrix \u0026amp; x_pre, const Matrix \u0026amp; x_post, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function Protected Attributes inherited from lds::Fit\nName data_t dt_ sample period Matrix A_ state matrix Matrix B_ input matrix Vector g_ input gain Vector m_ process noise mean Matrix Q_ process noise cov Matrix C_ output matrix Vector d_ output bias Matrix R_ measurement noise Vector x0_ initial state Matrix P0_ initial covar size_t n_u_ number of inputs size_t n_x_ number of states size_t n_y_ number of outputs Public Function Details # Fit # Fit() =default Fit # inline Fit( size_t n_u, size_t n_x, size_t n_y, data_t dt ) Parameters:\nn_u number of inputs n_x number of states n_y number of outputs dt sample period h # inline virtual View h( Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t ) override Parameters:\ny output estimate (over time) x state estimate (over time) t time index Return: output\nReimplements: lds::Fit::h\nset_R # inline virtual void set_R( const Matrix \u0026amp; R ) override Reimplements: lds::Fit::set_R\nR # inline virtual const Matrix \u0026amp; R() const override Reimplements: lds::Fit::R\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":41,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1poisson_1_1_fit_e_m/","title":"lds::poisson::FitEM","section":"Classes","content":" lds::poisson::FitEM # PLDS E-M Fit Type. More\u0026hellip;\n#include \u0026lt;lds_poisson_fit_em.h\u0026gt;\nInherits from lds::EM\u0026lt; Fit \u0026gt;\nAdditional inherited members # Public Functions inherited from lds::EM\u0026lt; Fit \u0026gt;\nName EM() =default\nConstructs a new EMFit type. EM(size_t n_x, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMFit type. EM(const Fit \u0026amp; fit0, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMFit type. virtual ~EM() =default const Fit \u0026amp; Run(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =true, bool calc_output =true, bool calc_measurement =true, size_t max_iter =100, data_t tol =1e-2)\nRuns fitting by Expectation(E)-Maximization(M) std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the input/output data to caller. const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; x() const\ngets estimated state (over time) const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; y() const\ngets estimated output (over time) const Matrix \u0026amp; sum_E_x_t_x_t() const\ngets state-input covariance const Matrix \u0026amp; sum_E_xu_tm1_xu_tm1() const\ngets state-input covariance (t-minus-1) const Matrix \u0026amp; sum_E_xu_t_xu_tm1() const\ngets single lag state-input covariance size_t n_t_tot()\ntotal number of time samples const Vector \u0026amp; theta() const\ngets parameters updated in M step Protected Functions inherited from lds::EM\u0026lt; Fit \u0026gt;\nName void Expectation(bool force_common_initial =false)\nExpectation step. void Maximization(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =false, bool calc_output =false, bool calc_measurement =false)\nMaximization step. void MaximizeDynamics() void MaximizeQ() void MaximizeInitial() void Smooth(bool force_common_initial)\nget smoothed estimates void Reset()\nreset to initial conditions void InitVars()\nInitializes the variables. Vector UpdateTheta()\nupdates parameter list, theta Protected Attributes inherited from lds::EM\u0026lt; Fit \u0026gt;\nName UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data std::vector\u0026lt; Matrix \u0026gt; x_ state estimate std::vector\u0026lt; Cube \u0026gt; P_ state estimate cov std::vector\u0026lt; Cube \u0026gt; P_t_tm1_ single-lag state covariance std::vector\u0026lt; Matrix \u0026gt; y_ output estimate Matrix diag_y_ Matrix sum_E_x_t_x_t_ state covariance (current time) Matrix sum_E_xu_tm1_xu_tm1_ state-input covariance (t-minus-1) Matrix sum_E_xu_t_xu_tm1_ single lag state-input covariance Fit fit_ Vector theta_ data_t dt_ sample period size_t n_u_ number of inputs size_t n_x_ number of states size_t n_y_ number of outputs size_t n_trials_ number of input/output data sequences std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps size_t n_t_tot_ total number of time steps across trials Detailed Description # class lds::poisson::FitEM; This type is used in the process of fitting PLDS models by expectation-maximization (EM). Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":42,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1poisson_1_1_fit_s_s_i_d/","title":"lds::poisson::FitSSID","section":"Classes","content":" lds::poisson::FitSSID # Subspace Identification (SSID) for PLDS. #include \u0026lt;lds_poisson_fit_ssid.h\u0026gt;\nInherits from lds::SSID\u0026lt; Fit \u0026gt;\nAdditional inherited members # Public Functions inherited from lds::SSID\u0026lt; Fit \u0026gt;\nName SSID() =default\nConstructs a new SSIDFit type. SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train, const Vector \u0026amp; d =Vector(1).fill(-kInf))\nConstructs a new SSIDFit type. std::tuple\u0026lt; Fit, Vector \u0026gt; Run(SSIDWt ssid_wt)\nRuns fitting by subspace identification (SSID) std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the I/O data to caller. Protected Functions inherited from lds::SSID\u0026lt; Fit \u0026gt;\nName void CalcD(data_t t_silence =0.1, data_t thresh_silence =0.001)\nUsing periods of silence in inputs (u), calculates the output \\ bias (d) void CreateHankelDataMat()\nCreates the block-hankel I/O data matrix. void CalcSVD(SSIDWt wt)\nperforms the singular value decomposition (SVD) void Solve(data_t wt_dc)\nsolves for LDS parameters void RecomputeExtObs()\nrecompute extended observability matrix from estimates of A, C Protected Attributes inherited from lds::SSID\u0026lt; Fit \u0026gt;\nName UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data Matrix D_ block-Hankel I/O data matrix Fit fit_ fit Matrix g_dc_ I/O gain @ DC. data_t dt_ sample period size_t n_u_ number of inputs size_t n_x_ number of states size_t n_y_ number of outputs size_t n_h_ size_t n_trials_ number of input/output data sequences std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps size_t n_t_tot_ total number of time steps across trials Matrix L_ lower triangle decomp of covariance matrix Vector s_ singular values Matrix ext_obs_t_ extended observability matrix Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":43,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1poisson_1_1_switched_controller/","title":"lds::poisson::SwitchedController","section":"Classes","content":" lds::poisson::SwitchedController # Poisson-observation SwitchedController Type. #include \u0026lt;lds_poisson_sctrl.h\u0026gt;\nInherits from lds::SwitchedController\u0026lt; System \u0026gt;, lds::Controller\u0026lt; System \u0026gt;\nPublic Functions # Name virtual void set_y_ref(const Vector \u0026amp; y_ref) override\nSet reference output. Additional inherited members # Public Functions inherited from lds::SwitchedController\u0026lt; System \u0026gt;\nName SwitchedController() =default\nConstructs a new SwitchedController. SwitchedController(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController. SwitchedController(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController (moves systems). void Switch(size_t idx, bool do_force_switch =false)\nSwitch to a different sub-system/controller. void set_Kc(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc)\nsets state feedback gains void set_Kc(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc)\nsets state feedback gains (moving) void set_Kc_inty(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_inty)\nsets integral feedback gains void set_Kc_inty(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_inty)\nsets integral feedback gains (moving) void set_Kc_u(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_u)\nsets input feedback gains void set_Kc_u(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_u)\nsets input feedback gains (moving) void set_g_design(const UniformVectorList \u0026amp; g)\nsets input gain used during controller design void set_g_design(UniformVectorList \u0026amp;\u0026amp; g)\nsets input gain used during controller design (moving) Protected Attributes inherited from lds::SwitchedController\u0026lt; System \u0026gt;\nName std::vector\u0026lt; System \u0026gt; systems_ underlying sub-systems which are switched between size_t n_sys_ number of systems size_t idx_ current system/controller index. UniformMatrixList Kc_list_ UniformMatrixList Kc_inty_list_ UniformMatrixList Kc_u_list_ UniformVectorList g_design_list_ Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\nName Controller() =default\nConstructs a new Controller. Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller. Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object. const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step) const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step) const System \u0026amp; sys() const const Matrix \u0026amp; Kc() const\nGet state feedback controller gain. const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain. const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain. const Vector \u0026amp; g_design() const\nGet input gain used in controller design. const Vector \u0026amp; u_ref() const\nGet reference input. const Vector \u0026amp; x_ref() const\nGet reference state. const Vector \u0026amp; y_ref() const\nGet reference output. size_t control_type() const\nGet controller type. data_t tau_awu() const\nGet time constant of anti-integral-windup. data_t u_lb() const\nGet control lower bound. data_t u_ub() const\nGet control upper bound. void set_sys(const System \u0026amp; sys)\nSet system. void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design) void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref) void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref) void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain. void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain. void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain. void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup. void set_control_type(size_t control_type)\nSets the control type. void set_u_lb(data_t u_lb)\nsets control lower bound void set_u_ub(data_t u_ub)\nSets control upper bound. void Reset()\nreset system and control variables. void Print()\nprints variables to stdout Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\nName System sys_ underlying LDS Vector u_ control signal Vector u_return_ control signal that is returned to user Vector g_design_ input gain of the system used for controller design Vector u_ref_ reference input Vector u_ref_prev_ reference input at previous time step Vector x_ref_ reference state Vector y_ref_ reference output Vector cx_ref_ Matrix Kc_ state controller gain Matrix Kc_u_ input controller gain (optional when control updates \\deltaU) Matrix Kc_inty_ integral controller gain Vector du_ref_ Vector dv_ref_ Vector v_ref_ Vector dv_ Vector v_ Control after g inversion (e.g., control in physical units) Vector int_e_ integrated error Vector int_e_awu_adjust_ anti-windup adjustment to intE Vector u_sat_ control signal after saturation (for antiWindup) bool do_control_prev_ bool do_lock_control_prev_ bool u_saturated_ whether control signal has reached saturation limits data_t u_lb_ lower bound on control data_t u_ub_ upper bound on control data_t tau_awu_ antiwindup time constant data_t k_awu_ data_t t_since_control_onset_ time since control epoch onset size_t control_type_ controller type Public Function Details # set_y_ref # inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":44,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1poisson_1_1_system/","title":"lds::poisson::System","section":"Classes","content":" lds::poisson::System # Poisson System type. #include \u0026lt;lds_poisson_sys.h\u0026gt;\nInherits from lds::System\nPublic Functions # Name System() =default\nConstructs a new System. System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0)\nConstructs a new Poisson System. virtual const Vector \u0026amp; Simulate(const Vector \u0026amp; u_tm1) override\nSimulate system measurement. Protected Functions # Name virtual void h() override\nSystem output function. virtual Vector h_(Vector x) override\nSystem output function: stateless. virtual void RecurseKe() override\nRecursively recalculate estimator gain (Ke) Additional inherited members # Public Functions inherited from lds::System\nName virtual ~System() void Filter(const Vector \u0026amp; u_tm1, const Vector \u0026amp; z)\nFilter data to produce causal state estimates. void f(const Vector \u0026amp; u, bool do_add_noise =false)\nsystem dynamics function size_t n_u() const\nGet number of inputs. size_t n_x() const\nGet number of states. size_t n_y() const\nGet number of outputs. data_t dt() const\nGet sample period. const Vector \u0026amp; x() const\nGet current state. const Matrix \u0026amp; P() const\nGet covariance of state estimate. const Vector \u0026amp; m() const\nGet current process disturbance/bias. const Matrix \u0026amp; P_m() const\nGet covariance of process disturbance estimate. const Vector \u0026amp; cx() const\nGet C*x. const Vector \u0026amp; y() const\nGet output. const Vector \u0026amp; x0() const\nGet initial state. const Vector \u0026amp; m0() const\nGet initial disturbance. const Matrix \u0026amp; A() const\nGet state matrix. const Matrix \u0026amp; B() const\nGet input matrix. const Vector \u0026amp; g() const\nGet input gain/conversion factor. const Matrix \u0026amp; C() const\nGet output matrix. const Vector \u0026amp; d() const\nGet output bias. const Matrix \u0026amp; Ke() const\nGet estimator gain. const Matrix \u0026amp; Ke_m() const\nGet estimator gain for process disturbance (m) const Matrix \u0026amp; Q()\nGet process noise covariance. const Matrix \u0026amp; Q_m()\nGet process noise covariance of disturbance evoluation. const Matrix \u0026amp; P0()\nGet covariance of initial state. const Matrix \u0026amp; P0_m()\nGet covariance of initial process disturbance. void set_A(const Matrix \u0026amp; A)\nSet state matrix. void set_B(const Matrix \u0026amp; B)\nSet input matrix. void set_m(const Vector \u0026amp; m, bool do_force_assign =false)\nSet process disturbance. void set_g(const Vector \u0026amp; g)\nSet input gain. void set_Q(const Matrix \u0026amp; Q)\nSet process noise covariance. void set_Q_m(const Matrix \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation. void set_x0(const Vector \u0026amp; x0)\nSet initial state. void set_P0(const Matrix \u0026amp; P0)\nSet covariance of initial state. void set_P0_m(const Matrix \u0026amp; P0_m)\nSet covariance of initial process disturbance. void set_C(const Matrix \u0026amp; C)\nSet output matrix. void set_d(const Vector \u0026amp; d)\nSet output bias. void set_x(const Vector \u0026amp; x)\nSet state of system. void Reset()\nReset system variables. std::vector\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; nstep_pred_block(UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z, size_t n_pred =1) void Print()\nPrint system variables to stdout. Protected Functions inherited from lds::System\nName void InitVars(data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0) Public Attributes inherited from lds::System\nName bool do_adapt_m whether to adaptively estimate disturbance m Protected Attributes inherited from lds::System\nName std::size_t n_x_ number of states std::size_t n_u_ number of inputs std::size_t n_y_ number of outputs data_t dt_ sample period Vector x_ state Matrix P_ covariance of state estimate Vector m_ process disturbance Matrix P_m_ covariance of disturbance estimate Vector cx_ C*x. Vector y_ output Vector z_ measurement Vector x0_ initial state Matrix P0_ covariance of initial state estimate Vector m0_ initial process disturbance Matrix P0_m_ covariance of initial disturbance est. Matrix A_ state matrix Matrix B_ input matrix Vector g_ input gain Matrix Q_ covariance of process noise Matrix Q_m_ covariance of disturbance random walk Matrix C_ output matrix Vector d_ output bias Matrix Ke_ estimator gain Matrix Ke_m_ estimator gain for process disturbance Public Function Details # System # System() =default System # System( std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0 ) Parameters:\nn_u number of inputs n_x number of states n_y number of outputs dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) Simulate # virtual const Vector \u0026amp; Simulate( const Vector \u0026amp; u_tm1 ) override Parameters:\nu_tm1 input at t-1 Return: z measurement\nReimplements: lds::System::Simulate\nSimulate system and produce measurement\nProtected Function Details # h # inline virtual void h() override Reimplements: lds::System::h\nh_ # inline virtual Vector h_( Vector x ) override Reimplements: lds::System::h_\nRecurseKe # virtual void RecurseKe() override Reimplements: lds::System::RecurseKe\nRecursively recalculate estimator gain (Ke).\nReferences:\nSmith AC, Brown EN. (2003) Estimating a State-Space Model from Point Process Observations. Neural Computation 15.\nEden UT, \u0026hellip;, Brown EN. (2004) Dynamic Analysis of Neural Encoding by Point Process Adaptive Filtering Neural Computation 16.\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":45,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1_s_s_i_d/","title":"lds::SSID","section":"Classes","content":" lds::SSID # More\u0026hellip;\nInherited by lds::gaussian::FitSSID, lds::poisson::FitSSID\nPublic Functions # Name SSID() =default\nConstructs a new SSIDFit type. SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train, const Vector \u0026amp; d =Vector(1).fill(-kInf))\nConstructs a new SSIDFit type. std::tuple\u0026lt; Fit, Vector \u0026gt; Run(SSIDWt ssid_wt)\nRuns fitting by subspace identification (SSID) std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the I/O data to caller. Protected Functions # Name void CalcD(data_t t_silence =0.1, data_t thresh_silence =0.001)\nUsing periods of silence in inputs (u), calculates the output \\ bias (d) void CreateHankelDataMat()\nCreates the block-hankel I/O data matrix. virtual void DecomposeData() =0\nDecompose data to lower-triangular matrix (used in Solve) void CalcSVD(SSIDWt wt)\nperforms the singular value decomposition (SVD) void Solve(data_t wt_dc)\nsolves for LDS parameters void RecomputeExtObs()\nrecompute extended observability matrix from estimates of A, C Protected Attributes # Name UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data Matrix D_ block-Hankel I/O data matrix Fit fit_ fit Matrix g_dc_ I/O gain @ DC. data_t dt_ sample period size_t n_u_ number of inputs size_t n_x_ number of states size_t n_y_ number of outputs size_t n_h_ size_t n_trials_ number of input/output data sequences std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps size_t n_t_tot_ total number of time steps across trials Matrix L_ lower triangle decomp of covariance matrix Vector s_ singular values Matrix ext_obs_t_ extended observability matrix Detailed Description # template \u0026lt;typename Fit \u0026gt; class lds::SSID; Public Function Details # SSID # SSID() =default SSID # SSID( size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train, const Vector \u0026amp; d =Vector(1).fill(-kInf) ) Parameters:\nn_x number of states n_h size of block-hankel data matrix dt sample period u_train input training data z_train measurement training data d output bias Run # std::tuple\u0026lt; Fit, Vector \u0026gt; Run( SSIDWt ssid_wt ) Parameters:\nssid_wt weight for singular value decomp Return: tuple (Fit, singular values)\nReturnData # inline std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData() Return: tuple(input data, output data)\nProtected Function Details # CalcD # void CalcD( data_t t_silence =0.1, data_t thresh_silence =0.001 ) Parameters:\nt_silence threshold on period of time that qualifies as \u0026ldquo;silence\u0026rdquo; thresh_silence threshold on input amplitude u that qualifies as \u0026ldquo;silence\u0026rdquo; CreateHankelDataMat # void CreateHankelDataMat() Creates the block-hankel I/O data matrix. Also calculates I/O gain @ DC.\nDecomposeData # virtual void DecomposeData() =0 Reimplemented by: lds::gaussian::FitSSID::DecomposeData, lds::poisson::FitSSID::DecomposeData\nCalcSVD # void CalcSVD( SSIDWt wt ) Parameters:\nssid_wt weight for SVD Solve # void Solve( data_t wt_dc ) Parameters:\nwt_dc weight placed on getting correct DC I/O gain RecomputeExtObs # void RecomputeExtObs() Protected Attribute Details # u_ # UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_; z_ # UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_; D_ # Matrix D_; fit_ # Fit fit_; g_dc_ # Matrix g_dc_; dt_ # data_t dt_ {}; n_u_ # size_t n_u_ {}; n_x_ # size_t n_x_ {}; n_y_ # size_t n_y_ {}; n_h_ # size_t n_h_ {}; n_trials_ # size_t n_trials_ {}; n_t_ # std::vector\u0026lt; size_t \u0026gt; n_t_; n_t_tot_ # size_t n_t_tot_ {}; L_ # Matrix L_; s_ # Vector s_; ext_obs_t_ # Matrix ext_obs_t_; Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":46,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1_switched_controller/","title":"lds::SwitchedController","section":"Classes","content":" lds::SwitchedController # SwitchedController Type. More\u0026hellip;\n#include \u0026lt;lds_sctrl.h\u0026gt;\nInherits from lds::Controller\u0026lt; System \u0026gt;\nInherited by lds::gaussian::SwitchedController, lds::poisson::SwitchedController\nPublic Functions # Name SwitchedController() =default\nConstructs a new SwitchedController. SwitchedController(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController. SwitchedController(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController (moves systems). void Switch(size_t idx, bool do_force_switch =false)\nSwitch to a different sub-system/controller. void set_Kc(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc)\nsets state feedback gains void set_Kc(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc)\nsets state feedback gains (moving) void set_Kc_inty(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_inty)\nsets integral feedback gains void set_Kc_inty(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_inty)\nsets integral feedback gains (moving) void set_Kc_u(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_u)\nsets input feedback gains void set_Kc_u(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_u)\nsets input feedback gains (moving) void set_g_design(const UniformVectorList \u0026amp; g)\nsets input gain used during controller design void set_g_design(UniformVectorList \u0026amp;\u0026amp; g)\nsets input gain used during controller design (moving) Protected Attributes # Name std::vector\u0026lt; System \u0026gt; systems_ underlying sub-systems which are switched between size_t n_sys_ number of systems size_t idx_ current system/controller index. UniformMatrixList Kc_list_ UniformMatrixList Kc_inty_list_ UniformMatrixList Kc_u_list_ UniformVectorList g_design_list_ Additional inherited members # Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\nName Controller() =default\nConstructs a new Controller. Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller. Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object. const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step) const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step) const System \u0026amp; sys() const const Matrix \u0026amp; Kc() const\nGet state feedback controller gain. const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain. const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain. const Vector \u0026amp; g_design() const\nGet input gain used in controller design. const Vector \u0026amp; u_ref() const\nGet reference input. const Vector \u0026amp; x_ref() const\nGet reference state. const Vector \u0026amp; y_ref() const\nGet reference output. size_t control_type() const\nGet controller type. data_t tau_awu() const\nGet time constant of anti-integral-windup. data_t u_lb() const\nGet control lower bound. data_t u_ub() const\nGet control upper bound. void set_sys(const System \u0026amp; sys)\nSet system. void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref) void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref) virtual void set_y_ref(const Vector \u0026amp; y_ref)\nSet reference output (y_ref) void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup. void set_control_type(size_t control_type)\nSets the control type. void set_u_lb(data_t u_lb)\nsets control lower bound void set_u_ub(data_t u_ub)\nSets control upper bound. void Reset()\nreset system and control variables. void Print()\nprints variables to stdout Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\nName System sys_ underlying LDS Vector u_ control signal Vector u_return_ control signal that is returned to user Vector g_design_ input gain of the system used for controller design Vector u_ref_ reference input Vector u_ref_prev_ reference input at previous time step Vector x_ref_ reference state Vector y_ref_ reference output Vector cx_ref_ Matrix Kc_ state controller gain Matrix Kc_u_ input controller gain (optional when control updates \\deltaU) Matrix Kc_inty_ integral controller gain Vector du_ref_ Vector dv_ref_ Vector v_ref_ Vector dv_ Vector v_ Control after g inversion (e.g., control in physical units) Vector int_e_ integrated error Vector int_e_awu_adjust_ anti-windup adjustment to intE Vector u_sat_ control signal after saturation (for antiWindup) bool do_control_prev_ bool do_lock_control_prev_ bool u_saturated_ whether control signal has reached saturation limits data_t u_lb_ lower bound on control data_t u_ub_ upper bound on control data_t tau_awu_ antiwindup time constant data_t k_awu_ data_t t_since_control_onset_ time since control epoch onset size_t control_type_ controller type Detailed Description # template \u0026lt;typename System \u0026gt; class lds::SwitchedController; Public Function Details # SwitchedController # SwitchedController() =default SwitchedController # inline SwitchedController( const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\nsystems vector of sub-systems u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask SwitchedController # inline SwitchedController( std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\nsystems vector of sub-systems u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask Switch # inline void Switch( size_t idx, bool do_force_switch =false ) Parameters:\nidx index do_force_switch whether to force a system switch even if already there. set_Kc # inline void set_Kc( const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc ) set_Kc # inline void set_Kc( UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc ) set_Kc_inty # inline void set_Kc_inty( const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_inty ) set_Kc_inty # inline void set_Kc_inty( UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_inty ) set_Kc_u # inline void set_Kc_u( const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_u ) set_Kc_u # inline void set_Kc_u( UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_u ) set_g_design # inline void set_g_design( const UniformVectorList \u0026amp; g ) set_g_design # inline void set_g_design( UniformVectorList \u0026amp;\u0026amp; g ) Protected Attribute Details # systems_ # std::vector\u0026lt; System \u0026gt; systems_; n_sys_ # size_t n_sys_ {}; idx_ # size_t idx_ {}; Kc_list_ # UniformMatrixList Kc_list_; Kc_inty_list_ # UniformMatrixList Kc_inty_list_; Kc_u_list_ # UniformMatrixList Kc_u_list_; g_design_list_ # UniformVectorList g_design_list_; Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":47,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1_system/","title":"lds::System","section":"Classes","content":" lds::System # Linear Dynamical System Type. #include \u0026lt;lds_sys.h\u0026gt;\nInherited by lds::gaussian::System, lds::poisson::System\nPublic Functions # Name System() =default\nConstructs a new System. System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0)\nconstructs a new System virtual ~System() void Filter(const Vector \u0026amp; u_tm1, const Vector \u0026amp; z)\nFilter data to produce causal state estimates. virtual const Vector \u0026amp; Simulate(const Vector \u0026amp; u_tm1) =0\nsimulates system (single time step) void f(const Vector \u0026amp; u, bool do_add_noise =false)\nsystem dynamics function virtual void h() =0\nsystem output function virtual Vector h_(Vector x) =0\nsystem output function (stateless) size_t n_u() const\nGet number of inputs. size_t n_x() const\nGet number of states. size_t n_y() const\nGet number of outputs. data_t dt() const\nGet sample period. const Vector \u0026amp; x() const\nGet current state. const Matrix \u0026amp; P() const\nGet covariance of state estimate. const Vector \u0026amp; m() const\nGet current process disturbance/bias. const Matrix \u0026amp; P_m() const\nGet covariance of process disturbance estimate. const Vector \u0026amp; cx() const\nGet C*x. const Vector \u0026amp; y() const\nGet output. const Vector \u0026amp; x0() const\nGet initial state. const Vector \u0026amp; m0() const\nGet initial disturbance. const Matrix \u0026amp; A() const\nGet state matrix. const Matrix \u0026amp; B() const\nGet input matrix. const Vector \u0026amp; g() const\nGet input gain/conversion factor. const Matrix \u0026amp; C() const\nGet output matrix. const Vector \u0026amp; d() const\nGet output bias. const Matrix \u0026amp; Ke() const\nGet estimator gain. const Matrix \u0026amp; Ke_m() const\nGet estimator gain for process disturbance (m) const Matrix \u0026amp; Q()\nGet process noise covariance. const Matrix \u0026amp; Q_m()\nGet process noise covariance of disturbance evoluation. const Matrix \u0026amp; P0()\nGet covariance of initial state. const Matrix \u0026amp; P0_m()\nGet covariance of initial process disturbance. void set_A(const Matrix \u0026amp; A)\nSet state matrix. void set_B(const Matrix \u0026amp; B)\nSet input matrix. void set_m(const Vector \u0026amp; m, bool do_force_assign =false)\nSet process disturbance. void set_g(const Vector \u0026amp; g)\nSet input gain. void set_Q(const Matrix \u0026amp; Q)\nSet process noise covariance. void set_Q_m(const Matrix \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation. void set_x0(const Vector \u0026amp; x0)\nSet initial state. void set_P0(const Matrix \u0026amp; P0)\nSet covariance of initial state. void set_P0_m(const Matrix \u0026amp; P0_m)\nSet covariance of initial process disturbance. void set_C(const Matrix \u0026amp; C)\nSet output matrix. void set_d(const Vector \u0026amp; d)\nSet output bias. void set_x(const Vector \u0026amp; x)\nSet state of system. void Reset()\nReset system variables. std::vector\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; nstep_pred_block(UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z, size_t n_pred =1) void Print()\nPrint system variables to stdout. Protected Functions # Name virtual void RecurseKe() =0\nRecursively recalculate estimator gain (Ke) void InitVars(data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0) Public Attributes # Name bool do_adapt_m whether to adaptively estimate disturbance m Protected Attributes # Name std::size_t n_x_ number of states std::size_t n_u_ number of inputs std::size_t n_y_ number of outputs data_t dt_ sample period Vector x_ state Matrix P_ covariance of state estimate Vector m_ process disturbance Matrix P_m_ covariance of disturbance estimate Vector cx_ C*x. Vector y_ output Vector z_ measurement Vector x0_ initial state Matrix P0_ covariance of initial state estimate Vector m0_ initial process disturbance Matrix P0_m_ covariance of initial disturbance est. Matrix A_ state matrix Matrix B_ input matrix Vector g_ input gain Matrix Q_ covariance of process noise Matrix Q_m_ covariance of disturbance random walk Matrix C_ output matrix Vector d_ output bias Matrix Ke_ estimator gain Matrix Ke_m_ estimator gain for process disturbance Public Function Details # System # System() =default System # System( size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0 ) Parameters:\nn_u number of inputs n_x number of states n_y number of outputs dt sample period p0 diagonal elements for state estimate covariance q0 diagonal elements for process noise covariance ~System # inline virtual ~System() Filter # void Filter( const Vector \u0026amp; u_tm1, const Vector \u0026amp; z ) Parameters:\nu_tm1 input at t-minus-1 z_t current measurement Given current measurement and input, filter data to produce causal state estimates using Kalman filtering, which procedes by predicting the state and subsequently updating.\nSimulate # virtual const Vector \u0026amp; Simulate( const Vector \u0026amp; u_tm1 ) =0 Parameters:\nu_tm1 input at time t-1 Return: simulated measurement at time t\nReimplemented by: lds::gaussian::System::Simulate, lds::poisson::System::Simulate\nf # inline void f( const Vector \u0026amp; u, bool do_add_noise =false ) Parameters:\nu input do_add_noise whether to add simulated process noise h # virtual void h() =0 Reimplemented by: lds::gaussian::System::h, lds::poisson::System::h\nh_ # virtual Vector h_( Vector x ) =0 Parameters:\nx_t state at time t Return: predicted state at time t + 1\nReimplemented by: lds::gaussian::System::h_, lds::poisson::System::h_\nn_u # inline size_t n_u() const n_x # inline size_t n_x() const n_y # inline size_t n_y() const dt # inline data_t dt() const x # inline const Vector \u0026amp; x() const P # inline const Matrix \u0026amp; P() const m # inline const Vector \u0026amp; m() const P_m # inline const Matrix \u0026amp; P_m() const cx # inline const Vector \u0026amp; cx() const y # inline const Vector \u0026amp; y() const x0 # inline const Vector \u0026amp; x0() const m0 # inline const Vector \u0026amp; m0() const A # inline const Matrix \u0026amp; A() const B # inline const Matrix \u0026amp; B() const g # inline const Vector \u0026amp; g() const C # inline const Matrix \u0026amp; C() const d # inline const Vector \u0026amp; d() const Ke # inline const Matrix \u0026amp; Ke() const Ke_m # inline const Matrix \u0026amp; Ke_m() const Q # inline const Matrix \u0026amp; Q() Q_m # inline const Matrix \u0026amp; Q_m() P0 # inline const Matrix \u0026amp; P0() P0_m # inline const Matrix \u0026amp; P0_m() set_A # inline void set_A( const Matrix \u0026amp; A ) set_B # inline void set_B( const Matrix \u0026amp; B ) set_m # inline void set_m( const Vector \u0026amp; m, bool do_force_assign =false ) set_g # inline void set_g( const Vector \u0026amp; g ) set_Q # inline void set_Q( const Matrix \u0026amp; Q ) set_Q_m # inline void set_Q_m( const Matrix \u0026amp; Q_m ) set_x0 # inline void set_x0( const Vector \u0026amp; x0 ) set_P0 # inline void set_P0( const Matrix \u0026amp; P0 ) set_P0_m # inline void set_P0_m( const Matrix \u0026amp; P0_m ) set_C # inline void set_C( const Matrix \u0026amp; C ) set_d # inline void set_d( const Vector \u0026amp; d ) set_x # inline void set_x( const Vector \u0026amp; x ) Reset # void Reset() nstep_pred_block # std::vector\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; nstep_pred_block( UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z, size_t n_pred =1 ) Print # void Print() Protected Function Details # RecurseKe # virtual void RecurseKe() =0 Reimplemented by: lds::gaussian::System::RecurseKe, lds::poisson::System::RecurseKe\nInitVars # void InitVars( data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0 ) Public Attribute Details # do_adapt_m # bool do_adapt_m {}; Protected Attribute Details # n_x_ # std::size_t n_x_ {}; n_u_ # std::size_t n_u_ {}; n_y_ # std::size_t n_y_ {}; dt_ # data_t dt_ {}; x_ # Vector x_; P_ # Matrix P_; m_ # Vector m_; P_m_ # Matrix P_m_; cx_ # Vector cx_; y_ # Vector y_; z_ # Vector z_; x0_ # Vector x0_; P0_ # Matrix P0_; m0_ # Vector m0_; P0_m_ # Matrix P0_m_; A_ # Matrix A_; B_ # Matrix B_; g_ # Vector g_; Q_ # Matrix Q_; Q_m_ # Matrix Q_m_; C_ # Matrix C_; d_ # Vector d_; Ke_ # Matrix Ke_; Ke_m_ # Matrix Ke_m_; Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":48,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1_uniform_matrix_list/","title":"lds::UniformMatrixList","section":"Classes","content":" lds::UniformMatrixList # More\u0026hellip;\nInherits from std::vector\u0026lt; Matrix \u0026gt;\nPublic Functions # Name UniformMatrixList() =default\nConstructs a new UniformMatrixList. UniformMatrixList(const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0})\nConstructs a new UniformMatrixList by copying existing vector of Matrix if dimensions consistent. UniformMatrixList(std::vector\u0026lt; Matrix \u0026gt; \u0026amp;\u0026amp; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0})\nConstructs a new UniformMatrixList by moving existing vector of Matrix if dimensions consistent. UniformMatrixList(std::initializer_list\u0026lt; Matrix \u0026gt; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0})\nConstructs a new UniformMatrixList from initializer_list of Matrix if dimensions consistent. UniformMatrixList(const UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; that)\nConstructs a new UniformMatrixList (copy). UniformMatrixList(UniformMatrixList\u0026lt; D \u0026gt; \u0026amp;\u0026amp; that)\nConstructs a new UniformMatrixList (move). ~UniformMatrixList() =default\nDestroys the object. const std::array\u0026lt; size_t, 2 \u0026gt; \u0026amp; dim(size_t n =0) const\ngets dimensions of uniformly sized matrices size_t size()\nsize of container const Matrix \u0026amp; at(size_t n)\ngets reference to n^th element void Swap(Matrix \u0026amp; that, size_t n)\nswaps input matrix with n^th matrix of list UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; operator=(const UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; that)\nassigns the contents (copy) UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; operator=(UniformMatrixList\u0026lt; D \u0026gt; \u0026amp;\u0026amp; that)\nassigns the contents (move) void append(const Matrix \u0026amp; mat)\nappends a matrix to the list Detailed Description # template \u0026lt;MatrixListFreeDim D =kMatFreeDimNone\u0026gt; class lds::UniformMatrixList; Public Function Details # UniformMatrixList # UniformMatrixList() =default UniformMatrixList # explicit UniformMatrixList( const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0} ) Parameters:\nmats input matrices dim dimensions UniformMatrixList # explicit UniformMatrixList( std::vector\u0026lt; Matrix \u0026gt; \u0026amp;\u0026amp; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0} ) Parameters:\nmats input matrices dim dimensions UniformMatrixList # UniformMatrixList( std::initializer_list\u0026lt; Matrix \u0026gt; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0} ) Parameters:\nmats input matrices dim dimensions UniformMatrixList # UniformMatrixList( const UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; that ) Parameters:\nthat another UniformMatrixList UniformMatrixList # UniformMatrixList( UniformMatrixList\u0026lt; D \u0026gt; \u0026amp;\u0026amp; that ) Parameters:\nthat another UniformMatrixList ~UniformMatrixList # ~UniformMatrixList() =default dim # inline const std::array\u0026lt; size_t, 2 \u0026gt; \u0026amp; dim( size_t n =0 ) const Parameters:\nn [optional] index in list of matrices Return: dimensions\nsize # inline size_t size() at # inline const Matrix \u0026amp; at( size_t n ) Swap # inline void Swap( Matrix \u0026amp; that, size_t n ) Parameters:\nthat input matrix n index where the matrix is moved operator= # inline UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; operator=( const UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; that ) Parameters:\nthat another UniformMatrixList Return: reference to object\noperator= # inline UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; operator=( UniformMatrixList\u0026lt; D \u0026gt; \u0026amp;\u0026amp; that ) Parameters:\nthat another UniformMatrixList Return: reference to object\nappend # void append( const Matrix \u0026amp; mat ) Parameters:\nmat input matrix Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":49,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1_uniform_system_list/","title":"lds::UniformSystemList","section":"Classes","content":" lds::UniformSystemList # More\u0026hellip;\nInherits from std::vector\u0026lt; System \u0026gt;\nPublic Functions # Name UniformSystemList() =default\nConstructs a new UniformSystemList. UniformSystemList(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0})\nConstructs a new UniformSystemList by copying existing vector of System if dimensions consistent. UniformSystemList(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0})\nConstructs a new UniformSystemList by moving existing vector of System if dimensions consistent. UniformSystemList(std::initializer_list\u0026lt; System \u0026gt; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0})\nConstructs a new UniformSystemList from initializer_list of System if dimensions consistent. UniformSystemList(const UniformSystemList \u0026amp; that)\nConstructs a new UniformSystemList (copy). UniformSystemList(UniformSystemList \u0026amp;\u0026amp; that)\nConstructs a new UniformSystemList (move). ~UniformSystemList() =default\nDestroys the object. const std::array\u0026lt; size_t, 3 \u0026gt; \u0026amp; dim() const\ngets dimensions of the uniformly sized systems size_t size()\nsize of container const System \u0026amp; at(size_t n)\ngets reference to n^th element void Swap(System \u0026amp; that, size_t n)\nswaps input system with n^th system of list UniformSystemList \u0026amp; operator=(const UniformSystemList \u0026amp; that)\nassigns the contents (copy) UniformSystemList \u0026amp; operator=(UniformSystemList \u0026amp;\u0026amp; that)\nassigns the contents (move) Detailed Description # template \u0026lt;typename System \u0026gt; class lds::UniformSystemList; Public Function Details # UniformSystemList # UniformSystemList() =default UniformSystemList # explicit UniformSystemList( const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0} ) Parameters:\nsystems input systems dim dimensions (n_u, n_x, n_y) UniformSystemList # explicit UniformSystemList( std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0} ) Parameters:\nsystems input systems dim dimensions (n_u, n_x, n_y) UniformSystemList # UniformSystemList( std::initializer_list\u0026lt; System \u0026gt; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0} ) Parameters:\nsystems input systems dim dimensions (n_u, n_x, n_y) UniformSystemList # UniformSystemList( const UniformSystemList \u0026amp; that ) Parameters:\nthat another UniformSystemList UniformSystemList # UniformSystemList( UniformSystemList \u0026amp;\u0026amp; that ) Parameters:\nthat another UniformSystemList ~UniformSystemList # ~UniformSystemList() =default dim # inline const std::array\u0026lt; size_t, 3 \u0026gt; \u0026amp; dim() const size # inline size_t size() at # inline const System \u0026amp; at( size_t n ) Swap # inline void Swap( System \u0026amp; that, size_t n ) Parameters:\nthat input system n index where the system is moved operator= # inline UniformSystemList \u0026amp; operator=( const UniformSystemList \u0026amp; that ) Parameters:\nthat another UniformSystemList Return: reference to object\noperator= # inline UniformSystemList \u0026amp; operator=( UniformSystemList \u0026amp;\u0026amp; that ) Parameters:\nthat another UniformSystemList Return: reference to object\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":50,"href":"/lds-ctrl-est/docs/api/classes/classlds_1_1_uniform_vector_list/","title":"lds::UniformVectorList","section":"Classes","content":" lds::UniformVectorList # Inherits from std::vector\u0026lt; Vector \u0026gt;\nPublic Functions # Name UniformVectorList() =default\nConstructs a new UniformVectorList. UniformVectorList(const std::vector\u0026lt; Vector \u0026gt; \u0026amp; vecs, size_t dim =0)\nConstructs a new UniformVectorList by copying existing vector of Vector if dimensions consistent. UniformVectorList(std::vector\u0026lt; Vector \u0026gt; \u0026amp;\u0026amp; vecs, size_t dim =0)\nConstructs a new UniformVectorList by moving existing vector of Vector if dimensions consistent. UniformVectorList(std::initializer_list\u0026lt; Vector \u0026gt; vecs, size_t dim =0)\nConstructs a new UniformVectorList from initializer_list of Vector if dimensions consistent. UniformVectorList(const UniformVectorList \u0026amp; that)\nConstructs a new UniformVectorList (copy) UniformVectorList(UniformVectorList \u0026amp;\u0026amp; that)\nConstructs a new UniformVectorList (move) ~UniformVectorList() =default\nDestroys the object. size_t dim() const\ngets dimensions of the uniformly sized matrices size_t size()\nsize of container const Vector \u0026amp; at(size_t n)\ngets reference to n^th element void Swap(Vector \u0026amp; that, size_t n)\nswaps input matrix with n^th vector of list UniformVectorList \u0026amp; operator=(const UniformVectorList \u0026amp; that)\nassigns the contents (copy) UniformVectorList \u0026amp; operator=(UniformVectorList \u0026amp;\u0026amp; that)\nassigns the contents (move) Public Function Details # UniformVectorList # UniformVectorList() =default UniformVectorList # explicit UniformVectorList( const std::vector\u0026lt; Vector \u0026gt; \u0026amp; vecs, size_t dim =0 ) Parameters:\nvecs input vectors dims dimension UniformVectorList # explicit UniformVectorList( std::vector\u0026lt; Vector \u0026gt; \u0026amp;\u0026amp; vecs, size_t dim =0 ) Parameters:\nvecs input vectors dim dimension UniformVectorList # UniformVectorList( std::initializer_list\u0026lt; Vector \u0026gt; vecs, size_t dim =0 ) Parameters:\nvecs input vectors dim dimension UniformVectorList # UniformVectorList( const UniformVectorList \u0026amp; that ) Parameters:\nthat another UniformVectorList UniformVectorList # UniformVectorList( UniformVectorList \u0026amp;\u0026amp; that ) Parameters:\nthat another UniformVectorList ~UniformVectorList # ~UniformVectorList() =default dim # inline size_t dim() const size # inline size_t size() at # inline const Vector \u0026amp; at( size_t n ) Swap # inline void Swap( Vector \u0026amp; that, size_t n ) Parameters:\nthat input vector n index where the vector is moved operator= # inline UniformVectorList \u0026amp; operator=( const UniformVectorList \u0026amp; that ) Parameters:\nthat another UniformVectorList Return: reference to object\noperator= # inline UniformVectorList \u0026amp; operator=( UniformVectorList \u0026amp;\u0026amp; that ) Parameters:\nthat another UniformVectorList Return: reference to object\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":51,"href":"/lds-ctrl-est/docs/api/files/dir_156a98879751e549d6939ca71a62d61f/","title":"ldsCtrlEst_h","section":"Files","content":" ldsCtrlEst_h # Files # Name ldsCtrlEst_h/lds.h lds namespace ldsCtrlEst_h/lds_ctrl.h Controller. ldsCtrlEst_h/lds_fit.h LDS base fit type. ldsCtrlEst_h/lds_fit_em.h subspace identification ldsCtrlEst_h/lds_fit_ssid.h subspace identification ldsCtrlEst_h/lds_gaussian.h glds namespace ldsCtrlEst_h/lds_gaussian_ctrl.h GLDS Controller. ldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type. ldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type. ldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type. ldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type. ldsCtrlEst_h/lds_gaussian_sys.h GLDS base type. ldsCtrlEst_h/lds_poisson.h plds namespace ldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type. ldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type. ldsCtrlEst_h/lds_poisson_fit_em.h PLDS E-M fit type. ldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type. ldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type. ldsCtrlEst_h/lds_poisson_sys.h PLDS base type. ldsCtrlEst_h/lds_sctrl.h SwitchedController type. ldsCtrlEst_h/lds_sys.h LDS base type. ldsCtrlEst_h/lds_uniform_mats.h List of uniformly sized matrices. ldsCtrlEst_h/lds_uniform_systems.h List of uniformly sized Systems. ldsCtrlEst_h/lds_uniform_vecs.h List of uniformly sized vectors. ldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API) ldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API) Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":52,"href":"/lds-ctrl-est/docs/api/files/lds__ctrl_8h/","title":"ldsCtrlEst_h/lds_ctrl.h","section":"Files","content":" ldsCtrlEst_h/lds_ctrl.h # Controller. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Classes # Name class lds::Controller Detailed Description # This file declares the type for control of a linear dynamical system (lds::Controller).\nSource code # //===-- ldsCtrlEst_h/lds_control.h - Controller -----------------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_CTRL_H #define LDSCTRLEST_LDS_CTRL_H // namespace #include \u0026#34;lds.h\u0026#34; // system type #include \u0026#34;lds_sys.h\u0026#34; namespace lds { template \u0026lt;typename System\u0026gt; class Controller { static_assert(std::is_base_of\u0026lt;lds::System, System\u0026gt;::value, \u0026#34;System must be derived from lds::System type.\u0026#34;); public: Controller() = default; Controller(const System\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type = 0); Controller(System\u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type = 0); const Vector\u0026amp; Control(const Vector\u0026amp; z, bool do_control = true, bool do_lock_control = false, data_t sigma_soft_start = 0, data_t sigma_u_noise = 0, bool do_reset_at_control_onset = true); const Vector\u0026amp; ControlOutputReference(const Vector\u0026amp; z, bool do_control = true, bool do_estimation = true, bool do_lock_control = false, data_t sigma_soft_start = 0, data_t sigma_u_noise = 0, bool do_reset_at_control_onset = true); // get methods: const System\u0026amp; sys() const { return sys_; }; const Matrix\u0026amp; Kc() const { return Kc_; }; const Matrix\u0026amp; Kc_inty() const { return Kc_inty_; }; const Matrix\u0026amp; Kc_u() const { return Kc_u_; }; const Vector\u0026amp; g_design() const { return g_design_; }; const Vector\u0026amp; u_ref() const { return u_ref_; }; const Vector\u0026amp; x_ref() const { return x_ref_; }; const Vector\u0026amp; y_ref() const { return y_ref_; }; size_t control_type() const { return control_type_; }; data_t tau_awu() const { return tau_awu_; }; data_t u_lb() const { return u_lb_; }; data_t u_ub() const { return u_ub_; }; // set methods void set_sys(const System\u0026amp; sys) { bool does_match = sys_.n_u() == sys.n_u(); does_match = does_match \u0026amp;\u0026amp; (sys_.n_x() == sys.n_x()); does_match = does_match \u0026amp;\u0026amp; (sys_.n_y() == sys.n_y()); if (does_match) { sys_ = sys; } else { throw std::runtime_error( \u0026#34;new system argument to `set_sys` does not match dimensionality of \u0026#34; \u0026#34;existing system\u0026#34;); } }; void set_g_design(const Vector\u0026amp; g_design) { Reassign(g_design_, g_design); }; void set_u_ref(const Vector\u0026amp; u_ref) { Reassign(u_ref_, u_ref); }; void set_x_ref(const Vector\u0026amp; x_ref) { Reassign(x_ref_, x_ref); cx_ref_ = sys_.C() * x_ref_; }; // y_ref needs to be handled differently depending on output fn. // (need to populate cx_ref_ too, which depends on output fn) virtual void set_y_ref(const Vector\u0026amp; y_ref) { Reassign(y_ref_, y_ref); }; void set_Kc(const Matrix\u0026amp; Kc) { Reassign(Kc_, Kc); }; void set_Kc_inty(const Matrix\u0026amp; Kc_inty) { Reassign(Kc_inty_, Kc_inty); }; void set_Kc_u(const Matrix\u0026amp; Kc_u) { Reassign(Kc_u_, Kc_u); }; void set_tau_awu(data_t tau) { tau_awu_ = tau; k_awu_ = sys_.dt() / tau_awu_; }; void set_control_type(size_t control_type); // There is no reason u_lb/ub should not be public, but making set methods // anyway. void set_u_lb(data_t u_lb) { u_lb_ = u_lb; }; void set_u_ub(data_t u_ub) { u_ub_ = u_ub; }; void Reset() { sys_.Reset(); u_ref_.zeros(); u_ref_prev_.zeros(); int_e_.zeros(); int_e_awu_adjust_.zeros(); u_sat_.zeros(); u_saturated_ = false; t_since_control_onset_ = 0.0; }; void Print() { sys_.Print(); std::cout \u0026lt;\u0026lt; \u0026#34;g_design : \u0026#34; \u0026lt;\u0026lt; g_design_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;u_lb : \u0026#34; \u0026lt;\u0026lt; u_lb_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;u_ub : \u0026#34; \u0026lt;\u0026lt; u_ub_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; protected: System sys_; Vector u_; Vector u_return_; Vector g_design_; // reference signals Vector u_ref_; // create no set method for this: Vector u_ref_prev_; Vector x_ref_; Vector y_ref_; Vector cx_ref_; // Controller gains Matrix Kc_; Matrix Kc_u_; Matrix Kc_inty_; // control after g inversion // do not need set methods for these. Vector du_ref_; Vector dv_ref_; Vector v_ref_; Vector dv_; Vector v_; // integral error // do not need set method for this Vector int_e_; Vector int_e_awu_adjust_; Vector u_sat_; bool do_control_prev_ = false; bool do_lock_control_prev_ = false; // whether the g of system has become inverted from what you think it is // (gain_ref) bool u_saturated_ = false; // should be safe to have references here bc nothing needs to be done // (like reset vars) when it changes... data_t u_lb_{}; data_t u_ub_{}; data_t tau_awu_{}; data_t k_awu_ = 0; data_t t_since_control_onset_ = 0; size_t control_type_{}; private: void CalcControl(bool do_control = true, bool do_estimation = true, bool do_lock_control = false, data_t sigma_soft_start = 0, data_t sigma_u_noise = 0, bool do_reset_at_control_onset = true); void CalcSteadyStateSetPoint(); void AntiWindup(); void InitVars(size_t control_type); }; // Implement the above: template \u0026lt;typename System\u0026gt; inline Controller\u0026lt;System\u0026gt;::Controller(const System\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type) : sys_(sys), u_lb_(u_lb), u_ub_(u_ub), tau_awu_(lds::kInf) { InitVars(control_type); } template \u0026lt;typename System\u0026gt; inline Controller\u0026lt;System\u0026gt;::Controller(System\u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type) : sys_(std::move(sys)), u_lb_(u_lb), u_ub_(u_ub), tau_awu_(lds::kInf) { InitVars(control_type); } template \u0026lt;typename System\u0026gt; inline void Controller\u0026lt;System\u0026gt;::set_control_type(size_t control_type) { if (control_type_ == control_type) { return; } // creating a blank slate... control_type_ = 0; Kc_inty_.zeros(0, 0); Kc_u_.zeros(0, 0); int_e_.zeros(0, 0); int_e_awu_adjust_.zeros(0, 0); // controller was designed to minimize integral error if (control_type \u0026amp; kControlTypeIntY) { Kc_inty_.zeros(sys_.n_u(), sys_.n_y()); int_e_.zeros(sys_.n_y()); int_e_awu_adjust_.zeros(sys_.n_u()); control_type_ = control_type_ | kControlTypeIntY; } // controller was designed to minimize deltaU // (i.e. state augmented with u) if (control_type \u0026amp; kControlTypeDeltaU) { Kc_u_.zeros(sys_.n_u(), sys_.n_u()); control_type_ = control_type_ | kControlTypeDeltaU; } // whether to adapt set point calculate with (re-estimated) process // disturbance (m) if (control_type \u0026amp; kControlTypeAdaptM) { if (sys_.do_adapt_m) // only if adapting m... { control_type_ = control_type_ | kControlTypeAdaptM; } } } // set_control_type template \u0026lt;typename System\u0026gt; inline const Vector\u0026amp; Controller\u0026lt;System\u0026gt;::Control( const Vector\u0026amp; z, bool do_control, bool do_lock_control, data_t sigma_soft_start, data_t sigma_u_noise, bool do_reset_at_control_onset) { // update state estimates, given latest measurement sys_.Filter(u_, z); bool do_estimation = true; // always have estimator on in this case // calculate control signal CalcControl(do_control, do_estimation, do_lock_control, sigma_soft_start, sigma_u_noise, do_reset_at_control_onset); return u_return_; } template \u0026lt;typename System\u0026gt; inline const Vector\u0026amp; Controller\u0026lt;System\u0026gt;::ControlOutputReference( const Vector\u0026amp; z, bool do_control, bool do_estimation, bool do_lock_control, data_t sigma_soft_start, data_t sigma_u_noise, bool do_reset_at_control_onset) { // update state estimates, given latest measurement if (do_estimation) { sys_.Filter(u_, z); } else { sys_.f(u_); } // calculate the set point // solves for u_ref and x_ref when output is at y_ref at steady state. if (do_control) { CalcSteadyStateSetPoint(); } // calculate control signal CalcControl(do_control, do_estimation, do_lock_control, sigma_soft_start, sigma_u_noise, do_reset_at_control_onset); return u_return_; } template \u0026lt;typename System\u0026gt; inline void Controller\u0026lt;System\u0026gt;::CalcControl(bool do_control, bool do_estimation, bool do_lock_control, data_t sigma_soft_start, data_t sigma_u_noise, bool do_reset_at_control_onset) { if (do_control \u0026amp;\u0026amp; do_estimation) { if (!do_control_prev_) { if (do_reset_at_control_onset) { Reset(); } t_since_control_onset_ = 0.0; } else { t_since_control_onset_ += sys_.dt(); } // enforce softstart on control vars. if (sigma_soft_start \u0026gt; 0) { // half-Gaussian soft-start scaling factor data_t soft_start_sf = 1 - exp(-pow(t_since_control_onset_, 2) / (2 * pow(sigma_soft_start, 2))); u_ref_ *= soft_start_sf; // TODO(mfbolus): May be appropriate to soft-start x_ref, y_ref too // x_ref_ *= soft_start_sf; // cx_ref_ *= soft_start_sf; // y_ref_ *= soft_start_sf; } if (!do_lock_control) { // first do u -\u0026gt; v change of vars. (v = g.*u) // e.g., convert into physical units (e.g., v[=] mW/mm2 rather than driver // control voltage u[=]V) v_ref_ = g_design_ % u_ref_; // Given FB, calc. the change in control if (control_type_ \u0026amp; kControlTypeDeltaU) { // if control designed to minimize not u but deltaU (i.e. state aug with // u): // TODO(mfbolus): Commented out for now. See note below. // du_ref_ = u_ref_ - u_ref_prev_; // dv_ref_ = g_design_ % du_ref_; // TODO(mfbolus): Assuming users want *smooth* control signals if using // kControlTypeDeltaU, it should be the case that dv_ref_ is --\u0026gt; 0. May // want to revisit, but I am going to force it to be zero unless a // situation arises that argues for keeping the above. dv_ref_.zeros(); dv_ = dv_ref_; // nominally-optimal. dv_ -= Kc_ * (sys_.x() - x_ref_); // instantaneous state error dv_ -= Kc_u_ * (v_ - v_ref_); // penalty on amp u (rel to ref) if (control_type_ \u0026amp; kControlTypeIntY) { // TODO(mfbolus): one approach to protection against integral windup // would be to not integrate error when control signal saturated: // if(!uSaturated) int_e_ += (sys_.cx() - cx_ref_) * sys_.dt(); // integrated error dv_ -= Kc_inty_ * int_e_; // control for integrated error } // update the control v_ += dv_; } else { v_ = v_ref_; // nominally-optimal. v_ -= Kc_ * (sys_.x() - x_ref_); // instantaneous state error if (control_type_ \u0026amp; kControlTypeIntY) { // TODO(mfbolus): one approach to protection against integral windup // would be to not integrate error when control signal saturated: // if (!uSaturated) int_e_ += (sys_.cx() - cx_ref_) * sys_.dt(); // integrated error v_ -= Kc_inty_ * int_e_; // control for integrated error } } // convert back to control voltage u[=]V u_ = v_ / sys_.g(); } // else do nothing until lock is low } else { // if not control // feed through u_ref in open loop u_ = u_ref_ % g_design_ / sys_.g(); v_ = sys_.g() % u_; u_ref_.zeros(); int_e_.zeros(); int_e_awu_adjust_.zeros(); u_sat_.zeros(); } // ends do_control // enforce box constraints (and antiwindup) AntiWindup(); // add noise to input? // The value for u that is *returned* to user after addition of any noise, // while keeping controller/estimator blind to this addition. u_return_ = u_; if ((sigma_u_noise \u0026gt; 0.0) \u0026amp;\u0026amp; (do_control \u0026amp;\u0026amp; !do_lock_control)) { u_return_ += sigma_u_noise * Vector(sys_.n_u(), fill::randn); Limit(u_return_, u_lb_, u_ub_); }; // For next time step: u_ref_prev_ = u_ref_; do_control_prev_ = do_control; do_lock_control_prev_ = do_lock_control; } // CalcControl template \u0026lt;typename System\u0026gt; inline void Controller\u0026lt;System\u0026gt;::CalcSteadyStateSetPoint() { // Linearly-constrained least squares (ls). // // _reference: // Boyd \u0026amp; Vandenberghe (2018) Introduction to Applied Linear Algebra // Matrix a_ls = join_horiz(sys_.C(), Matrix(sys_.n_y(), sys_.n_u(), fill::zeros)); Vector b_ls = cx_ref_; Matrix c_ls = join_horiz(sys_.A() - Matrix(sys_.n_x(), sys_.n_x(), fill::eye), sys_.B() * arma::diagmat(sys_.g())); Vector d_ls = -sys_.m0(); if (control_type_ \u0026amp; kControlTypeAdaptM) { d_ls = -sys_.m(); // adapt setpoint calc with disturbance? } Matrix a_ls_t = a_ls.t(); // TODO(mfbolus): not sure why but causes seg // fault if I do not do this. Matrix phi_ls = join_vert(join_horiz(2 * a_ls_t * a_ls, c_ls.t()), join_horiz(c_ls, Matrix(sys_.n_x(), sys_.n_x(), fill::zeros))); // TODO(mfbolus): should be actual inverse, rather than pseudo-inverse: Matrix inv_phi = pinv(phi_ls); Vector xulam = inv_phi * join_vert(2 * a_ls_t * b_ls, d_ls); x_ref_ = xulam.subvec(0, sys_.n_x() - 1); u_ref_ = xulam.subvec(sys_.n_x(), sys_.n_x() + sys_.n_u() - 1); cx_ref_ = sys_.C() * x_ref_; } // CalcSteadyStateSetPoint template \u0026lt;typename System\u0026gt; void Controller\u0026lt;System\u0026gt;::AntiWindup() { u_saturated_ = false; u_sat_ = u_; // limit u and flag whether saturated for (size_t k = 0; k \u0026lt; u_.n_elem; k++) { if (u_[k] \u0026lt; u_lb_) { u_sat_[k] = u_lb_; u_saturated_ = true; } if (u_[k] \u0026gt; u_ub_) { u_sat_[k] = u_ub_; u_saturated_ = true; } } if ((control_type_ \u0026amp; kControlTypeIntY) \u0026amp;\u0026amp; (tau_awu_ \u0026lt; lds::kInf)) { // one-step back-calculation (calculate intE for u=u_sat) // (Astroem, Rundqwist 1989 warn against using this...) // int_e_awu_adjust_ = // solve(Kc_inty_, (u_ - u_sat_)); // pinv(Kc_inty) * (u-uSat); // gradual: see Astroem, Rundqwist 1989 // this is a fudge for doing MIMO gradual // n.b., went ahead and multiplied 1/T by dt so don\u0026#39;t have to do that here. int_e_awu_adjust_ = k_awu_ * (sign(Kc_inty_).t() / sys_.n_u()) * (u_ - u_sat_); // int_e_awu_adjust_ = k_awu_ * (u_-u_sat_); int_e_ += int_e_awu_adjust_; } // set u to saturated version u_ = u_sat_; } template \u0026lt;typename System\u0026gt; void Controller\u0026lt;System\u0026gt;::InitVars(size_t control_type) { // initialize to default values u_ref_ = Vector(sys_.n_u(), fill::zeros); u_ref_prev_ = Vector(sys_.n_u(), fill::zeros); x_ref_ = Vector(sys_.n_x(), fill::zeros); y_ref_ = Vector(sys_.n_y(), fill::zeros); cx_ref_ = Vector(sys_.n_y(), fill::zeros); u_ = Vector(sys_.n_u(), fill::zeros); u_return_ = Vector(sys_.n_u(), fill::zeros); u_sat_ = Vector(sys_.n_u(), fill::zeros); // Might not need all these, so zero elements until later. Kc_ = Matrix(sys_.n_u(), sys_.n_x(), fill::zeros); Kc_u_ = Matrix(0, 0, fill::zeros); Kc_inty_ = Matrix(0, 0, fill::zeros); g_design_ = sys_.g(); // by default, same as model dv_ = Vector(sys_.n_u(), fill::zeros); v_ = Vector(sys_.n_u(), fill::zeros); du_ref_ = Vector(sys_.n_u(), fill::zeros); dv_ref_ = Vector(sys_.n_u(), fill::zeros); v_ref_ = Vector(sys_.n_u(), fill::zeros); int_e_ = Vector(0, fill::zeros); int_e_awu_adjust_ = Vector(0, fill::zeros); set_control_type(control_type); } } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":53,"href":"/lds-ctrl-est/docs/api/files/lds__fit__em_8h/","title":"ldsCtrlEst_h/lds_fit_em.h","section":"Files","content":" ldsCtrlEst_h/lds_fit_em.h # subspace identification More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Classes # Name class lds::EM Detailed Description # This file declares the type for fitting a linear dynamical system by expectation-maximization (lds::EM).\nSource code # //===-- ldsCtrlEst_h/lds_fit_em.h - EM Fit ----------------------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_EMAX_H #define LDSCTRLEST_LDS_EMAX_H #include \u0026#34;lds_fit.h\u0026#34; namespace lds { template \u0026lt;typename Fit\u0026gt; class EM { static_assert(std::is_base_of\u0026lt;lds::Fit, Fit\u0026gt;::value, \u0026#34;Fit must be derived from lds::Fit type.\u0026#34;); public: EM() = default; EM(size_t n_x, data_t dt, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train); EM(const Fit\u0026amp; fit0, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train); virtual ~EM() = default; const Fit\u0026amp; Run(bool calc_dynamics = true, bool calc_Q = true, bool calc_init = true, bool calc_output = true, bool calc_measurement = true, size_t max_iter = 100, data_t tol = 1e-2); std::tuple\u0026lt;UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026gt; ReturnData() { auto tuple = std::make_tuple(std::move(u_), std::move(z_)); // auto tuple = std::make_tuple(u_, z_); u_ = UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;(); z_ = UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;(); return tuple; } const std::vector\u0026lt;Matrix\u0026gt;\u0026amp; x() const { return x_; }; const std::vector\u0026lt;Matrix\u0026gt;\u0026amp; y() const { return y_; }; const Matrix\u0026amp; sum_E_x_t_x_t() const { return sum_E_x_t_x_t_; }; const Matrix\u0026amp; sum_E_xu_tm1_xu_tm1() const { return sum_E_xu_tm1_xu_tm1_; }; const Matrix\u0026amp; sum_E_xu_t_xu_tm1() const { return sum_E_xu_t_xu_tm1_; }; size_t n_t_tot() { return n_t_tot_; } const Vector\u0026amp; theta() const { return theta_; }; protected: void Expectation(bool force_common_initial = false); void Maximization(bool calc_dynamics = true, bool calc_Q = true, bool calc_init = false, bool calc_output = false, bool calc_measurement = false); void MaximizeDynamics(); void MaximizeQ(); void MaximizeInitial(); virtual void MaximizeOutput() = 0; virtual void MaximizeMeasurement() = 0; void Smooth(bool force_common_initial); virtual void RecurseKe(Matrix\u0026amp; Ke, Cube\u0026amp; P_pre, Cube\u0026amp; P_post, size_t t) = 0; void Reset(); void InitVars(); Vector UpdateTheta(); // input/output training data UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; u_; UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; z_; std::vector\u0026lt;Matrix\u0026gt; x_; std::vector\u0026lt;Cube\u0026gt; P_; std::vector\u0026lt;Cube\u0026gt; P_t_tm1_; std::vector\u0026lt;Matrix\u0026gt; y_; Matrix diag_y_; // expectations calculated in E-step Matrix sum_E_x_t_x_t_; Matrix sum_E_xu_tm1_xu_tm1_; Matrix sum_E_xu_t_xu_tm1_; Fit fit_; Vector theta_; data_t dt_{}; size_t n_u_{}; size_t n_x_{}; size_t n_y_{}; size_t n_trials_{}; std::vector\u0026lt;size_t\u0026gt; n_t_; size_t n_t_tot_{}; }; template \u0026lt;typename Fit\u0026gt; EM\u0026lt;Fit\u0026gt;::EM(size_t n_x, data_t dt, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train) { n_u_ = u_train.at(0).n_rows; n_y_ = z_train.at(0).n_rows; fit_ = Fit(n_u_, n_x, n_y_, dt); u_ = std::move(u_train); z_ = std::move(z_train); InitVars(); } template \u0026lt;typename Fit\u0026gt; EM\u0026lt;Fit\u0026gt;::EM(const Fit\u0026amp; fit0, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train) { // make sure fit dims match I/O data if (fit0.n_u() != u_train.at(0).n_rows) { throw std::runtime_error( \u0026#34;Initial fit and input training data have inconsistent dimensions\u0026#34;); } if (fit0.n_y() != z_train.at(0).n_rows) { throw std::runtime_error( \u0026#34;Initial fit and output training data have inconsistent dimensions\u0026#34;); } fit_ = fit0; u_ = std::move(u_train); z_ = std::move(z_train); InitVars(); } template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::InitVars() { // check input/output data dimensions are consistent if (z_.size() != u_.size()) { throw std::runtime_error( \u0026#34;I/O training data have different number of trials.\u0026#34;); } n_trials_ = u_.size(); n_t_tot_ = 0; n_t_ = std::vector\u0026lt;size_t\u0026gt;(n_trials_); for (size_t trial = 0; trial \u0026lt; n_trials_; trial++) { if (z_.at(trial).n_cols != u_.at(trial).n_cols) { throw std::runtime_error( \u0026#34;I/O training data have different number of time steps.\u0026#34;); } n_t_[trial] = u_.at(trial).n_cols; n_t_tot_ += n_t_[trial]; } n_u_ = fit_.n_u(); n_x_ = fit_.n_x(); n_y_ = fit_.n_y(); dt_ = fit_.dt(); x_ = std::vector\u0026lt;Matrix\u0026gt;(n_trials_); P_ = std::vector\u0026lt;Cube\u0026gt;(n_trials_); P_t_tm1_ = std::vector\u0026lt;Cube\u0026gt;(n_trials_); y_ = std::vector\u0026lt;Matrix\u0026gt;(n_trials_); for (size_t trial = 0; trial \u0026lt; n_trials_; trial++) { x_[trial] = Matrix(n_x_, n_t_[trial], fill::zeros); P_[trial] = Cube(n_x_, n_x_, n_t_[trial], fill::zeros); P_t_tm1_[trial] = Cube(n_x_, n_x_, n_t_[trial], fill::zeros); y_[trial] = Matrix(n_y_, n_t_[trial], fill::zeros); } diag_y_ = Matrix(n_y_, n_y_, fill::zeros); // covariances in expectation step sum_E_x_t_x_t_ = Matrix(n_x_, n_x_, fill::zeros); sum_E_xu_tm1_xu_tm1_ = Matrix(n_x_ + n_u_, n_x_ + n_u_, fill::zeros); sum_E_xu_t_xu_tm1_ = Matrix(n_x_ + n_u_, n_x_ + n_u_, fill::zeros); } template \u0026lt;typename Fit\u0026gt; const Fit\u0026amp; EM\u0026lt;Fit\u0026gt;::Run(bool calc_dynamics, bool calc_Q, bool calc_init, bool calc_output, bool calc_measurement, size_t max_iter, data_t tol) { Reset(); // to initial conditions size_t n_params = 3 * n_x_ * n_x_ + n_x_ * n_u_ + n_x_ + n_y_ * n_x_ + n_y_ * n_y_; Vector theta(n_params); Vector theta_new(n_params); data_t max_dtheta = 1; // if solving for initial conditions, allow them be varied. // otherwise, freeze at provided values. bool force_common_initial = !calc_init; // go until parameter convergence for (size_t l = 0; l \u0026lt; max_iter; l++) { theta_ = UpdateTheta(); std::cout \u0026lt;\u0026lt; \u0026#34;Iteration \u0026#34; \u0026lt;\u0026lt; l + 1 \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; max_iter \u0026lt;\u0026lt; \u0026#34; ...\\n\u0026#34;; Expectation(force_common_initial); Maximization(calc_dynamics, calc_Q, calc_init, calc_output, calc_measurement); // check convergence theta_new = UpdateTheta(); Vector dtheta = abs(theta_new - theta_) / abs(theta_); // some parameters could be zero... arma::uvec ubi_finite = find_finite(dtheta); max_dtheta = max(dtheta.elem(ubi_finite)); std::cout \u0026lt;\u0026lt; \u0026#34;max dtheta: \u0026#34; \u0026lt;\u0026lt; max_dtheta \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; if (max_dtheta \u0026lt; tol) { std::cout \u0026lt;\u0026lt; \u0026#34;Converged.\\n\u0026#34;; break; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return fit_; } template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::Smooth(bool force_common_initial) { Matrix k_e(n_x_, n_y_); // estimator gain Cube k_backfilt; // back-filtering gains // TODO(mfbolus): this loop could be made parallel for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { Matrix x_pre(n_x_, n_t_[trial], fill::zeros); Cube p_pre(n_x_, n_x_, n_t_[trial], fill::zeros); Matrix x_post(n_x_, n_t_[trial], fill::zeros); Cube p_post(n_x_, n_x_, n_t_[trial], fill::zeros); if (force_common_initial) // forces all trials to have same initial // conditions. { x_[trial].col(0) = fit_.x0(); P_[trial].slice(0) = fit_.P0(); } y_[trial].col(0) = fit_.C() * x_[trial].col(0) + fit_.d(); // This *should not* be necessary but make sure P is symmetric. ForceSymPD(P_[trial].slice(0)); x_pre.col(0) = x_[trial].col(0); p_pre.slice(0) = P_[trial].slice(0); x_post.col(0) = x_[trial].col(0); p_post.slice(0) = P_[trial].slice(0); // filter for (size_t t = 1; t \u0026lt; n_t_[trial]; t++) { // predict fit_.f(x_pre, x_post, u_.at(trial), t); fit_.h(y_[trial], x_pre, t); diag_y_.diag() = y_[trial].col(t); // TODO(mfbolus): change if parallel // update --\u0026gt; posterior estimation RecurseKe(k_e, p_pre, p_post, t); x_post.col(t) = x_pre.col(t) + k_e * (z_.at(trial).col(t) - y_[trial].col(t)); y_[trial].col(t) = fit_.C() * x_post.col(t) + fit_.d(); } // backfilter -\u0026gt; Smoothed estimate // Reference: // Shumway et Stoffer (1982) ForceSymPD(p_post.slice(n_t_[trial] - 1)); k_backfilt = Cube(n_x_, n_x_, n_t_[trial], fill::zeros); x_[trial].col(n_t_[trial] - 1) = x_post.col(n_t_[trial] - 1); P_[trial].slice(n_t_[trial] - 1) = p_post.slice(n_t_[trial] - 1); for (size_t t = (n_t_[trial] - 1); t \u0026gt; 0; t--) { // TODO(mfmbolus): should not be necessary to force symm positive def ForceSymPD(p_pre.slice(t)); ForceSymPD(p_post.slice(t - 1)); ForceSymPD(P_[trial].slice(t)); k_backfilt.slice(t - 1) = p_post.slice(t - 1) * fit_.A().t() * inv_sympd(p_pre.slice(t)); x_[trial].col(t - 1) = x_post.col(t - 1) + k_backfilt.slice(t - 1) * (x_[trial].col(t) - x_pre.col(t)); P_[trial].slice(t - 1) = p_post.slice(t - 1) + k_backfilt.slice(t - 1) * (P_[trial].slice(t) - p_pre.slice(t)) * k_backfilt.slice(t - 1).t(); } // do the same for P_t_tm1 Matrix id(n_x_, n_x_, fill::eye); P_t_tm1_[trial].slice(n_t_[trial] - 1) = (id - k_e * fit_.C()) * fit_.A() * p_post.slice(n_t_[trial] - 2); for (size_t t = (n_t_[trial] - 1); t \u0026gt; 1; t--) { P_t_tm1_[trial].slice(t - 1) = p_post.slice(t - 1) * k_backfilt.slice(t - 2).t() + k_backfilt.slice(t - 1) * (P_t_tm1_[trial].slice(t) - fit_.A() * p_post.slice(t - 1)) * k_backfilt.slice(t - 2).t(); } // finally, get smoothed estimate of output for (size_t t = 0; t \u0026lt; n_t_[trial]; t++) { fit_.h(y_[trial], x_[trial], t); } // samps loop } // trial loop } // Smooth // template \u0026lt;typename Fit\u0026gt; // void EM\u0026lt;Fit\u0026gt;::RecurseKe(Matrix\u0026amp; Ke, Cube\u0026amp; P_pre, Cube\u0026amp; P_post, size_t t) { // // predict covar // P_pre.slice(t) = fit_.A() * P_post.slice(t - 1) * fit_.A().t() + fit_.Q(); // // update Ke // Ke = P_pre.slice(t) * fit_.C().t() * // inv_sympd(fit_.C() * P_pre.slice(t) * fit_.C().t() + fit_.R()); // // update cov // // Reference: Ghahramani et Hinton (1996) // P_post.slice(t) = P_pre.slice(t) - Ke * fit_.C() * P_pre.slice(t); // // // n.b. for poisson : // // P_pre.slice(t) = fit_.A() * P_post.slice(t - 1) * fit_.A().t() + // fit_.Q(); // // // update cov // // P_post.slice(t) = pinv(pinv(P_pre.slice(t)) + fit_.C().t() * diag_y_ * // // fit_.C()); // // // update Ke // // Ke = P_post.slice(t) * fit_.C(); // } template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::Expectation(bool force_common_initial) { // calculate the mean/cov of state needed for maximizing E[pr(z|theta)] Smooth(force_common_initial); // now get the various forms of sum(E[xx\u0026#39;]) needed // n.b. Going to start at t=1 rather than 0 bc most max terms need that. // so really \u0026#34;n_t_tot_\u0026#34; is (n_t_tot_-1) n_t_tot_ = 0; sum_E_x_t_x_t_ = Matrix(n_x_, n_x_, fill::zeros); sum_E_xu_tm1_xu_tm1_ = Matrix(n_x_ + n_u_, n_x_ + n_u_, fill::zeros); sum_E_xu_t_xu_tm1_ = Matrix(n_x_ + n_u_, n_x_ + n_u_, fill::zeros); Vector xu_tm1(n_x_ + n_u_, fill::zeros); Vector xu_t(n_x_ + n_u_, fill::zeros); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { for (size_t t = 1; t \u0026lt; n_t_[trial]; t++) { // ------------ sum_E_x_t_x_t ------------ sum_E_x_t_x_t_ += x_[trial].col(t) * x_[trial].col(t).t(); sum_E_x_t_x_t_ += P_[trial].slice(t); // ------------ sum_E_xu_tm1_xu_tm1 ------------ xu_tm1 = join_vert(x_[trial].col(t - 1), u_.at(trial).col(t - 1)); sum_E_xu_tm1_xu_tm1_ += xu_tm1 * xu_tm1.t(); sum_E_xu_tm1_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ - 1) += P_[trial].slice(t - 1); // ------------ sum_E_xu_t_xu_tm1 ------------ xu_t = join_vert(x_[trial].col(t), u_.at(trial).col(t)); sum_E_xu_t_xu_tm1_ += xu_t * xu_tm1.t(); sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ - 1) += P_t_tm1_[trial].slice(t); n_t_tot_ += 1; } // time } // trial } // Expectation template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::Maximization(bool calc_dynamics, bool calc_Q, bool calc_init, bool calc_output, bool calc_measurement) { if (calc_output) { MaximizeOutput(); } if (calc_measurement) { MaximizeMeasurement(); } if (calc_dynamics) { MaximizeDynamics(); } if (calc_Q) { MaximizeQ(); } if (calc_init) { MaximizeInitial(); } } // Maximization template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::MaximizeDynamics() { // Shumway, Stoffer (1982); Ghahgramani, Hinton (1996) Matrix ab = sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1) * inv_sympd(sum_E_xu_tm1_xu_tm1_); fit_.set_A(ab.submat(0, 0, n_x_ - 1, n_x_ - 1)); fit_.set_B(ab.submat(0, n_x_, n_x_ - 1, n_x_ + n_u_ - 1)); std::cout \u0026lt;\u0026lt; \u0026#34;A_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.A()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;B_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.B()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::MaximizeQ() { // // Shumway, Stoffer (1982); Ghahgramani, Hinton (1996) // View sum_e_x_t_xu_tm1 = // sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1); // Matrix q = sum_E_x_t_x_t_ - sum_e_x_t_xu_tm1 * // inv_sympd(sum_E_xu_tm1_xu_tm1_) * // sum_e_x_t_xu_tm1.t(); // q /= n_t_tot_; // this way is same as above iff dynamics were just updated: // View sum_e_x_t_xu_tm1 = // sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1); // Matrix ab = arma::join_horiz(fit_.A(), fit_.B()); // Matrix q = sum_E_x_t_x_t_ - ab * sum_e_x_t_xu_tm1.t(); // q /= n_t_tot_; // From scratch method: // Q is covariance of the error between state and dynamics-predicted state // (aka process noise) // Q* = E[(x_t - Ax_{t-1} - Bu_{t-1})*(x_t - Ax_{t-1} - Bu_{t-1})\u0026#39;] // t-1 terms: View sum_e_x_tm1_x_tm1 = sum_E_xu_tm1_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ - 1); View sum_e_u_tm1_u_tm1 = sum_E_xu_tm1_xu_tm1_.submat(n_x_, n_x_, n_x_ + n_u_ - 1, n_x_ + n_u_ - 1); View sum_e_x_tm1_u_tm1 = sum_E_xu_tm1_xu_tm1_.submat(0, n_x_, n_x_ - 1, n_x_ + n_u_ - 1); // t, t-1 terms: View sum_e_x_t_x_tm1 = sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ - 1); View sum_e_x_t_u_tm1 = sum_E_xu_t_xu_tm1_.submat(0, n_x_, n_x_ - 1, n_x_ + n_u_ - 1); Matrix q = sum_E_x_t_x_t_; q += fit_.A() * sum_e_x_tm1_x_tm1 * fit_.A().t(); q -= sum_e_x_t_x_tm1 * fit_.A().t(); q -= fit_.A() * sum_e_x_t_x_tm1.t(); // input-related terms: q += fit_.B() * sum_e_u_tm1_u_tm1 * fit_.B().t(); q -= sum_e_x_t_u_tm1 * fit_.B().t(); q -= fit_.B() * sum_e_x_t_u_tm1.t(); q += fit_.A() * sum_e_x_tm1_u_tm1 * fit_.B().t(); q += fit_.B() * sum_e_x_tm1_u_tm1.t() * fit_.A().t(); q /= n_t_tot_; fit_.set_Q(q); std::cout \u0026lt;\u0026lt; \u0026#34;Q_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.Q()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // std::cout \u0026lt;\u0026lt; \u0026#34;Q_new: \\n\u0026#34; \u0026lt;\u0026lt; fit_.Q() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::MaximizeInitial() { Vector x0 = fit_.x0(); x0.zeros(); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { x0 += x_[trial].col(0); } x0 /= z_.size(); std::cout \u0026lt;\u0026lt; \u0026#34;x0_new[0]: \u0026#34; \u0026lt;\u0026lt; x0[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // always recalc P0 even if the initial state is fixed (at zero, for // example) Matrix e_var(n_x_, n_x_, fill::zeros); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { e_var += (x_[trial].col(0) - x0) * (x_[trial].col(0) - x0).t(); } e_var /= z_.size(); // go ahead and subtract x0*x0\u0026#39; so don\u0026#39;t have to below. e_var -= x0 * x0.t(); // To get P0, going to get initial P_ per trial and average. // (which might be wrong, but need a single number) Matrix p0 = fit_.P0(); p0.zeros(); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { p0 += (x_[trial].col(0) * x_[trial].col(0).t()) + P_[trial].slice(0) + e_var; } p0 /= z_.size(); fit_.set_P0(p0); std::cout \u0026lt;\u0026lt; \u0026#34;P0_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.P0()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::MaximizeOutput() { // solve for C+d: Matrix sum_zx(n_y_, n_x_ + 1, fill::zeros); Vector x1(n_x_ + 1, fill::zeros); x1[n_x_] = 1.0; // augment with one to solve for bias Matrix sum_e_x1_x1(n_x_ + 1, n_x_ + 1, fill::zeros); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { for (size_t t = 1; t \u0026lt; n_t_[trial]; t++) { x1.subvec(0, n_x_ - 1) = x_[trial].col(t); sum_zx += z_.at(trial).col(t) * x1.t(); sum_e_x1_x1 += x1 * x1.t(); sum_e_x1_x1.submat(0, 0, n_x_ - 1, n_x_ - 1) += P_[trial].slice(t); } } Matrix cd = sum_zx * inv_sympd(sum_e_x1_x1); fit_.set_C(cd.submat(0, 0, n_y_ - 1, n_x_ - 1)); fit_.set_d(vectorise(cd.submat(0, n_x_, n_y_ - 1, n_x_))); std::cout \u0026lt;\u0026lt; \u0026#34;C_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.C()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;d_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.d()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::MaximizeMeasurement() { // Solve for measurement noise covar size_t n_t_tot = 0; // Ghahgramani, Hinton 1996: Matrix sum_zz(n_y_, n_y_, fill::zeros); Matrix sum_yz(n_y_, n_y_, fill::zeros); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { for (size_t t = 1; t \u0026lt; n_t_[trial]; t++) { sum_zz += z_.at(trial).col(t) * z_.at(trial).col(t).t(); // Use Cnew: sum_yz += (fit_.C() * x_[trial].col(t) + fit_.d()) * z_.at(trial).col(t).t(); n_t_tot += 1; } } fit_.set_R((sum_zz - sum_yz) / n_t_tot); std::cout \u0026lt;\u0026lt; \u0026#34;R_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.R()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EM\u0026lt;Fit\u0026gt;::Reset() { // reset to initial conditions for (size_t trial = 0; trial \u0026lt; n_trials_; trial++) { x_[trial].col(0) = fit_.x0(); P_[trial].slice(0) = fit_.P0(); y_[trial].col(0) = fit_.C() * x_[trial].col(0) + fit_.d(); } } template \u0026lt;typename Fit\u0026gt; Vector EM\u0026lt;Fit\u0026gt;::UpdateTheta() { // TODO(mfbolus): This should include n_y_ more params for d. size_t n_params = 3 * n_x_ * n_x_ + n_x_ * n_u_ + n_x_ + n_y_ * n_x_ + n_y_; if (fit_.R().n_elem \u0026gt; 0) { n_params += n_y_ * n_y_; } Vector theta(n_params); size_t idx_start = 0; theta.subvec(idx_start, idx_start + n_x_ * n_x_ - 1) = vectorise(fit_.A()); idx_start += n_x_ * n_x_; theta.subvec(idx_start, idx_start + n_x_ * n_u_ - 1) = vectorise(fit_.B()); idx_start += n_x_ * n_u_; theta.subvec(idx_start, idx_start + n_x_ * n_x_ - 1) = vectorise(fit_.Q()); idx_start += n_x_ * n_x_; theta.subvec(idx_start, idx_start + n_x_ - 1) = vectorise(fit_.x0()); idx_start += n_x_; theta.subvec(idx_start, idx_start + n_x_ * n_x_ - 1) = vectorise(fit_.P0()); idx_start += n_x_ * n_x_; theta.subvec(idx_start, idx_start + n_y_ * n_x_ - 1) = vectorise(fit_.C()); idx_start += n_y_ * n_x_; theta.subvec(idx_start, idx_start + n_y_ - 1) = vectorise(fit_.d()); idx_start += n_y_; if (fit_.R().n_elem \u0026gt; 0) { theta.subvec(idx_start, idx_start + n_y_ * n_y_ - 1) = vectorise(fit_.R()); } return theta; } } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":54,"href":"/lds-ctrl-est/docs/api/files/lds__fit__ssid_8h/","title":"ldsCtrlEst_h/lds_fit_ssid.h","section":"Files","content":" ldsCtrlEst_h/lds_fit_ssid.h # subspace identification More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Classes # Name class lds::SSID Detailed Description # This file declares and partially defines a template type by which LDS models are fit by a subspace identification (SSID) algorithm ([lds::SSID](/lds-ctrl-est/docs/api/classes/classlds_1_1_s_s_i_d/)\u0026lt;Fit\u0026gt;).\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer.\nSource code # //===-- ldsCtrlEst_h/lds_fit_ssid.h - SSID Fit ------------------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_FIT_SSID_H #define LDSCTRLEST_LDS_FIT_SSID_H #include \u0026#34;lds_fit.h\u0026#34; namespace lds { template \u0026lt;typename Fit\u0026gt; class SSID { static_assert(std::is_base_of\u0026lt;lds::Fit, Fit\u0026gt;::value, \u0026#34;Fit must be derived from lds::Fit type.\u0026#34;); public: SSID() = default; SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train, const Vector\u0026amp; d = Vector(1).fill(-kInf)); std::tuple\u0026lt;Fit, Vector\u0026gt; Run(SSIDWt ssid_wt); std::tuple\u0026lt;UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026gt; ReturnData() { auto tuple = std::make_tuple(std::move(u_), std::move(z_)); u_ = UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;(); z_ = UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;(); return tuple; } protected: void CalcD(data_t t_silence = 0.1, data_t thresh_silence = 0.001); void CreateHankelDataMat(); virtual void DecomposeData() = 0; void CalcSVD(SSIDWt wt); void Solve(data_t wt_dc); void RecomputeExtObs(); // input/output training data UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; u_; UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; z_; Matrix D_; Fit fit_; Matrix g_dc_; data_t dt_{}; size_t n_u_{}; size_t n_x_{}; size_t n_y_{}; size_t n_h_{}; size_t n_trials_{}; std::vector\u0026lt;size_t\u0026gt; n_t_; size_t n_t_tot_{}; Matrix L_; Vector s_; Matrix ext_obs_t_; }; template \u0026lt;typename Fit\u0026gt; SSID\u0026lt;Fit\u0026gt;::SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train, const Vector\u0026amp; d) { // check input/output data dimensions are consistent if (z_train.size() != u_train.size()) { throw std::runtime_error( \u0026#34;I/O training data have different number of trials.\u0026#34;); } n_trials_ = u_train.size(); n_t_tot_ = 0; n_t_ = std::vector\u0026lt;size_t\u0026gt;(n_trials_); for (size_t trial = 0; trial \u0026lt; n_trials_; trial++) { if (z_train.at(trial).n_cols != u_train.at(trial).n_cols) { throw std::runtime_error( \u0026#34;I/O training data have different number of time steps.\u0026#34;); } n_t_[trial] = u_train.at(trial).n_cols; n_t_tot_ += n_t_[trial]; } dt_ = dt; n_x_ = n_x; n_u_ = u_train.at(0).n_rows; n_y_ = z_train.at(0).n_rows; n_h_ = n_h; // dimensionality check for eventual block-hankel data matrix size_t len = n_t_tot_ - 2 * n_h_ + 1; if (len \u0026lt; (2 * n_h_ * (n_u_ + n_y_))) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;Dataset problem! More rows than columns in block-hankel data \u0026#34; \u0026#34;matrix: 2*(n_u+n_y)*n_h \u0026gt; data-length! Need higher data-length or \u0026#34; \u0026#34;lower n_h.\u0026#34;; throw std::runtime_error(ss.str()); } fit_ = Fit(n_u_, n_x_, n_y_, dt_); u_ = std::move(u_train); z_ = std::move(z_train); if (!d.is_finite() || (d.n_rows != n_y_)) { // TODO(mfbolus): implement least-square solution for impulse response with // a second input of ones. Data-driven way of accounting for offset *not* // driven by an input. // // For now, calculate output bias (d) as the // output wherever the stimulus has not been on for some amount of time. // convolve u with rectangle and take all samples. This is a reasonable // approach, since often when autonomous systems are fit (i.e., systems with // no input), they will subtract off the mean of the output. This // essentially amounts to setting output bias to the mean of the output when // there is no stimulation. data_t t_silence = 0.1; data_t thresh_silence = 0.001; CalcD(t_silence, thresh_silence); } else { fit_.set_d(d); } } template \u0026lt;typename Fit\u0026gt; std::tuple\u0026lt;Fit, Vector\u0026gt; SSID\u0026lt;Fit\u0026gt;::Run(SSIDWt ssid_wt) { // the weight on minimizing dc I/O gain only works for gaussian, // and hopefully not necessary with appropriate dataset. data_t wt_dc = 0; // std::cout \u0026lt;\u0026lt; \u0026#34;creating hankel mat\\n\u0026#34;; CreateHankelDataMat(); // std::cout \u0026lt;\u0026lt; \u0026#34;decomposing data\\n\u0026#34;; DecomposeData(); // std::cout \u0026lt;\u0026lt; \u0026#34;calculating svd\\n\u0026#34;; CalcSVD(ssid_wt); // std::cout \u0026lt;\u0026lt; \u0026#34;solving for params\\n\u0026#34;; Solve(wt_dc); // std::cout \u0026lt;\u0026lt; \u0026#34;fin\\n\u0026#34;; return std::make_tuple(fit_, s_); } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::CalcD(data_t t_silence, data_t thresh_silence) { Vector d(z_.at(0).n_rows, fill::zeros); Vector win(static_cast\u0026lt;size_t\u0026gt;(t_silence / dt_), fill::ones); Vector sum_z_silence(n_y_, fill::zeros); size_t n_silence(0); for (size_t trial = 0; trial \u0026lt; u_.size(); trial++) { // find silent samples // start by convolving with Vector sum_u = vectorise(sum(abs(u_.at(trial)), 0)); Vector u_conv = conv(sum_u, win, \u0026#34;same\u0026#34;); // get only the samples that are silent... arma::uvec ubi_silence = find(u_conv \u0026lt;= thresh_silence); if (ubi_silence.n_elem \u0026gt; 0) { sum_z_silence += arma::sum(z_.at(trial).cols(ubi_silence), 1); n_silence += ubi_silence.n_elem; } } if (n_silence \u0026gt; 0) { d = sum_z_silence / n_silence; } fit_.set_d(d); } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::CreateHankelDataMat() { // temporary copy of data Matrix z(n_y_, n_t_tot_, fill::zeros); Matrix u(n_u_, n_t_tot_, fill::zeros); size_t so_far(0); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { z.submat(0, so_far, n_y_ - 1, so_far + n_t_.at(trial) - 1) = z_.at(trial); u.submat(0, so_far, n_u_ - 1, so_far + n_t_.at(trial) - 1) = u_.at(trial); so_far += n_t_.at(trial); } // remove output bias z.each_col() -= fit_.d(); // calculate I/O gain @ DC while data in convenient form g_dc_ = z * pinv(u); // std::cout \u0026lt;\u0026lt; \u0026#34;G0_data = \u0026#34; \u0026lt;\u0026lt; g_dc_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // create hankel data matrix size_t len = z.n_cols - 2 * n_h_ + 1; // data length in hankel mat // block-hankel data matrix D_ = Matrix(2 * n_h_ * (n_u_ + n_y_), len, fill::zeros); // past input auto u_p = D_.submat(0, 0, n_h_ * n_u_ - 1, len - 1); // future input auto u_f = D_.submat(n_h_ * n_u_, 0, 2 * n_h_ * n_u_ - 1, len - 1); // past output auto y_p = D_.submat(2 * n_h_ * n_u_, 0, n_h_ * (2 * n_u_ + n_y_) - 1, len - 1); // future output auto y_f = D_.submat(n_h_ * (2 * n_u_ + n_y_), 0, 2 * n_h_ * (n_u_ + n_y_) - 1, len - 1); size_t idx = 0; for (size_t k = 0; k \u0026lt; len; k++) { idx = 0; for (size_t kk = k; kk \u0026lt; (n_h_ + k); kk++) { u_p.col(k).subvec(idx, idx + n_u_ - 1) = u.col(kk); idx += n_u_; } idx = 0; for (size_t kk = (n_h_ + k); kk \u0026lt; (2 * n_h_ + k); kk++) { u_f.col(k).subvec(idx, idx + n_u_ - 1) = u.col(kk); idx += n_u_; } idx = 0; for (size_t kk = k; kk \u0026lt; (n_h_ + k); kk++) { y_p.col(k).subvec(idx, idx + n_y_ - 1) = z.col(kk); idx += n_y_; } idx = 0; for (size_t kk = (n_h_ + k); kk \u0026lt; (2 * n_h_ + k); kk++) { y_f.col(k).subvec(idx, idx + n_y_ - 1) = z.col(kk); idx += n_y_; } } D_ /= sqrt(static_cast\u0026lt;data_t\u0026gt;(len)); } // template \u0026lt;typename Fit\u0026gt; // void SSID\u0026lt;Fit\u0026gt;::DecomposeData() { // // do LQ decomp instead of calculating covariance expensive way // // Note that \u0026#34;R\u0026#34; in van Overschee is lower-triangular (L), not \u0026#34;R\u0026#34; in QR // // decomp. Very confusing. // Matrix q_t; // lq(L_, q_t, D_); // // van Overschee zeros out the other elements. // L_ = trimatl(L_); // } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::CalcSVD(SSIDWt wt) { // submats that will be needed: auto R_14_14 = L_.submat(0, 0, n_h_ * (2 * n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_11_14 = L_.submat(0, 0, n_h_ * n_u_ - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_11_13 = L_.submat(0, 0, n_h_ * n_u_ - 1, n_h_ * (2 * n_u_) - 1); auto R_23_13 = L_.submat(n_h_ * n_u_, 0, 2 * n_h_ * n_u_ - 1, 2 * n_h_ * n_u_ - 1); auto R_44_14 = L_.submat(2 * n_u_ * n_h_, 0, n_h_ * (2 * n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_44_13 = L_.submat(2 * n_u_ * n_h_, 0, n_h_ * (2 * n_u_ + n_y_) - 1, n_h_ * (2 * n_u_) - 1); auto R_44 = L_.submat(2 * n_u_ * n_h_, 2 * n_u_ * n_h_, n_h_ * (2 * n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_56_14 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, n_h_ * (2 * n_u_ + 2 * n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); Matrix Lup_Luf_Lyp = R_56_14 * pinv(R_14_14); auto Lup = Lup_Luf_Lyp.submat(0, 0, n_h_ * n_y_ - 1, n_h_ * n_u_ - 1); auto Luf = Lup_Luf_Lyp.submat(0, n_h_ * n_u_, n_h_ * n_y_ - 1, 2 * n_h_ * n_u_ - 1); auto Lyp = Lup_Luf_Lyp.submat(0, 2 * n_h_ * n_u_, n_h_ * n_y_ - 1, n_h_ * (2 * n_u_ + n_y_) - 1); // aka: R_f Matrix R_56_16 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, 2 * n_h_ * (n_u_ + n_y_) - 1, L_.n_cols - 1); // from van Overschee subid.m: // Rf = R((2*m+l)*i+1:2*(m+l)*i,:); % Future outputs Matrix U; Matrix V; switch (wt) { case kSSIDNone: { // No weighting. (what van Overschee calls \u0026#34;N4SID\u0026#34;) Matrix O_k_sans_Qt = Lup * R_11_14 + Lyp * R_44_14; arma::svd(U, s_, V, O_k_sans_Qt, \u0026#34;std\u0026#34;); } break; case kSSIDMOESP: { // MOESP weighting // This is what they use in the \u0026#34;robust\u0026#34; algorithm van Overschee, de Moor // 1996 Matrix Pi = Matrix(2 * n_h_ * n_u_, 2 * n_h_ * n_u_, fill::eye) - R_23_13.t() * inv(R_23_13 * R_23_13.t()) * R_23_13; Matrix O_k_ortho_Uf_sans_Qt = join_horiz((Lup * R_11_13 + Lyp * R_44_13) * Pi, Lyp * R_44); svd(U, s_, V, O_k_ortho_Uf_sans_Qt, \u0026#34;std\u0026#34;); } break; case kSSIDCVA: { // CVA weighting // See van Overschee\u0026#39;s matlab code (subid.m): // https://www.mathworks.com/matlabcentral/fileexchange/2290-subspace-identification-for-linear-systems Matrix Pi = Matrix(2 * n_h_ * n_u_, 2 * n_h_ * n_u_, fill::eye) - R_23_13.t() * inv(R_23_13 * R_23_13.t()) * R_23_13; Matrix O_k_ortho_Uf_sans_Qt = join_horiz((Lup * R_11_13 + Lyp * R_44_13) * Pi, Lyp * R_44); Matrix inv_w1; Matrix qt1; lq(inv_w1, qt1, R_56_16); // lq decomp of R_f (future output data) inv_w1 = trimatl(inv_w1); inv_w1 = inv_w1.submat(0, 0, n_y_ * n_h_ - 1, n_y_ * n_h_ - 1); Matrix w_o_w = arma::solve( inv_w1, O_k_ortho_Uf_sans_Qt); // alternatively // pinv(inv_W1)*O_k_ortho_Uf_sans_Qt svd(U, s_, V, w_o_w, \u0026#34;std\u0026#34;); U = inv_w1 * U; break; } } // Truncate to model order (heart of ssid method) auto s_hat = s_.subvec(0, n_x_ - 1); Matrix diag_sqrt_s = diagmat(sqrt(s_hat)); auto u_hat = U.submat(0, 0, U.n_rows - 1, n_x_ - 1); // get extended observability and controllability mats ext_obs_t_ = u_hat * diag_sqrt_s; // extended observability matrix } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::Solve(data_t wt_dc) { // required submats auto R_56_14 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, n_h_ * (2 * n_u_ + 2 * n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_23_15 = L_.submat(n_h_ * n_u_, 0, 2 * n_h_ * n_u_ - 1, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1); auto R_66_15 = L_.submat(n_h_ * (2 * n_u_ + n_y_) + n_y_, 0, 2 * n_h_ * (n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1); auto R_55_15 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1); auto R_56_15 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, 2 * n_h_ * (n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1); // Solve for params using appropriate algorithm: // robust deterministic/stochastic algorithm in van Overschee 1996 // algorithm that the authors say \u0026#34;works\u0026#34; in practice. auto ext_obs_tm1 = ext_obs_t_.submat( 0, 0, ext_obs_t_.n_rows - 1 - n_y_, ext_obs_t_.n_cols - 1); // extended observability matrix // This is what textbook (1996) says: // // Matrix Tr = join_vert(pinv(ext_obs_t_) * R_56_15, R_23_15); // // HOWEVER, do not know why but have to fill the last place with zeros like // authors\u0026#39; matlab implementation (see `subid.m`) // Otherwise, get ridiculous covariances (although A,C estimates are close to // same...) Matrix Tr = join_vert( join_horiz(pinv(ext_obs_t_) * R_56_14, Matrix(n_x_, n_y_, fill::zeros)), R_23_15); Matrix Tl = join_vert(pinv(ext_obs_tm1) * R_66_15, R_55_15); Matrix S = Tl * pinv(Tr); // Use alternative in van Overschee 1996, p. 129. Apparently, should ensure // stability. fit_.set_C(ext_obs_t_.submat(0, 0, n_y_ - 1, ext_obs_t_.n_cols - 1)); Matrix ext_obs_t_p1 = join_vert( ext_obs_t_.submat(n_y_, 0, ext_obs_t_.n_rows - 1, ext_obs_t_.n_cols - 1), Matrix(n_y_, ext_obs_t_.n_cols, fill::zeros)); fit_.set_A(pinv(ext_obs_t_) * ext_obs_t_p1); // At this point, van Overschee \u0026amp; de Moor suggest re-calculating ext_obs_t_, // ext_obs_tm1 from (A, C) because it was just an approximation. This is RecomputeExtObs(); ext_obs_tm1 = ext_obs_t_.submat( 0, 0, ext_obs_t_.n_rows - 1 - n_y_, ext_obs_t_.n_cols - 1); // extended observability matrix Tl = join_vert(pinv(ext_obs_tm1) * R_66_15, R_55_15); Tr = join_vert( join_horiz(pinv(ext_obs_t_) * R_56_14, Matrix(n_x_, n_y_, fill::zeros)), R_23_15); S = Tl * pinv(Tr); Matrix Lcurly = S.submat(0, 0, n_x_ + n_y_ - 1, n_x_ - 1) * pinv(ext_obs_t_); Matrix Mcurly = pinv(ext_obs_tm1); Matrix Pcurly = Tl - Lcurly * R_56_15; Vector Pvec = vectorise(Pcurly); Matrix Qcurly = R_23_15; // Identify [D; B], assuming D=0 and ensuring DC gain is correct Matrix sum_QcurlyT_kron_Ncurly( (n_h_ * (2 * n_u_ + n_y_) + n_y_) * (n_y_ + n_x_), n_u_ * (n_y_ + n_x_), fill::zeros); Matrix eye_ext_obs_tm1(n_y_ + ext_obs_tm1.n_rows, n_y_ + ext_obs_tm1.n_cols, fill::eye); eye_ext_obs_tm1.submat(n_y_, n_y_, eye_ext_obs_tm1.n_rows - 1, eye_ext_obs_tm1.n_cols - 1) = ext_obs_tm1; // van Overschee (1996) p. 126 Matrix N1_Tl = -Lcurly; N1_Tl.submat(0, 0, n_x_ - 1, N1_Tl.n_cols - 1) += join_horiz(Matrix(n_x_, n_y_, fill::zeros), Mcurly); N1_Tl.submat(n_x_, 0, n_x_ + n_y_ - 1, n_y_ - 1) += Matrix(n_y_, n_y_, fill::eye); Matrix Nk_Tl(N1_Tl.n_rows, N1_Tl.n_cols, fill::zeros); Matrix N_k; for (size_t k = 0; k \u0026lt; n_h_; k++) { auto Qcurly_k = Qcurly.submat(n_u_ * k, 0, n_u_ * (k + 1) - 1, Qcurly.n_cols - 1); Nk_Tl.zeros(); Nk_Tl.submat(0, 0, n_x_ + n_y_ - 1, Nk_Tl.n_cols - k * n_y_ - 1) = N1_Tl.submat(0, k * n_y_, N1_Tl.n_rows - 1, N1_Tl.n_cols - 1); N_k = Nk_Tl * eye_ext_obs_tm1; sum_QcurlyT_kron_Ncurly += kron(Qcurly_k.t(), N_k); } Matrix err_vec; if (wt_dc \u0026gt; 0) { // Constraints enforced by weighted least squares // // Reference: // // Privara S, ..., Ferkl L_. (2010) Subspace Identification of Poorly // Excited Industrial Systems. Conference in Decision and Control. // constraint 1: assume D=0 --\u0026gt; remove the components for Dvec (this is // actually a hard constraint in that it ignores D) Matrix sum_QcurlyT_kron_Ncurly_db = sum_QcurlyT_kron_Ncurly; sum_QcurlyT_kron_Ncurly = Matrix(sum_QcurlyT_kron_Ncurly_db.n_rows, n_x_ * n_u_); size_t kkk = 0; for (size_t k = 1; k \u0026lt; (n_u_ + 1); k++) { size_t start_idx = k * (n_y_ + n_x_) - n_x_; for (size_t kk = 0; kk \u0026lt; n_x_; kk++) { sum_QcurlyT_kron_Ncurly.col(kkk) = sum_QcurlyT_kron_Ncurly_db.col(start_idx + kk); kkk++; } } // constraint 2: Make sure DC I/O gain is correct Matrix b_to_g0 = fit_.C() * inv(Matrix(n_x_, n_x_, fill::eye) - fit_.A()); Matrix Pvec_Gvec = join_vert(Pvec, vectorise(g_dc_)); Matrix eye_kron_b_to_g0 = kron(Matrix(n_u_, n_u_, fill::eye), b_to_g0); Matrix sum_QcurlyT_kron_Ncurly_b_to_g0 = join_vert(sum_QcurlyT_kron_Ncurly, eye_kron_b_to_g0); // WEIGHTED LS // Important in practice because I care a lot about at least getting the DC // gain correct. Put x weight on minimizing error at DC, relative to others Matrix w(sum_QcurlyT_kron_Ncurly_b_to_g0.n_rows, sum_QcurlyT_kron_Ncurly_b_to_g0.n_rows, fill::eye); // Make weight on minimizing DC error immense so at least that // should be nailed. size_t start_row = sum_QcurlyT_kron_Ncurly.n_rows; size_t start_col = sum_QcurlyT_kron_Ncurly.n_rows; size_t stop_row = w.n_rows - 1; size_t stop_col = w.n_cols - 1; // w.submat(start_row, start_col, stop_row, stop_col) *= wt_dc*N;// scale // weight with data length? w.submat(start_row, start_col, stop_row, stop_col) *= wt_dc; Vector b_vec = inv(sum_QcurlyT_kron_Ncurly_b_to_g0.t() * w * sum_QcurlyT_kron_Ncurly_b_to_g0) * sum_QcurlyT_kron_Ncurly_b_to_g0.t() * w * Pvec_Gvec; fit_.set_B(Matrix(b_vec.memptr(), n_x_, n_u_)); // Calculate residuals and their cov. // Because I\u0026#39;ve added constraints, I need to re-calculate the right term // with b_vec instead of how van Overschee do in final algorithm. err_vec = Pvec - sum_QcurlyT_kron_Ncurly * b_vec; } else { // default way: *no* constraint on G0 or D=0 Vector db_vec = pinv(sum_QcurlyT_kron_Ncurly) * Pvec; // TODO(mfbolus) n.b., this gets thrown away... // Matrix D = Matrix(db_vec.memptr(), n_y_, n_u_); fit_.set_B(Matrix(db_vec.memptr() + (n_u_ * n_y_), n_x_, n_u_)); err_vec = Pvec - sum_QcurlyT_kron_Ncurly * db_vec; } // Matrix err = Matrix(err_vec.memptr(), Pcurly.n_rows, Pcurly.n_cols); // TODO(mfbolus): Something is wrong with the error calculation above. // Use the way van overschee does it in `subid.m` // WARNING: this ignores any above constraints, so Q, R will be approximate... Matrix err = Tl - S * Tr; Matrix cov_err = err * err.t(); fit_.set_Q(cov_err.submat(0, 0, n_x_ - 1, n_x_ - 1)); fit_.set_R(cov_err.submat(n_x_, n_x_, n_x_ + n_y_ - 1, n_x_ + n_y_ - 1)); } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::RecomputeExtObs() { ext_obs_t_.submat(0, 0, n_y_ - 1, ext_obs_t_.n_cols - 1) = fit_.C(); for (size_t k = 2; k \u0026lt; (n_h_ + 1); k++) { ext_obs_t_.submat((k - 1) * n_y_, 0, k * n_y_ - 1, ext_obs_t_.n_cols - 1) = ext_obs_t_.submat((k - 2) * n_y_, 0, (k - 1) * n_y_ - 1, ext_obs_t_.n_cols - 1) * fit_.A(); } } } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":55,"href":"/lds-ctrl-est/docs/api/files/lds__fit_8h/","title":"ldsCtrlEst_h/lds_fit.h","section":"Files","content":" ldsCtrlEst_h/lds_fit.h # LDS base fit type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Classes # Name class lds::Fit LDS Fit Type. Detailed Description # This file declares and partially defines the base fit type for a linear dynamical system. It is expounded upon by variants with Gaussian and Poisson observation assumptions for fitting.\nSource code # //===-- ldsCtrlEst_h/lds_fit.h - Fit Type for LDS ---------------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDS_FIT_HPP #define LDS_FIT_HPP // namespace #include \u0026#34;lds.h\u0026#34; #include \u0026#34;lds_uniform_mats.h\u0026#34; namespace lds { class Fit { public: Fit() = default; Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt); virtual ~Fit() = default; // get methods size_t n_u() const { return n_u_; }; size_t n_x() const { return n_x_; }; size_t n_y() const { return n_y_; }; data_t dt() const { return dt_; }; const Matrix\u0026amp; A() const { return A_; }; const Matrix\u0026amp; B() const { return B_; }; const Vector\u0026amp; g() const { return g_; }; const Vector\u0026amp; m() const { return m_; }; const Matrix\u0026amp; Q() const { return Q_; }; const Vector\u0026amp; x0() const { return x0_; }; const Matrix\u0026amp; P0() const { return P0_; }; const Matrix\u0026amp; C() const { return C_; }; const Vector\u0026amp; d() const { return d_; }; // gets measurement noise virtual const Matrix\u0026amp; R() const = 0; // set methods (e.g., seeding initial fit values) void set_A(const Matrix\u0026amp; A) { Reassign(A_, A); }; void set_B(const Matrix\u0026amp; B) { Reassign(B_, B); }; void set_g(const Vector\u0026amp; g) { Reassign(g_, g); }; void set_m(const Vector\u0026amp; m) { Reassign(m_, m); }; void set_Q(const Matrix\u0026amp; Q) { Reassign(Q_, Q); ForceSymPD(Q_); }; virtual void set_R(const Matrix\u0026amp; R) = 0; void set_x0(const Vector\u0026amp; x0) { Reassign(x0_, x0); }; void set_P0(const Matrix\u0026amp; P0) { Reassign(P0_, P0); ForceSymPD(P0_); }; void set_C(const Matrix\u0026amp; C) { Reassign(C_, C); }; void set_d(const Vector\u0026amp; d) { Reassign(d_, d); }; View f(Matrix\u0026amp; x, const Matrix\u0026amp; u, size_t t) { x.col(t) = A_ * x.col(t - 1) + B_ * (g_ % u.col(t - 1)) + m_; return x.col(t); }; View f(Matrix\u0026amp; x_pre, const Matrix\u0026amp; x_post, const Matrix\u0026amp; u, size_t t) { x_pre.col(t) = A_ * x_post.col(t - 1) + B_ * (g_ % u.col(t - 1)) + m_; return x_pre.col(t); }; virtual View h(Matrix\u0026amp; y, const Matrix\u0026amp; x, size_t t) = 0; protected: data_t dt_{}; // Dynamics Matrix A_; Matrix B_; Vector g_; Vector m_; Matrix Q_; // Output Matrix C_; Vector d_; Matrix R_; // initial conditions Vector x0_; Matrix P0_; size_t n_u_{}; size_t n_x_{}; size_t n_y_{}; }; } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":56,"href":"/lds-ctrl-est/docs/api/files/lds__gaussian__ctrl_8h/","title":"ldsCtrlEst_h/lds_gaussian_ctrl.h","section":"Files","content":" ldsCtrlEst_h/lds_gaussian_ctrl.h # GLDS Controller. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::gaussian Linear Dynamical Systems with Gaussian observations. Classes # Name class lds::gaussian::Controller Gaussian-observation Controller Type. Detailed Description # This file declares and partially defines the type for control of a gaussian-observation linear dynamical system (lds::gaussian::Controller). It inherits functionality from the underlying GLDS model type (lds::gaussian::System), including state estimation.\nSource code # //===-- ldsCtrlEst_h/lds_gaussian_ctrl.h - GLDS Controller ------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_GAUSSIAN_CTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_CTRL_H // namespace #include \u0026#34;lds_gaussian.h\u0026#34; // system #include \u0026#34;lds_gaussian_sys.h\u0026#34; // controller #include \u0026#34;lds_ctrl.h\u0026#34; namespace lds { namespace gaussian { class Controller : public lds::Controller\u0026lt;System\u0026gt; { public: void set_y_ref(const Vector\u0026amp; y_ref) override { Reassign(y_ref_,y_ref); cx_ref_ = y_ref - sys_.d(); }; // make sure base class template methods available using lds::Controller\u0026lt;System\u0026gt;::Controller; using lds::Controller\u0026lt;System\u0026gt;::Control; using lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference; using lds::Controller\u0026lt;System\u0026gt;::sys; using lds::Controller\u0026lt;System\u0026gt;::Kc; using lds::Controller\u0026lt;System\u0026gt;::Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::Kc_u; using lds::Controller\u0026lt;System\u0026gt;::g_design; using lds::Controller\u0026lt;System\u0026gt;::u_ref; using lds::Controller\u0026lt;System\u0026gt;::x_ref; using lds::Controller\u0026lt;System\u0026gt;::y_ref; using lds::Controller\u0026lt;System\u0026gt;::control_type; using lds::Controller\u0026lt;System\u0026gt;::set_sys; using lds::Controller\u0026lt;System\u0026gt;::set_g_design; using lds::Controller\u0026lt;System\u0026gt;::set_u_ref; using lds::Controller\u0026lt;System\u0026gt;::set_x_ref; using lds::Controller\u0026lt;System\u0026gt;::set_y_ref; using lds::Controller\u0026lt;System\u0026gt;::set_Kc; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_u; using lds::Controller\u0026lt;System\u0026gt;::set_tau_awu; using lds::Controller\u0026lt;System\u0026gt;::set_control_type; using lds::Controller\u0026lt;System\u0026gt;::Reset; using lds::Controller\u0026lt;System\u0026gt;::Print; }; } // namespace gaussian } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":57,"href":"/lds-ctrl-est/docs/api/files/lds__gaussian__fit__em_8h/","title":"ldsCtrlEst_h/lds_gaussian_fit_em.h","section":"Files","content":" ldsCtrlEst_h/lds_gaussian_fit_em.h # GLDS E-M fit type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::gaussian Linear Dynamical Systems with Gaussian observations. Classes # Name class lds::gaussian::FitEM GLDS E-M Fit Type. Detailed Description # This file declares and partially defines a type by which Gaussian-output LDS models are fit by the expectation-maximization (EM) algorithm (lds::gaussian::emFit_t).\nReferences: [1] Shumway RH, Stoffer DS. (1982) An Approach to Time Series Smoothing and Forecasting Using the EM Algorithm.Journal of Time Series Analysis 3(2).\n[2] Ghahramani Z, Hinton GE. (1996) Parameter Estimation for Linear Dynamical Systems. Technical Report CRG-TR-96-2.\nSource code # //===-- ldsCtrlEst_h/lds_gaussian_fit_em.h - GLDS Fit (EM) ------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H #include \u0026#34;lds_fit_em.h\u0026#34; #include \u0026#34;lds_gaussian_fit.h\u0026#34; namespace lds { namespace gaussian { class FitEM : public EM\u0026lt;Fit\u0026gt; { public: using EM\u0026lt;Fit\u0026gt;::EM; private: void MaximizeOutput() override; void MaximizeMeasurement() override; void RecurseKe(Matrix\u0026amp; Ke, Cube\u0026amp; P_pre, Cube\u0026amp; P_post, size_t t) override; }; } // namespace gaussian } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":58,"href":"/lds-ctrl-est/docs/api/files/lds__gaussian__fit__ssid_8h/","title":"ldsCtrlEst_h/lds_gaussian_fit_ssid.h","section":"Files","content":" ldsCtrlEst_h/lds_gaussian_fit_ssid.h # GLDS SSID fit type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::gaussian Linear Dynamical Systems with Gaussian observations. Classes # Name class lds::gaussian::FitSSID Subspace Identification (SSID) for GLDS. Detailed Description # This file declares and partially defines a type by which Gaussian-output LDS models are fit by a subspace identification (SSID) algorithm (lds::gaussian::ssidFit_t).\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer.\nSource code # //===-- ldsCtrlEst_h/lds_gaussian_fit_ssid.h - GLDS Fit (SSID) --*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H #include \u0026#34;lds_fit_ssid.h\u0026#34; #include \u0026#34;lds_gaussian_fit.h\u0026#34; namespace lds { namespace gaussian { class FitSSID : public SSID\u0026lt;Fit\u0026gt; { public: using SSID\u0026lt;Fit\u0026gt;::SSID; using SSID\u0026lt;Fit\u0026gt;::Run; private: using SSID\u0026lt;Fit\u0026gt;::CreateHankelDataMat; using SSID\u0026lt;Fit\u0026gt;::CalcSVD; using SSID\u0026lt;Fit\u0026gt;::Solve; void DecomposeData() override; void SolveVanOverschee(); }; } // namespace gaussian } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":59,"href":"/lds-ctrl-est/docs/api/files/lds__gaussian__fit_8h/","title":"ldsCtrlEst_h/lds_gaussian_fit.h","section":"Files","content":" ldsCtrlEst_h/lds_gaussian_fit.h # GLDS fit type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::gaussian Linear Dynamical Systems with Gaussian observations. Classes # Name class lds::gaussian::Fit GLDS Fit Type. Detailed Description # This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code # //===-- ldsCtrlEst_h/lds_gaussian_fit.h - Fit Type for GLDS -----*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_H // namespace #include \u0026#34;lds_gaussian.h\u0026#34; // fit type #include \u0026#34;lds_fit.h\u0026#34; namespace lds { namespace gaussian { class Fit : public lds::Fit { public: Fit() = default; Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt); const Matrix\u0026amp; R() const override { return R_; }; void set_R(const Matrix\u0026amp; R) override { Reassign(R_, R); ForceSymPD(R_); }; View h(Matrix\u0026amp; y, const Matrix\u0026amp; x, size_t t) override { y.col(t) = C_ * x.col(t) + d_; return y.col(t); }; }; }; // namespace gaussian } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":60,"href":"/lds-ctrl-est/docs/api/files/lds__gaussian__sctrl_8h/","title":"ldsCtrlEst_h/lds_gaussian_sctrl.h","section":"Files","content":" ldsCtrlEst_h/lds_gaussian_sctrl.h # GLDS switched controller type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::gaussian Linear Dynamical Systems with Gaussian observations. Classes # Name class lds::gaussian::SwitchedController Gaussian-observation SwitchedController Type. Detailed Description # This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Gaussian-output linear dynamical systems (lds::gaussian::SwitchedController).\nSource code # //===-- ldsCtrlEst_h/lds_gaussian_sctrl.h - Switched Controller -*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H // controller type #include \u0026#34;lds_gaussian_ctrl.h\u0026#34; // switched controller #include \u0026#34;lds_sctrl.h\u0026#34; namespace lds { namespace gaussian { class SwitchedController : public lds::SwitchedController\u0026lt;System\u0026gt; { public: void set_y_ref(const Vector\u0026amp; y_ref) override { Reassign(y_ref_, y_ref); cx_ref_ = y_ref - sys_.d(); } // make sure base class template methods available using lds::SwitchedController\u0026lt;System\u0026gt;::SwitchedController; using lds::SwitchedController\u0026lt;System\u0026gt;::Switch; using lds::SwitchedController\u0026lt;System\u0026gt;::Control; using lds::SwitchedController\u0026lt;System\u0026gt;::ControlOutputReference; using lds::SwitchedController\u0026lt;System\u0026gt;::sys; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::set_g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::set_u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::set_tau_awu; using lds::SwitchedController\u0026lt;System\u0026gt;::set_control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::Reset; using lds::SwitchedController\u0026lt;System\u0026gt;::Print; }; // SwitchedController } // namespace gaussian } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":61,"href":"/lds-ctrl-est/docs/api/files/lds__gaussian__sys_8h/","title":"ldsCtrlEst_h/lds_gaussian_sys.h","section":"Files","content":" ldsCtrlEst_h/lds_gaussian_sys.h # GLDS base type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::gaussian Linear Dynamical Systems with Gaussian observations. Classes # Name class lds::gaussian::System Gaussian LDS Type. Detailed Description # This file declares and partially defines the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems ([lds::gaussian::System](/lds-ctrl-est/docs/api/classes/classlds_1_1gaussian_1_1_system/)). It inherits functionality from the underlying linear dynamical system ([lds::System](/lds-ctrl-est/docs/api/classes/classlds_1_1_system/)).\nSource code # //===-- ldsCtrlEst_h/lds_gaussian_sys.h - GLDS ------------------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_GAUSSIAN_SYS_H #define LDSCTRLEST_LDS_GAUSSIAN_SYS_H // namespace #include \u0026#34;lds_gaussian.h\u0026#34; // system #include \u0026#34;lds_sys.h\u0026#34; namespace lds { namespace gaussian { class System : public lds::System { public: System() = default; System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0, data_t r0 = kDefaultR0); const Vector\u0026amp; Simulate(const Vector\u0026amp; u_tm1) override; // get methods const Matrix\u0026amp; R() const { return R_; }; // set methods void set_Q(const Matrix\u0026amp; Q) { lds::System::set_Q(Q); do_recurse_Ke_ = true; } void set_R(const Matrix\u0026amp; R) { Reassign(R_, R); do_recurse_Ke_ = true; }; void set_Ke(const Matrix\u0026amp; Ke) { Reassign(Ke_, Ke); // if users have set Ke, they must not want to calculate it online. do_recurse_Ke_ = false; }; void set_Ke_m(const Matrix\u0026amp; Ke_m) { Reassign(Ke_m_, Ke_m); // if users have set Ke, they must not want to calculate it online. do_recurse_Ke_ = false; }; void Print(); protected: void h() override { cx_ = C_ * x_; y_ = cx_ + d_; }; Vector h_(Vector x) override { return C_ * x + d_; }; void RecurseKe() override; // Gaussian-output-specific Matrix R_; bool do_recurse_Ke_{}; }; // System } // namespace gaussian } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":62,"href":"/lds-ctrl-est/docs/api/files/lds__gaussian_8h/","title":"ldsCtrlEst_h/lds_gaussian.h","section":"Files","content":" ldsCtrlEst_h/lds_gaussian.h # glds namespace More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::gaussian Linear Dynamical Systems with Gaussian observations. Detailed Description # This file declares and partially defines the namespace for linear dynamical systems with Gaussian observations ([lds::gaussian](/lds-ctrl-est/docs/api/namespaces/namespacelds_1_1gaussian/)).\nSource code # //===-- ldsCtrlEst_h/lds_gaussian.h - LDS with Gaussian Output --*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_GAUSSIAN_H #define LDSCTRLEST_LDS_GAUSSIAN_H // namespace #include \u0026#34;lds.h\u0026#34; namespace lds { namespace gaussian { // insert any Gaussian-specific things here... } // namespace gaussian } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":63,"href":"/lds-ctrl-est/docs/api/files/lds__poisson__ctrl_8h/","title":"ldsCtrlEst_h/lds_poisson_ctrl.h","section":"Files","content":" ldsCtrlEst_h/lds_poisson_ctrl.h # PLDS controller type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::poisson Linear Dynamical Systems with Poisson observations. Classes # Name class lds::poisson::Controller PLDS Controller Type. Detailed Description # This file declares and partially defines the type for feedback control of a Poisson-output linear dynamical system ([lds::poisson::Controller](/lds-ctrl-est/docs/api/classes/classlds_1_1poisson_1_1_controller/)). It inherits functionality from the underlying PLDS model type ([lds::poisson::System](/lds-ctrl-est/docs/api/classes/classlds_1_1poisson_1_1_system/)), including state estimation.\nSource code # //===-- ldsCtrlEst_h/lds_poisson_ctrl.h - PLDS Controller -------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_POISSON_CTRL_H #define LDSCTRLEST_LDS_POISSON_CTRL_H // namespace #include \u0026#34;lds_poisson.h\u0026#34; // system type #include \u0026#34;lds_poisson_sys.h\u0026#34; // control type #include \u0026#34;lds_ctrl.h\u0026#34; namespace lds { namespace poisson { class Controller : public lds::Controller\u0026lt;System\u0026gt; { public: void set_y_ref(const Vector\u0026amp; y_ref) override { Reassign(y_ref_, y_ref); lds::Limit(y_ref_, kYRefLb, lds::kInf); cx_ref_ = log(y_ref_) - sys_.d(); }; // make sure base class template methods available using lds::Controller\u0026lt;System\u0026gt;::Controller; using lds::Controller\u0026lt;System\u0026gt;::Control; using lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference; using lds::Controller\u0026lt;System\u0026gt;::sys; using lds::Controller\u0026lt;System\u0026gt;::Kc; using lds::Controller\u0026lt;System\u0026gt;::Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::Kc_u; using lds::Controller\u0026lt;System\u0026gt;::g_design; using lds::Controller\u0026lt;System\u0026gt;::u_ref; using lds::Controller\u0026lt;System\u0026gt;::x_ref; using lds::Controller\u0026lt;System\u0026gt;::y_ref; using lds::Controller\u0026lt;System\u0026gt;::control_type; using lds::Controller\u0026lt;System\u0026gt;::set_sys; using lds::Controller\u0026lt;System\u0026gt;::set_g_design; using lds::Controller\u0026lt;System\u0026gt;::set_u_ref; using lds::Controller\u0026lt;System\u0026gt;::set_x_ref; using lds::Controller\u0026lt;System\u0026gt;::set_y_ref; using lds::Controller\u0026lt;System\u0026gt;::set_Kc; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_u; using lds::Controller\u0026lt;System\u0026gt;::set_tau_awu; using lds::Controller\u0026lt;System\u0026gt;::set_control_type; using lds::Controller\u0026lt;System\u0026gt;::Reset; using lds::Controller\u0026lt;System\u0026gt;::Print; private: constexpr static const data_t kYRefLb = 1e-4; }; } // namespace poisson } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":64,"href":"/lds-ctrl-est/docs/api/files/lds__poisson__fit__em_8h/","title":"ldsCtrlEst_h/lds_poisson_fit_em.h","section":"Files","content":" ldsCtrlEst_h/lds_poisson_fit_em.h # PLDS E-M fit type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::poisson Linear Dynamical Systems with Poisson observations. Classes # Name class lds::poisson::FitEM PLDS E-M Fit Type. Detailed Description # This file declares and partially defines a type by which Gaussian-output LDS models are fit by the expectation-maximization (EM) algorithm (lds::gaussian::emFit_t).\nReferences: [1] Shumway RH, Stoffer DS. (1982) An Approach to Time Series Smoothing and Forecasting Using the EM Algorithm.Journal of Time Series Analysis 3(2).\n[2] Ghahramani Z, Hinton GE. (1996) Parameter Estimation for Linear Dynamical Systems. Technical Report CRG-TR-96-2.\n[3] Smith A, Brown E. (2003) Estimating a State-Space Model from Point Process Observations. Neural Computation.\nSource code # //===-- ldsCtrlEst_h/lds_poisson_fit_em.h - PLDS Fit (EM) -------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_POISSON_FIT_EM_H #define LDSCTRLEST_LDS_POISSON_FIT_EM_H #include \u0026#34;lds_fit_em.h\u0026#34; #include \u0026#34;lds_poisson_fit.h\u0026#34; namespace lds { namespace poisson { class FitEM : public EM\u0026lt;Fit\u0026gt; { public: using EM\u0026lt;Fit\u0026gt;::EM; private: void MaximizeOutput() override; void MaximizeMeasurement() override{}; void RecurseKe(Matrix\u0026amp; Ke, Cube\u0026amp; P_pre, Cube\u0026amp; P_post, size_t t) override; data_t NewtonSolveC(); void AnalyticalSolveD(); }; } // namespace poisson } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":65,"href":"/lds-ctrl-est/docs/api/files/lds__poisson__fit__ssid_8h/","title":"ldsCtrlEst_h/lds_poisson_fit_ssid.h","section":"Files","content":" ldsCtrlEst_h/lds_poisson_fit_ssid.h # PLDS SSID fit type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::poisson Linear Dynamical Systems with Poisson observations. Classes # Name class lds::poisson::FitSSID Subspace Identification (SSID) for PLDS. Detailed Description # This file declares and partially defines a type by which Poisson-output LDS models are fit by a subspace identification (SSID) algorithm ([lds::gaussian::FitSSID](/lds-ctrl-est/docs/api/classes/classlds_1_1gaussian_1_1_fit_s_s_i_d/)).\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer. [2] Buesing L, Macke JH, Sahani M. (2012) Spectral learning of linear dynamics from generalised-linear observations with application to neural population data. NIPS 25.\nSource code # //===-- ldsCtrlEst_h/lds_poisson_fit_ssid.h - PLDS Fit (SSID) ---*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_POISSON_FIT_SSID_H #define LDSCTRLEST_LDS_POISSON_FIT_SSID_H #include \u0026#34;lds_fit_ssid.h\u0026#34; #include \u0026#34;lds_poisson_fit.h\u0026#34; namespace lds { namespace poisson { class FitSSID : public SSID\u0026lt;Fit\u0026gt; { public: using SSID\u0026lt;Fit\u0026gt;::SSID; private: void DecomposeData() override; void CalcCov(); void PoissonToGaussianMoments(); Matrix cov_; }; } // namespace poisson } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":66,"href":"/lds-ctrl-est/docs/api/files/lds__poisson__fit_8h/","title":"ldsCtrlEst_h/lds_poisson_fit.h","section":"Files","content":" ldsCtrlEst_h/lds_poisson_fit.h # PLDS base fit type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::poisson Linear Dynamical Systems with Poisson observations. Classes # Name class lds::poisson::Fit PLDS Fit Type. Detailed Description # This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code # //===-- ldsCtrlEst_h/lds_poisson_fit.h - Fit Type for PLDS ------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_POISSON_FIT_H #define LDSCTRLEST_LDS_POISSON_FIT_H // namespace #include \u0026#34;lds_poisson.h\u0026#34; // fit #include \u0026#34;lds_fit.h\u0026#34; namespace lds { namespace poisson { class Fit : public lds::Fit { public: Fit() = default; Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt) : lds::Fit(n_u, n_x, n_y, dt){}; View h(Matrix\u0026amp; y, const Matrix\u0026amp; x, size_t t) override { y.col(t) = exp(C_ * x.col(t) + d_); return y.col(t); }; void set_R(const Matrix\u0026amp; R) override { std::cerr \u0026lt;\u0026lt; \u0026#34;WARNING: Cannot set R (R[0] = \u0026#34; \u0026lt;\u0026lt; R.at(0) \u0026lt;\u0026lt; \u0026#34;). No Gaussian measurement noise in Poisson observation model.\\n\u0026#34;; }; const Matrix\u0026amp; R() const override { return R_; }; }; }; // namespace poisson } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":67,"href":"/lds-ctrl-est/docs/api/files/lds__poisson__sctrl_8h/","title":"ldsCtrlEst_h/lds_poisson_sctrl.h","section":"Files","content":" ldsCtrlEst_h/lds_poisson_sctrl.h # PLDS switched controller type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::poisson Linear Dynamical Systems with Poisson observations. Classes # Name class lds::poisson::SwitchedController Poisson-observation SwitchedController Type. Detailed Description # This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Poisson-output linear dynamical systems (lds::poisson::SwitchedController).\nSource code # //===-- ldsCtrlEst_h/lds_poisson_sctrl.h - Switched Controller --*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H #define LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H #include \u0026#34;lds_poisson_ctrl.h\u0026#34; #include \u0026#34;lds_sctrl.h\u0026#34; namespace lds { namespace poisson { class SwitchedController : public lds::SwitchedController\u0026lt;System\u0026gt; { public: void set_y_ref(const Vector\u0026amp; y_ref) override { Reassign(y_ref_,y_ref); lds::Limit(y_ref_, kYRefLB, lds::kInf); cx_ref_ = log(y_ref_) - sys_.d(); }; // make sure base class template methods available using lds::SwitchedController\u0026lt;System\u0026gt;::SwitchedController; using lds::SwitchedController\u0026lt;System\u0026gt;::Switch; using lds::SwitchedController\u0026lt;System\u0026gt;::Control; using lds::SwitchedController\u0026lt;System\u0026gt;::ControlOutputReference; using lds::SwitchedController\u0026lt;System\u0026gt;::sys; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::set_g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::set_u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::set_tau_awu; using lds::SwitchedController\u0026lt;System\u0026gt;::set_control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::Reset; using lds::SwitchedController\u0026lt;System\u0026gt;::Print; private: constexpr static data_t kYRefLB = 1e-4; }; } // namespace poisson } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":68,"href":"/lds-ctrl-est/docs/api/files/lds__poisson__sys_8h/","title":"ldsCtrlEst_h/lds_poisson_sys.h","section":"Files","content":" ldsCtrlEst_h/lds_poisson_sys.h # PLDS base type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::poisson Linear Dynamical Systems with Poisson observations. Classes # Name class lds::poisson::System Poisson System type. Detailed Description # This file declares and partially defines the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems ([lds::poisson::System](/lds-ctrl-est/docs/api/classes/classlds_1_1poisson_1_1_system/)). It inherits functionality from the underlying linear dynamical system ([lds::System](/lds-ctrl-est/docs/api/classes/classlds_1_1_system/)).\nSource code # //===-- ldsCtrlEst_h/lds_poisson_sys.h - PLDS -------------------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_POISSON_SYS_H #define LDSCTRLEST_LDS_POISSON_SYS_H // namespace #include \u0026#34;lds_poisson.h\u0026#34; // system #include \u0026#34;lds_sys.h\u0026#34; // needed for Poisson random number generation #include \u0026lt;random\u0026gt; namespace lds { namespace poisson { class System : public lds::System { public: System() = default; System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0); const Vector\u0026amp; Simulate(const Vector\u0026amp; u_tm1) override; protected: void h() override { cx_ = C_ * x_; y_ = exp(cx_ + d_); diag_y_.diag() = y_; }; Vector h_(Vector x) override { return exp(C_ * x + d_); }; void RecurseKe() override; private: // Poisson-output-specific Matrix diag_y_; std::poisson_distribution\u0026lt;size_t\u0026gt; pd_; }; // System } // namespace poisson } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":69,"href":"/lds-ctrl-est/docs/api/files/lds__poisson_8h/","title":"ldsCtrlEst_h/lds_poisson.h","section":"Files","content":" ldsCtrlEst_h/lds_poisson.h # plds namespace More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. lds::poisson Linear Dynamical Systems with Poisson observations. Detailed Description # This file declares and partially defines the namespace for linear dynamical systems with Poisson observations ([lds::poisson](/lds-ctrl-est/docs/api/namespaces/namespacelds_1_1poisson/)).\nSource code # //===-- ldsCtrlEst_h/lds_poisson.h - LDS with Poisson Output ----*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_POISSON_H #define LDSCTRLEST_LDS_POISSON_H #include \u0026#34;lds.h\u0026#34; namespace lds { namespace poisson { // TODO(mfbolus): Not sure if defining these as static here makes the most // sense. Is there a downside to letting multiple poisson System objects share a // common random number generator? static std::random_device rd; static std::mt19937 rng = std::mt19937( rd()); } // namespace poisson } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":70,"href":"/lds-ctrl-est/docs/api/files/lds__sctrl_8h/","title":"ldsCtrlEst_h/lds_sctrl.h","section":"Files","content":" ldsCtrlEst_h/lds_sctrl.h # SwitchedController type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Classes # Name class lds::SwitchedController SwitchedController Type. Detailed Description # This file declares the type for switched control of a system approximated as multiple discrete Gaussian-output linear dynamical systems (lds::gaussian::SwitchedController).\nSource code # //===-- ldsCtrlEst_h/lds_sctrl.h - Switched Controller ----------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_SCTRL_H #define LDSCTRLEST_LDS_SCTRL_H #include \u0026#34;lds_ctrl.h\u0026#34; #include \u0026#34;lds_uniform_mats.h\u0026#34; #include \u0026#34;lds_uniform_vecs.h\u0026#34; namespace lds { template \u0026lt;typename System\u0026gt; class SwitchedController : public Controller\u0026lt;System\u0026gt; { public: SwitchedController() = default; SwitchedController(const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type = 0); SwitchedController(std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type = 0); void Switch(size_t idx, bool do_force_switch = false); void set_Kc(const UniformMatrixList\u0026lt;\u0026gt;\u0026amp; Kc) { Kc_list_ = Kc; Kc_ = Kc_list_.at(0); // set to first if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc(UniformMatrixList\u0026lt;\u0026gt;\u0026amp;\u0026amp; Kc) { Kc_list_ = std::move(Kc); Kc_ = Kc_list_.at(0); // set to first if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc_inty(const UniformMatrixList\u0026lt;\u0026gt;\u0026amp; Kc_inty) { Kc_inty_list_ = Kc_inty; Kc_inty_ = Kc_inty_list_.at(0); // set to first if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc_inty(UniformMatrixList\u0026lt;\u0026gt;\u0026amp;\u0026amp; Kc_inty) { Kc_inty_list_ = std::move(Kc_inty); Kc_inty_ = Kc_inty_list_.at(0); // set to first if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc_u(const UniformMatrixList\u0026lt;\u0026gt;\u0026amp; Kc_u) { Kc_u_list_ = Kc_u; Kc_u_ = Kc_u_list_.at(0); // set to first if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc_u(UniformMatrixList\u0026lt;\u0026gt;\u0026amp;\u0026amp; Kc_u) { Kc_u_list_ = std::move(Kc_u); Kc_u_ = Kc_u_list_.at(0); // set to first if (idx_ != 0) { Switch(idx_, true); } }; void set_g_design(const UniformVectorList\u0026amp; g) { g_design_list_ = g; g_design_ = g_design_list_.at(0); // set to first if (idx_ != 0) { Switch(idx_, true); } }; void set_g_design(UniformVectorList\u0026amp;\u0026amp; g) { g_design_list_ = std::move(g); g_design_ = g_design_list_.at(0); // set to first if (idx_ != 0) { Switch(idx_, true); } }; // make sure base class template methods available using lds::Controller\u0026lt;System\u0026gt;::Controller; using lds::Controller\u0026lt;System\u0026gt;::Control; using lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference; using lds::Controller\u0026lt;System\u0026gt;::sys; using lds::Controller\u0026lt;System\u0026gt;::Kc; using lds::Controller\u0026lt;System\u0026gt;::Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::Kc_u; using lds::Controller\u0026lt;System\u0026gt;::g_design; using lds::Controller\u0026lt;System\u0026gt;::u_ref; using lds::Controller\u0026lt;System\u0026gt;::x_ref; using lds::Controller\u0026lt;System\u0026gt;::y_ref; using lds::Controller\u0026lt;System\u0026gt;::control_type; using lds::Controller\u0026lt;System\u0026gt;::set_u_ref; using lds::Controller\u0026lt;System\u0026gt;::set_x_ref; using lds::Controller\u0026lt;System\u0026gt;::set_y_ref; using lds::Controller\u0026lt;System\u0026gt;::set_tau_awu; using lds::Controller\u0026lt;System\u0026gt;::set_control_type; using lds::Controller\u0026lt;System\u0026gt;::Reset; using lds::Controller\u0026lt;System\u0026gt;::Print; protected: std::vector\u0026lt;System\u0026gt; systems_; size_t n_sys_{}; size_t idx_{}; // controller gains could be different for each UniformMatrixList\u0026lt;\u0026gt; Kc_list_; UniformMatrixList\u0026lt;\u0026gt; Kc_inty_list_; UniformMatrixList\u0026lt;\u0026gt; Kc_u_list_; // design-phase input gain could also be different UniformVectorList g_design_list_; // TODO(mfbolus): not sure why I need to do this. using Controller\u0026lt;System\u0026gt;::Kc_; using Controller\u0026lt;System\u0026gt;::Kc_inty_; using Controller\u0026lt;System\u0026gt;::Kc_u_; using Controller\u0026lt;System\u0026gt;::g_design_; using Controller\u0026lt;System\u0026gt;::sys_; // using Controller\u0026lt;System\u0026gt;::u_ref_; // using Controller\u0026lt;System\u0026gt;::x_ref_; // using Controller\u0026lt;System\u0026gt;::y_ref_; // using Controller\u0026lt;System\u0026gt;::control_type_; private: void InitVars(); using lds::Controller\u0026lt;System\u0026gt;::set_sys; // using Controller\u0026lt;System\u0026gt;::set_Kc; // using Controller\u0026lt;System\u0026gt;::set_Kc_inty; // using Controller\u0026lt;System\u0026gt;::set_Kc_u; // using Controller\u0026lt;System\u0026gt;::set_g_design; }; template \u0026lt;typename System\u0026gt; inline SwitchedController\u0026lt;System\u0026gt;::SwitchedController( const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type) : Controller\u0026lt;System\u0026gt;(systems.at(0), u_lb, u_ub, control_type), systems_(systems) { InitVars(); } template \u0026lt;typename System\u0026gt; inline SwitchedController\u0026lt;System\u0026gt;::SwitchedController( std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type) : Controller\u0026lt;System\u0026gt;(System(systems.at(0).n_u(), systems.at(0).n_x(), systems.at(0).n_y(), systems.at(0).dt()), u_lb, u_ub, control_type), systems_(std::move(systems)) { InitVars(); } template \u0026lt;typename System\u0026gt; inline void SwitchedController\u0026lt;System\u0026gt;::InitVars() { n_sys_ = systems_.size(); sys_ = systems_.at(0); Kc_list_ = UniformMatrixList\u0026lt;\u0026gt;(std::vector\u0026lt;Matrix\u0026gt;(n_sys_, Kc_)); Kc_inty_list_ = UniformMatrixList\u0026lt;\u0026gt;(std::vector\u0026lt;Matrix\u0026gt;(n_sys_, Kc_inty_)); Kc_u_list_ = UniformMatrixList\u0026lt;\u0026gt;(std::vector\u0026lt;Matrix\u0026gt;(n_sys_, Kc_inty_)); g_design_list_ = UniformVectorList(std::vector\u0026lt;Vector\u0026gt;(n_sys_, g_design_)); } template \u0026lt;typename System\u0026gt; inline void SwitchedController\u0026lt;System\u0026gt;::Switch(size_t idx, bool do_force_switch) { if ((idx == idx_) \u0026amp;\u0026amp; !do_force_switch) { return; // already there. } // put old up and get new one out systems_.at(idx_) = std::move(sys_); sys_ = std::move(systems_.at(idx)); // set the state of this system to that of the previous system // TODO(mfbolus): This will only work as intended if state matrix is the same. // See example fudge in 0.4 branch src/lds_poisson_sctrl.cpp. sys_.set_m(systems_.at(idx_).m(), true); sys_.set_x(systems_.at(idx_).x()); // swap controller gains Kc_list_.Swap(Kc_, idx_); Kc_list_.Swap(Kc_, idx); if (control_type_ \u0026amp; kControlTypeIntY) { Kc_inty_list_.Swap(Kc_inty_, idx_); Kc_inty_list_.Swap(Kc_inty_, idx); } if (control_type_ \u0026amp; kControlTypeDeltaU) { Kc_u_list_.Swap(Kc_u_, idx_); Kc_u_list_.Swap(Kc_u_, idx); } g_design_list_.Swap(g_design_, idx_); g_design_list_.Swap(g_design_, idx); idx_ = idx; } // Switch } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":71,"href":"/lds-ctrl-est/docs/api/files/lds__sys_8h/","title":"ldsCtrlEst_h/lds_sys.h","section":"Files","content":" ldsCtrlEst_h/lds_sys.h # LDS base type. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Classes # Name class lds::System Linear Dynamical System Type. Detailed Description # This file declares and partially defines the base type for linear dynamical systems ([lds::System](/lds-ctrl-est/docs/api/classes/classlds_1_1_system/)). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code # //===-- ldsCtrlEst_h/lds_sys.h - LDS ----------------------------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_SYS_H #define LDSCTRLEST_LDS_SYS_H #include \u0026#34;lds.h\u0026#34; #include \u0026#34;lds_uniform_mats.h\u0026#34; namespace lds { class System { public: System() = default; System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0); virtual ~System() {} void Filter(const Vector\u0026amp; u_tm1, const Vector\u0026amp; z); virtual const Vector\u0026amp; Simulate(const Vector\u0026amp; u_tm1) = 0; void f(const Vector\u0026amp; u, bool do_add_noise = false) { x_ = A_ * x_ + B_ * (g_ % u) + m_; if (do_add_noise) { x_ += arma::mvnrnd(Vector(n_x_).fill(0), Q_); } }; virtual void h() = 0; virtual Vector h_(Vector x) = 0; size_t n_u() const { return n_u_; }; size_t n_x() const { return n_x_; }; size_t n_y() const { return n_y_; }; data_t dt() const { return dt_; }; const Vector\u0026amp; x() const { return x_; }; const Matrix\u0026amp; P() const { return P_; }; const Vector\u0026amp; m() const { return m_; }; const Matrix\u0026amp; P_m() const { return P_m_; }; const Vector\u0026amp; cx() const { return cx_; }; const Vector\u0026amp; y() const { return y_; }; const Vector\u0026amp; x0() const { return x0_; }; const Vector\u0026amp; m0() const { return m0_; }; const Matrix\u0026amp; A() const { return A_; }; const Matrix\u0026amp; B() const { return B_; }; const Vector\u0026amp; g() const { return g_; }; const Matrix\u0026amp; C() const { return C_; }; const Vector\u0026amp; d() const { return d_; }; const Matrix\u0026amp; Ke() const { return Ke_; }; const Matrix\u0026amp; Ke_m() const { return Ke_m_; }; const Matrix\u0026amp; Q() { return Q_; }; const Matrix\u0026amp; Q_m() { return Q_m_; }; const Matrix\u0026amp; P0() { return P0_; }; const Matrix\u0026amp; P0_m() { return P0_m_; }; void set_A(const Matrix\u0026amp; A) { Reassign(A_, A); }; void set_B(const Matrix\u0026amp; B) { Reassign(B_, B); }; void set_m(const Vector\u0026amp; m, bool do_force_assign = false) { Reassign(m0_, m); if ((!do_adapt_m) || do_force_assign) { Reassign(m_, m); } }; void set_g(const Vector\u0026amp; g) { Reassign(g_, g); }; void set_Q(const Matrix\u0026amp; Q) { Reassign(Q_, Q); }; void set_Q_m(const Matrix\u0026amp; Q_m) { Reassign(Q_m_, Q_m); }; void set_x0(const Vector\u0026amp; x0) { Reassign(x0_, x0); }; void set_P0(const Matrix\u0026amp; P0) { Reassign(P0_, P0); }; void set_P0_m(const Matrix\u0026amp; P0_m) { Reassign(P0_m_, P0_m); }; void set_C(const Matrix\u0026amp; C) { Reassign(C_, C); }; void set_d(const Vector\u0026amp; d) { Reassign(d_, d); }; void set_x(const Vector\u0026amp; x) { Reassign(x_, x); h(); }; void Reset(); std::vector\u0026lt;UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026gt; nstep_pred_block( UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; u, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; z, size_t n_pred = 1); void Print(); // safe to leave this public and non-const bool do_adapt_m{}; protected: virtual void RecurseKe() = 0; void InitVars(data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0); std::size_t n_x_{}; std::size_t n_u_{}; std::size_t n_y_{}; data_t dt_{}; // Signals: Vector x_; Matrix P_; Vector m_; Matrix P_m_; Vector cx_; Vector y_; Vector z_; // Parameters: Vector x0_; Matrix P0_; Vector m0_; Matrix P0_m_; Matrix A_; Matrix B_; Vector g_; Matrix Q_; Matrix Q_m_; Matrix C_; Vector d_; Matrix Ke_; Matrix Ke_m_; }; // System } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":72,"href":"/lds-ctrl-est/docs/api/files/lds__uniform__mats_8h/","title":"ldsCtrlEst_h/lds_uniform_mats.h","section":"Files","content":" ldsCtrlEst_h/lds_uniform_mats.h # List of uniformly sized matrices. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Classes # Name class lds::UniformMatrixList Detailed Description # This file provides a container for uniformly sized matrices. Users may specify one dimension to be free to vary in the list.\nSource code # //===-- ldsCtrlEst_h/lds_uniform_mats.h - Uniform Matrices ------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_UNIFORM_MATS_H #define LDSCTRLEST_LDS_UNIFORM_MATS_H #include \u0026lt;array\u0026gt; // std::array #include \u0026lt;vector\u0026gt; // std::vector #include \u0026#34;lds.h\u0026#34; namespace lds { template \u0026lt;MatrixListFreeDim D = kMatFreeDimNone\u0026gt; class UniformMatrixList : public std::vector\u0026lt;Matrix\u0026gt; { private: // TODO(mfbolus): would rather *uncomment* the below for sake of conversion // using std::vector\u0026lt;Matrix\u0026gt;::vector; // don\u0026#39;t allow push_back to be used since it doesn\u0026#39;t check dims using std::vector\u0026lt;Matrix\u0026gt;::push_back; public: using std::vector\u0026lt;Matrix\u0026gt;::operator=; using std::vector\u0026lt;Matrix\u0026gt;::operator[]; using std::vector\u0026lt;Matrix\u0026gt;::begin; using std::vector\u0026lt;Matrix\u0026gt;::end; using std::vector\u0026lt;Matrix\u0026gt;::size; using std::vector\u0026lt;Matrix\u0026gt;::at; UniformMatrixList() = default; explicit UniformMatrixList(const std::vector\u0026lt;Matrix\u0026gt;\u0026amp; mats, std::array\u0026lt;size_t, 2\u0026gt; dim = {0, 0}); explicit UniformMatrixList(std::vector\u0026lt;Matrix\u0026gt;\u0026amp;\u0026amp; mats, std::array\u0026lt;size_t, 2\u0026gt; dim = {0, 0}); UniformMatrixList(std::initializer_list\u0026lt;Matrix\u0026gt; mats, std::array\u0026lt;size_t, 2\u0026gt; dim = {0, 0}); UniformMatrixList(const UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; that); UniformMatrixList(UniformMatrixList\u0026lt;D\u0026gt;\u0026amp;\u0026amp; that) noexcept; ~UniformMatrixList() = default; const std::array\u0026lt;size_t, 2\u0026gt;\u0026amp; dim(size_t n = 0) const { return dim_.at(n); } size_t size() { return std::vector\u0026lt;Matrix\u0026gt;::size(); }; const Matrix\u0026amp; at(size_t n) { return std::vector\u0026lt;Matrix\u0026gt;::at(n); }; void Swap(Matrix\u0026amp; that, size_t n); UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; operator=(const UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; that); UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; operator=(UniformMatrixList\u0026lt;D\u0026gt;\u0026amp;\u0026amp; that) noexcept; void append(const Matrix\u0026amp; mat); private: void CheckDimensions(std::array\u0026lt;size_t, 2\u0026gt; dim); std::vector\u0026lt;std::array\u0026lt;size_t, 2\u0026gt;\u0026gt; dim_; }; template \u0026lt;MatrixListFreeDim D\u0026gt; inline void UniformMatrixList\u0026lt;D\u0026gt;::Swap(Matrix\u0026amp; that, size_t n) { // make sure request in range if (n \u0026gt;= this-\u0026gt;size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Requested UniformMatrixList element out of bounds. Skipping.\\n\u0026#34;; return; } // check dim bool does_match = true; if (!(D == kMatFreeDim1)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][0] == that.n_rows); } if (!(D == kMatFreeDim2)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][1] == that.n_cols); } if (!does_match) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot swap a UniformMatrixList element for an element of \u0026#34; \u0026#34;different size. Skipping.\\n\u0026#34;; return; } // if checks pass, perform swap // not moving, since it causes memory issues. // so this method isn\u0026#39;t a memory-saver as designed for now Matrix tmp = (*this)[n]; (*this)[n] = that; that = tmp; if (D == kMatFreeDim1) { this-\u0026gt;dim_[n][0] = (*this)[n].n_rows; } if (D == kMatFreeDim2) { this-\u0026gt;dim_[n][1] = (*this)[n].n_cols; } } template \u0026lt;MatrixListFreeDim D\u0026gt; void UniformMatrixList\u0026lt;D\u0026gt;::append(const Matrix\u0026amp; mat) { std::array\u0026lt;size_t, 2\u0026gt; dim({mat.n_rows, mat.n_cols}); CheckDimensions(dim); std::vector\u0026lt;Matrix\u0026gt;::push_back(mat); dim_.push_back(dim); } template \u0026lt;MatrixListFreeDim D\u0026gt; inline UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; UniformMatrixList\u0026lt;D\u0026gt;::operator=( const UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; that) { // make sure dim_ vector is initialized if (dim_.empty()) { dim_ = std::vector\u0026lt;std::array\u0026lt;size_t, 2\u0026gt;\u0026gt;(that.size(), {0, 0}); } // check dimensions if (!this-\u0026gt;empty()) { if (this-\u0026gt;size() != that.size()) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; matrices with \u0026#34; \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; matrices\u0026#34;; throw std::runtime_error(ss.str()); } // if dimensions a not zero and do not match, skip move with error message. bool dims_nonzero = true; for (auto d : dim_) { if (!(D == kMatFreeDim1) \u0026amp;\u0026amp; d[0] \u0026lt; 1) { dims_nonzero = false; break; } if (!(D == kMatFreeDim2) \u0026amp;\u0026amp; d[1] \u0026lt; 1) { dims_nonzero = false; break; } } if (dims_nonzero) { bool does_match = true; if (!(D == kMatFreeDim1)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][0] == that.at(0).n_rows); } if (!(D == kMatFreeDim2)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][1] == that.at(0).n_cols); } if (!does_match) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign matrices of size \u0026#34; \u0026lt;\u0026lt; dim_[0][0] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; dim_[0][1] \u0026lt;\u0026lt; \u0026#34; with matrices of size \u0026#34; \u0026lt;\u0026lt; that.at(0).n_rows \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; that.at(0).n_cols; throw std::runtime_error(ss.str()); } } } for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { (*this)[k] = that[k]; dim_[k] = that.dim(k); } return (*this); } template \u0026lt;MatrixListFreeDim D\u0026gt; inline UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; UniformMatrixList\u0026lt;D\u0026gt;::operator=( UniformMatrixList\u0026lt;D\u0026gt;\u0026amp;\u0026amp; that) noexcept { // // check dimensions // // if empty, assume a default constructed object and safe to move // if (!this-\u0026gt;empty()) { // if (this-\u0026gt;size() != that.size()) { // std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; matrices with \u0026#34; // \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; matrices. Skipping.\\n\u0026#34;; // return (*this); // } // // // if dimensions a not zero and do not match, skip move with error // message. bool dims_nonzero = true; for (auto d : dim_) { // if (!(D == kMatFreeDim1) \u0026amp;\u0026amp; (d[0] \u0026lt; 1)) { // dims_nonzero = false; // break; // } // if (!(D == kMatFreeDim2) \u0026amp;\u0026amp; (d[1] \u0026lt; 1)) { // dims_nonzero = false; // break; // } // } // // if (dims_nonzero) { // bool does_match = true; // if (!(D == kMatFreeDim1)) { // does_match = does_match \u0026amp;\u0026amp; (dim_[0][0] == that.at(0).n_rows); // } // // if (!(D == kMatFreeDim2)) { // does_match = does_match \u0026amp;\u0026amp; (dim_[0][1] == that.at(0).n_cols); // } // // if (!does_match) { // this-\u0026gt;at(0).print(\u0026#34;this[0] = \u0026#34;); // that.at(0).print(\u0026#34;that[0] = \u0026#34;); // std::cerr // \u0026lt;\u0026lt; \u0026#34;Cannot move a UniformMatrixList element of size (\u0026#34; \u0026lt;\u0026lt; // that.at(0).n_rows \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; that.at(0).n_cols \u0026lt;\u0026lt; \u0026#34;) for an // element of size (\u0026#34; \u0026lt;\u0026lt; dim_[0][0] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; dim_[0][1] \u0026lt;\u0026lt; \u0026#34;). // Skipping.\\n\u0026#34;; // return (*this); // } // } // } dim_ = that.dim_; std::vector\u0026lt;Matrix\u0026gt;::operator=(std::move(that)); return (*this); } template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(const std::vector\u0026lt;Matrix\u0026gt;\u0026amp; mats, std::array\u0026lt;size_t, 2\u0026gt; dim) : vector(mats) { CheckDimensions(dim); } template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(std::vector\u0026lt;Matrix\u0026gt;\u0026amp;\u0026amp; mats, std::array\u0026lt;size_t, 2\u0026gt; dim) : vector(std::move(mats)) { CheckDimensions(dim); }; template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(std::initializer_list\u0026lt;Matrix\u0026gt; mats, std::array\u0026lt;size_t, 2\u0026gt; dim) : vector(mats) { CheckDimensions(dim); }; template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(const UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; that) : vector(that) { (*this) = that; } template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(UniformMatrixList\u0026lt;D\u0026gt;\u0026amp;\u0026amp; that) noexcept : vector(std::move(that)) { for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { std::array\u0026lt;size_t, 2\u0026gt; dim_k({this-\u0026gt;at(k).n_rows, this-\u0026gt;at(k).n_cols}); dim_.push_back(dim_k); } } template \u0026lt;MatrixListFreeDim D\u0026gt; void UniformMatrixList\u0026lt;D\u0026gt;::CheckDimensions(std::array\u0026lt;size_t, 2\u0026gt; dim) { // change behavior based on free dim D if ((dim[0] == 0) \u0026amp;\u0026amp; !(D == kMatFreeDim1)) { dim[0] = this-\u0026gt;at(0).n_rows; } if ((dim[1] == 0) \u0026amp;\u0026amp; !(D == kMatFreeDim2)) { dim[1] = this-\u0026gt;at(0).n_cols; } // make sure dimensiolaties are all uniform bool does_match(true); for (const Matrix\u0026amp; mat : *this) { if (!(D == kMatFreeDim1)) { does_match = does_match \u0026amp;\u0026amp; (mat.n_rows == dim[0]); } if (!(D == kMatFreeDim2)) { does_match = does_match \u0026amp;\u0026amp; (mat.n_cols == dim[1]); } if (!does_match) { throw std::runtime_error( \u0026#34;Dimensionality of one or more input matrices are not uniform.\u0026#34;); } } dim_ = std::vector\u0026lt;std::array\u0026lt;size_t, 2\u0026gt;\u0026gt;(this-\u0026gt;size(), dim); for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { dim_[k][0] = (*this)[k].n_rows; dim_[k][1] = (*this)[k].n_cols; } } } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":73,"href":"/lds-ctrl-est/docs/api/files/lds__uniform__systems_8h/","title":"ldsCtrlEst_h/lds_uniform_systems.h","section":"Files","content":" ldsCtrlEst_h/lds_uniform_systems.h # List of uniformly sized Systems. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Classes # Name class lds::UniformSystemList Detailed Description # This file provides a container for uniformly sized Systems.\nSource code # //===-- ldsCtrlEst_h/lds_uniform_systems.h - Uniform Systems ----*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_UNIFORM_SYSTEMS_H #define LDSCTRLEST_LDS_UNIFORM_SYSTEMS_H #include \u0026lt;array\u0026gt; // std::array #include \u0026lt;vector\u0026gt; // std::vector // namespace #include \u0026#34;lds.h\u0026#34; // System type #include \u0026#34;lds_sys.h\u0026#34; namespace lds { template \u0026lt;typename System\u0026gt; class UniformSystemList : public std::vector\u0026lt;System\u0026gt; { static_assert(std::is_base_of\u0026lt;lds::System, System\u0026gt;::value, \u0026#34;System must be derived from lds::System type.\u0026#34;); private: // TODO(mfbolus): would rather *uncomment* the below for sake of conversion // using std::vector\u0026lt;System\u0026gt;::vector; using std::vector\u0026lt;System\u0026gt;::operator=; using std::vector\u0026lt;System\u0026gt;::operator[]; using std::vector\u0026lt;System\u0026gt;::at; using std::vector\u0026lt;System\u0026gt;::begin; using std::vector\u0026lt;System\u0026gt;::end; using std::vector\u0026lt;System\u0026gt;::size; public: UniformSystemList() = default; explicit UniformSystemList(const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, std::array\u0026lt;size_t, 3\u0026gt; dim = {0, 0, 0}); explicit UniformSystemList(std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, std::array\u0026lt;size_t, 3\u0026gt; dim = {0, 0, 0}); UniformSystemList(std::initializer_list\u0026lt;System\u0026gt; systems, std::array\u0026lt;size_t, 3\u0026gt; dim = {0, 0, 0}); UniformSystemList(const UniformSystemList\u0026amp; that); UniformSystemList(UniformSystemList\u0026amp;\u0026amp; that) noexcept; ~UniformSystemList() = default; const std::array\u0026lt;size_t, 3\u0026gt;\u0026amp; dim() const { return dim_; } size_t size() { return std::vector\u0026lt;System\u0026gt;::size(); }; const System\u0026amp; at(size_t n) { return std::vector\u0026lt;System\u0026gt;::at(n); }; void Swap(System\u0026amp; that, size_t n); UniformSystemList\u0026amp; operator=(const UniformSystemList\u0026amp; that); UniformSystemList\u0026amp; operator=(UniformSystemList\u0026amp;\u0026amp; that) noexcept; private: void CheckDimensions(std::array\u0026lt;size_t, 3\u0026gt; dim); std::array\u0026lt;size_t, 3\u0026gt; dim_{}; }; template \u0026lt;typename System\u0026gt; inline void UniformSystemList\u0026lt;System\u0026gt;::Swap(System\u0026amp; that, size_t n) { // make sure request in range if (n \u0026gt;= this-\u0026gt;size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Requested UniformSystemList element out of bounds. Skipping.\\n\u0026#34;; return; } // check dim bool does_match = (dim_[0] == that.n_u()) \u0026amp;\u0026amp; (dim_[1] == that.n_x()) \u0026amp;\u0026amp; (dim_[2] == that.n_y()); if (!does_match) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot swap a UniformSystemList element for an element of \u0026#34; \u0026#34;different size. Skipping.\\n\u0026#34;; return; } // if checks pass, perform swap System tmp = std::move((*this)[n]); (*this)[n] = std::move(that); that = std::move(tmp); } template \u0026lt;typename System\u0026gt; inline UniformSystemList\u0026lt;System\u0026gt;\u0026amp; UniformSystemList\u0026lt;System\u0026gt;::operator=( const UniformSystemList\u0026amp; that) { // check dimensions if (!this-\u0026gt;empty()) { if (this-\u0026gt;size() != that.size()) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; systems with \u0026#34; \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; systems\u0026#34;; throw std::runtime_error(ss.str()); } if (dim_[0] + dim_[1] + dim_[2]) { std::array\u0026lt;size_t, 3\u0026gt; other_dim(that.dim()); if (dim_ != other_dim) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign systems of size \u0026#34; \u0026lt;\u0026lt; dim_[0] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; dim_[1] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; dim_[2] \u0026lt;\u0026lt; \u0026#34; with systems of size \u0026#34; \u0026lt;\u0026lt; other_dim[0] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; other_dim[1] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; dim_[2]; throw std::runtime_error(ss.str()); } } } for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { (*this)[k] = that[k]; } return (*this); } template \u0026lt;typename System\u0026gt; inline UniformSystemList\u0026lt;System\u0026gt;\u0026amp; UniformSystemList\u0026lt;System\u0026gt;::operator=( UniformSystemList\u0026amp;\u0026amp; that) noexcept { // // check dimensions // // if empty, assume a default constructed object and safe to move // if (!this-\u0026gt;empty()) { // if (this-\u0026gt;size() != that.size()) { // std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; systems with \u0026#34; // \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; systems. Skipping.\\n\u0026#34;; // return (*this); // } // // // if dimensions a not zero and do not match, skip move with error // message. if (dim_[0] + dim_[1] + dim_[2]) { // bool does_match = (dim_[0] == that.at(0).n_u()) \u0026amp;\u0026amp; // (dim_[1] == that.at(0).n_x()) \u0026amp;\u0026amp; // (dim_[2] == that.at(0).n_y()); // if (!does_match) { // std::cerr // \u0026lt;\u0026lt; \u0026#34;Cannot move a UniformSystemList element for an element of \u0026#34; // \u0026#34;different size. Skipping.\\n\u0026#34;; // return (*this); // } // } // } dim_ = that.dim_; std::vector\u0026lt;System\u0026gt;::operator=(std::move(that)); return (*this); } template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList(const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, std::array\u0026lt;size_t, 3\u0026gt; dim) : std::vector\u0026lt;System\u0026gt;(systems) { CheckDimensions(dim); } template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList(std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, std::array\u0026lt;size_t, 3\u0026gt; dim) : std::vector\u0026lt;System\u0026gt;(std::move(systems)) { CheckDimensions(dim); }; template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList( std::initializer_list\u0026lt;System\u0026gt; systems, std::array\u0026lt;size_t, 3\u0026gt; dim) : std::vector\u0026lt;System\u0026gt;(systems) { CheckDimensions(dim); }; template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList(const UniformSystemList\u0026amp; that) : std::vector\u0026lt;System\u0026gt;(that) { (*this) = that; } template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList(UniformSystemList\u0026amp;\u0026amp; that) noexcept : std::vector\u0026lt;System\u0026gt;(std::move(that)) { this-\u0026gt;dim_[0] = this-\u0026gt;at(0).n_u(); this-\u0026gt;dim_[1] = this-\u0026gt;at(0).n_x(); this-\u0026gt;dim_[2] = this-\u0026gt;at(0).n_y(); } template \u0026lt;typename System\u0026gt; void UniformSystemList\u0026lt;System\u0026gt;::CheckDimensions(std::array\u0026lt;size_t, 3\u0026gt; dim) { if (dim[0] + dim[1] + dim[2]) { dim_ = dim; } else { dim_[0] = this-\u0026gt;at(0).n_u(); dim_[1] = this-\u0026gt;at(0).n_x(); dim_[2] = this-\u0026gt;at(0).n_y(); } // make sure dimensiolaties are all uniform bool does_match(true); for (const System\u0026amp; sys : *this) { does_match = does_match \u0026amp;\u0026amp; (sys.n_u() == dim_[0]); does_match = does_match \u0026amp;\u0026amp; (sys.n_x() == dim_[1]); does_match = does_match \u0026amp;\u0026amp; (sys.n_y() == dim_[2]); if (!does_match) { throw std::runtime_error( \u0026#34;Dimensionality of one or more input systems are not uniform.\u0026#34;); } } } } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":74,"href":"/lds-ctrl-est/docs/api/files/lds__uniform__vecs_8h/","title":"ldsCtrlEst_h/lds_uniform_vecs.h","section":"Files","content":" ldsCtrlEst_h/lds_uniform_vecs.h # List of uniformly sized vectors. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Classes # Name class lds::UniformVectorList Detailed Description # This file provides a container for uniformly sized vectors.\nSource code # //===-- ldsCtrlEst_h/lds_uniform_vecs.h - Uniform Vectors -------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_UNIFORM_VECS_H #define LDSCTRLEST_LDS_UNIFORM_VECS_H #include \u0026lt;array\u0026gt; // std::array #include \u0026lt;vector\u0026gt; // std::vector #include \u0026#34;lds.h\u0026#34; namespace lds { class UniformVectorList : public std::vector\u0026lt;Vector\u0026gt; { private: // TODO(mfbolus): would rather *uncomment* the below for sake of conversion // using std::vector\u0026lt;Vector\u0026gt;::vector; using std::vector\u0026lt;Vector\u0026gt;::operator=; using std::vector\u0026lt;Vector\u0026gt;::operator[]; using std::vector\u0026lt;Vector\u0026gt;::at; using std::vector\u0026lt;Vector\u0026gt;::begin; using std::vector\u0026lt;Vector\u0026gt;::end; using std::vector\u0026lt;Vector\u0026gt;::size; public: UniformVectorList() = default; explicit UniformVectorList(const std::vector\u0026lt;Vector\u0026gt;\u0026amp; vecs, size_t dim = 0); explicit UniformVectorList(std::vector\u0026lt;Vector\u0026gt;\u0026amp;\u0026amp; vecs, size_t dim = 0); UniformVectorList(std::initializer_list\u0026lt;Vector\u0026gt; vecs, size_t dim = 0); UniformVectorList(const UniformVectorList\u0026amp; that); UniformVectorList(UniformVectorList\u0026amp;\u0026amp; that) noexcept; ~UniformVectorList() = default; size_t dim() const { return dim_; } size_t size() { return std::vector\u0026lt;Vector\u0026gt;::size(); }; const Vector\u0026amp; at(size_t n) { return std::vector\u0026lt;Vector\u0026gt;::at(n); }; void Swap(Vector\u0026amp; that, size_t n); UniformVectorList\u0026amp; operator=(const UniformVectorList\u0026amp; that); UniformVectorList\u0026amp; operator=(UniformVectorList\u0026amp;\u0026amp; that) noexcept; private: void CheckDimensions(size_t dim); size_t dim_{}; }; inline void UniformVectorList::Swap(Vector\u0026amp; that, size_t n) { // make sure request in range if (n \u0026gt;= this-\u0026gt;size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Requested UniformMatrixList element out of bounds. Skipping.\\n\u0026#34;; return; } // check dim bool does_match = dim_ == that.n_elem; if (!does_match) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot swap a UniformMatrixList element for an element of \u0026#34; \u0026#34;different size. Skipping.\\n\u0026#34;; return; } // if checks pass, perform swap Vector tmp = std::move((*this)[n]); (*this)[n] = std::move(that); that = std::move(tmp); } inline UniformVectorList\u0026amp; UniformVectorList::operator=( const UniformVectorList\u0026amp; that) { // check dimensions if (!this-\u0026gt;empty()) { if (this-\u0026gt;size() != that.size()) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; vectors with \u0026#34; \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; vectors\u0026#34;; throw std::runtime_error(ss.str()); } if (dim_) { size_t other_dim(that.dim()); if (dim_ != other_dim) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign vectors of size \u0026#34; \u0026lt;\u0026lt; dim_ \u0026lt;\u0026lt; \u0026#34; with vectors of size \u0026#34; \u0026lt;\u0026lt; other_dim; throw std::runtime_error(ss.str()); } } } for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { (*this)[k] = that[k]; } return (*this); } inline UniformVectorList\u0026amp; UniformVectorList::operator=( UniformVectorList\u0026amp;\u0026amp; that) noexcept { // // check dimensions // if (!this-\u0026gt;empty()) { // if (this-\u0026gt;size() != that.size()) { // std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; vectors with \u0026#34; // \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; vectors. Skipping.\\n\u0026#34;; // return (*this); // } // // if (dim_) { // size_t other_dim(that.dim()); // if (dim_ != other_dim) { // std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot reassign vectors of size \u0026#34; \u0026lt;\u0026lt; dim_ // \u0026lt;\u0026lt; \u0026#34; with matrices of size \u0026#34; \u0026lt;\u0026lt; other_dim \u0026lt;\u0026lt; \u0026#34;. // Skipping.\\n\u0026#34;; // return (*this); // } // } // } dim_ = that.dim_; std::vector\u0026lt;Vector\u0026gt;::operator=(std::move(that)); return (*this); } } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":75,"href":"/lds-ctrl-est/docs/api/files/lds_8h/","title":"ldsCtrlEst_h/lds.h","section":"Files","content":" ldsCtrlEst_h/lds.h # lds namespace More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Detailed Description # This file defines the lds namespace, which will be an umbrella for linear dynamical systems with Gaussian ([lds::gaussian](/lds-ctrl-est/docs/api/namespaces/namespacelds_1_1gaussian/)) or Poisson ([lds::poisson](/lds-ctrl-est/docs/api/namespaces/namespacelds_1_1poisson/)) observations.\nSource code # //===-- ldsCtrlEst_h/lds.h - Linear Dynmical System Namespace ---*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_LDS_H #define LDSCTRLEST_LDS_H // #ifndef LDSCTRLEST // #include \u0026lt;ldsCtrlEst\u0026gt; // #endif #include \u0026lt;armadillo\u0026gt; namespace lds { using data_t = double; // may change to float (but breaks mex functions) using Vector = arma::Col\u0026lt;data_t\u0026gt;; using Matrix = arma::Mat\u0026lt;data_t\u0026gt;; using Cube = arma::Cube\u0026lt;data_t\u0026gt;; using View = arma::subview\u0026lt;data_t\u0026gt;; namespace fill = arma::fill; static const std::size_t kControlTypeDeltaU = 0x1; static const std::size_t kControlTypeIntY = kControlTypeDeltaU \u0026lt;\u0026lt; 1; static const std::size_t kControlTypeAdaptM = kControlTypeDeltaU \u0026lt;\u0026lt; 2; static const data_t kInf = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(); static const data_t kPi = arma::datum::pi; static const data_t kDefaultP0 = 1e-6; static const data_t kDefaultQ0 = 1e-6; static const data_t kDefaultR0 = 1e-2; enum SSIDWt { kSSIDNone, kSSIDMOESP, kSSIDCVA }; enum MatrixListFreeDim { kMatFreeDimNone, kMatFreeDim1, kMatFreeDim2 }; // TODO(mfbolus): for SwitchedController, may want systems to have differing // numbers of states. Use this enum as template parameter? // enum SystemListFreeDim { // kSysFreeDimNone, // kSysFreeDimX ///\u0026lt; allow state dim (x) of systems in list to be hetero // }; // place hard limits on contents of vecors/mats void Limit(std::vector\u0026lt;data_t\u0026gt;\u0026amp; x, data_t lb, data_t ub); void Limit(Vector\u0026amp; x, data_t lb, data_t ub); void Limit(Matrix\u0026amp; x, data_t lb, data_t ub); // in-place assign that errs if there are dimension mismatches: void Reassign(Vector\u0026amp; some, const Vector\u0026amp; other, const std::string\u0026amp; parenthetical = \u0026#34;Reassign\u0026#34;); void Reassign(Matrix\u0026amp; some, const Matrix\u0026amp; other, const std::string\u0026amp; parenthetical = \u0026#34;Reassign\u0026#34;); // TODO(mfbolus): this is a fudge, but for some reason, cov mats often going // numerically asymm. void ForceSymPD(Matrix\u0026amp; X); void ForceSymMinEig(Matrix\u0026amp; X, data_t eig_min = 0); void lq(Matrix\u0026amp; L, Matrix\u0026amp; Qt, const Matrix\u0026amp; X); Matrix calcCov(const Matrix\u0026amp; A, const Matrix\u0026amp; B); inline void Limit(std::vector\u0026lt;data_t\u0026gt;\u0026amp; x, data_t lb, data_t ub) { for (data_t\u0026amp; el : x) { el = el \u0026lt; lb ? lb : el; el = el \u0026gt; ub ? ub : el; } } inline void Limit(Vector\u0026amp; x, data_t lb, data_t ub) { for (data_t\u0026amp; el : x) { el = el \u0026lt; lb ? lb : el; el = el \u0026gt; ub ? ub : el; } } inline void Limit(Matrix\u0026amp; x, data_t lb, data_t ub) { for (data_t\u0026amp; el : x) { el = el \u0026lt; lb ? lb : el; el = el \u0026gt; ub ? ub : el; } } inline void Reassign(Vector\u0026amp; some, const Vector\u0026amp; other, const std::string\u0026amp; parenthetical) { // check dimensions if (other.n_elem != some.n_elem) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign vector of size \u0026#34; \u0026lt;\u0026lt; some.n_elem \u0026lt;\u0026lt; \u0026#34; with vector of size \u0026#34; \u0026lt;\u0026lt; other.n_elem \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; parenthetical \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; throw std::runtime_error(ss.str()); } for (size_t k = 0; k \u0026lt; some.n_elem; k++) { some[k] = other[k]; } } inline void Reassign(Matrix\u0026amp; some, const Matrix\u0026amp; other, const std::string\u0026amp; parenthetical) { // check dimensions if ((other.n_rows != some.n_rows) || (other.n_cols != some.n_cols)) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign matrix of size \u0026#34; \u0026lt;\u0026lt; some.n_rows \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; some.n_cols \u0026lt;\u0026lt; \u0026#34; with matrix of size \u0026#34; \u0026lt;\u0026lt; other.n_rows \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; other.n_cols \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; parenthetical \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; throw std::runtime_error(ss.str()); } for (size_t k = 0; k \u0026lt; some.n_elem; k++) { some[k] = other[k]; } } } // namespace lds #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":76,"href":"/lds-ctrl-est/docs/api/files/mex__c__util_8h/","title":"ldsCtrlEst_h/mex_c_util.h","section":"Files","content":" ldsCtrlEst_h/mex_c_util.h # arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API) More\u0026hellip;\nNamespaces # Name armamexc arma/mex interface using Matlab C API Detailed Description # This file defines utility functions for interoperability between armadillo and Matlab/Octave\u0026rsquo;s C mex API.\nSource code # //===-- ldsCtrlEst_h/mex_c_util.h - Mex C API Utilities ---------*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_MEXC_UTIL_H #define LDSCTRLEST_MEXC_UTIL_H #include \u0026lt;ldsCtrlEst\u0026gt; #include \u0026#34;mex.h\u0026#34; // // If Matlab_FOUND, include matrix.h. // // (Octave does not need/have it.) // #ifdef Matlab_FOUND // #include \u0026#34;matrix.h\u0026#34; // #endif namespace armamexc { template \u0026lt;class T\u0026gt; inline auto m2T_scalar(const mxArray *matlab_scalar) -\u0026gt; T { if (mxGetData(matlab_scalar)) { return static_cast\u0026lt;T\u0026gt;(mxGetScalar(matlab_scalar)); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return 0; } template \u0026lt;class T\u0026gt; inline auto m2a_mat(const mxArray *matlab_mat, bool copy_aux_mem = false, bool strict = true) -\u0026gt; arma::Mat\u0026lt;T\u0026gt; { if (mxGetData(matlab_mat)) { const mwSize n_dim = mxGetNumberOfDimensions(matlab_mat); if (n_dim == 2) { return arma::Mat\u0026lt;T\u0026gt;(static_cast\u0026lt;T *\u0026gt;(mxGetData(matlab_mat)), mxGetM(matlab_mat), mxGetN(matlab_mat), copy_aux_mem, strict); } mexErrMsgTxt(\u0026#34;Number of dimensions must be 2.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } // TODO(mfbolus): make these templated. template \u0026lt;typename T\u0026gt; inline auto a2m_mat(arma::Mat\u0026lt;T\u0026gt; const \u0026amp;arma_mat) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_mat.n_rows, arma_mat.n_cols, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;T *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;T *\u0026gt;(arma_mat.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy. std::memcpy(dst_pointer, src_pointer, sizeof(T) * arma_mat.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Mat.\u0026#34;); return nullptr; } template \u0026lt;typename T\u0026gt; inline auto a2m_vec(arma::Col\u0026lt;T\u0026gt; const \u0026amp;arma_vec) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_vec.n_elem, 1, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;T *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;T *\u0026gt;(arma_vec.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy. std::memcpy(dst_pointer, src_pointer, sizeof(T) * arma_vec.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Col.\u0026#34;); return nullptr; } } // namespace armamexc #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":77,"href":"/lds-ctrl-est/docs/api/files/mex__cpp__util_8h/","title":"ldsCtrlEst_h/mex_cpp_util.h","section":"Files","content":" ldsCtrlEst_h/mex_cpp_util.h # arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API) More\u0026hellip;\nNamespaces # Name armamexcpp arma/mex interface using Matlab C++ API Detailed Description # This file defines utility functions for interoperability between armadillo and Matlab\u0026rsquo;s C++ mex API.\nSource code # //===-- ldsCtrlEst_h/mex_cpp_util.h - Mex C++ API Utilities -----*- C++ -*-===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #ifndef LDSCTRLEST_MEXCPP_UTIL_H #define LDSCTRLEST_MEXCPP_UTIL_H #include \u0026lt;ldsCtrlEst\u0026gt; #include \u0026#34;mex.hpp\u0026#34; #include \u0026#34;mexAdapter.hpp\u0026#34; namespace armamexcpp { template \u0026lt;class T\u0026gt; std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; m2a_cellmat(matlab::data::CellArray\u0026amp; matlab_cell) { size_t n_cells = matlab_cell.getNumberOfElements(); std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; arma_mat(n_cells, arma::Mat\u0026lt;T\u0026gt;(1, 1, arma::fill::zeros)); for (size_t k = 0; k \u0026lt; n_cells; k++) { matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = matlab_cell[k]; auto dims = matlab_mat.getDimensions(); arma_mat[k] = arma::Mat\u0026lt;T\u0026gt;(matlab_mat.release().get(), dims[0], dims[1]); } return arma_mat; }; template \u0026lt;class T\u0026gt; std::vector\u0026lt;T\u0026gt; m2s_vec(matlab::data::TypedArray\u0026lt;T\u0026gt;\u0026amp; matlab_array) { size_t n_elem = matlab_array.getNumberOfElements(); T* ptr = matlab_array.release().get(); std::vector\u0026lt;T\u0026gt; vec(ptr, ptr + n_elem); return vec; }; template \u0026lt;class T\u0026gt; arma::Col\u0026lt;T\u0026gt; m2a_vec(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) { size_t n_elem = matlab_array.getNumberOfElements(); // T* ptr = matlab_array.release().get(); // arma::Col\u0026lt;T\u0026gt; vec(ptr, n_elem); //, false); // TODO(mfbolus): for some reason, using the above pointer at times leads to // getting garbage values. matlab array values may be stored in non-contiguous // memory? arma::Col\u0026lt;T\u0026gt; vec(n_elem, arma::fill::zeros); for (size_t k = 0; k \u0026lt; n_elem; k++) { vec[k] = matlab_array[k]; } return vec; }; template \u0026lt;class T\u0026gt; arma::Mat\u0026lt;T\u0026gt; m2a_mat(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) { // ArrayDimensions == std::vector\u0026lt;size_t\u0026gt; auto dims = matlab_array.getDimensions(); // T* ptr = matlab_array.release().get(); // // mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false) // arma::Mat\u0026lt;T\u0026gt; mat(ptr, dims[0], dims[1]); //, false); // TODO(mfbolus): for some reason, using the above pointer at times leads to // getting garbage values. matlab array values may be stored in non-contiguous // memory? // // armadillo and matlab both use column-major ordering, so this should work: size_t n_elem = dims[0] * dims[1]; arma::Mat\u0026lt;T\u0026gt; mat(dims[0], dims[1], arma::fill::zeros); size_t k(0); for (auto m: matlab_array) { mat[k] = m; k++; } return mat; }; template \u0026lt;class T\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; a2m_mat(const arma::Mat\u0026lt;T\u0026gt;\u0026amp; arma_mat, matlab::data::ArrayFactory\u0026amp; factory) { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {arma_mat.n_rows, arma_mat.n_cols}, arma_mat.memptr(), arma_mat.memptr() + arma_mat.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; a2m_vec(const arma::Col\u0026lt;T\u0026gt;\u0026amp; arma_vec, matlab::data::ArrayFactory\u0026amp; factory) { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;({arma_vec.n_elem, 1}, arma_vec.memptr(), arma_vec.memptr() + arma_vec.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; s2m_vec(const std::vector\u0026lt;T\u0026gt;\u0026amp; std_vec, matlab::data::ArrayFactory\u0026amp; factory) { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {std_vec.size(), 1}, std_vec.data(), std_vec.data() + std_vec.size()); return matlab_mat; }; } // namespace armamexcpp #endif Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":78,"href":"/lds-ctrl-est/docs/terminology/model/","title":"Models","section":"LDS C+E Documentation","content":" Model Definitions # This library provides methods for control and estimation of linear dynamical systems (LDS) of the following form: \\[\\mathbf{x}_{t\u0026#43;1} = f\\left( \\mathbf{x}_{t}, \\mathbf{v}_{t} \\right) = \\mathbf{A} \\mathbf{x}_{t} \u0026#43; \\mathbf{B} \\mathbf{v}_{t} \u0026#43; \\mathbf{m}_{t} \u0026#43; \\mathbf{w}_{t}\\] \\[\\mathbf{y}_{t} = h\\left( \\mathbf{x}_{t} \\right)\\] t : time index x : system state v = g%u : input (e.g., in physical units used for model fit) u : control signal sent to actuator (e.g., in Volts) y : system output m : process disturbance w ~ N(0, Q) : process noise/disturbance A : state matrix B : input coupling matrix g : input gain (e.g., for converting to control signal actuator voltage) n.b., assumes this conversion is linear Q : process noise covariance % : element-wise multiplication LDS with Gaussian Observations # For linear dynamical systems whose outputs are assumed to be corrupted by additive Gaussian noise before measurement (Gaussian LDS models), the output function takes the following form.\n\\[\\mathbf{y}_{t} = \\mathbf{C} \\mathbf{x}_{t} \u0026#43; \\mathbf{d}\\] \\[\\mathbf{z}_{t} \\sim \\mathcal{N}\\left(\\mathbf{y}_{t} , \\mathbf{R} \\right)\\] z : measurement C : output matrix d : output bias R : measurement noise covariance LDS with Poisson Observations # For linear dynamical systems whose outputs are assumed to be rates underlying measured count data derived from a Poisson distribution (Poisson LDS models), the output function takes the following form. Note an element-wise exponentiation is used to rectify the linear dynamics for the rate of the Poisson process.\n\\[y_{t}^{i} = \\exp \\left(\\mathbf{c}^i \\mathbf{x}_{t} \u0026#43; d^i\\right)\\] \\[z_{t}^i \\sim \\rm{Poisson} \\left(y_{t}^i \\right)\\] i : output index z : measurement (count data) c : i^th row of output matrix (C) d : output bias Model Predictive Control (MPC) # Model Predictive Control (MPC) is an advanced control strategy that utilizes a dynamic model of the system to predict and optimize future behavior over a specified time horizon. At each control step, MPC solves an optimization problem to determine the control inputs that minimize a cost function, which typically includes terms for tracking desired reference trajectories and penalizing excessive control efforts. This approach allows MPC to handle multivariable systems with constraints effectively, making it suitable for complex industrial applications.\nIn the context of linear systems, the optimization problem within MPC can be formulated as a quadratic program. This involves defining a quadratic cost function over the prediction horizon, which balances the trade-off between tracking performance and control effort. The solution to this quadratic program yields the optimal control inputs that drive the system towards the desired state while respecting operational constraints. Tools like the Operator Splitting Quadratic Program (OSQP) solver are often employed to efficiently solve these optimization problems in real-time.\n"},{"id":79,"href":"/lds-ctrl-est/docs/api/modules/","title":"Modules","section":"LDS C+E Documentation","content":" Modules # Control Mode Bit Masks provides fill types for constructing new armadillo vectors, matrices\nDefaults\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":80,"href":"/lds-ctrl-est/docs/api/namespaces/","title":"Namespaces","section":"LDS C+E Documentation","content":" Namespaces # armamexc arma/mex interface using Matlab C API\narmamexcpp arma/mex interface using Matlab C++ API\nlds::gaussian Linear Dynamical Systems with Gaussian observations.\nlds::poisson Linear Dynamical Systems with Poisson observations.\nstd\nUpdated on 5 March 2025 at 16:32:33 EST\n"},{"id":81,"href":"/lds-ctrl-est/docs/api/pages/","title":"Pages","section":"LDS C+E Documentation","content":" Pages # Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":82,"href":"/lds-ctrl-est/docs/tutorials/eg_plds_state_estimation/","title":"PLDS State Estimation","section":"LDS C+E Examples","content":" PLDS State Estimation Tutorial # This tutorial shows how to use this library to estimate the state of an LDS with Poisson observations from input/output data. In place of a physical system, another PLDS model (lds::poisson::System) receives random inputs and provides measurements for the state estimator. For the sake of example, the only parameter mismatch is assumed to be the process disturbance, which is adaptively re-estimated.\nThe full code for this can be found here.\nPreamble # In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; Note that lds::Matrix and lds::Vector are typedefs for arma::Mat\u0026lt;data_t\u0026gt; and arma::Col\u0026lt;data_t\u0026gt;, where the data type is double by default. May be changed to float in include/ldsCtrlEst_h/lds.h if there are memory constraints (e.g., large-scale MIMO control problems).\nCreating a simulated system # A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// Make SISO system sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; // no. inputs size_t n_x = 1; // no. states size_t n_y = 1; // no. outputs auto n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation. When a system is initialized, rather than requiring all parameters be provided at construction, users may create a default system by setting only the dimensions and sample period.\n// construct ground truth system... lds::poisson::System system_true(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example, \\[x_{t\u0026#43;1} = x_t \u0026#43; w_t\\] \\[y_{t} = \\exp\\left(x_t\\right)\\] where \\( w_{t} \\sim \\mathcal{N}\\left( 0, Q \\right) \\) .\nNow, create non-default parameters for this model.\n// Model parameters Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); Matrix b_true = Matrix(n_x, n_u).fill(1e-2); Vector m0_true = Vector(n_x, arma::fill::zeros).fill(-7e-2); // disturbance Vector x0_true = m0_true * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state Finally, assign the parameters using corresponding set-methods.\n// Assign params. system_true.set_A(a_true); system_true.set_B(b_true); system_true.set_x0(x0_true); system_true.set_m(m0_true); system_true.Reset(); Creating the estimator # Now, create the estimator. The system type includes filtering functionality for state estimation, so create another lds::poisson::System. As noted above, the only parameter mismatch in this simulation will be the process disturbance.\n// Construct system for estimation // e.g., will create a model with incorrect disturbance lds::poisson::System system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object system_estimator = system_true; // wrong disturbance Vector m0_est = m0_true * 2; system_estimator.set_m(m0_est); // set new initial conditions Vector x0_est = m0_est * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state system_estimator.set_x0(x0_est); system_estimator.Reset(); // reset to initial condition. To ensure robust estimates, adaptively re-estimate the process disturbance.\n// turn on adaptive disturbance estimation system_estimator.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise acting // on random-walk evolution of m Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.set_Q_m(q_m); Simulating estimation # In this demonstration, random inputs are presented to the system, measurements are taken, and filtering is carried out in a for-loop.\n// Simlate the true system. z.col(t) = system_true.Simulate(u.col(t - 1)); // Filter (predict -\u0026gt; update) system_estimator.Filter(u.col(t - 1), z.col(t)); Example simulation result # Below are example results for this simulation, including outputs, latent states, process disturbance, and the input. The online estimates of the output, state, and disturbance are given in purple.\nWith this parameterization, it takes the estimator approximately 5 seconds to minimize state error. The state and output error distributions for the period after 5 seconds is shown below.\n"},{"id":83,"href":"/lds-ctrl-est/docs/tutorials/eg_switched_plds_control/","title":"PLDS Switched Control","section":"LDS C+E Examples","content":" PLDS Switched Control Tutorial # This tutorial shows how to use this library to control a system with a switched PLDS controller (lds::poisson::SwitchedController). This type of controller is applicable in scenarios where a physical system is not accurately captured by a single LDS but has multiple discrete operating modes where the dynamics can be well-approximated as linear.\nIn the example that follows, another PLDS model (lds::poisson::System) is used in place of a physical system. It receives control inputs and provides measurements for the simulated feedback control loop. This system stochastically flips between two input gains. Here, the controller is assumed to have a perfect model of the switching system being controlled. Note that in practice, users would need to have a decoder that estimates operating mode of the physical system being controlled. This library does not currently include operating mode estimation.\nThe full code for this can be found here.\nPreamble # In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; Note that lds::Matrix and lds::Vector are typedefs for arma::Mat\u0026lt;data_t\u0026gt; and arma::Col\u0026lt;data_t\u0026gt;, where the data type is double by default. May be changed to float in include/ldsCtrlEst_h/lds.h if there are memory constraints (e.g., large-scale MIMO control problems).\nCreating the simulated system # A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// whether to do switched control bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation. auto n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); The system\u0026rsquo;s input matrix (B) will be switched stochastically from one value (b1) to a less sensitive value (b2) according to the following probabilities.\n// for simulating switching size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2 data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1 Initially, the system will be in \u0026ldquo;mode\u0026rdquo; 1, where B = b1.\n// simulated system being controlled lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well // characterized by two LDS models with different input matrices.** data_t scale_sys_b = 2; Matrix a(n_x, n_x, arma::fill::eye); a[0] = 0.985; Matrix b1 = Matrix(n_x, n_u).fill(0.05); Vector d = Vector(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.set_A(a); controlled_system.set_B(b1); controlled_system.set_d(d); controlled_system.Reset(); // reset to initial conditions See the GLDS Control and PLDS State Estimation tutorials for more detail about creating System objects.\nCreating the controller # Now, create the controller. A switched-system controller (SwitchedController) essentially toggles between the parameters of its subsystems when the controller is told a switch has occured. The first thing the user needs to do is define these subsystems. In this example, there are two Poisson systems (sys1, sys2), which are the same save for their input gains.\nSimilar to a non-switched controller, constructing a SwitchedController requires these system models and upper/lower bounds on control. See the GLDS Control tutorial for more details. In the case of a SwitchedController, it needs a list of systems, using the std::vector container.\nMoreover, when assigning control-related signals such as the feedback controller gains, it is crucial that the list of gains optimized for each operating mode of the system have the same dimensionality. For this reason, this library provides UniformMatrixList and UniformVectorList containers that should be used when setting Kc, Kc_inty, g_design. These containers are std::vectors whose contents are uniformly sized.\nPutting this information together, here is how to create the controller and the list of controller gains optimized for each system operating mode.\n// create switched controller lds::poisson::SwitchedController switched_controller; lds::UniformMatrixList\u0026lt;\u0026gt; k_x; // feedback controller gains { // create switched controller sub-systems // system 1 lds::poisson::System sys1(controlled_system); // set process noise covariance Matrix q_controller = Matrix(n_x, n_x, arma::fill::eye) * 5e-3; sys1.set_Q(q_controller); // adaptively estimate process disturbance (m) // n.b. using arbitrary default value for process noise if enabled. sys1.do_adapt_m = true; // setting initial mode to target to avoid large error at onset: Vector x0_controller = arma::log(y_ref0) - d; sys1.set_x0(x0_controller); sys1.Reset(); // reset to initial conditions // system 2 lds::poisson::System sys2 = sys1; // set parameters sys2.set_B(b2); lds::UniformSystemList\u0026lt;lds::poisson::System\u0026gt; systems({sys1, sys2}); // controller gains for underlying systems: Matrix k_x1(n_u, n_x, arma::fill::ones); Matrix k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive. k_x = lds::UniformMatrixList\u0026lt;\u0026gt;({k_x1, k_x2}); data_t u_lb = 0.0; data_t u_ub = 5.0; switched_controller = std::move( lds::poisson::SwitchedController(std::move(systems), u_lb, u_ub)); } Note that the above code block demonstrates how move semantics can be used for assignment/construction. Copy assignment/construction is of course also allowed.\nNow that the SwitchedController is instantiated, assign its parameters.\n// Control variables size_t control_type = 0; // no integral action, etc switched_controller.set_control_type(control_type); switched_controller.set_Kc(std::move(k_x)); switched_controller.set_y_ref(y_ref0); Simulating control # In this demonstration, we will use the ControlOutputReference method which allows users to simply set the reference output event rate (y_ref) and supply the current measurement z. It then calculates the solution for the state/input required to track that output at steady state. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system. Importantly, this method performs control in the linear state space (i.e., taking the logarithm of the reference output).\nThe control loop is carried out here in a simple for-loop, controlled system is simulated along with stochastic mode switches, a measurement taken, and the control signal updated.\n// Let the controlled system stochastically change gain // Assume another algorithm decodes this mode change and signals the // switched_controller Vector chance(1, arma::fill::randu); if (which_mode == 1) // mode1 { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.set_B(b2); if (do_switch_ctrl) { switched_controller.Switch(1); } } } else { // mode2 if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.set_B(b1); if (do_switch_ctrl) { switched_controller.Switch(0); } } } // Simulate the true system. z.col(t) = controlled_system.Simulate(u.col(t - 1)); // perform control u.col(t) = switched_controller.ControlOutputReference(z.col(t)); Note that as the gain of the controlled system changes stochastically, the controller is informed of this change. In practice, a user must decode such changes in the system\u0026rsquo;s operating mode and call the Switch method accordingly. Such a decoder is not currently included in this library.\nExample simulation result # Below are example results for this simulation, including outputs, latent states, mode switches, and the control signal. The controller\u0026rsquo;s online estimates of the output and state are shown in purple.\nNote that every time the operating mode of the system changes (here, a gain changes), the controller immediately adjusts its inputs. In contrast, a non-switched controller with integral action would also compensate but do so in a comparitively sluggish fashion.\n"},{"id":84,"href":"/lds-ctrl-est/docs/api/files/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"src","section":"Files","content":" src # Files # Name src/lds.cpp misc lds namespace functions src/lds_gaussian_sys.cpp GLDS base type. src/lds_poisson_sys.cpp PLDS base type. src/lds_sys.cpp LDS base type. src/lds_uniform_vecs.cpp Uniformly sized vectors. Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":85,"href":"/lds-ctrl-est/docs/api/files/lds__gaussian__sys_8cpp/","title":"src/lds_gaussian_sys.cpp","section":"Files","content":" src/lds_gaussian_sys.cpp # GLDS base type. More\u0026hellip;\nDetailed Description # This file implements the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems (lds::gaussian::sys_t). It inherits functionality from the underlying linear dynamical system (lds::sys_t).\nSource code # //===-- lds_gaussian_sys.cpp - GLDS ---------------------------------------===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst_h/lds_gaussian_sys.h\u0026gt; lds::gaussian::System::System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0, data_t q0, data_t r0) : lds::System(n_u, n_x, n_y, dt, p0, q0) { R_.zeros(n_y, n_y); R_.diag().fill(r0); do_recurse_Ke_=true; }; // recursively estimate Ke void lds::gaussian::System::RecurseKe() { if (!do_recurse_Ke_) { return; } // predict covariance P_ = A_ * P_ * A_.t() + Q_; // calc Kalman gain Ke_ = P_ * C_.t() * inv_sympd(C_ * P_ * C_.t() + R_); // update covariance // Reference: Ghahramani et Hinton (1996) P_ = P_ - Ke_ * C_ * P_; if (do_adapt_m) { P_m_ += Q_m_; // A_m = I (i.e., random walk) Ke_m_ = P_m_ * C_.t() * inv_sympd(C_ * P_m_ * C_.t() + R_); P_m_ = P_m_ - Ke_m_ * C_ * P_m_; } } // Simulate const lds::Vector\u0026amp; lds::gaussian::System::Simulate(const Vector\u0026amp; u_tm1){ f(u_tm1, true);//simulate dynamics with noise added h();//output z_ = y_ + arma::mvnrnd(Vector(n_y_).fill(0), R_);//measure return z_; } void lds::gaussian::System::Print() { lds::System::Print(); std::cout \u0026lt;\u0026lt; \u0026#34;R: \\n\u0026#34; \u0026lt;\u0026lt; R_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":86,"href":"/lds-ctrl-est/docs/api/files/lds__poisson__sys_8cpp/","title":"src/lds_poisson_sys.cpp","section":"Files","content":" src/lds_poisson_sys.cpp # PLDS base type. More\u0026hellip;\nDetailed Description # This file implements the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems (lds::poisson::sys_t). It inherits functionality from the underlying linear dynamical system (lds::sys_t).\nSource code # //===-- lds_poisson_sys.cpp - PLDS ----------------------------------------===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst_h/lds_poisson_sys.h\u0026gt; lds::poisson::System::System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0, data_t q0) : lds::System(n_u, n_x, n_y, dt, p0, q0) { diag_y_ = diagmat(y_); pd_ = std::poisson_distribution\u0026lt;size_t\u0026gt;(0); }; // Correct: Given measurement (z) and current input (u), update estimate of the // state, covar, output. // // see Eden et al. 2004 void lds::poisson::System::RecurseKe() { // predict covariance P_ = A_ * P_ * A_.t() + Q_; // update cov P_ = pinv(pinv(P_) + C_.t() * diag_y_ * C_); Ke_ = P_ * C_.t(); if (do_adapt_m) { P_m_ += Q_m_; // predict (A_m = I) P_m_ = pinv(pinv(P_m_) + C_.t() * diag_y_ * C_); // update Ke_m_ = P_m_ * C_.t(); } } // Simulate Measurement: z ~ Poisson(y) const lds::Vector\u0026amp; lds::poisson::System::Simulate(const Vector\u0026amp; u_tm1) { f(u_tm1, true); // simulate dynamics with noise added h(); // output z_.zeros(); for (std::size_t k = 0; k \u0026lt; n_y_; k++) { // construct a Poisson distribution object with mean y[k] pd_ = std::poisson_distribution\u0026lt;size_t\u0026gt;(y_[k]); // pull random sample from this distribution z_[k] = pd_(rng); } return z_; } // ******************* SYS_T ******************* Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":87,"href":"/lds-ctrl-est/docs/api/files/lds__sys_8cpp/","title":"src/lds_sys.cpp","section":"Files","content":" src/lds_sys.cpp # LDS base type. More\u0026hellip;\nDetailed Description # This file implements the base type for linear dynamical systems (lds::System). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code # //===-- lds_sys.cpp - LDS -------------------------------------------------===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst_h/lds_sys.h\u0026gt; #include \u0026lt;vector\u0026gt; lds::System::System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0, data_t q0) : n_u_(n_u), n_x_(n_x), n_y_(n_y), dt_(dt) { InitVars(p0, q0); } void lds::System::InitVars(data_t p0, data_t q0) { // initial conditions. x0_ = Vector(n_x_, fill::zeros); // includes bias (nY) and g (nU) P0_ = p0 * Matrix(n_x_, n_x_, fill::eye); m0_ = x0_; P0_m_ = P0_; // signals x_ = x0_; P_ = P0_; m_ = m0_; P_m_ = P0_m_; y_ = Vector(n_y_, fill::zeros); cx_ = Vector(n_y_, fill::zeros); z_ = Vector(n_y_, fill::zeros); // By default, random walk where each state is independent // In this way, provides independent estimates of rate per channel of output. A_ = Matrix(n_x_, n_x_, fill::eye); B_ = Matrix(n_x_, n_u_, fill::zeros); g_ = Vector(n_u_, fill::ones); Q_ = q0 * Matrix(n_x_, n_x_, fill::eye); Q_m_ = Q_; C_ = Matrix(n_y_, n_x_, fill::eye); // each state will map to an output by d_ = Vector(n_y_, fill::zeros); Ke_ = Matrix(n_x_, n_y_, fill::zeros); // estimator gain. Ke_m_ = Matrix(n_x_, n_y_, fill::zeros); // estimator gain for m adaptation. do_adapt_m = false; } // Filter: Given measurement (`z`) and previous input (`u_tm1`), predict state // and update estimate of the state, covar, output using Kalman filter void lds::System::Filter(const Vector\u0026amp; u_tm1, const Vector\u0026amp; z_t) { // predict mean f(u_tm1); // dynamics h(); // output // recursively calculate esimator gains (or just keep existing values) // (also predicts+updates estimate covariance) RecurseKe(); // update x_ += Ke_ * (z_t - y_); if (do_adapt_m) { m_ += Ke_m_ * (z_t - y_); // adaptively estimating disturbance } // With new state, estimate output. h(); // --\u0026gt; posterior } void lds::System::Reset() { // reset to initial conditions x_ = x0_; // mean P_ = P0_; // cov of state estimate m_ = m0_; // process disturbance P_m_ = P0_m_; // cov of disturbance estimate h(); } std::vector\u0026lt;lds::UniformMatrixList\u0026lt;lds::kMatFreeDim2\u0026gt;\u0026gt; lds::System::nstep_pred_block(lds::UniformMatrixList\u0026lt;lds::kMatFreeDim2\u0026gt; u, lds::UniformMatrixList\u0026lt;lds::kMatFreeDim2\u0026gt; z, size_t n_pred) { lds::UniformMatrixList\u0026lt;lds::kMatFreeDim2\u0026gt; x_filt; lds::UniformMatrixList\u0026lt;lds::kMatFreeDim2\u0026gt; x_pred; lds::UniformMatrixList\u0026lt;lds::kMatFreeDim2\u0026gt; y_pred; for (size_t k = 0; k \u0026lt; u.size(); k++) { Reset(); size_t n_t = arma::size(u[k])[1]; Matrix x_filt_k(n_x_, n_t, fill::zeros); Matrix x_pred_k(n_x_, n_t - n_pred, fill::zeros); Matrix y_pred_k(n_y_, n_t - n_pred, fill::zeros); for (size_t t = 0; t \u0026lt; n_t - n_pred; t++) { Vector x_pred_ahead = x_; for (size_t t_u = t; t_u \u0026lt; t + n_pred; t_u++) { x_pred_ahead = A_ * x_pred_ahead + B_ * u[k].col(t_u); } x_pred_k.col(t) = x_pred_ahead; y_pred_k.col(t) = h_(x_pred_ahead); if (t \u0026gt; 0) { Filter(u[k].col(t - 1), z[k].col(t)); } x_filt_k.col(t) = x_; // given previous measurment } for (size_t t = n_t - n_pred; t \u0026lt; n_t; t++) { if (t \u0026gt; 0) { Filter(u[k].col(t - 1), z[k].col(t)); } x_filt_k.col(t) = x_; } x_filt.append(x_filt_k); x_pred.append(x_pred_k); y_pred.append(y_pred_k); } return {x_filt, x_pred, y_pred}; } void lds::System::Print() { std::cout \u0026lt;\u0026lt; \u0026#34;\\n ********** SYSTEM ********** \\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;x: \\n\u0026#34; \u0026lt;\u0026lt; x_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;P: \\n\u0026#34; \u0026lt;\u0026lt; P_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;A: \\n\u0026#34; \u0026lt;\u0026lt; A_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;B: \\n\u0026#34; \u0026lt;\u0026lt; B_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;g: \\n\u0026#34; \u0026lt;\u0026lt; g_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;m: \\n\u0026#34; \u0026lt;\u0026lt; m_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Q: \\n\u0026#34; \u0026lt;\u0026lt; Q_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Q_m: \\n\u0026#34; \u0026lt;\u0026lt; Q_m_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;d: \\n\u0026#34; \u0026lt;\u0026lt; d_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;C: \\n\u0026#34; \u0026lt;\u0026lt; C_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;y: \\n\u0026#34; \u0026lt;\u0026lt; y_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } //******************* SYS_T ******************* Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":88,"href":"/lds-ctrl-est/docs/api/files/lds__uniform__vecs_8cpp/","title":"src/lds_uniform_vecs.cpp","section":"Files","content":" src/lds_uniform_vecs.cpp # Uniformly sized vectors. More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Detailed Description # This file provides a container for uniformly sized vectors.\nSource code # //===-- ldsCtrlEst_h/lds_uniform_vecs.cpp - Uniform Matrices --------------===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst_h/lds_uniform_vecs.h\u0026gt; namespace lds { UniformVectorList::UniformVectorList(const std::vector\u0026lt;Vector\u0026gt;\u0026amp; vecs, size_t dim) : vector(vecs) { CheckDimensions(dim); } UniformVectorList::UniformVectorList(std::vector\u0026lt;Vector\u0026gt;\u0026amp;\u0026amp; vecs, size_t dim) : vector(std::move(vecs)) { CheckDimensions(dim); }; UniformVectorList::UniformVectorList(std::initializer_list\u0026lt;Vector\u0026gt; vecs, size_t dim) : vector(vecs) { CheckDimensions(dim); }; UniformVectorList::UniformVectorList(const UniformVectorList\u0026amp; that) : vector(that) { (*this) = that; } UniformVectorList::UniformVectorList(UniformVectorList\u0026amp;\u0026amp; that) noexcept : vector(std::move(that)) { this-\u0026gt;dim_ = this-\u0026gt;at(0).n_elem; } void UniformVectorList::CheckDimensions(size_t dim) { if (dim) { dim_ = dim; } else { dim_ = this-\u0026gt;at(0).n_elem; } // make sure dimensiolaties are all uniform bool does_match(true); for (const Vector\u0026amp; vec : *this) { does_match = does_match \u0026amp;\u0026amp; (vec.n_elem == dim_); if (!does_match) { throw std::runtime_error( \u0026#34;Dimensionality of one or more input matrices are not uniform.\u0026#34;); } } } } // namespace lds Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":89,"href":"/lds-ctrl-est/docs/api/files/lds_8cpp/","title":"src/lds.cpp","section":"Files","content":" src/lds.cpp # misc lds namespace functions More\u0026hellip;\nNamespaces # Name lds Linear Dynamical Systems (LDS) namespace. Detailed Description # This file implements miscellaneous lds namespace functions not bound to a class.\nSource code # //===-- lds.cpp - LDS -----------------------------------------------------===// // // Copyright 2021 Michael Bolus // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \u0026lt;ldsCtrlEst_h/lds.h\u0026gt; // insert any necessary function definitions here. namespace lds { void ForceSymPD(Matrix\u0026amp; X) { if (X.is_sympd() || !X.is_square()) { return; } // make symmetric X = (X + X.t()) / 2; // for eigenval decomp bool did_succeed(true); Vector d; Matrix u; // see first method (which may not be ideal): // https://nhigham.com/2021/02/16/diagonally-perturbing-a-symmetric-matrix-to-make-it-positive-definite/ size_t k(1); bool is_sympd = X.is_sympd(); Matrix id = Matrix(X.n_rows, X.n_cols, fill::eye); while (!is_sympd) { if (k \u0026gt; 100) { did_succeed = arma::eig_sym(d, u, X, \u0026#34;std\u0026#34;); data_t min_eig = arma::min(d); std::cerr \u0026lt;\u0026lt; \u0026#34;After multiple iterations, min eigen val = \u0026#34; \u0026lt;\u0026lt; min_eig \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; throw std::runtime_error( \u0026#34;Failed to make matrix symmetric positive definite.\u0026#34;); return; } // Limit(d, arma::eps(0), kInf); // force to be positive... // Matrix d_diag = arma::diagmat(d); // X = u * d_diag * u.t(); did_succeed = arma::eig_sym(d, u, X, \u0026#34;std\u0026#34;); if (!did_succeed) { throw std::runtime_error(\u0026#34;ForceSymPD failed.\u0026#34;); } data_t min_eig = arma::min(d); X += id * abs(min_eig) + arma::datum::eps; // make sure symm: X = (X + X.t()) / 2; // double check eigenvals positive after symmetrizing: arma::eig_sym(d, u, X, \u0026#34;std\u0026#34;); min_eig = arma::min(d); is_sympd = min_eig \u0026gt; 0; k++; } } void ForceSymMinEig(Matrix\u0026amp; X, data_t eig_min) { if (!X.is_square()) { return; } // make symmetric X = (X + X.t()) / 2; bool did_succeed(true); Vector d; Matrix u; did_succeed = arma::eig_sym(d, u, X, \u0026#34;std\u0026#34;); if (!did_succeed) { throw std::runtime_error(\u0026#34;ForceSymMinEig failed.\u0026#34;); } Limit(d, eig_min + arma::eps(eig_min), kInf); // enforce lower bound Matrix d_diag = arma::diagmat(d); X = u * d_diag * u.t(); // double check symmetric X = (X + X.t()) / 2; } void lq(Matrix\u0026amp; L, Matrix\u0026amp; Qt, const Matrix\u0026amp; X) { bool did_succeed(true); did_succeed = arma::qr_econ(Qt, L, X.t()); if (!did_succeed) { throw std::runtime_error(\u0026#34;LQ decomposition failed.\u0026#34;); } arma::inplace_trans(L); arma::inplace_trans(Qt); } Matrix calcCov(const Matrix\u0026amp; A, const Matrix\u0026amp; B) { // subtract out mean auto m_a = arma::mean(A, 1); Matrix a0 = A; a0.each_col() -= m_a; auto m_b = arma::mean(B, 1); Matrix b0 = B; b0.each_col() -= m_b; Matrix cov = a0 * b0.t() / a0.n_cols; return cov; } } // namespace lds Updated on 5 March 2025 at 16:32:33 EST\n"},{"id":90,"href":"/lds-ctrl-est/docs/api/namespaces/namespacestd/","title":"std","section":"Namespaces","content":" std # Updated on 5 March 2025 at 16:32:33 EST\n"}]