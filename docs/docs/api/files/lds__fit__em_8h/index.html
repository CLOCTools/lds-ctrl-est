<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="subspace identification">
<meta name="theme-color" content="#FFFFFF"><meta property="og:url" content="https://stanley-rozell.github.io/lds-ctrl-est/docs/api/files/lds__fit__em_8h/">
  <meta property="og:site_name" content="LDS C&E">
  <meta property="og:title" content="ldsCtrlEst_h/lds_fit_em.h">
  <meta property="og:description" content="subspace identification">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
<title>ldsCtrlEst_h/lds_fit_em.h | LDS C&amp;E</title>
<link rel="manifest" href="/lds-ctrl-est/manifest.json">
<link rel="icon" href="/lds-ctrl-est/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/lds-ctrl-est/book.min.57f7f660871517a5bfcfb5e2de853d806f7e34d94ebd5f3f3bad62e9ddbae209.css" integrity="sha256-V/f2YIcVF6W/z7Xi3oU9gG9&#43;NNlOvV8/O61i6d264gk=" crossorigin="anonymous">
  <script defer src="/lds-ctrl-est/flexsearch.min.js"></script>
  <script defer src="/lds-ctrl-est/en.search.min.4f6b617641b714cbf70266302fdeb12a9567eb52ebfb017533f9c9af1b260392.js" integrity="sha256-T2thdkG3FMv3AmYwL96xKpVn61Lr&#43;wF1M/nJrxsmA5I=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/lds-ctrl-est/"><img src="/lds-ctrl-est/ldsctrlest-logo.png" alt="Logo" /><span>LDS C&amp;E</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li><strong>Library Terminology</strong>
<ul>
<li><a href="/lds-ctrl-est/docs/terminology/model/"><strong>Model Definitions</strong></a></li>
<li><a href="/lds-ctrl-est/docs/terminology/control-estimation/"><strong>Control &amp; Estimation</strong></a></li>
</ul>
</li>
</ul>
<br />
<ul>
<li><a href="/lds-ctrl-est/docs/getting-started/getting-started/"><strong>Getting Started</strong></a>
<ul>
<li><a href="/lds-ctrl-est/docs/getting-started/windows/"><strong>Windows</strong></a></li>
</ul>
</li>
</ul>
<br />
<ul>
<li><strong>Tutorials</strong>
<ul>
<li><a href="/lds-ctrl-est/docs/tutorials/eg_glds_control/">GLDS Control</a></li>
<li><a href="/lds-ctrl-est/docs/tutorials/eg_plds_state_estimation/">PLDS Estimation</a></li>
<li><a href="/lds-ctrl-est/docs/tutorials/eg_switched_plds_control/">Switched PLDS Control</a></li>
</ul>
</li>
</ul>
<br />
<ul>
<li><strong>API Reference</strong>
<ul>
<li><a href="/lds-ctrl-est/docs/api/namespaces/">Namespaces</a></li>
<li><a href="/lds-ctrl-est/docs/api/classes/">Classes</a></li>
<li><a href="/lds-ctrl-est/docs/api/modules/">Modules</a></li>
<li><a href="/lds-ctrl-est/docs/api/files/">Files</a></li>
<li><a href="/lds-ctrl-est/docs/api/examples/">Examples</a></li>
</ul>
</li>
</ul>
<br />
<ul>
<li><a href="/lds-ctrl-est/issues-contributing/"><strong>Reporting Issues &amp; Contributing</strong></a></li>
</ul>
<br />
<ul>
<li><a href="/lds-ctrl-est/acknowledgements/"><strong>Acknowledgements</strong></a></li>
</ul>
<br />






  
<ul>
  
  <li>
    <a href="https://github.com/stanley-rozell/lds-ctrl-est" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/lds-ctrl-est/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>ldsCtrlEst_h/lds_fit_em.h</strong>

  <label for="toc-control">
    
    <img src="/lds-ctrl-est/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#ldsctrlest_hlds_fit_emh">ldsCtrlEst_h/lds_fit_em.h</a>
      <ul>
        <li><a href="#namespaces">Namespaces</a></li>
        <li><a href="#classes">Classes</a></li>
        <li><a href="#detailed-description">Detailed Description</a></li>
        <li><a href="#source-code">Source code</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="ldsctrlest_hlds_fit_emh">
  ldsCtrlEst_h/lds_fit_em.h
  <a class="anchor" href="#ldsctrlest_hlds_fit_emh">#</a>
</h1>
<p>subspace identification  <a href="#detailed-description">More&hellip;</a></p>
<h2 id="namespaces">
  Namespaces
  <a class="anchor" href="#namespaces">#</a>
</h2>
<table>
  <thead>
      <tr>
          <th>Name</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong><a href="/lds-ctrl-est/docs/api/namespaces/namespacelds/">lds</a></strong> <br>Linear Dynamical Systems (LDS) namespace.</td>
      </tr>
  </tbody>
</table>
<h2 id="classes">
  Classes
  <a class="anchor" href="#classes">#</a>
</h2>
<table>
  <thead>
      <tr>
          <th></th>
          <th>Name</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>class</td>
          <td><strong><a href="/lds-ctrl-est/docs/api/classes/classlds_1_1_e_m/">lds::EM</a></strong></td>
      </tr>
  </tbody>
</table>
<h2 id="detailed-description">
  Detailed Description
  <a class="anchor" href="#detailed-description">#</a>
</h2>
<p>This file declares the type for fitting a linear dynamical system by expectation-maximization (<a href="/lds-ctrl-est/docs/api/classes/classlds_1_1_e_m/">lds::EM</a>).</p>
<h2 id="source-code">
  Source code
  <a class="anchor" href="#source-code">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//===-- ldsCtrlEst_h/lds_fit_em.h - EM Fit ----------------------*- C++ -*-===//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Copyright 2021 Michael Bolus
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Copyright 2021 Georgia Institute of Technology
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// you may not use this file except in compliance with the License.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// You may obtain a copy of the License at
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     http://www.apache.org/licenses/LICENSE-2.0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Unless required by applicable law or agreed to in writing, software
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// See the License for the specific language governing permissions and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// limitations under the License.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//===----------------------------------------------------------------------===//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//===----------------------------------------------------------------------===//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef LDSCTRLEST_LDS_EMAX_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define LDSCTRLEST_LDS_EMAX_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;lds_fit.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> lds {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EM</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static_assert</span>(std<span style="color:#f92672">::</span>is_base_of<span style="color:#f92672">&lt;</span>lds<span style="color:#f92672">::</span>Fit, Fit<span style="color:#f92672">&gt;::</span>value,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;Fit must be derived from lds::Fit type.&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  EM() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  EM(size_t n_x, data_t dt, UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> u_train,
</span></span><span style="display:flex;"><span>     UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> z_train);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  EM(<span style="color:#66d9ef">const</span> Fit<span style="color:#f92672">&amp;</span> fit0, UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> u_train,
</span></span><span style="display:flex;"><span>     UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> z_train);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>EM() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Fit<span style="color:#f92672">&amp;</span> Run(<span style="color:#66d9ef">bool</span> calc_dynamics <span style="color:#f92672">=</span> true, <span style="color:#66d9ef">bool</span> calc_Q <span style="color:#f92672">=</span> true,
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">bool</span> calc_init <span style="color:#f92672">=</span> true, <span style="color:#66d9ef">bool</span> calc_output <span style="color:#f92672">=</span> true,
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">bool</span> calc_measurement <span style="color:#f92672">=</span> true, size_t max_iter <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>,
</span></span><span style="display:flex;"><span>                 data_t tol <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span>UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span>, UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>  ReturnData() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> tuple <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_tuple(std<span style="color:#f92672">::</span>move(u_), std<span style="color:#f92672">::</span>move(z_));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// auto tuple = std::make_tuple(u_, z_);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    u_ <span style="color:#f92672">=</span> UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>    z_ <span style="color:#f92672">=</span> UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tuple;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;&amp;</span> x() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> x_; };
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;&amp;</span> y() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> y_; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Matrix<span style="color:#f92672">&amp;</span> sum_E_x_t_x_t() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> sum_E_x_t_x_t_; };
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Matrix<span style="color:#f92672">&amp;</span> sum_E_xu_tm1_xu_tm1() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> sum_E_xu_tm1_xu_tm1_; };
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Matrix<span style="color:#f92672">&amp;</span> sum_E_xu_t_xu_tm1() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> sum_E_xu_t_xu_tm1_; };
</span></span><span style="display:flex;"><span>  size_t <span style="color:#a6e22e">n_t_tot</span>() { <span style="color:#66d9ef">return</span> n_t_tot_; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Vector<span style="color:#f92672">&amp;</span> theta() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> theta_; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> Expectation(<span style="color:#66d9ef">bool</span> force_common_initial <span style="color:#f92672">=</span> false);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Maximization</span>(<span style="color:#66d9ef">bool</span> calc_dynamics <span style="color:#f92672">=</span> true, <span style="color:#66d9ef">bool</span> calc_Q <span style="color:#f92672">=</span> true,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">bool</span> calc_init <span style="color:#f92672">=</span> false, <span style="color:#66d9ef">bool</span> calc_output <span style="color:#f92672">=</span> false,
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">bool</span> calc_measurement <span style="color:#f92672">=</span> false);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeDynamics</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeQ</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeInitial</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeOutput</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeMeasurement</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Smooth</span>(<span style="color:#66d9ef">bool</span> force_common_initial);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">RecurseKe</span>(Matrix<span style="color:#f92672">&amp;</span> Ke, Cube<span style="color:#f92672">&amp;</span> P_pre, Cube<span style="color:#f92672">&amp;</span> P_post, size_t t) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Reset</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitVars</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Vector <span style="color:#a6e22e">UpdateTheta</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// input/output training data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span> u_;  
</span></span><span style="display:flex;"><span>  UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span> z_;  
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;</span> x_;              
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Cube<span style="color:#f92672">&gt;</span> P_;                
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Cube<span style="color:#f92672">&gt;</span> P_t_tm1_;          
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;</span> y_;              
</span></span><span style="display:flex;"><span>  Matrix diag_y_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// expectations calculated in E-step
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Matrix sum_E_x_t_x_t_;        
</span></span><span style="display:flex;"><span>  Matrix sum_E_xu_tm1_xu_tm1_;  
</span></span><span style="display:flex;"><span>  Matrix sum_E_xu_t_xu_tm1_;    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Fit fit_;
</span></span><span style="display:flex;"><span>  Vector theta_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  data_t dt_{};              
</span></span><span style="display:flex;"><span>  size_t n_u_{};             
</span></span><span style="display:flex;"><span>  size_t n_x_{};             
</span></span><span style="display:flex;"><span>  size_t n_y_{};             
</span></span><span style="display:flex;"><span>  size_t n_trials_{};        
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> n_t_;  
</span></span><span style="display:flex;"><span>  size_t n_t_tot_{};         
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>EM(size_t n_x, data_t dt, UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> u_train,
</span></span><span style="display:flex;"><span>            UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> z_train) {
</span></span><span style="display:flex;"><span>  n_u_ <span style="color:#f92672">=</span> u_train.at(<span style="color:#ae81ff">0</span>).n_rows;
</span></span><span style="display:flex;"><span>  n_y_ <span style="color:#f92672">=</span> z_train.at(<span style="color:#ae81ff">0</span>).n_rows;
</span></span><span style="display:flex;"><span>  fit_ <span style="color:#f92672">=</span> Fit(n_u_, n_x, n_y_, dt);
</span></span><span style="display:flex;"><span>  u_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(u_train);
</span></span><span style="display:flex;"><span>  z_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(z_train);
</span></span><span style="display:flex;"><span>  InitVars();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>EM(<span style="color:#66d9ef">const</span> Fit<span style="color:#f92672">&amp;</span> fit0, UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> u_train,
</span></span><span style="display:flex;"><span>            UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> z_train) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// make sure fit dims match I/O data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (fit0.n_u() <span style="color:#f92672">!=</span> u_train.at(<span style="color:#ae81ff">0</span>).n_rows) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Initial fit and input training data have inconsistent dimensions&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (fit0.n_y() <span style="color:#f92672">!=</span> z_train.at(<span style="color:#ae81ff">0</span>).n_rows) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Initial fit and output training data have inconsistent dimensions&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  fit_ <span style="color:#f92672">=</span> fit0;
</span></span><span style="display:flex;"><span>  u_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(u_train);
</span></span><span style="display:flex;"><span>  z_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(z_train);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  InitVars();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>InitVars() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// check input/output data dimensions are consistent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (z_.size() <span style="color:#f92672">!=</span> u_.size()) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;I/O training data have different number of trials.&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  n_trials_ <span style="color:#f92672">=</span> u_.size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  n_t_tot_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  n_t_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span>(n_trials_);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> n_trials_; trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (z_.at(trial).n_cols <span style="color:#f92672">!=</span> u_.at(trial).n_cols) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;I/O training data have different number of time steps.&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    n_t_[trial] <span style="color:#f92672">=</span> u_.at(trial).n_cols;
</span></span><span style="display:flex;"><span>    n_t_tot_ <span style="color:#f92672">+=</span> n_t_[trial];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  n_u_ <span style="color:#f92672">=</span> fit_.n_u();
</span></span><span style="display:flex;"><span>  n_x_ <span style="color:#f92672">=</span> fit_.n_x();
</span></span><span style="display:flex;"><span>  n_y_ <span style="color:#f92672">=</span> fit_.n_y();
</span></span><span style="display:flex;"><span>  dt_ <span style="color:#f92672">=</span> fit_.dt();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  x_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;</span>(n_trials_);
</span></span><span style="display:flex;"><span>  P_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Cube<span style="color:#f92672">&gt;</span>(n_trials_);
</span></span><span style="display:flex;"><span>  P_t_tm1_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Cube<span style="color:#f92672">&gt;</span>(n_trials_);
</span></span><span style="display:flex;"><span>  y_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;</span>(n_trials_);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> n_trials_; trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    x_[trial] <span style="color:#f92672">=</span> Matrix(n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>    P_[trial] <span style="color:#f92672">=</span> Cube(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>    P_t_tm1_[trial] <span style="color:#f92672">=</span> Cube(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>    y_[trial] <span style="color:#f92672">=</span> Matrix(n_y_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  diag_y_ <span style="color:#f92672">=</span> Matrix(n_y_, n_y_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// covariances in expectation step
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  sum_E_x_t_x_t_ <span style="color:#f92672">=</span> Matrix(n_x_, n_x_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  sum_E_xu_tm1_xu_tm1_ <span style="color:#f92672">=</span> Matrix(n_x_ <span style="color:#f92672">+</span> n_u_, n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  sum_E_xu_t_xu_tm1_ <span style="color:#f92672">=</span> Matrix(n_x_ <span style="color:#f92672">+</span> n_u_, n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Fit<span style="color:#f92672">&amp;</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Run(<span style="color:#66d9ef">bool</span> calc_dynamics, <span style="color:#66d9ef">bool</span> calc_Q, <span style="color:#66d9ef">bool</span> calc_init,
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">bool</span> calc_output, <span style="color:#66d9ef">bool</span> calc_measurement,
</span></span><span style="display:flex;"><span>                        size_t max_iter, data_t tol) {
</span></span><span style="display:flex;"><span>  Reset();  <span style="color:#75715e">// to initial conditions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  size_t n_params <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_u_ <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_y_;
</span></span><span style="display:flex;"><span>  Vector <span style="color:#a6e22e">theta</span>(n_params);
</span></span><span style="display:flex;"><span>  Vector <span style="color:#a6e22e">theta_new</span>(n_params);
</span></span><span style="display:flex;"><span>  data_t max_dtheta <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// if solving for initial conditions, allow them be varied.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// otherwise, freeze at provided values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> force_common_initial <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>calc_init;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// go until parameter convergence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (size_t l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; l <span style="color:#f92672">&lt;</span> max_iter; l<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    theta_ <span style="color:#f92672">=</span> UpdateTheta();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Iteration &#34;</span> <span style="color:#f92672">&lt;&lt;</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;/&#34;</span> <span style="color:#f92672">&lt;&lt;</span> max_iter <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; ...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Expectation(force_common_initial);
</span></span><span style="display:flex;"><span>    Maximization(calc_dynamics, calc_Q, calc_init, calc_output,
</span></span><span style="display:flex;"><span>                 calc_measurement);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// check convergence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    theta_new <span style="color:#f92672">=</span> UpdateTheta();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Vector dtheta <span style="color:#f92672">=</span> abs(theta_new <span style="color:#f92672">-</span> theta_) <span style="color:#f92672">/</span> abs(theta_);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// some parameters could be zero...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    arma<span style="color:#f92672">::</span>uvec ubi_finite <span style="color:#f92672">=</span> find_finite(dtheta);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    max_dtheta <span style="color:#f92672">=</span> max(dtheta.elem(ubi_finite));
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;max dtheta: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> max_dtheta <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (max_dtheta <span style="color:#f92672">&lt;</span> tol) {
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Converged.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> fit_;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Smooth(<span style="color:#66d9ef">bool</span> force_common_initial) {
</span></span><span style="display:flex;"><span>  Matrix <span style="color:#a6e22e">k_e</span>(n_x_, n_y_);  <span style="color:#75715e">// estimator gain
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Cube k_backfilt;         <span style="color:#75715e">// back-filtering gains
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// TODO(mfbolus): this loop could be made parallel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    Matrix <span style="color:#a6e22e">x_pre</span>(n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>    Cube <span style="color:#a6e22e">p_pre</span>(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>    Matrix <span style="color:#a6e22e">x_post</span>(n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>    Cube <span style="color:#a6e22e">p_post</span>(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (force_common_initial)  <span style="color:#75715e">// forces all trials to have same initial
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                               <span style="color:#75715e">// conditions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>      x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.x0();
</span></span><span style="display:flex;"><span>      P_[trial].slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.P0();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    y_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.C() <span style="color:#f92672">*</span> x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> fit_.d();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This *should not* be necessary but make sure P is symmetric.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ForceSymPD(P_[trial].slice(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    x_pre.col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> x_[trial].col(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    p_pre.slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> P_[trial].slice(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    x_post.col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> x_[trial].col(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    p_post.slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> P_[trial].slice(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// filter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// predict
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      fit_.f(x_pre, x_post, u_.at(trial), t);
</span></span><span style="display:flex;"><span>      fit_.h(y_[trial], x_pre, t);
</span></span><span style="display:flex;"><span>      diag_y_.diag() <span style="color:#f92672">=</span> y_[trial].col(t);  <span style="color:#75715e">// TODO(mfbolus): change if parallel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// update --&gt; posterior estimation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      RecurseKe(k_e, p_pre, p_post, t);
</span></span><span style="display:flex;"><span>      x_post.col(t) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>          x_pre.col(t) <span style="color:#f92672">+</span> k_e <span style="color:#f92672">*</span> (z_.at(trial).col(t) <span style="color:#f92672">-</span> y_[trial].col(t));
</span></span><span style="display:flex;"><span>      y_[trial].col(t) <span style="color:#f92672">=</span> fit_.C() <span style="color:#f92672">*</span> x_post.col(t) <span style="color:#f92672">+</span> fit_.d();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// backfilter -&gt; Smoothed estimate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Reference:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Shumway et Stoffer (1982)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ForceSymPD(p_post.slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    k_backfilt <span style="color:#f92672">=</span> Cube(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>    x_[trial].col(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> x_post.col(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    P_[trial].slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> p_post.slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> (n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); t <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; t<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// TODO(mfmbolus): should not be necessary to force symm positive def
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      ForceSymPD(p_pre.slice(t));
</span></span><span style="display:flex;"><span>      ForceSymPD(p_post.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>      ForceSymPD(P_[trial].slice(t));
</span></span><span style="display:flex;"><span>      k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>          p_post.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> fit_.A().t() <span style="color:#f92672">*</span> inv_sympd(p_pre.slice(t));
</span></span><span style="display:flex;"><span>      x_[trial].col(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>          x_post.col(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>          k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> (x_[trial].col(t) <span style="color:#f92672">-</span> x_pre.col(t));
</span></span><span style="display:flex;"><span>      P_[trial].slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>          p_post.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>                                    (P_[trial].slice(t) <span style="color:#f92672">-</span> p_pre.slice(t)) <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>                                    k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>).t();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do the same for P_t_tm1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Matrix <span style="color:#a6e22e">id</span>(n_x_, n_x_, fill<span style="color:#f92672">::</span>eye);
</span></span><span style="display:flex;"><span>    P_t_tm1_[trial].slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        (id <span style="color:#f92672">-</span> k_e <span style="color:#f92672">*</span> fit_.C()) <span style="color:#f92672">*</span> fit_.A() <span style="color:#f92672">*</span> p_post.slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> (n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); t <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>; t<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>      P_t_tm1_[trial].slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>          p_post.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>).t() <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>          k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>              (P_t_tm1_[trial].slice(t) <span style="color:#f92672">-</span> fit_.A() <span style="color:#f92672">*</span> p_post.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>              k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>).t();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// finally, get smoothed estimate of output
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      fit_.h(y_[trial], x_[trial], t);
</span></span><span style="display:flex;"><span>    }  <span style="color:#75715e">// samps loop
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }    <span style="color:#75715e">// trial loop
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}  <span style="color:#75715e">// Smooth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// template &lt;typename Fit&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// void EM&lt;Fit&gt;::RecurseKe(Matrix&amp; Ke, Cube&amp; P_pre, Cube&amp; P_post, size_t t) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   // predict covar
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   P_pre.slice(t) = fit_.A() * P_post.slice(t - 1) * fit_.A().t() + fit_.Q();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//   // update Ke
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   Ke = P_pre.slice(t) * fit_.C().t() *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        inv_sympd(fit_.C() * P_pre.slice(t) * fit_.C().t() + fit_.R());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//   // update cov
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   // Reference: Ghahramani et Hinton (1996)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   P_post.slice(t) = P_pre.slice(t) - Ke * fit_.C() * P_pre.slice(t);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//   // // n.b. for poisson :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   // P_pre.slice(t) = fit_.A() * P_post.slice(t - 1) * fit_.A().t() +
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   fit_.Q();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   // // update cov
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   // P_post.slice(t) = pinv(pinv(P_pre.slice(t)) + fit_.C().t() * diag_y_ *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   // fit_.C());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   // // update Ke
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   // Ke = P_post.slice(t) * fit_.C();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Expectation(<span style="color:#66d9ef">bool</span> force_common_initial) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// calculate the mean/cov of state needed for maximizing E[pr(z|theta)]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Smooth(force_common_initial);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// now get the various forms of sum(E[xx&#39;]) needed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// n.b. Going to start at t=1 rather than 0 bc most max terms need that.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// so really &#34;n_t_tot_&#34; is (n_t_tot_-1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  n_t_tot_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  sum_E_x_t_x_t_ <span style="color:#f92672">=</span> Matrix(n_x_, n_x_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  sum_E_xu_tm1_xu_tm1_ <span style="color:#f92672">=</span> Matrix(n_x_ <span style="color:#f92672">+</span> n_u_, n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  sum_E_xu_t_xu_tm1_ <span style="color:#f92672">=</span> Matrix(n_x_ <span style="color:#f92672">+</span> n_u_, n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Vector <span style="color:#a6e22e">xu_tm1</span>(n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  Vector <span style="color:#a6e22e">xu_t</span>(n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ------------ sum_E_x_t_x_t ------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      sum_E_x_t_x_t_ <span style="color:#f92672">+=</span> x_[trial].col(t) <span style="color:#f92672">*</span> x_[trial].col(t).t();
</span></span><span style="display:flex;"><span>      sum_E_x_t_x_t_ <span style="color:#f92672">+=</span> P_[trial].slice(t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ------------ sum_E_xu_tm1_xu_tm1 ------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      xu_tm1 <span style="color:#f92672">=</span> join_vert(x_[trial].col(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), u_.at(trial).col(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>      sum_E_xu_tm1_xu_tm1_ <span style="color:#f92672">+=</span> xu_tm1 <span style="color:#f92672">*</span> xu_tm1.t();
</span></span><span style="display:flex;"><span>      sum_E_xu_tm1_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+=</span>
</span></span><span style="display:flex;"><span>          P_[trial].slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ------------ sum_E_xu_t_xu_tm1 ------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      xu_t <span style="color:#f92672">=</span> join_vert(x_[trial].col(t), u_.at(trial).col(t));
</span></span><span style="display:flex;"><span>      sum_E_xu_t_xu_tm1_ <span style="color:#f92672">+=</span> xu_t <span style="color:#f92672">*</span> xu_tm1.t();
</span></span><span style="display:flex;"><span>      sum_E_xu_t_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+=</span>
</span></span><span style="display:flex;"><span>          P_t_tm1_[trial].slice(t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      n_t_tot_ <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }  <span style="color:#75715e">// time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }    <span style="color:#75715e">// trial
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}  <span style="color:#75715e">// Expectation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Maximization(<span style="color:#66d9ef">bool</span> calc_dynamics, <span style="color:#66d9ef">bool</span> calc_Q, <span style="color:#66d9ef">bool</span> calc_init,
</span></span><span style="display:flex;"><span>                           <span style="color:#66d9ef">bool</span> calc_output, <span style="color:#66d9ef">bool</span> calc_measurement) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (calc_output) {
</span></span><span style="display:flex;"><span>    MaximizeOutput();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (calc_measurement) {
</span></span><span style="display:flex;"><span>    MaximizeMeasurement();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (calc_dynamics) {
</span></span><span style="display:flex;"><span>    MaximizeDynamics();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (calc_Q) {
</span></span><span style="display:flex;"><span>    MaximizeQ();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (calc_init) {
</span></span><span style="display:flex;"><span>    MaximizeInitial();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}  <span style="color:#75715e">// Maximization
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeDynamics() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Shumway, Stoffer (1982); Ghahgramani, Hinton (1996)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Matrix ab <span style="color:#f92672">=</span> sum_E_xu_t_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>              inv_sympd(sum_E_xu_tm1_xu_tm1_);
</span></span><span style="display:flex;"><span>  fit_.set_A(ab.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>  fit_.set_B(ab.submat(<span style="color:#ae81ff">0</span>, n_x_, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.A()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.B()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeQ() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// // Shumway, Stoffer (1982); Ghahgramani, Hinton (1996)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// View sum_e_x_t_xu_tm1 =
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//     sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Matrix q = sum_E_x_t_x_t_ - sum_e_x_t_xu_tm1 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//                                inv_sympd(sum_E_xu_tm1_xu_tm1_) *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//                                sum_e_x_t_xu_tm1.t();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// q /= n_t_tot_;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// this way is same as above iff dynamics were just updated:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// View sum_e_x_t_xu_tm1 =
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//     sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Matrix ab = arma::join_horiz(fit_.A(), fit_.B());
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Matrix q = sum_E_x_t_x_t_ - ab * sum_e_x_t_xu_tm1.t();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// q /= n_t_tot_;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// From scratch method:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Q is covariance of the error between state and dynamics-predicted state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// (aka process noise)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Q* = E[(x_t - Ax_{t-1} - Bu_{t-1})*(x_t - Ax_{t-1} - Bu_{t-1})&#39;]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// t-1 terms:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  View sum_e_x_tm1_x_tm1 <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      sum_E_xu_tm1_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  View sum_e_u_tm1_u_tm1 <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      sum_E_xu_tm1_xu_tm1_.submat(n_x_, n_x_, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  View sum_e_x_tm1_u_tm1 <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      sum_E_xu_tm1_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, n_x_, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// t, t-1 terms:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  View sum_e_x_t_x_tm1 <span style="color:#f92672">=</span> sum_E_xu_t_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  View sum_e_x_t_u_tm1 <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      sum_E_xu_t_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, n_x_, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Matrix q <span style="color:#f92672">=</span> sum_E_x_t_x_t_;
</span></span><span style="display:flex;"><span>  q <span style="color:#f92672">+=</span> fit_.A() <span style="color:#f92672">*</span> sum_e_x_tm1_x_tm1 <span style="color:#f92672">*</span> fit_.A().t();
</span></span><span style="display:flex;"><span>  q <span style="color:#f92672">-=</span> sum_e_x_t_x_tm1 <span style="color:#f92672">*</span> fit_.A().t();
</span></span><span style="display:flex;"><span>  q <span style="color:#f92672">-=</span> fit_.A() <span style="color:#f92672">*</span> sum_e_x_t_x_tm1.t();
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// input-related terms:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  q <span style="color:#f92672">+=</span> fit_.B() <span style="color:#f92672">*</span> sum_e_u_tm1_u_tm1 <span style="color:#f92672">*</span> fit_.B().t();
</span></span><span style="display:flex;"><span>  q <span style="color:#f92672">-=</span> sum_e_x_t_u_tm1 <span style="color:#f92672">*</span> fit_.B().t();
</span></span><span style="display:flex;"><span>  q <span style="color:#f92672">-=</span> fit_.B() <span style="color:#f92672">*</span> sum_e_x_t_u_tm1.t();
</span></span><span style="display:flex;"><span>  q <span style="color:#f92672">+=</span> fit_.A() <span style="color:#f92672">*</span> sum_e_x_tm1_u_tm1 <span style="color:#f92672">*</span> fit_.B().t();
</span></span><span style="display:flex;"><span>  q <span style="color:#f92672">+=</span> fit_.B() <span style="color:#f92672">*</span> sum_e_x_tm1_u_tm1.t() <span style="color:#f92672">*</span> fit_.A().t();
</span></span><span style="display:flex;"><span>  q <span style="color:#f92672">/=</span> n_t_tot_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  fit_.set_Q(q);
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Q_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.Q()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// std::cout &lt;&lt; &#34;Q_new: \n&#34; &lt;&lt; fit_.Q() &lt;&lt; &#34;\n&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeInitial() {
</span></span><span style="display:flex;"><span>  Vector x0 <span style="color:#f92672">=</span> fit_.x0();
</span></span><span style="display:flex;"><span>  x0.zeros();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    x0 <span style="color:#f92672">+=</span> x_[trial].col(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  x0 <span style="color:#f92672">/=</span> z_.size();
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;x0_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> x0[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// always recalc P0 even if the initial state is fixed (at zero, for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// example)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Matrix <span style="color:#a6e22e">e_var</span>(n_x_, n_x_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    e_var <span style="color:#f92672">+=</span> (x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">-</span> x0) <span style="color:#f92672">*</span> (x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">-</span> x0).t();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  e_var <span style="color:#f92672">/=</span> z_.size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// go ahead and subtract x0*x0&#39; so don&#39;t have to below.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  e_var <span style="color:#f92672">-=</span> x0 <span style="color:#f92672">*</span> x0.t();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// To get P0, going to get initial P_ per trial and average.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// (which might be wrong, but need a single number)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Matrix p0 <span style="color:#f92672">=</span> fit_.P0();
</span></span><span style="display:flex;"><span>  p0.zeros();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    p0 <span style="color:#f92672">+=</span>
</span></span><span style="display:flex;"><span>        (x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">*</span> x_[trial].col(<span style="color:#ae81ff">0</span>).t()) <span style="color:#f92672">+</span> P_[trial].slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> e_var;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  p0 <span style="color:#f92672">/=</span> z_.size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  fit_.set_P0(p0);
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;P0_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.P0()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeOutput() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// solve for C+d:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Matrix <span style="color:#a6e22e">sum_zx</span>(n_y_, n_x_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  Vector <span style="color:#a6e22e">x1</span>(n_x_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  x1[n_x_] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;  <span style="color:#75715e">// augment with one to solve for bias
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Matrix <span style="color:#a6e22e">sum_e_x1_x1</span>(n_x_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      x1.subvec(<span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> x_[trial].col(t);
</span></span><span style="display:flex;"><span>      sum_zx <span style="color:#f92672">+=</span> z_.at(trial).col(t) <span style="color:#f92672">*</span> x1.t();
</span></span><span style="display:flex;"><span>      sum_e_x1_x1 <span style="color:#f92672">+=</span> x1 <span style="color:#f92672">*</span> x1.t();
</span></span><span style="display:flex;"><span>      sum_e_x1_x1.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+=</span> P_[trial].slice(t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  Matrix cd <span style="color:#f92672">=</span> sum_zx <span style="color:#f92672">*</span> inv_sympd(sum_e_x1_x1);
</span></span><span style="display:flex;"><span>  fit_.set_C(cd.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_y_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>  fit_.set_d(vectorise(cd.submat(<span style="color:#ae81ff">0</span>, n_x_, n_y_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_)));
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.C()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;d_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.d()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeMeasurement() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Solve for measurement noise covar
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  size_t n_t_tot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Ghahgramani, Hinton 1996:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Matrix <span style="color:#a6e22e">sum_zz</span>(n_y_, n_y_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  Matrix <span style="color:#a6e22e">sum_yz</span>(n_y_, n_y_, fill<span style="color:#f92672">::</span>zeros);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      sum_zz <span style="color:#f92672">+=</span> z_.at(trial).col(t) <span style="color:#f92672">*</span> z_.at(trial).col(t).t();
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Use Cnew:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      sum_yz <span style="color:#f92672">+=</span>
</span></span><span style="display:flex;"><span>          (fit_.C() <span style="color:#f92672">*</span> x_[trial].col(t) <span style="color:#f92672">+</span> fit_.d()) <span style="color:#f92672">*</span> z_.at(trial).col(t).t();
</span></span><span style="display:flex;"><span>      n_t_tot <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  fit_.set_R((sum_zz <span style="color:#f92672">-</span> sum_yz) <span style="color:#f92672">/</span> n_t_tot);
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;R_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.R()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Reset() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// reset to initial conditions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> n_trials_; trial<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.x0();
</span></span><span style="display:flex;"><span>    P_[trial].slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.P0();
</span></span><span style="display:flex;"><span>    y_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.C() <span style="color:#f92672">*</span> x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> fit_.d();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Vector EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>UpdateTheta() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// TODO(mfbolus): This should include n_y_ more params for d.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  size_t n_params <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_u_ <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">+</span> n_y_;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (fit_.R().n_elem <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    n_params <span style="color:#f92672">+=</span> n_y_ <span style="color:#f92672">*</span> n_y_;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  Vector <span style="color:#a6e22e">theta</span>(n_params);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  size_t idx_start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.A());
</span></span><span style="display:flex;"><span>  idx_start <span style="color:#f92672">+=</span> n_x_ <span style="color:#f92672">*</span> n_x_;
</span></span><span style="display:flex;"><span>  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.B());
</span></span><span style="display:flex;"><span>  idx_start <span style="color:#f92672">+=</span> n_x_ <span style="color:#f92672">*</span> n_u_;
</span></span><span style="display:flex;"><span>  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.Q());
</span></span><span style="display:flex;"><span>  idx_start <span style="color:#f92672">+=</span> n_x_ <span style="color:#f92672">*</span> n_x_;
</span></span><span style="display:flex;"><span>  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.x0());
</span></span><span style="display:flex;"><span>  idx_start <span style="color:#f92672">+=</span> n_x_;
</span></span><span style="display:flex;"><span>  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.P0());
</span></span><span style="display:flex;"><span>  idx_start <span style="color:#f92672">+=</span> n_x_ <span style="color:#f92672">*</span> n_x_;
</span></span><span style="display:flex;"><span>  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.C());
</span></span><span style="display:flex;"><span>  idx_start <span style="color:#f92672">+=</span> n_y_ <span style="color:#f92672">*</span> n_x_;
</span></span><span style="display:flex;"><span>  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.d());
</span></span><span style="display:flex;"><span>  idx_start <span style="color:#f92672">+=</span> n_y_;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (fit_.R().n_elem <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_y_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.R());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> theta;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}  <span style="color:#75715e">// namespace lds
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><hr>
<p>Updated on 31 March 2025 at 16:04:30 EDT</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#ldsctrlest_hlds_fit_emh">ldsCtrlEst_h/lds_fit_em.h</a>
      <ul>
        <li><a href="#namespaces">Namespaces</a></li>
        <li><a href="#classes">Classes</a></li>
        <li><a href="#detailed-description">Detailed Description</a></li>
        <li><a href="#source-code">Source code</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












