<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta name="generator" content="Hugo 0.80.0" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="subspace identification">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="ldsCtrlEst_h/lds_fit_em.h" />
<meta property="og:description" content="subspace identification" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mfbolus.github.io/ldsctrlest/docs/api/files/lds__fit__em_8h/" />

<title>ldsCtrlEst_h/lds_fit_em.h | LDS C&amp;E</title>
<link rel="manifest" href="/ldsctrlest/manifest.json">
<link rel="icon" href="/ldsctrlest/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/ldsctrlest/book.min.44110be292c9f873dbe57bd8895d52b387519bad9a89a86ed5c3705e11d6b0d5.css" integrity="sha256-RBEL4pLJ&#43;HPb5XvYiV1Ss4dRm62aiahu1cNwXhHWsNU=">
<script defer src="/ldsctrlest/en.search.min.88e84de0df48ee0fae77b8096842b20bf0c4e9bdfd60edab92e44d995bb44094.js" integrity="sha256-iOhN4N9I7g&#43;ud7gJaEKyC/DE6b39YO2rkuRNmVu0QJQ="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a href="/ldsctrlest"><img src="/ldsctrlest/ldsctrlest-logo.png" alt="Logo" /><span>LDS C&amp;E</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li><strong>Library Terminology</strong>
<ul>
<li><a href="/ldsctrlest/docs/terminology/model/"><strong>Model Definitions</strong></a></li>
<li><a href="/ldsctrlest/docs/terminology/control-estimation/"><strong>Control &amp; Estimation</strong></a></li>
</ul>
</li>
</ul>
<p><br /></p>
<ul>
<li><a href="/ldsctrlest/docs/getting-started/"><strong>Getting Started</strong></a></li>
</ul>
<p><br /></p>
<ul>
<li><strong>Tutorials</strong>
<ul>
<li><a href="/ldsctrlest/docs/tutorials/eg_glds_control/">GLDS Control</a></li>
<li><a href="/ldsctrlest/docs/tutorials/eg_plds_state_estimation/">PLDS Estimation</a></li>
<li><a href="/ldsctrlest/docs/tutorials/eg_switched_plds_control/">Switched PLDS Control</a></li>
</ul>
</li>
</ul>
<p><br /></p>
<ul>
<li><strong>API Reference</strong>
<ul>
<li><a href="/ldsctrlest/docs/api/namespaces/">Namespaces</a></li>
<li><a href="/ldsctrlest/docs/api/classes/">Classes</a></li>
<li><a href="/ldsctrlest/docs/api/modules/">Modules</a></li>
<li><a href="/ldsctrlest/docs/api/files/">Files</a></li>
<li><a href="/ldsctrlest/docs/api/examples/">Examples</a></li>
</ul>
</li>
</ul>
<p><br /></p>
<ul>
<li><a href="/ldsctrlest/issues-contributing/"><strong>Reporting Issues &amp; Contributing</strong></a></li>
</ul>
<p><br /></p>
<ul>
<li><a href="/ldsctrlest/acknowledgements/"><strong>Acknowledgements</strong></a></li>
</ul>
<p><br /></p>






  
<ul>
  
  <li>
    <a href="https://github.com/mfbolus/ldsctrlest" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/ldsctrlest/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>ldsCtrlEst_h/lds_fit_em.h</strong>

  <label for="toc-control">
    
    <img src="/ldsctrlest/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#ldsctrlest_hlds_fit_emh">ldsCtrlEst_h/lds_fit_em.h</a>
      <ul>
        <li><a href="#namespaces">Namespaces</a></li>
        <li><a href="#classes">Classes</a></li>
        <li><a href="#detailed-description">Detailed Description</a></li>
        <li><a href="#source-code">Source code</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="ldsctrlest_hlds_fit_emh">
  ldsCtrlEst_h/lds_fit_em.h
  <a class="anchor" href="#ldsctrlest_hlds_fit_emh">#</a>
</h1>
<p>subspace identification  <a href="#detailed-description">More&hellip;</a></p>
<h2 id="namespaces">
  Namespaces
  <a class="anchor" href="#namespaces">#</a>
</h2>
<table>
<thead>
<tr>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="/ldsctrlest/docs/api/namespaces/namespacelds/">lds</a></strong> <br>Linear Dynamical Systems (LDS) namespace.</td>
</tr>
</tbody>
</table>
<h2 id="classes">
  Classes
  <a class="anchor" href="#classes">#</a>
</h2>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td><strong><a href="/ldsctrlest/docs/api/classes/classlds_1_1_e_m/">lds::EM</a></strong></td>
</tr>
</tbody>
</table>
<h2 id="detailed-description">
  Detailed Description
  <a class="anchor" href="#detailed-description">#</a>
</h2>
<p>This file declares the type for fitting a linear dynamical system by expectation-maximization (<a href="/ldsctrlest/docs/api/classes/classlds_1_1_e_m/">lds::EM</a>).</p>
<h2 id="source-code">
  Source code
  <a class="anchor" href="#source-code">#</a>
</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">//===-- ldsCtrlEst_h/lds_fit_em.h - EM Fit ----------------------*- C++ -*-===//
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// Copyright 2021 Georgia Institute of Technology
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
</span><span style="color:#75715e">// you may not use this file except in compliance with the License.
</span><span style="color:#75715e">// You may obtain a copy of the License at
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//     http://www.apache.org/licenses/LICENSE-2.0
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// Unless required by applicable law or agreed to in writing, software
</span><span style="color:#75715e">// distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
</span><span style="color:#75715e">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span><span style="color:#75715e">// See the License for the specific language governing permissions and
</span><span style="color:#75715e">// limitations under the License.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//===----------------------------------------------------------------------===//
</span><span style="color:#75715e">//===----------------------------------------------------------------------===//
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#ifndef LDSCTRLEST_LDS_EMAX_H
</span><span style="color:#75715e">#define LDSCTRLEST_LDS_EMAX_H
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;lds_fit.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">namespace</span> lds {

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EM</span> {
  <span style="color:#66d9ef">static_assert</span>(std<span style="color:#f92672">::</span>is_base_of<span style="color:#f92672">&lt;</span>lds<span style="color:#f92672">::</span>Fit, Fit<span style="color:#f92672">&gt;::</span>value,
                <span style="color:#e6db74">&#34;Fit must be derived from lds::Fit type.&#34;</span>);

 <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  EM() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;

  EM(size_t n_x, data_t dt, UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> u_train,
       UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> z_train);

  EM(<span style="color:#66d9ef">const</span> Fit<span style="color:#f92672">&amp;</span> fit0, UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> u_train,
       UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> z_train);

  <span style="color:#66d9ef">const</span> Fit<span style="color:#f92672">&amp;</span> Run(<span style="color:#66d9ef">bool</span> calc_dynamics <span style="color:#f92672">=</span> true, <span style="color:#66d9ef">bool</span> calc_Q <span style="color:#f92672">=</span> true,
                 <span style="color:#66d9ef">bool</span> calc_init <span style="color:#f92672">=</span> true, <span style="color:#66d9ef">bool</span> calc_output <span style="color:#f92672">=</span> true,
                 <span style="color:#66d9ef">bool</span> calc_measurement <span style="color:#f92672">=</span> true, size_t max_iter <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>,
                 data_t tol <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-2</span>);

  std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span>UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span>, UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&gt;</span>
  ReturnData() {
    <span style="color:#66d9ef">auto</span> tuple <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_tuple(std<span style="color:#f92672">::</span>move(u_), std<span style="color:#f92672">::</span>move(z_));
    <span style="color:#75715e">// auto tuple = std::make_tuple(u_, z_);
</span><span style="color:#75715e"></span>    u_ <span style="color:#f92672">=</span> UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span>();
    z_ <span style="color:#f92672">=</span> UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span>();
    <span style="color:#66d9ef">return</span> tuple;
  }

  <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;&amp;</span> x() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> x_; };
  <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;&amp;</span> y() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> y_; };

  <span style="color:#66d9ef">const</span> Matrix<span style="color:#f92672">&amp;</span> sum_E_x_t_x_t() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> sum_E_x_t_x_t_; };
  <span style="color:#66d9ef">const</span> Matrix<span style="color:#f92672">&amp;</span> sum_E_xu_tm1_xu_tm1() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> sum_E_xu_tm1_xu_tm1_; };
  <span style="color:#66d9ef">const</span> Matrix<span style="color:#f92672">&amp;</span> sum_E_xu_t_xu_tm1() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> sum_E_xu_t_xu_tm1_; };
  size_t <span style="color:#a6e22e">n_t_tot</span>() { <span style="color:#66d9ef">return</span> n_t_tot_; }

  <span style="color:#66d9ef">const</span> Vector<span style="color:#f92672">&amp;</span> theta() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> theta_; };

 <span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">void</span> Expectation(<span style="color:#66d9ef">bool</span> force_common_initial <span style="color:#f92672">=</span> false);

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Maximization</span>(<span style="color:#66d9ef">bool</span> calc_dynamics <span style="color:#f92672">=</span> true, <span style="color:#66d9ef">bool</span> calc_Q <span style="color:#f92672">=</span> true,
                    <span style="color:#66d9ef">bool</span> calc_init <span style="color:#f92672">=</span> false, <span style="color:#66d9ef">bool</span> calc_output <span style="color:#f92672">=</span> false,
                    <span style="color:#66d9ef">bool</span> calc_measurement <span style="color:#f92672">=</span> false);

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeDynamics</span>();
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeQ</span>();
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeInitial</span>();
  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeOutput</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MaximizeMeasurement</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Smooth</span>(<span style="color:#66d9ef">bool</span> force_common_initial);

  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">RecurseKe</span>(Matrix<span style="color:#f92672">&amp;</span> Ke, Cube<span style="color:#f92672">&amp;</span> P_pre, Cube<span style="color:#f92672">&amp;</span> P_post, size_t t) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Reset</span>();

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitVars</span>();

  Vector <span style="color:#a6e22e">UpdateTheta</span>();

  <span style="color:#75715e">// input/output training data
</span><span style="color:#75715e"></span>  UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span> u_;  
  UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;</span> z_;  
  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;</span> x_;              
  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Cube<span style="color:#f92672">&gt;</span> P_;                
  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Cube<span style="color:#f92672">&gt;</span> P_t_tm1_;          
  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;</span> y_;              
  Matrix diag_y_;

  <span style="color:#75715e">// expectations calculated in E-step
</span><span style="color:#75715e"></span>  Matrix sum_E_x_t_x_t_;        
  Matrix sum_E_xu_tm1_xu_tm1_;  
  Matrix sum_E_xu_t_xu_tm1_;    

  Fit fit_;
  Vector theta_;

  data_t dt_{};              
  size_t n_u_{};             
  size_t n_x_{};             
  size_t n_y_{};             
  size_t n_trials_{};        
  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> n_t_;  
  size_t n_t_tot_{};         
};

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>EM(size_t n_x, data_t dt,
                UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> u_train,
                UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> z_train) {
  n_u_ <span style="color:#f92672">=</span> u_train.at(<span style="color:#ae81ff">0</span>).n_rows;
  n_y_ <span style="color:#f92672">=</span> z_train.at(<span style="color:#ae81ff">0</span>).n_rows;
  fit_ <span style="color:#f92672">=</span> Fit(n_u_, n_x, n_y_, dt);
  u_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(u_train);
  z_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(z_train);
  InitVars();
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>EM(<span style="color:#66d9ef">const</span> Fit<span style="color:#f92672">&amp;</span> fit0, UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> u_train,
                UniformMatrixList<span style="color:#f92672">&lt;</span>kMatFreeDim2<span style="color:#f92672">&gt;&amp;&amp;</span> z_train) {
  <span style="color:#75715e">// make sure fit dims match I/O data
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (fit0.n_u() <span style="color:#f92672">!=</span> u_train.at(<span style="color:#ae81ff">0</span>).n_rows) {
    <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(
        <span style="color:#e6db74">&#34;Initial fit and input training data have inconsistent dimensions&#34;</span>);
  }
  <span style="color:#66d9ef">if</span> (fit0.n_y() <span style="color:#f92672">!=</span> z_train.at(<span style="color:#ae81ff">0</span>).n_rows) {
    <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(
        <span style="color:#e6db74">&#34;Initial fit and output training data have inconsistent dimensions&#34;</span>);
  }

  fit_ <span style="color:#f92672">=</span> fit0;
  u_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(u_train);
  z_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(z_train);

  InitVars();
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>InitVars() {
  <span style="color:#75715e">// check input/output data dimensions are consistent
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (z_.size() <span style="color:#f92672">!=</span> u_.size()) {
    <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(
        <span style="color:#e6db74">&#34;I/O training data have different number of trials.&#34;</span>);
  }
  n_trials_ <span style="color:#f92672">=</span> u_.size();

  n_t_tot_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  n_t_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span>(n_trials_);
  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> n_trials_; trial<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (z_.at(trial).n_cols <span style="color:#f92672">!=</span> u_.at(trial).n_cols) {
      <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>runtime_error(
          <span style="color:#e6db74">&#34;I/O training data have different number of time steps.&#34;</span>);
    }
    n_t_[trial] <span style="color:#f92672">=</span> u_.at(trial).n_cols;
    n_t_tot_ <span style="color:#f92672">+=</span> n_t_[trial];
  }

  n_u_ <span style="color:#f92672">=</span> fit_.n_u();
  n_x_ <span style="color:#f92672">=</span> fit_.n_x();
  n_y_ <span style="color:#f92672">=</span> fit_.n_y();
  dt_ <span style="color:#f92672">=</span> fit_.dt();

  x_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;</span>(n_trials_);
  P_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Cube<span style="color:#f92672">&gt;</span>(n_trials_);
  P_t_tm1_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Cube<span style="color:#f92672">&gt;</span>(n_trials_);
  y_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Matrix<span style="color:#f92672">&gt;</span>(n_trials_);
  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> n_trials_; trial<span style="color:#f92672">++</span>) {
    x_[trial] <span style="color:#f92672">=</span> Matrix(n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
    P_[trial] <span style="color:#f92672">=</span> Cube(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
    P_t_tm1_[trial] <span style="color:#f92672">=</span> Cube(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
    y_[trial] <span style="color:#f92672">=</span> Matrix(n_y_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
  }

  diag_y_ <span style="color:#f92672">=</span> Matrix(n_y_, n_y_, fill<span style="color:#f92672">::</span>zeros);

  <span style="color:#75715e">// covariances in expectation step
</span><span style="color:#75715e"></span>  sum_E_x_t_x_t_ <span style="color:#f92672">=</span> Matrix(n_x_, n_x_, fill<span style="color:#f92672">::</span>zeros);
  sum_E_xu_tm1_xu_tm1_ <span style="color:#f92672">=</span> Matrix(n_x_ <span style="color:#f92672">+</span> n_u_, n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
  sum_E_xu_t_xu_tm1_ <span style="color:#f92672">=</span> Matrix(n_x_ <span style="color:#f92672">+</span> n_u_, n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">const</span> Fit<span style="color:#f92672">&amp;</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Run(<span style="color:#66d9ef">bool</span> calc_dynamics, <span style="color:#66d9ef">bool</span> calc_Q, <span style="color:#66d9ef">bool</span> calc_init,
                          <span style="color:#66d9ef">bool</span> calc_output, <span style="color:#66d9ef">bool</span> calc_measurement,
                          size_t max_iter, data_t tol) {
  Reset();  <span style="color:#75715e">// to initial conditions
</span><span style="color:#75715e"></span>
  size_t n_params <span style="color:#f92672">=</span>
      <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_u_ <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_y_;
  Vector <span style="color:#a6e22e">theta</span>(n_params);
  Vector <span style="color:#a6e22e">theta_new</span>(n_params);
  data_t max_dtheta <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

  <span style="color:#75715e">// if solving for initial conditions, allow them be varied.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// otherwise, freeze at provided values.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> force_common_initial <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>calc_init;

  <span style="color:#75715e">// go until parameter convergence
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (size_t l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; l <span style="color:#f92672">&lt;</span> max_iter; l<span style="color:#f92672">++</span>) {
    theta_ <span style="color:#f92672">=</span> UpdateTheta();

    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Iteration &#34;</span> <span style="color:#f92672">&lt;&lt;</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;/&#34;</span> <span style="color:#f92672">&lt;&lt;</span> max_iter <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; ...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;

    Expectation(force_common_initial);
    Maximization(calc_dynamics, calc_Q, calc_init, calc_output,
                 calc_measurement);

    <span style="color:#75715e">// check convergence
</span><span style="color:#75715e"></span>    theta_new <span style="color:#f92672">=</span> UpdateTheta();

    Vector dtheta <span style="color:#f92672">=</span> abs(theta_new <span style="color:#f92672">-</span> theta_) <span style="color:#f92672">/</span> abs(theta_);
    <span style="color:#75715e">// some parameters could be zero...
</span><span style="color:#75715e"></span>    arma<span style="color:#f92672">::</span>uvec ubi_finite <span style="color:#f92672">=</span> find_finite(dtheta);

    max_dtheta <span style="color:#f92672">=</span> max(dtheta.elem(ubi_finite));
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;max dtheta: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> max_dtheta <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">if</span> (max_dtheta <span style="color:#f92672">&lt;</span> tol) {
      std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Converged.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
      <span style="color:#66d9ef">break</span>;
    }

    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
  }

  <span style="color:#66d9ef">return</span> fit_;
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Smooth(<span style="color:#66d9ef">bool</span> force_common_initial) {
  Matrix <span style="color:#a6e22e">k_e</span>(n_x_, n_y_);  <span style="color:#75715e">// estimator gain
</span><span style="color:#75715e"></span>  Cube k_backfilt;         <span style="color:#75715e">// back-filtering gains
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// TODO(mfbolus): this loop could be made parallel
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
    Matrix <span style="color:#a6e22e">x_pre</span>(n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
    Cube <span style="color:#a6e22e">p_pre</span>(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
    Matrix <span style="color:#a6e22e">x_post</span>(n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
    Cube <span style="color:#a6e22e">p_post</span>(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);

    <span style="color:#66d9ef">if</span> (force_common_initial)  <span style="color:#75715e">// forces all trials to have same initial
</span><span style="color:#75715e"></span>                               <span style="color:#75715e">// conditions.
</span><span style="color:#75715e"></span>    {
      x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.x0();
      P_[trial].slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.P0();
    }
    y_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.C() <span style="color:#f92672">*</span> x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> fit_.d();

    <span style="color:#75715e">// This *should not* be necessary but make sure P is symmetric.
</span><span style="color:#75715e"></span>    ForceSymPD(P_[trial].slice(<span style="color:#ae81ff">0</span>));

    x_pre.col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> x_[trial].col(<span style="color:#ae81ff">0</span>);
    p_pre.slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> P_[trial].slice(<span style="color:#ae81ff">0</span>);

    x_post.col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> x_[trial].col(<span style="color:#ae81ff">0</span>);
    p_post.slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> P_[trial].slice(<span style="color:#ae81ff">0</span>);

    <span style="color:#75715e">// filter
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
      <span style="color:#75715e">// predict
</span><span style="color:#75715e"></span>      fit_.f(x_pre, x_post, u_.at(trial), t);
      fit_.h(y_[trial], x_pre, t);
      diag_y_.diag() <span style="color:#f92672">=</span> y_[trial].col(t);  <span style="color:#75715e">// TODO(mfbolus): change if parallel
</span><span style="color:#75715e"></span>
      <span style="color:#75715e">// update --&gt; posterior estimation
</span><span style="color:#75715e"></span>      RecurseKe(k_e, p_pre, p_post, t);
      x_post.col(t) <span style="color:#f92672">=</span>
          x_pre.col(t) <span style="color:#f92672">+</span> k_e <span style="color:#f92672">*</span> (z_.at(trial).col(t) <span style="color:#f92672">-</span> y_[trial].col(t));
      y_[trial].col(t) <span style="color:#f92672">=</span> fit_.C() <span style="color:#f92672">*</span> x_post.col(t) <span style="color:#f92672">+</span> fit_.d();
    }
    ForceSymPD(P_[trial].slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));

    <span style="color:#75715e">// backfilter -&gt; Smoothed estimate
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Reference:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Shumway et Stoffer (1982)
</span><span style="color:#75715e"></span>    k_backfilt <span style="color:#f92672">=</span> Cube(n_x_, n_x_, n_t_[trial], fill<span style="color:#f92672">::</span>zeros);
    x_[trial].col(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> x_post.col(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    P_[trial].slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> p_post.slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> (n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); t <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; t<span style="color:#f92672">--</span>) {
      k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
          p_post.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> fit_.A().t() <span style="color:#f92672">*</span> inv_sympd(p_pre.slice(t));
      x_[trial].col(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
          x_post.col(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span>
          k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> (x_[trial].col(t) <span style="color:#f92672">-</span> x_pre.col(t));
      P_[trial].slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
          p_post.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span>
                                    (P_[trial].slice(t) <span style="color:#f92672">-</span> p_pre.slice(t)) <span style="color:#f92672">*</span>
                                    k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>).t();
    }

    <span style="color:#75715e">// do the same for P_t_tm1
</span><span style="color:#75715e"></span>    Matrix <span style="color:#a6e22e">id</span>(n_x_, n_x_, fill<span style="color:#f92672">::</span>eye);
    P_t_tm1_[trial].slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
        (id <span style="color:#f92672">-</span> k_e <span style="color:#f92672">*</span> fit_.C()) <span style="color:#f92672">*</span> fit_.A() <span style="color:#f92672">*</span> p_post.slice(n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> (n_t_[trial] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>); t <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>; t<span style="color:#f92672">--</span>) {
      P_t_tm1_[trial].slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>
          p_post.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>).t() <span style="color:#f92672">+</span>
          k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span>
              (P_t_tm1_[trial].slice(t) <span style="color:#f92672">-</span> fit_.A() <span style="color:#f92672">*</span> p_post.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">*</span>
              k_backfilt.slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>).t();
    }

    <span style="color:#75715e">// finally, get smoothed estimate of output
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
      fit_.h(y_[trial], x_[trial], t);
    }  <span style="color:#75715e">// samps loop
</span><span style="color:#75715e"></span>  }    <span style="color:#75715e">// trial loop
</span><span style="color:#75715e"></span>}  <span style="color:#75715e">// Smooth
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// template &lt;typename Fit&gt;
</span><span style="color:#75715e">// void EM&lt;Fit&gt;::RecurseKe(Matrix&amp; Ke, Cube&amp; P_pre, Cube&amp; P_post, size_t t) {
</span><span style="color:#75715e">//   // predict covar
</span><span style="color:#75715e">//   P_pre.slice(t) = fit_.A() * P_post.slice(t - 1) * fit_.A().t() + fit_.Q();
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//   // update Ke
</span><span style="color:#75715e">//   Ke = P_pre.slice(t) * fit_.C().t() *
</span><span style="color:#75715e">//        inv_sympd(fit_.C() * P_pre.slice(t) * fit_.C().t() + fit_.R());
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//   // update cov
</span><span style="color:#75715e">//   // Reference: Ghahramani et Hinton (1996)
</span><span style="color:#75715e">//   P_post.slice(t) = P_pre.slice(t) - Ke * fit_.C() * P_pre.slice(t);
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//   // // n.b. for poisson :
</span><span style="color:#75715e">//   // P_pre.slice(t) = fit_.A() * P_post.slice(t - 1) * fit_.A().t() +
</span><span style="color:#75715e">//   fit_.Q();
</span><span style="color:#75715e">//   // // update cov
</span><span style="color:#75715e">//   // P_post.slice(t) = pinv(pinv(P_pre.slice(t)) + fit_.C().t() * diag_y_ *
</span><span style="color:#75715e">//   // fit_.C());
</span><span style="color:#75715e">//   // // update Ke
</span><span style="color:#75715e">//   // Ke = P_post.slice(t) * fit_.C();
</span><span style="color:#75715e">// }
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Expectation(<span style="color:#66d9ef">bool</span> force_common_initial) {
  <span style="color:#75715e">// calculate the mean/cov of state needed for maximizing E[pr(z|theta)]
</span><span style="color:#75715e"></span>  Smooth(force_common_initial);

  <span style="color:#75715e">// now get the various forms of sum(E[xx&#39;]) needed
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// n.b. Going to start at t=1 rather than 0 bc most max terms need that.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// so really &#34;n_t_tot_&#34; is (n_t_tot_-1)
</span><span style="color:#75715e"></span>  n_t_tot_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  sum_E_x_t_x_t_ <span style="color:#f92672">=</span> Matrix(n_x_, n_x_, fill<span style="color:#f92672">::</span>zeros);
  sum_E_xu_tm1_xu_tm1_ <span style="color:#f92672">=</span> Matrix(n_x_ <span style="color:#f92672">+</span> n_u_, n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
  sum_E_xu_t_xu_tm1_ <span style="color:#f92672">=</span> Matrix(n_x_ <span style="color:#f92672">+</span> n_u_, n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);

  Vector <span style="color:#a6e22e">xu_tm1</span>(n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);
  Vector <span style="color:#a6e22e">xu_t</span>(n_x_ <span style="color:#f92672">+</span> n_u_, fill<span style="color:#f92672">::</span>zeros);

  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
      <span style="color:#75715e">// ------------ sum_E_x_t_x_t ------------
</span><span style="color:#75715e"></span>      sum_E_x_t_x_t_ <span style="color:#f92672">+=</span> x_[trial].col(t) <span style="color:#f92672">*</span> x_[trial].col(t).t();
      sum_E_x_t_x_t_ <span style="color:#f92672">+=</span> P_[trial].slice(t);

      <span style="color:#75715e">// ------------ sum_E_xu_tm1_xu_tm1 ------------
</span><span style="color:#75715e"></span>      xu_tm1 <span style="color:#f92672">=</span> join_vert(x_[trial].col(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), u_.at(trial).col(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
      sum_E_xu_tm1_xu_tm1_ <span style="color:#f92672">+=</span> xu_tm1 <span style="color:#f92672">*</span> xu_tm1.t();
      sum_E_xu_tm1_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+=</span>
          P_[trial].slice(t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);

      <span style="color:#75715e">// ------------ sum_E_xu_t_xu_tm1 ------------
</span><span style="color:#75715e"></span>      xu_t <span style="color:#f92672">=</span> join_vert(x_[trial].col(t), u_.at(trial).col(t));
      sum_E_xu_t_xu_tm1_ <span style="color:#f92672">+=</span> xu_t <span style="color:#f92672">*</span> xu_tm1.t();
      sum_E_xu_t_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+=</span>
          P_t_tm1_[trial].slice(t);

      n_t_tot_ <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
    }  <span style="color:#75715e">// time
</span><span style="color:#75715e"></span>  }    <span style="color:#75715e">// trial
</span><span style="color:#75715e"></span>}  <span style="color:#75715e">// Expectation
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Maximization(<span style="color:#66d9ef">bool</span> calc_dynamics, <span style="color:#66d9ef">bool</span> calc_Q, <span style="color:#66d9ef">bool</span> calc_init,
                             <span style="color:#66d9ef">bool</span> calc_output, <span style="color:#66d9ef">bool</span> calc_measurement) {
  <span style="color:#66d9ef">if</span> (calc_output) {
    MaximizeOutput();
  }

  <span style="color:#66d9ef">if</span> (calc_measurement) {
    MaximizeMeasurement();
  }

  <span style="color:#66d9ef">if</span> (calc_dynamics) {
    MaximizeDynamics();
  }

  <span style="color:#66d9ef">if</span> (calc_Q) {
    MaximizeQ();
  }

  <span style="color:#66d9ef">if</span> (calc_init) {
    MaximizeInitial();
  }
}  <span style="color:#75715e">// Maximization
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeDynamics() {
  <span style="color:#75715e">// Shumway, Stoffer (1982); Ghahgramani, Hinton (1996)
</span><span style="color:#75715e"></span>  Matrix ab <span style="color:#f92672">=</span> sum_E_xu_t_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span>
              inv_sympd(sum_E_xu_tm1_xu_tm1_);
  fit_.set_A(ab.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
  fit_.set_B(ab.submat(<span style="color:#ae81ff">0</span>, n_x_, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.A()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.B()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeQ() {
  <span style="color:#75715e">// // Shumway, Stoffer (1982); Ghahgramani, Hinton (1996)
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// View sum_e_x_t_xu_tm1 =
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//     sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1);
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Matrix q = sum_E_x_t_x_t_ - sum_e_x_t_xu_tm1 *
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//                                inv_sympd(sum_E_xu_tm1_xu_tm1_) *
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//                                sum_e_x_t_xu_tm1.t();
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// q /= n_t_tot_;
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// this way is same as above iff dynamics were just updated:
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// View sum_e_x_t_xu_tm1 =
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//     sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1);
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Matrix ab = arma::join_horiz(fit_.A(), fit_.B());
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Matrix q = sum_E_x_t_x_t_ - ab * sum_e_x_t_xu_tm1.t();
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// q /= n_t_tot_;
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// From scratch method:
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Q is covariance of the error between state and dynamics-predicted state
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// (aka process noise)
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Q* = E[(x_t - Ax_{t-1} - Bu_{t-1})*(x_t - Ax_{t-1} - Bu_{t-1})&#39;]
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// t-1 terms:
</span><span style="color:#75715e"></span>  View sum_e_x_tm1_x_tm1 <span style="color:#f92672">=</span>
      sum_E_xu_tm1_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
  View sum_e_u_tm1_u_tm1 <span style="color:#f92672">=</span>
      sum_E_xu_tm1_xu_tm1_.submat(n_x_, n_x_, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
  View sum_e_x_tm1_u_tm1 <span style="color:#f92672">=</span>
      sum_E_xu_tm1_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, n_x_, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);

  <span style="color:#75715e">// t, t-1 terms:
</span><span style="color:#75715e"></span>  View sum_e_x_t_x_tm1 <span style="color:#f92672">=</span> sum_E_xu_t_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
  View sum_e_x_t_u_tm1 <span style="color:#f92672">=</span>
      sum_E_xu_t_xu_tm1_.submat(<span style="color:#ae81ff">0</span>, n_x_, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);

  Matrix q <span style="color:#f92672">=</span> sum_E_x_t_x_t_;
  q <span style="color:#f92672">+=</span> fit_.A() <span style="color:#f92672">*</span> sum_e_x_tm1_x_tm1 <span style="color:#f92672">*</span> fit_.A().t();
  q <span style="color:#f92672">-=</span> sum_e_x_t_x_tm1 <span style="color:#f92672">*</span> fit_.A().t();
  q <span style="color:#f92672">-=</span> fit_.A() <span style="color:#f92672">*</span> sum_e_x_t_x_tm1.t();
  <span style="color:#75715e">// input-related terms:
</span><span style="color:#75715e"></span>  q <span style="color:#f92672">+=</span> fit_.B() <span style="color:#f92672">*</span> sum_e_u_tm1_u_tm1 <span style="color:#f92672">*</span> fit_.B().t();
  q <span style="color:#f92672">-=</span> sum_e_x_t_u_tm1 <span style="color:#f92672">*</span> fit_.B().t();
  q <span style="color:#f92672">-=</span> fit_.B() <span style="color:#f92672">*</span> sum_e_x_t_u_tm1.t();
  q <span style="color:#f92672">+=</span> fit_.A() <span style="color:#f92672">*</span> sum_e_x_tm1_u_tm1 <span style="color:#f92672">*</span> fit_.B().t();
  q <span style="color:#f92672">+=</span> fit_.B() <span style="color:#f92672">*</span> sum_e_x_tm1_u_tm1.t() <span style="color:#f92672">*</span> fit_.A().t();
  q <span style="color:#f92672">/=</span> n_t_tot_;

  fit_.set_Q(q);
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Q_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.Q()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
  <span style="color:#75715e">// std::cout &lt;&lt; &#34;Q_new: \n&#34; &lt;&lt; fit_.Q() &lt;&lt; &#34;\n&#34;;
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeInitial() {
  Vector x0 <span style="color:#f92672">=</span> fit_.x0();
  x0.zeros();
  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
    x0 <span style="color:#f92672">+=</span> x_[trial].col(<span style="color:#ae81ff">0</span>);
  }
  x0 <span style="color:#f92672">/=</span> z_.size();
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;x0_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> x0[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;

  <span style="color:#75715e">// always recalc P0 even if the initial state is fixed (at zero, for
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// example)
</span><span style="color:#75715e"></span>  Matrix <span style="color:#a6e22e">e_var</span>(n_x_, n_x_, fill<span style="color:#f92672">::</span>zeros);
  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
    e_var <span style="color:#f92672">+=</span> (x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">-</span> x0) <span style="color:#f92672">*</span> (x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">-</span> x0).t();
  }
  e_var <span style="color:#f92672">/=</span> z_.size();

  <span style="color:#75715e">// go ahead and subtract x0*x0&#39; so don&#39;t have to below.
</span><span style="color:#75715e"></span>  e_var <span style="color:#f92672">-=</span> x0 <span style="color:#f92672">*</span> x0.t();

  <span style="color:#75715e">// To get P0, going to get initial P_ per trial and average.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// (which might be wrong, but need a single number)
</span><span style="color:#75715e"></span>  Matrix p0 <span style="color:#f92672">=</span> fit_.P0();
  p0.zeros();
  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
    p0 <span style="color:#f92672">+=</span>
        (x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">*</span> x_[trial].col(<span style="color:#ae81ff">0</span>).t()) <span style="color:#f92672">+</span> P_[trial].slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> e_var;
  }
  p0 <span style="color:#f92672">/=</span> z_.size();

  fit_.set_P0(p0);
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;P0_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.P0()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeOutput() {
  <span style="color:#75715e">// solve for C+d:
</span><span style="color:#75715e"></span>  Matrix <span style="color:#a6e22e">sum_zx</span>(n_y_, n_x_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, fill<span style="color:#f92672">::</span>zeros);
  Vector <span style="color:#a6e22e">x1</span>(n_x_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, fill<span style="color:#f92672">::</span>zeros);
  x1[n_x_] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;  <span style="color:#75715e">// augment with one to solve for bias
</span><span style="color:#75715e"></span>  Matrix <span style="color:#a6e22e">sum_e_x1_x1</span>(n_x_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, fill<span style="color:#f92672">::</span>zeros);
  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
      x1.subvec(<span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> x_[trial].col(t);
      sum_zx <span style="color:#f92672">+=</span> z_.at(trial).col(t) <span style="color:#f92672">*</span> x1.t();
      sum_e_x1_x1 <span style="color:#f92672">+=</span> x1 <span style="color:#f92672">*</span> x1.t();
      sum_e_x1_x1.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+=</span> P_[trial].slice(t);
    }
  }
  Matrix cd <span style="color:#f92672">=</span> sum_zx <span style="color:#f92672">*</span> inv_sympd(sum_e_x1_x1);
  fit_.set_C(cd.submat(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, n_y_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
  fit_.set_d(vectorise(cd.submat(<span style="color:#ae81ff">0</span>, n_x_, n_y_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_x_)));
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.C()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;d_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.d()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>MaximizeMeasurement() {
  <span style="color:#75715e">// Solve for measurement noise covar
</span><span style="color:#75715e"></span>  size_t n_t_tot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#75715e">// Ghahgramani, Hinton 1996:
</span><span style="color:#75715e"></span>  Matrix <span style="color:#a6e22e">sum_zz</span>(n_y_, n_y_, fill<span style="color:#f92672">::</span>zeros);
  Matrix <span style="color:#a6e22e">sum_yz</span>(n_y_, n_y_, fill<span style="color:#f92672">::</span>zeros);
  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> z_.size(); trial<span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">for</span> (size_t t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; t <span style="color:#f92672">&lt;</span> n_t_[trial]; t<span style="color:#f92672">++</span>) {
      sum_zz <span style="color:#f92672">+=</span> z_.at(trial).col(t) <span style="color:#f92672">*</span> z_.at(trial).col(t).t();
      <span style="color:#75715e">// Use Cnew:
</span><span style="color:#75715e"></span>      sum_yz <span style="color:#f92672">+=</span>
          (fit_.C() <span style="color:#f92672">*</span> x_[trial].col(t) <span style="color:#f92672">+</span> fit_.d()) <span style="color:#f92672">*</span> z_.at(trial).col(t).t();
      n_t_tot <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
    }
  }
  fit_.set_R((sum_zz <span style="color:#f92672">-</span> sum_yz) <span style="color:#f92672">/</span> n_t_tot);
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;R_new[0]: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> fit_.R()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>Reset() {
  <span style="color:#75715e">// reset to initial conditions
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (size_t trial <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; trial <span style="color:#f92672">&lt;</span> n_trials_; trial<span style="color:#f92672">++</span>) {
    x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.x0();
    P_[trial].slice(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.P0();
    y_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> fit_.C() <span style="color:#f92672">*</span> x_[trial].col(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> fit_.d();
  }
}

<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fit<span style="color:#f92672">&gt;</span>
Vector EM<span style="color:#f92672">&lt;</span>Fit<span style="color:#f92672">&gt;::</span>UpdateTheta() {
  <span style="color:#75715e">// TODO(mfbolus): This should include n_y_ more params for d.
</span><span style="color:#75715e"></span>  size_t n_params <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_u_ <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">+</span> n_y_;
  <span style="color:#66d9ef">if</span> (fit_.R().n_elem <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
    n_params <span style="color:#f92672">+=</span> n_y_ <span style="color:#f92672">*</span> n_y_;
  }
  Vector <span style="color:#a6e22e">theta</span>(n_params);

  size_t idx_start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.A());
  idx_start <span style="color:#f92672">+=</span> n_x_ <span style="color:#f92672">*</span> n_x_;
  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_u_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.B());
  idx_start <span style="color:#f92672">+=</span> n_x_ <span style="color:#f92672">*</span> n_u_;
  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.Q());
  idx_start <span style="color:#f92672">+=</span> n_x_ <span style="color:#f92672">*</span> n_x_;
  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.x0());
  idx_start <span style="color:#f92672">+=</span> n_x_;
  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_x_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.P0());
  idx_start <span style="color:#f92672">+=</span> n_x_ <span style="color:#f92672">*</span> n_x_;
  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_x_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.C());
  idx_start <span style="color:#f92672">+=</span> n_y_ <span style="color:#f92672">*</span> n_x_;
  theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.d());
  idx_start <span style="color:#f92672">+=</span> n_y_;
  <span style="color:#66d9ef">if</span> (fit_.R().n_elem <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
    theta.subvec(idx_start, idx_start <span style="color:#f92672">+</span> n_y_ <span style="color:#f92672">*</span> n_y_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> vectorise(fit_.R());
  }

  <span style="color:#66d9ef">return</span> theta;
}

}  <span style="color:#75715e">// namespace lds
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#endif
</span></code></pre></div><hr>
<p>Updated on 23 March 2021 at 09:14:15 CDT</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>

 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#ldsctrlest_hlds_fit_emh">ldsCtrlEst_h/lds_fit_em.h</a>
      <ul>
        <li><a href="#namespaces">Namespaces</a></li>
        <li><a href="#classes">Classes</a></li>
        <li><a href="#detailed-description">Detailed Description</a></li>
        <li><a href="#source-code">Source code</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>

</html>












