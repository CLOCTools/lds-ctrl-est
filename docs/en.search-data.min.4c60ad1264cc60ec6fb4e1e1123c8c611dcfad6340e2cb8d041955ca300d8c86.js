'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/ldsctrlest/docs/','title':"LDS C+E Documentation",'section':"LDS Control \u0026 Estimation",'content':"LDS Control \u0026amp; Estimation Documentation #  "});index.add({'id':1,'href':'/ldsctrlest/docs/tutorials/','title':"LDS C+E Examples",'section':"LDS C+E Documentation",'content':"Examples #  "});index.add({'id':2,'href':'/ldsctrlest/acknowledgements/','title':"Acknowledgements",'section':"LDS Control \u0026 Estimation",'content':"Acknowledgements #  Development and publication of this library was supported in part by the NIH/NINDS Collaborative Research in Computational Neuroscience (CRCNS)/BRAIN Grant 5R01NS115327-02.\n"});index.add({'id':3,'href':'/ldsctrlest/docs/getting-started/','title':"Getting Started",'section':"LDS C+E Documentation",'content':"Downloading the Library #  The source code for this library can be downloaded from stanley-rozell/ldsCtrlEst either by downloading a snapshot or cloning the repository via git.\ngit clone https://github.com/stanley-rozell/ldsCtrlEst.git By default, this would check out the master branch. In most cases, we suggest downloading or checking out the latest release instead.\ncd /path/to/ldsCtrlEst git checkout 0.5.0 Dependencies #  Note that the primary dependencies of this project listed below must be installed along with their header files and with CMake config files or pkg-config files. The latter files are used to configure this project\u0026rsquo;s build. It is strongly encouraged to install the dependencies below using a package manager (e.g., apt, pacman, macports).\n For project configuration, install cmake as well as pkg-config. The latter is optional. The linear algebra library armadillo is used throughout this repository. The HDF5 library is used to save output from example test programs. For use of this library in Matlab executables (mex) on Linux operating systems, you will need OpenBlas, ensuring the static library libopenblas.a is installed. You will also need to install gfortran.  Compilation + Installation #  This project is configured/compiled/installed by way of CMake and (on Unix-based operating systems) GNU Make. For configuration with CMake, there are three available options.\n LDSCTRLEST_BUILD_EXAMPLES : [default= ON] whether to build example programs located under examples/ in the source tree LDSCTRLEST_BUILD_FIT : [default=OFF] whether to build the auxiliary fitting portion of the source code that is not pertinent to control implementation LDSCTRLEST_BUILD_STATIC : [default=OFF] whether to statically link against OpenBLAS and create a static ldsCtrlEst library for future use  n.b., If both options 2 and 3 are enabled, Matlab/Octave mex functions will be compiled for exposing some of the fitting functionality to Matlab/Octave.\nBelow are example usages of cmake/make to configure/build the library.\n  For basic project build \u0026amp; install\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake .. #configure build make #build the project sudo make install #[optional] installs to default location (OS-specific)   To set the install prefix\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DCMAKE_INSTALL_PREFIX=/your/install/prefix .. #configure build with chosen install location make #build the project make install #install to /your/install/prefix   To build the entire project including fit code, a static library for Matlab compatibility, and the included Matlab mex functions for fitting GLDS/PLDS models.\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DLDSCTRLEST_BUILD_FIT=1 -DLDSCTRLEST_STATIC_OPENBLAS=1 .. #configure to build the fitting portion of library and statically link openblas and ldsCtrlEst to mex files make #build the project n.b., If you choose not to install the library or install it to the non-default location, ensure you have updated the following environment variables on Unix-based operating systems.\n LD_LIBRARY_PATH: search path for dynamically loaded libraries PKG_CONFIG_PATH: search path for pkg-config tool CMAKE_PREFIX_PATH: search path of prefix where CMake will look for package config files  e.g., Assuming you set -DCMAKE_INSTALL_PREFIX=/your/install/prefix during project configuration and your login shell uses the ~/.profile startup file, open ~/.profile in a text editor and add \u0026hellip;\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/your/install/prefix/lib export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix/lib/pkgconfig export CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix   Common issues #   \u0026ldquo;I have installed all the dependencies including gfortran with a package manager as suggested; however, cmake complains it cannot find the gfortran library.\u0026rdquo;  When gfortran is installed, its library is usually not installed in a standard location like /usr/lib. gfortran is part of the gcc suite, so their libraries are organized together. e.g., When you install gfortran on Ubuntu using apt, its location is /usr/lib/gcc/x86_64-linux-gnu/9, in the case that gcc version 9 is installed. The build configuration script in ldsCtrlEst is written to add LD_LIBRARY_PATH (Unix) or PATH (Windows) to the CMake library search path on Unix or Windows systems, respectively. Therefore, to fix this issue, simply add the directory in which libgfortran was installed to the OS-appropriate environment variable. Continuing with the Ubuntu example above and assuming a Unix login shell whose startup file is ~/.profile, add the following to the file.\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/gcc/x86_64-linux-gnu/9 \u0026ldquo;I have built the library and installed it in a non-default location. In building my own project linking against ldsCtrlEst, cmake or pkg-config cannot find the library or its configuration information.\u0026rdquo;  If cmake and/or pkg-config cannot find the required configuration files for your project to link against ldsCtrlEst, make sure that these utilities know to look for them in the non-default location where you installed the library. For cmake this means adding your chosen install prefix to the environment variable CMAKE_PREFIX_PATH. Similarly, for pkg-config you need to add your/install/prefix/lib/pkgconfig to its search path, PKG_CONFIG_PATH. Assuming a Unix shell whose login startup file is ~/.profile and ldsCtrlEst was installed using prefix your/install/prefix, add the following to .profile.\nexport CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix "});index.add({'id':4,'href':'/ldsctrlest/issues-contributing/','title':"Issues Contributing",'section':"LDS Control \u0026 Estimation",'content':"Reporting Issues #  If you encounter bugs when using this library or have specific feature requests that you believe fall within the stated scope of this project, please open an issue on GitHub and use an appropriate issue template where possible. You may also fork the repository and submit pull-requests with your suggested changes.\nContributing #  We welcome any community contributions to this project. Please fork the repository and if possible use clang-format and clang-tidy to conform to the coding format/style of this repository.\n"});index.add({'id':5,'href':'/ldsctrlest/docs/api/namespaces/namespacearma/','title':"arma",'section':"Namespaces",'content':"arma #   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':6,'href':'/ldsctrlest/docs/api/namespaces/namespacearmamexc/','title':"armamexc",'section':"Namespaces",'content':"armamexc #  arma/mex interface using Matlab C API More\u0026hellip; Functions #      Name     template \u0026lt;class T \u0026gt; auto m2T_scalar(const mxArray * matlab_scalar)\nConvert Matlab mxArray to scalar of type T.   template \u0026lt;class T \u0026gt; auto m2a_mat(const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true)\nConvert matlab matrix to armadillo.   auto a2m_mat(arma::Mat\u0026lt; double \u0026gt; const \u0026amp; arma_mat)\nConvert armadillo to matlab matrix.   auto a2m_vec(arma::Col\u0026lt; double \u0026gt; const \u0026amp; arma_vec)\nConvert armadillo to matlab vector.    Detailed Description #  Utilities for arma/mex interface using Matlab C API\nFunction Details #  m2T_scalar #  template \u0026lt;class T \u0026gt; inline auto m2T_scalar( const mxArray * matlab_scalar ) Parameters:\n matlab_scalar matlab scalar  Template Parameters:\n T type  Return: scalar of type T\nm2a_mat #  template \u0026lt;class T \u0026gt; inline auto m2a_mat( const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true ) Parameters:\n matlab_mat matlab matrix copy_aux_mem [optional] whether to copy auxiliary memory strict [optional] strictly enforce the above  Template Parameters:\n T type  Return: armadillo matrix of type T\na2m_mat #  inline auto a2m_mat( arma::Mat\u0026lt; double \u0026gt; const \u0026amp; arma_mat ) Parameters:\n arma_mat armadillo matrix  Return: matlab matrix\na2m_vec #  inline auto a2m_vec( arma::Col\u0026lt; double \u0026gt; const \u0026amp; arma_vec ) Parameters:\n arma_vec armadillo vector  Return: matlab vector\n Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':7,'href':'/ldsctrlest/docs/api/namespaces/namespacearmamexcpp/','title':"armamexcpp",'section':"Namespaces",'content':"armamexcpp #  arma/mex interface using Matlab C++ API More\u0026hellip; Functions #      Name     template \u0026lt;class T \u0026gt; auto m2a_cellmat(matlab::data::CellArray \u0026amp; matlab_cell)\nConvert matlab cell array to vector of armadillo matrices.   template \u0026lt;class T \u0026gt; auto m2s_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array)\nConvert matlab matrix to a vector of scalars.   template \u0026lt;class T \u0026gt; auto m2a_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo vector.   template \u0026lt;class T \u0026gt; auto m2a_mat(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo matrix.   template \u0026lt;class T \u0026gt; auto a2m_mat(arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab matrix.   template \u0026lt;class T \u0026gt; auto a2m_vec(arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab vector.   template \u0026lt;class T \u0026gt; auto s2m_vec(std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert vector of scalar T to matlab matrix.    Detailed Description #  utilities for arma/mex interface using Matlab C++ API\nFunction Details #  m2a_cellmat #  template \u0026lt;class T \u0026gt; auto m2a_cellmat( matlab::data::CellArray \u0026amp; matlab_cell ) Parameters:\n matlab_cell matlab cell  Template Parameters:\n T type  Return: vector of armadillo matrices of type T\nm2s_vec #  template \u0026lt;class T \u0026gt; auto m2s_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array ) Parameters:\n matlab_array matlab array  Template Parameters:\n T type  Return: vector of type T\nm2a_vec #  template \u0026lt;class T \u0026gt; auto m2a_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\n matlab_array matlab array  Template Parameters:\n T type  Return: armadillo vector of type T\nm2a_mat #  template \u0026lt;class T \u0026gt; auto m2a_mat( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\n matlab_array matlab matrix  Template Parameters:\n T type  Return: armadillo matrix of type T\na2m_mat #  template \u0026lt;class T \u0026gt; auto a2m_mat( arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n arma_mat arma matrix factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\na2m_vec #  template \u0026lt;class T \u0026gt; auto a2m_vec( arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n arma_vec armadillo vector factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\ns2m_vec #  template \u0026lt;class T \u0026gt; auto s2m_vec( std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n std_vec standard vector factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\n Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':8,'href':'/ldsctrlest/docs/api/files/dir_4fef79e7177ba769987a8da36c892c5f/','title':"build",'section':"Files",'content':"build #  Directories #     Name     include     Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':9,'href':'/ldsctrlest/docs/terminology/control-estimation/','title':"C\u0026E",'section':"LDS C+E Documentation",'content':"Control \u0026amp; Estimation #  The control system provided by this library is comprised of a state estimator and a controller. The estimator is responsible for estimating the latent state of the system, given measurements up to and including the current time (i.e., filtering). At each time step, the controller then uses the resulting state feedback and an internal model of the system to update the inputs to the process being manipulated.\nState estimation #  In general, the filtering performed to estimate the underlying state proceeds recursively by first using the model dynamics to predict the state change at the next time step, followed by updating this prediction when a new measurement is available. For a LDS, this two-step process can be summarized by   \\[\\widehat{\\mathbf{x}}_{t|t-1} = \\mathbf{A}\\widehat{\\mathbf{x}}_{t-1|t-1} \u0026#43; \\mathbf{B} u_{t-1} \u0026#43; \\mathbf{m}_{t-1} \\;,\\]   \\[\\widehat{\\mathbf{x}}_{t|t} = \\widehat{\\mathbf{x}}_{t|t-1} \u0026#43; \\mathbf{K}^{\\rm e}_t \\left(\\mathbf{z}_t - \\widehat{\\mathbf{y}}_{t|t-1}\\right)\\;,\\]  where  \\( \\hat{\\left(\\cdot\\right)}_{t|j} \\)  indicates an estimate at time  \\( t \\)  given data up to time  \\( j \\)  inclusive,  \\( \\mathbf{K}^{\\rm e} \\)  is the estimator gain, and\n \\[ \\widehat{\\mathbf{y}}_{t|t-1} = h\\left( \\widehat{\\mathbf{x}}_{t|t-1} \\right) \\; .\\]  In the case of GLDS models, the estimator gain (called Ke in library) is calculated recursively by Kalman filtering, which requires knowledge of the process noise and measurement noise covariances (Q, R) in addition to the system matrices. For time-invariant GLDS models, the infinite horizon solution is often used, so this gain need not be time-varying. Users may instead set its pre-determined value with the lds::gaussian::sys_t::setKe method and disable recursive gain calculation in the filter method.\nIn the case of PLDS models, there is a analogue of the Kalman filter developed for dynamical systems with point-process observations (Eden et al. 2004). This nonlinear filter recursively updates Ke at each time step and requires an estimate of the process noise covariance (Q) as well.\nAdaptive estimation of process disturbance #  Both the Kalman filter and point-process analogue are model-based; therefore, their performance can be sensitive to model mismatch, whether this be imperfect model fitting or true drifts in system behavior. A practical approach to improving robustness is parameter adaptation. To that end, this library provides dual state-parameter estimation. Specifically, an additive process disturbance (m) is adaptively re-estimated when the sys_t::adaptM property is set to true. This effectively provides integral action on minimizing state estimation error that could either be due to model mismatch or a true disturbance.\nWhen parameter adaptation is enabled, this process disturbance is assumed to vary stochastically on a random walk  \\[\\mathbf{m}_{t} = \\mathbf{m}_{t-1} \u0026#43; \\mathbf{w}^m_{t-1} \\;,\\]  where  \\( \\mathbf{w}^m \\sim \\mathcal{N}\\left(0, \\mathbf{Q}_m\\right)\\)  . Kalman filtering or the point-process analogue are then used to estimate this disturbance in parallel with the state.\nControl #  Given the estimated state, the controller updates the inputs to the system according to the following law:  \\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\]  where  \\( \\left( \\cdot \\right)^{\\rm ref} \\)  correspond to reference/target signals and  \\( \\mathbf{K}^c_x \\)  is the state feedback controller gain. Recall that these controller gains are assumed to have been designed before the experiment using, for example, LQR.\nIf users are employing integral action for more robust tracking at DC and did not use the approach of augmenting the state vector and system matrices accordingly, there is an option to include the integral term as\n \\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right) - \\mathbf{K}^c_{\\rm inty} \\sum_{j=1}^{t}\\left( \\widehat{\\mathbf{y}}_j - \\mathbf{y}^{\\rm ref}_j \\right) \\;.\\]  An additional option available to users is a control law that updates the change in u,\n \\[\\Delta\\mathbf{u}_{t} = \\Delta\\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\]   \\[\\mathbf{u}_{t} = \\mathbf{u}_{t-1} \u0026#43; \\Delta\\mathbf{u}_{t} \\; .\\]  This can be useful in cases where users have designed the controller gains by LQR to minimize not the amplitude of the input, but the change in input, by augmenting the state vector with the input during LQR design.\nIntegral action and the  \\( \\Delta \\mathbf{u} \\)  control law can be combined. The library keeps track of the controller type by way of bit masks which can be bit-wise OR\u0026rsquo;d to use in combination.\nCalculating reference state-control from output #  In cases where an output reference is supplied and the goal is to track either a static or slowly varying output, users do not have to produce  \\( \\mathbf{x}^{\\rm ref} \\)  and  \\( \\mathbf{u}^{\\rm ref} \\)  . Methods are provided for calculating the state and control that would be required to reach the reference output at steady state (ctrl_t::steadyState_fbCtrl). This is achieved by linearly-constrained least squares. For single-output systems, it results in an exact solution; however, for multi-output solutions it provides a least squares comprimise across outputs.\n"});index.add({'id':10,'href':'/ldsctrlest/docs/api/classes/','title':"Classes",'section':"LDS C+E Documentation",'content':"Classes #    lds::Controller\n  lds::Matrix\n  lds::SwitchedController SwitchedController Type.\n  lds::System Linear Dynamical System Type.\n  lds::Vector\n  lds::fit_t LDS Fit Type.\n  lds::gaussian::Controller Gaussian-observation Controller Type.\n  lds::gaussian::SwitchedController Gaussian-observation SwitchedController Type.\n  lds::gaussian::System Gaussian LDS Type.\n  lds::gaussian::emFit_t GLDS E-M Fit Type.\n  lds::gaussian::fit_t GLDS Fit Type.\n  lds::gaussian::ssidFit_t GLDS SSID Fit Type.\n  lds::poisson::Controller PLDS Controller Type.\n  lds::poisson::SwitchedController Poisson-observation SwitchedController Type.\n  lds::poisson::System Poisson System type.\n  lds::poisson::fit_t PLDS Fit Type.\n  lds::poisson::ssidFit_t GLDS SSID Fit Type.\n   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':11,'href':'/ldsctrlest/docs/api/modules/group__control__masks/','title':"Control Mode Bit Masks",'section':"Modules",'content':"Control Mode Bit Masks #  \nMore\u0026hellip; Attributes #      Name     const std::size_t kControlTypeDeltaU   const std::size_t kControlTypeIntY   const std::size_t kControlTypeAdaptM Control setpoint adapted with (re-estimated) process disturbance m.    Detailed Description #  Control mode bit masks. These can be bit-wise OR\u0026rsquo;d to use in combination.\nAttribute Details #  kControlTypeDeltaU #  static const std::size_t kControlTypeDeltaU = 0x1; Control was designed to penalize change in input (i.e., the state was augmented with input u)\nkControlTypeIntY #  static const std::size_t kControlTypeIntY = kControlTypeDeltaU \u0026lt;\u0026lt; 1; Control using integral action (i.e., the state was augmented with output y during design)\nkControlTypeAdaptM #  static const std::size_t kControlTypeAdaptM = kControlTypeDeltaU \u0026lt;\u0026lt; 2;  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':12,'href':'/ldsctrlest/docs/api/modules/group__defaults/','title':"Defaults",'section':"Modules",'content':"Defaults #  \nMore\u0026hellip; Attributes #      Name     const data_t kDefaultP0   const data_t kDefaultQ0   const data_t kDefaultR0   std::vector\u0026lt; data_t \u0026gt; kDefaultT0    Detailed Description #  Default values for common variables (e.g., default diagonal elements of covariances in case there is need to resolve dimension mismatch)\nAttribute Details #  kDefaultP0 #  static const data_t kDefaultP0 = 1e-6; kDefaultQ0 #  static const data_t kDefaultQ0 = 1e-6; kDefaultR0 #  static const data_t kDefaultR0 = 1e-2; kDefaultT0 #  static std::vector\u0026lt; data_t \u0026gt; kDefaultT0 = std::vector\u0026lt;data_t\u0026gt;(1, 0.0);  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':13,'href':'/ldsctrlest/docs/api/examples/eg_glds_ctrl_8cpp-example/','title':"eg_glds_ctrl.cpp",'section':"Examples",'content':"eg_glds_ctrl.cpp #  Example GLDS Control\n//===-- eg_glds_ctrl.cpp - Example GLDS Control ---------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS Control ********** \\n\\n\u0026#34;; // Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); // construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::System controlled_system(n_u, n_x, n_y, dt); // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); armaMat b_true = armaMat(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  armaVec g_true = armaVec(n_y).fill(10.0); // output noise covariance  armaMat r_true = armaMat(n_y, n_y, arma::fill::eye) * 1e-4; size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  armaVec m0_true = armaVec(n_y).fill(m_low); // Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_R(r_true); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // make a controller  lds::gaussian::Controller controller; { // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  armaMat b_controller = b_true / 2; // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  armaVec m_controller = armaVec(n_x, arma::fill::zeros); // for this demo, just use arbitrary default R  armaMat r_controller = armaMat(n_y, n_y, arma::fill::eye) * lds::kDefaultR0; lds::gaussian::System controller_system(controlled_system); controller_system.set_B(b_controller); controller_system.set_m(m_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m  // going to adaptively re-estimate the disturbance  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; controller_system.set_Q_m(q_m); // create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); } // Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y).fill(20.0 * dt); // (Can either use arma::Mat or mats flattened into std::vector)  armaMat k_x = armaMat(n_u, n_x).fill(100); // gains on state error  armaMat k_inty = armaMat(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  armaVec x0 = armaVec(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::kControlTypeAdaptM; } else { // use integral action to minimize DC error  control_type = control_type | lds::kControlTypeIntY; } // set controller type  controller.set_control_type(control_type); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  armaVec g_design = armaVec(n_u).fill(9); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_g_design(g_design); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // set up variables for simulation  // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // get initial val  y_hat.submat(0, 0, n_y - 1, 0) = controller.sys().y(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.y(); x_hat.submat(0, 0, n_x - 1, 0) = controller.sys().x(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.x(); m_hat.submat(0, 0, n_x - 1, 0) = controller.sys().m(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // input  armaVec u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  armaVec z_t(z.colptr(t), z.n_rows, false, true); z_t = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Therefore, it is only  // applicable to regulation problems or cases where reference trajectory  // changes slowly compared to system dynamics.  u.col(t) = controller.ControlOutputReference(z_t); // save the signals  y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; } Filename: eg_glds_ctrl.cpp\n Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':14,'href':'/ldsctrlest/docs/api/examples/eg_plds_ctrl_8cpp-example/','title':"eg_plds_ctrl.cpp",'section':"Examples",'content':"eg_plds_ctrl.cpp #  Example PLDS Control\n//===-- eg_plds_ctrl.cpp - Example PLDS Control ---------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; auto main(void) -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Control ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(10.0 / dt); // Control variables: _reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y, arma::fill::ones) * 30.0 * dt; armaMat k_x = armaMat(n_u, n_x, arma::fill::zeros) + 1; // gains on state error  armaMat k_inty = armaMat(n_u, n_y, arma::fill::zeros) + 10; // gains on integrated output err  // Set control type bit mask, so controller knows what to do  size_t control_type = lds::kControlTypeIntY; // integral action  // // uncomment to use control that was designed to minimize change in control  // // signal, rather than instantaneous amplitude  // control_type = control_type | lds::kControlTypeDeltaU;  // if (control_type \u0026amp; lds::kControlTypeDeltaU) {  // k_x *= dt*10;  // k_inty *= 0;  // }  // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = 0.986; armaMat b_true(n_x, n_u, arma::fill::zeros); b_true[0] = 0.054; armaVec x0_true = armaVec(n_x, arma::fill::ones) * log(1 * dt); size_t which_m = 0; data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; armaVec m0_true = armaVec(n_y, arma::fill::ones) * m_low; // construct ground truth system to be controlled...  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_x0(x0_true); // reset to initial conditions  controlled_system.Reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create the controller  lds::poisson::Controller controller; { // Create model used for control.  lds::poisson::System controller_system(controlled_system); // for this example, assume model correct, except disturbance  armaVec m0_controller = armaVec(n_y, arma::fill::ones) * m_low; armaVec x0_controller = arma::log(y_ref0); controller_system.set_m(m0_controller); controller_system.set_x0(x0_controller); controller_system.Reset(); //reset to new init condition  // adaptively re-estimate process disturbance (m)  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-5; controller_system.set_Q_m(q_m); data_t u_lb = 0.0; data_t u_ub = 5.0; controller = std::move( lds::poisson::Controller(std::move(controller_system), u_lb, u_ub)); } // set controller type  controller.set_control_type(control_type); // set controller gains  controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); // to protect against integral windup when output is consistently above  // target:  data_t tau_awu(0.1); controller.set_tau_awu(tau_awu); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::zeros); y_ref.each_col() += y_ref0; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // set initial val  y_hat.col(0) = controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = controller.sys().x(); x_true.col(0) = controlled_system.x(); m_hat.col(0) = controller.sys().m(); m_true.col(0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // e.g., use sinusoidal reference  data_t f = 0.5; // freq [=] Hz  armaVec t_vec = armaVec(n_y, arma::fill::ones) * t; y_ref.col(t) += y_ref0 % arma::sin(f * 2 * lds::kPi * dt * t_vec - lds::kPi / 4); // Simulate the true system.  z.col(t)=controlled_system.Simulate(u.col(t-1)); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Notably, it does this in the  // log-linear space (i.e., log(y)).  //  // Therefore, it is only applicable to regulation problems or cases where  // reference trajectory changes slowly compared to system dynamics.  controller.set_y_ref(y_ref.col(t)); u.col(t)=controller.ControlOutputReference(z.col(t)); y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } Filename: eg_plds_ctrl.cpp\n Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':15,'href':'/ldsctrlest/docs/api/examples/eg_plds_est_8cpp-example/','title':"eg_plds_est.cpp",'section':"Examples",'content':"eg_plds_est.cpp #  Example PLDS Estimation\n//===-- eg_plds_est.cpp - Example PLDS Estimation -------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; // for generating random input armaMat random_walk(size_t n_t, const arma::mat\u0026amp; Q, const arma::vec\u0026amp; x0); int main(void) { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Estimation ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation.  // construct ground truth system...  lds::poisson::System system_true(n_u, n_x, n_y, dt); // Model parameters  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); armaMat b_true = armaMat(n_x, n_u).fill(1e-2); armaVec m0_true = armaVec(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  armaVec x0_true = m0_true * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  // Assign params.  system_true.set_A(a_true); system_true.set_B(b_true); system_true.set_x0(x0_true); system_true.set_m(m0_true); system_true.Reset(); // Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::System system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  armaVec m0_est = m0_true * 2; system_estimator.set_m(m0_est); // set new initial conditions  armaVec x0_est = m0_est * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.set_x0(x0_est); system_estimator.Reset(); // reset to initial condition.  // turn on adaptive disturbance estimation  system_estimator.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.set_Q_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;estimator:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; system_estimator.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Set up simulation :  // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // Stimulus (generate random stimulus)  armaMat q_u = armaMat(n_u, n_u, arma::fill::eye) * 1e-3; // cov of random walk  armaMat u = random_walk(n_t, q_u, armaVec(n_u, arma::fill::zeros)); // create matrix to save outputs in...  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat y_true(n_y, n_t, arma::fill::zeros); // states and disturbance params  armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_x, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // initial conditions  y_hat.col(0) = system_estimator.y(); y_true.col(0) = system_true.y(); x_hat.col(0) = system_estimator.x(); x_true.col(0) = system_true.x(); m_hat.col(0) = system_estimator.m(); m_true.col(0) = system_true.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simlation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Simlate the true system.  z.col(t) = system_true.Simulate(u.col(t - 1)); // Filter (predict -\u0026gt; update)  system_estimator.Filter(u.col(t - 1), z.col(t)); // save signals  y_hat.col(t) = system_estimator.y(); y_true.col(t) = system_true.y(); x_true.col(t) = system_true.x(); m_true.col(t) = system_true.m(); x_hat.col(t) = system_estimator.x(); m_hat.col(t) = system_estimator.m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simlation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;dt\u0026#34;)); u.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } // for generating random input armaMat random_walk(size_t n_t, const arma::mat\u0026amp; Q, const arma::vec\u0026amp; x0) { size_t n = Q.n_rows; if ((n != Q.n_cols) || (Q.n_cols != Q.n_rows)) { throw std::logic_error(\u0026#34;Q must be `n` x `n`.\u0026#34;); } arma::mat x(n, n_t, arma::fill::zeros); x.col(0) = x0; for (size_t t = 1; t \u0026lt; n_t; t++) { x.col(t) = x.col(t - 1) + arma::mvnrnd(arma::vec(n, arma::fill::zeros), Q); } return x; } Filename: eg_plds_est.cpp\n Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':16,'href':'/ldsctrlest/docs/api/examples/eg_plds_switched_ctrl_8cpp-example/','title':"eg_plds_switched_ctrl.cpp",'section':"Examples",'content':"eg_plds_switched_ctrl.cpp #  Example Switched PLDS Control\n//===-- eg_plds_switched_ctrl.cpp - Example Switched PLDS Control ---===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Switched Poisson LDS Control ********** \\n\\n\u0026#34;; // whether to do switched control  bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); // for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1  // simulated system being controlled  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  armaMat a(n_x, n_x, arma::fill::eye); a[0] = 0.985; armaMat b1 = armaMat(n_x, n_u).fill(0.05); armaVec d = armaVec(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.set_A(a); controlled_system.set_B(b1); controlled_system.set_d(d); controlled_system.Reset(); // reset to initial conditions  // reference  armaVec y_ref0 = armaVec(n_y, arma::fill::zeros).fill(25.0 * dt); // Let underlying system 1 be more sensitive than system 2  data_t scale_sys_b = 2; armaMat b2 = armaMat(n_x, n_u).fill(b1[0] / scale_sys_b); // create switched controller  lds::poisson::SwitchedController switched_controller; std::vector\u0026lt;armaMat\u0026gt; k_x; { // create switched controller sub-systems  // system 1  lds::poisson::System sys1(controlled_system); // set process noise covariance  armaMat q_controller = armaMat(n_x, n_x, arma::fill::eye) * 5e-3; sys1.set_Q(q_controller); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  sys1.do_adapt_m = true; // setting initial mode to target to avoid large error at onset:  armaVec x0_controller = arma::log(y_ref0) - d; sys1.set_x0(x0_controller); sys1.Reset(); // reset to initial conditions  cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys1.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // system 2  lds::poisson::System sys2 = sys1; // set parameters  sys2.set_B(b2); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys2.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; std::vector\u0026lt;lds::poisson::System\u0026gt; systems(2, sys1); systems.at(1) = std::move(sys2); // controller gains for underlying system s:  armaMat k_x1(n_u, n_x, arma::fill::ones); armaMat k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  k_x = std::vector\u0026lt;armaMat\u0026gt;(2, k_x1); k_x.at(1) = std::move(k_x2); data_t u_lb = 0.0; data_t u_ub = 5.0; switched_controller = std::move( lds::poisson::SwitchedController(std::move(systems), u_lb, u_ub)); } // Control variables  size_t control_type = 0; // no integral action, etc.  switched_controller.set_control_type(control_type); switched_controller.set_Kc(std::move(k_x)); switched_controller.set_y_ref(y_ref0); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;switched_controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; switched_controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Fake measurements  armaMat z(n_y, n_t, arma::fill::zeros); // Will later contain control.  armaMat u(n_u, n_t, arma::fill::zeros); // create armaMatrix to save outputs in...  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat y_ref = armaMat(n_y, n_t).fill(y_ref0[0]); // modes and gain/disturbance params  armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat mode(1, n_t, arma::fill::ones); // set initial val  y_hat.col(0) = switched_controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = switched_controller.sys().x(); x_true.col(0) = controlled_system.x(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Let the controlled system stachastically change gain  // Assume another algorithm decodes this mode change and signals the  // switched_controller  //  armaVec chance(1, arma::fill::randu); if (which_mode == 1) // mode1  { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.set_B(b2); if (do_switch_ctrl) { switched_controller.Switch(1); } } } else { // mode2  if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.set_B(b1); if (do_switch_ctrl) { switched_controller.Switch(0); } } } // Simulate the true system.  z.col(t) = controlled_system.Simulate(u.col(t - 1)); // perform control  u.col(t) = switched_controller.ControlOutputReference(z.col(t)); mode.col(t) = which_mode; y_ref.col(t) = y_ref0; y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); y_hat.col(t) = switched_controller.sys().y(); x_hat.col(t) = switched_controller.sys().x(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); mode.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;mode\u0026#34;, replace)); return 0; } Filename: eg_plds_switched_ctrl.cpp\n Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':17,'href':'/ldsctrlest/docs/api/examples/','title':"Examples",'section':"LDS C+E Documentation",'content':"Examples #    eg_glds_ctrl.cpp Example GLDS Control.\n  eg_plds_ctrl.cpp Example PLDS Control.\n  eg_plds_est.cpp Example PLDS Estimation.\n  eg_plds_switched_ctrl.cpp Example Switched PLDS Control.\n   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':18,'href':'/ldsctrlest/docs/api/files/dir_d28a4824dc47e487b107a5db32ef43c4/','title':"examples",'section':"Files",'content':"examples #  Files #     Name     examples/eg_glds_ctrl.cpp   examples/eg_plds_ctrl.cpp   examples/eg_plds_est.cpp   examples/eg_plds_switched_ctrl.cpp     Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':19,'href':'/ldsctrlest/docs/api/files/eg__glds__ctrl_8cpp/','title':"examples/eg_glds_ctrl.cpp",'section':"Files",'content':"examples/eg_glds_ctrl.cpp #  Functions #      Name     auto main()    Function Details #  main #  auto main() Going to simulate a switching disturbance (m) acting on system\nSource code #  //===-- eg_glds_ctrl.cpp - Example GLDS Control ---------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS Control ********** \\n\\n\u0026#34;; // Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); // construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::System controlled_system(n_u, n_x, n_y, dt); // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); armaMat b_true = armaMat(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  armaVec g_true = armaVec(n_y).fill(10.0); // output noise covariance  armaMat r_true = armaMat(n_y, n_y, arma::fill::eye) * 1e-4; size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  armaVec m0_true = armaVec(n_y).fill(m_low); // Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_R(r_true); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // make a controller  lds::gaussian::Controller controller; { // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  armaMat b_controller = b_true / 2; // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  armaVec m_controller = armaVec(n_x, arma::fill::zeros); // for this demo, just use arbitrary default R  armaMat r_controller = armaMat(n_y, n_y, arma::fill::eye) * lds::kDefaultR0; lds::gaussian::System controller_system(controlled_system); controller_system.set_B(b_controller); controller_system.set_m(m_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m  // going to adaptively re-estimate the disturbance  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; controller_system.set_Q_m(q_m); // create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); } // Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y).fill(20.0 * dt); // (Can either use arma::Mat or mats flattened into std::vector)  armaMat k_x = armaMat(n_u, n_x).fill(100); // gains on state error  armaMat k_inty = armaMat(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  armaVec x0 = armaVec(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::kControlTypeAdaptM; } else { // use integral action to minimize DC error  control_type = control_type | lds::kControlTypeIntY; } // set controller type  controller.set_control_type(control_type); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  armaVec g_design = armaVec(n_u).fill(9); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_g_design(g_design); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // set up variables for simulation  // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // get initial val  y_hat.submat(0, 0, n_y - 1, 0) = controller.sys().y(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.y(); x_hat.submat(0, 0, n_x - 1, 0) = controller.sys().x(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.x(); m_hat.submat(0, 0, n_x - 1, 0) = controller.sys().m(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // input  armaVec u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  armaVec z_t(z.colptr(t), z.n_rows, false, true); z_t = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Therefore, it is only  // applicable to regulation problems or cases where reference trajectory  // changes slowly compared to system dynamics.  u.col(t) = controller.ControlOutputReference(z_t); // save the signals  y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; }  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':20,'href':'/ldsctrlest/docs/api/files/eg__plds__ctrl_8cpp/','title':"examples/eg_plds_ctrl.cpp",'section':"Files",'content':"examples/eg_plds_ctrl.cpp #  Functions #      Name     auto main(void )    Function Details #  main #  auto main( void ) Going to simulate a switching disturbance (m) acting on system\nSource code #  //===-- eg_plds_ctrl.cpp - Example PLDS Control ---------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; auto main(void) -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Control ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(10.0 / dt); // Control variables: _reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y, arma::fill::ones) * 30.0 * dt; armaMat k_x = armaMat(n_u, n_x, arma::fill::zeros) + 1; // gains on state error  armaMat k_inty = armaMat(n_u, n_y, arma::fill::zeros) + 10; // gains on integrated output err  // Set control type bit mask, so controller knows what to do  size_t control_type = lds::kControlTypeIntY; // integral action  // // uncomment to use control that was designed to minimize change in control  // // signal, rather than instantaneous amplitude  // control_type = control_type | lds::kControlTypeDeltaU;  // if (control_type \u0026amp; lds::kControlTypeDeltaU) {  // k_x *= dt*10;  // k_inty *= 0;  // }  // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = 0.986; armaMat b_true(n_x, n_u, arma::fill::zeros); b_true[0] = 0.054; armaVec x0_true = armaVec(n_x, arma::fill::ones) * log(1 * dt); size_t which_m = 0; data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; armaVec m0_true = armaVec(n_y, arma::fill::ones) * m_low; // construct ground truth system to be controlled...  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_x0(x0_true); // reset to initial conditions  controlled_system.Reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create the controller  lds::poisson::Controller controller; { // Create model used for control.  lds::poisson::System controller_system(controlled_system); // for this example, assume model correct, except disturbance  armaVec m0_controller = armaVec(n_y, arma::fill::ones) * m_low; armaVec x0_controller = arma::log(y_ref0); controller_system.set_m(m0_controller); controller_system.set_x0(x0_controller); controller_system.Reset(); //reset to new init condition  // adaptively re-estimate process disturbance (m)  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-5; controller_system.set_Q_m(q_m); data_t u_lb = 0.0; data_t u_ub = 5.0; controller = std::move( lds::poisson::Controller(std::move(controller_system), u_lb, u_ub)); } // set controller type  controller.set_control_type(control_type); // set controller gains  controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); // to protect against integral windup when output is consistently above  // target:  data_t tau_awu(0.1); controller.set_tau_awu(tau_awu); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::zeros); y_ref.each_col() += y_ref0; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // set initial val  y_hat.col(0) = controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = controller.sys().x(); x_true.col(0) = controlled_system.x(); m_hat.col(0) = controller.sys().m(); m_true.col(0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // e.g., use sinusoidal reference  data_t f = 0.5; // freq [=] Hz  armaVec t_vec = armaVec(n_y, arma::fill::ones) * t; y_ref.col(t) += y_ref0 % arma::sin(f * 2 * lds::kPi * dt * t_vec - lds::kPi / 4); // Simulate the true system.  z.col(t)=controlled_system.Simulate(u.col(t-1)); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Notably, it does this in the  // log-linear space (i.e., log(y)).  //  // Therefore, it is only applicable to regulation problems or cases where  // reference trajectory changes slowly compared to system dynamics.  controller.set_y_ref(y_ref.col(t)); u.col(t)=controller.ControlOutputReference(z.col(t)); y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; }  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':21,'href':'/ldsctrlest/docs/api/files/eg__plds__est_8cpp/','title':"examples/eg_plds_est.cpp",'section':"Files",'content':"examples/eg_plds_est.cpp #  Functions #      Name     armaMat random_walk(size_t n_t, const arma::mat \u0026amp; Q, const arma::vec \u0026amp; x0)   int main(void )    Function Details #  random_walk #  armaMat random_walk( size_t n_t, const arma::mat \u0026amp; Q, const arma::vec \u0026amp; x0 ) main #  int main( void ) Source code #  //===-- eg_plds_est.cpp - Example PLDS Estimation -------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; // for generating random input armaMat random_walk(size_t n_t, const arma::mat\u0026amp; Q, const arma::vec\u0026amp; x0); int main(void) { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Estimation ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation.  // construct ground truth system...  lds::poisson::System system_true(n_u, n_x, n_y, dt); // Model parameters  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); armaMat b_true = armaMat(n_x, n_u).fill(1e-2); armaVec m0_true = armaVec(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  armaVec x0_true = m0_true * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  // Assign params.  system_true.set_A(a_true); system_true.set_B(b_true); system_true.set_x0(x0_true); system_true.set_m(m0_true); system_true.Reset(); // Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::System system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  armaVec m0_est = m0_true * 2; system_estimator.set_m(m0_est); // set new initial conditions  armaVec x0_est = m0_est * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.set_x0(x0_est); system_estimator.Reset(); // reset to initial condition.  // turn on adaptive disturbance estimation  system_estimator.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.set_Q_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;estimator:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; system_estimator.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Set up simulation :  // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // Stimulus (generate random stimulus)  armaMat q_u = armaMat(n_u, n_u, arma::fill::eye) * 1e-3; // cov of random walk  armaMat u = random_walk(n_t, q_u, armaVec(n_u, arma::fill::zeros)); // create matrix to save outputs in...  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat y_true(n_y, n_t, arma::fill::zeros); // states and disturbance params  armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_x, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // initial conditions  y_hat.col(0) = system_estimator.y(); y_true.col(0) = system_true.y(); x_hat.col(0) = system_estimator.x(); x_true.col(0) = system_true.x(); m_hat.col(0) = system_estimator.m(); m_true.col(0) = system_true.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simlation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Simlate the true system.  z.col(t) = system_true.Simulate(u.col(t - 1)); // Filter (predict -\u0026gt; update)  system_estimator.Filter(u.col(t - 1), z.col(t)); // save signals  y_hat.col(t) = system_estimator.y(); y_true.col(t) = system_true.y(); x_true.col(t) = system_true.x(); m_true.col(t) = system_true.m(); x_hat.col(t) = system_estimator.x(); m_hat.col(t) = system_estimator.m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simlation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;dt\u0026#34;)); u.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } // for generating random input armaMat random_walk(size_t n_t, const arma::mat\u0026amp; Q, const arma::vec\u0026amp; x0) { size_t n = Q.n_rows; if ((n != Q.n_cols) || (Q.n_cols != Q.n_rows)) { throw std::logic_error(\u0026#34;Q must be `n` x `n`.\u0026#34;); } arma::mat x(n, n_t, arma::fill::zeros); x.col(0) = x0; for (size_t t = 1; t \u0026lt; n_t; t++) { x.col(t) = x.col(t - 1) + arma::mvnrnd(arma::vec(n, arma::fill::zeros), Q); } return x; }  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':22,'href':'/ldsctrlest/docs/api/files/eg__plds__switched__ctrl_8cpp/','title':"examples/eg_plds_switched_ctrl.cpp",'section':"Files",'content':"examples/eg_plds_switched_ctrl.cpp #  Functions #      Name     auto main()    Function Details #  main #  auto main() Source code #  //===-- eg_plds_switched_ctrl.cpp - Example Switched PLDS Control ---===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Switched Poisson LDS Control ********** \\n\\n\u0026#34;; // whether to do switched control  bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); // for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1  // simulated system being controlled  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  armaMat a(n_x, n_x, arma::fill::eye); a[0] = 0.985; armaMat b1 = armaMat(n_x, n_u).fill(0.05); armaVec d = armaVec(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.set_A(a); controlled_system.set_B(b1); controlled_system.set_d(d); controlled_system.Reset(); // reset to initial conditions  // reference  armaVec y_ref0 = armaVec(n_y, arma::fill::zeros).fill(25.0 * dt); // Let underlying system 1 be more sensitive than system 2  data_t scale_sys_b = 2; armaMat b2 = armaMat(n_x, n_u).fill(b1[0] / scale_sys_b); // create switched controller  lds::poisson::SwitchedController switched_controller; std::vector\u0026lt;armaMat\u0026gt; k_x; { // create switched controller sub-systems  // system 1  lds::poisson::System sys1(controlled_system); // set process noise covariance  armaMat q_controller = armaMat(n_x, n_x, arma::fill::eye) * 5e-3; sys1.set_Q(q_controller); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  sys1.do_adapt_m = true; // setting initial mode to target to avoid large error at onset:  armaVec x0_controller = arma::log(y_ref0) - d; sys1.set_x0(x0_controller); sys1.Reset(); // reset to initial conditions  cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys1.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // system 2  lds::poisson::System sys2 = sys1; // set parameters  sys2.set_B(b2); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys2.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; std::vector\u0026lt;lds::poisson::System\u0026gt; systems(2, sys1); systems.at(1) = std::move(sys2); // controller gains for underlying system s:  armaMat k_x1(n_u, n_x, arma::fill::ones); armaMat k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  k_x = std::vector\u0026lt;armaMat\u0026gt;(2, k_x1); k_x.at(1) = std::move(k_x2); data_t u_lb = 0.0; data_t u_ub = 5.0; switched_controller = std::move( lds::poisson::SwitchedController(std::move(systems), u_lb, u_ub)); } // Control variables  size_t control_type = 0; // no integral action, etc.  switched_controller.set_control_type(control_type); switched_controller.set_Kc(std::move(k_x)); switched_controller.set_y_ref(y_ref0); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;switched_controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; switched_controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Fake measurements  armaMat z(n_y, n_t, arma::fill::zeros); // Will later contain control.  armaMat u(n_u, n_t, arma::fill::zeros); // create armaMatrix to save outputs in...  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat y_ref = armaMat(n_y, n_t).fill(y_ref0[0]); // modes and gain/disturbance params  armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat mode(1, n_t, arma::fill::ones); // set initial val  y_hat.col(0) = switched_controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = switched_controller.sys().x(); x_true.col(0) = controlled_system.x(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Let the controlled system stachastically change gain  // Assume another algorithm decodes this mode change and signals the  // switched_controller  //  armaVec chance(1, arma::fill::randu); if (which_mode == 1) // mode1  { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.set_B(b2); if (do_switch_ctrl) { switched_controller.Switch(1); } } } else { // mode2  if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.set_B(b1); if (do_switch_ctrl) { switched_controller.Switch(0); } } } // Simulate the true system.  z.col(t) = controlled_system.Simulate(u.col(t - 1)); // perform control  u.col(t) = switched_controller.ControlOutputReference(z.col(t)); mode.col(t) = which_mode; y_ref.col(t) = y_ref0; y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); y_hat.col(t) = switched_controller.sys().y(); x_hat.col(t) = switched_controller.sys().x(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); mode.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;mode\u0026#34;, replace)); return 0; }  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':23,'href':'/ldsctrlest/docs/api/files/','title':"Files",'section':"LDS C+E Documentation",'content':"Files #    ldsCtrlEst_h/lds.h lds namespace\n  ldsCtrlEst_h/lds_ctrl.h Controller.\n  ldsCtrlEst_h/lds_fit.h LDS base fit type.\n  ldsCtrlEst_h/lds_gaussian.h glds namespace\n  ldsCtrlEst_h/lds_gaussian_ctrl.h GLDS Controller.\n  ldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type.\n  ldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type.\n  ldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type.\n  ldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type.\n  ldsCtrlEst_h/lds_gaussian_sys.h GLDS base type.\n  ldsCtrlEst_h/lds_poisson.h plds namespace\n  ldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type.\n  ldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type.\n  ldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type.\n  ldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type.\n  ldsCtrlEst_h/lds_poisson_sys.h PLDS base type.\n  ldsCtrlEst_h/lds_sctrl.h SwitchedController type.\n  ldsCtrlEst_h/lds_sys.h LDS base type.\n  ldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API)\n  ldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API)\n  examples/eg_glds_ctrl.cpp\n  examples/eg_plds_ctrl.cpp\n  examples/eg_plds_est.cpp\n  examples/eg_plds_switched_ctrl.cpp\n  src/lds.cpp misc lds namespace functions\n  src/lds_gaussian_sys.cpp GLDS base type.\n  src/lds_poisson_sys.cpp PLDS base type.\n  src/lds_sys.cpp LDS base type.\n   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':24,'href':'/ldsctrlest/docs/tutorials/eg_glds_control/','title':"GLDS Control",'section':"LDS C+E Examples",'content':"GLDS Control Tutorial #  This tutorial shows how to use this library to control a system with a Gaussian LDS controller (lds::gaussian::ctrl_t). In place of a physical system, another GLDS model (lds::gaussian::sys_t) receives control inputs and provides measurements for the simulated feedback control loop. The controller is assumed to have an imperfect model of the system being controlled (here, a gain mismatch), and there is a stochastic, unmeasured disturbance acting on the system. A combination of integral action and adaptive estimation of this process disturbance is used to perform control.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; Creating a simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 5 seconds.\n// Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); When a system is initialized, rather than requiring all parameters to be provided at construction, only the dimensions and sample period are required and a default system is created.\n// construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::sys_t controlled_system(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example,   \\[x_{t\u0026#43;1} = x_t \u0026#43; w_t\\]   \\[y_{t} = x_t \\; .\\]  Now, we\u0026rsquo;ll create non-default parameters for this model.\n// Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); armaMat b_true = armaMat(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  armaVec g_true = armaVec(n_y).fill(10.0); // output noise covariance  armaMat r_true = armaMat(n_y, n_y, arma::fill::eye) * 1e-4; As mentioned above, this example will feature a stochastic disturbance. More specifically, a process disturbance will randomly change between two values.\n/// Going to simulate a switching disturbance (m) acting on system  size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  armaVec m0_true = armaVec(n_y).fill(m_low); Finally, assign the parameters using corresponding set-methods.\n// Assign params.  controlled_system.setA(a_true); controlled_system.setB(b_true); controlled_system.setM(m0_true); controlled_system.setG(g_true); controlled_system.setR(r_true); Creating the controller #  Now, create the controller. Similar to creating a system, most parameters are set to defaults at object construction. In additioin to system dimensions and sample period, the controller needs to know the upper and lower bounds on the control signal, past which the control saturates. If your actuator does not saturate somehow, simply set the lower and upper bounds to -lds::inf and lds::inf, respectively. Simple saturation is currently the only actuator model in this library.\nHere, the control signal is command voltage sent to a physical driver (e.g., for an LED). Its limits are 0 to 5 V.\n// create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  glds::ctrl_t controller(n_u, n_x, n_y, u_lb, u_ub, dt); Now, assign non-default parameters to this controller. For the sake of this simulation, the input matrix is set to an incorrect value. We also assume that the controller feedback gains were designed with an actuator whose conversion factor from volts to physical units (e.g., mW/mm2 optical intensity) differed from the actuator being used in the current experiment.\n// Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  armaMat b_controller = armaMat(n_x, n_u).fill(1e-4); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  armaVec g_design = armaVec(n_u).fill(9); // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  armaVec m_controller = armaVec(n_x, arma::fill::zeros); // Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y).fill(20.0 * dt); // (Can either use arma::Mat or mats flattened into std::vector)  armaMat k_x = armaMat(n_u, n_x).fill(100); // gains on state error  armaMat k_inty = armaMat(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  armaVec x0 = armaVec(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::CONTROL_TYPE_ADAPT_M; } else { // use integral action to minimize DC error  control_type = control_type | lds::CONTROL_TYPE_INTY; } // Start configuring controller:  // Adaptively re-estimate process disturance (m)  controller.adaptM = true; // set controller type  controller.setControlType(control_type); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.setYRef(y_ref0); controller.setKc_x(k_x); controller.setKc_inty(k_inty); controller.setA(a_true); controller.setB(b_controller); controller.setM(m_controller); controller.setG(g_true); controller.setGDesign(g_design); controller.setX0(x0); controller.reset(); // reset to new initial condition  // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; controller.setQ_m(q_m); Simulating control #  In this demonstration, we will use the steadyState_fbCtrl method which allows users to simply set the reference output and supply the current measurement z_t. It then calculates the steady-state solution for the reference state/input. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system.\nThe control loop is carried out here in a simple for-loop, where a the controlled system is simulated, a measurement taken, and the control signal updated.\n// Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_t(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_t); // This method uses a steady-state solution to control problem to calculate  // xRef, uRef from reference output yRef. Therefore, it is only applicable  // to regulation problems or cases where reference trajectory changes slowly  // compared to system dynamics.  controller.steadyState_fbCtrl(z_t); Example simulation result #  Below are example results for this simulation, including outputs, latent states, process disturbance, and the control signal. The controller\u0026rsquo;s online estimates of the output, state, and disturbance are given in purple.\n"});index.add({'id':25,'href':'/ldsctrlest/docs/api/files/dir_8f2980731aba7ec7b9fcae5764f196e3/','title':"include",'section':"Files",'content':"include #  Directories #     Name     ldsCtrlEst_h     Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':26,'href':'/ldsctrlest/docs/api/namespaces/namespacelds/','title':"lds",'section':"Namespaces",'content':"lds #  Linear Dynamical Systems (LDS) namespace. Namespaces #     Name     lds::gaussian Linear Dynamical Systems with Gaussian observations.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::Vector   class lds::Matrix   class lds::Controller   class lds::fit_t LDS Fit Type.   class lds::SwitchedController SwitchedController Type.   class lds::System Linear Dynamical System Type.    Types #      Name     enum SSIDWt { kNONE, kMOESP, kCVA}   using double data_t   using std::vector\u0026lt; data_t \u0026gt; stdVec provides fill types for constructing new armadillo vectors, matrices   using arma::Col\u0026lt; data_t \u0026gt; armaVec   using arma::Mat\u0026lt; data_t \u0026gt; armaMat   using arma::Cube\u0026lt; data_t \u0026gt; armaCube   using arma::subview_col\u0026lt; data_t \u0026gt; armaSubVec   using arma::subview\u0026lt; data_t \u0026gt; armaSubMat    Functions #      Name     void Limit(stdVec \u0026amp; x, data_t lb, data_t ub)   void Limit(armaVec \u0026amp; x, data_t lb, data_t ub)   void Limit(armaMat \u0026amp; x, data_t lb, data_t ub)    Attributes #      Name     const std::size_t kControlTypeDeltaU   const std::size_t kControlTypeIntY   const std::size_t kControlTypeAdaptM Control setpoint adapted with (re-estimated) process disturbance m.   const data_t kInf Some useful numbers.   const data_t kPi   const data_t kDefaultP0   const data_t kDefaultQ0   const data_t kDefaultR0   std::vector\u0026lt; data_t \u0026gt; kDefaultT0    Type Details #  SSIDWt #     Enumerator Value Description     kNONE     kMOESP     kCVA      Weighting options for singular value decomposition performed during subspace identification (SSID): None, MOESP \u0026ldquo;robust method\u0026rdquo;, CVA \u0026ldquo;Canonical Variate Analysis\u0026rdquo;)\ndata_t #  using lds::data_t = typedef double; Precision/type of all data in library. If need 32b, change double to float.\nstdVec #  using lds::stdVec = typedef std::vector\u0026lt;data_t\u0026gt;; armaVec #  using lds::armaVec = typedef arma::Col\u0026lt;data_t\u0026gt;; armaMat #  using lds::armaMat = typedef arma::Mat\u0026lt;data_t\u0026gt;; armaCube #  using lds::armaCube = typedef arma::Cube\u0026lt;data_t\u0026gt;; armaSubVec #  using lds::armaSubVec = typedef arma::subview_col\u0026lt;data_t\u0026gt;; armaSubMat #  using lds::armaSubMat = typedef arma::subview\u0026lt;data_t\u0026gt;; Function Details #  Limit #  void Limit( stdVec \u0026amp; x, data_t lb, data_t ub ) Limit #  void Limit( armaVec \u0026amp; x, data_t lb, data_t ub ) Limit #  void Limit( armaMat \u0026amp; x, data_t lb, data_t ub ) Attribute Details #  kControlTypeDeltaU #  static const std::size_t kControlTypeDeltaU = 0x1; Control was designed to penalize change in input (i.e., the state was augmented with input u)\nkControlTypeIntY #  static const std::size_t kControlTypeIntY = kControlTypeDeltaU \u0026lt;\u0026lt; 1; Control using integral action (i.e., the state was augmented with output y during design)\nkControlTypeAdaptM #  static const std::size_t kControlTypeAdaptM = kControlTypeDeltaU \u0026lt;\u0026lt; 2; kInf #  static const data_t kInf = std::numeric_limits\u0026lt;[data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#using-data_t)\u0026gt;::infinity(); kPi #  static const data_t kPi = arma::datum::pi; kDefaultP0 #  static const data_t kDefaultP0 = 1e-6; kDefaultQ0 #  static const data_t kDefaultQ0 = 1e-6; kDefaultR0 #  static const data_t kDefaultR0 = 1e-2; kDefaultT0 #  static std::vector\u0026lt; data_t \u0026gt; kDefaultT0 = std::vector\u0026lt;[data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#using-data_t)\u0026gt;(1, 0.0);  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':27,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_controller/','title':"lds::Controller",'section':"Classes",'content':"lds::Controller #  More\u0026hellip;\nInherited by lds::SwitchedController\u0026lt; System \u0026gt;, lds::gaussian::Controller, lds::poisson::Controller\nPublic Functions #      Name      Controller() =default    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const armaVec \u0026amp; Control(const armaVec \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const armaVec \u0026amp; ControlOutputReference(const armaVec \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const armaMat \u0026amp; Kc() const\nGet state feedback controller gain.   const armaMat \u0026amp; Kc_inty() const\nGet integral controller gain.   const armaMat \u0026amp; Kc_u() const\nGet input feedback controller gain.   const armaVec \u0026amp; g_design() const\nGet input gain used in controller design.   const armaVec \u0026amp; u_ref() const\nGet reference input.   const armaVec \u0026amp; x_ref() const\nGet reference state.   const armaVec \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const armaVec \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const armaVec \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const armaVec \u0026amp; x_ref)\nSet reference state (x_ref)   virtual void set_y_ref(const armaVec \u0026amp; y_ref)\nSet reference output (y_ref)   void set_Kc(const armaMat \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const armaMat \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const armaMat \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()    Protected Attributes #      Name     System sys_ underlying LDS   armaVec u_ control signal   armaVec g_design_ input gain of the system used for controller design   armaVec u_ref_ reference input   armaVec u_ref_prev_ reference input at previous time step   armaVec x_ref_ reference state   armaVec y_ref_ reference output   armaVec cx_ref_   armaMat Kc_ state controller gain   armaMat Kc_u_ input controller gain (optional when control updates \\deltaU)   armaMat Kc_inty_ integral controller gain   armaVec du_ref_   armaVec dv_ref_   armaVec v_ref_   armaVec dv_   armaVec v_ Control after g inversion (e.g., control in physical units)   armaVec int_e_ integrated error   armaVec int_e_awu_adjust_ anti-windup adjustment to intE   armaVec u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type    Detailed Description #  template \u0026lt;typename System \u0026gt; class lds::Controller;   Public Function Details #  Controller #  Controller() =default  Controller #  inline Controller( const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\n sys System (derived from lds::System) u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask  Template Parameters:\n System type derived from lds::System   Controller #  inline Controller( System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\n sys System (derived from lds::System) u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask  Template Parameters:\n System type derived from lds::System   Control #  inline const armaVec \u0026amp; Control( const armaVec \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true ) Parameters:\n z measurement do_control [optional] whether to update control (true) or simply feed through u_ref (false) do_lock_control [optional] whether to lock control at its current value sigma_soft_start [optional] standard deviation (sigma) of a Gaussian soft-start to control (do_control from false to true) sigma_u_noise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal do_reset_at_control_onset [optional] whether to reset controller at control epoch onset (i.e., do_control from false to true)  Return: updated control signal\nUpdates the control signal (single-step). This is the most flexible option, but requires user to have set the controller\u0026rsquo;s y_ref, x_ref, and u_ref variables.\n ControlOutputReference #  inline const armaVec \u0026amp; ControlOutputReference( const armaVec \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true ) Parameters:\n z measurement do_control [optional] whether to update control (true) or simply feed through u_ref (false) do_estimation [optional] whether to update state estimate (if false, effectively open-loop control) do_lock_control [optional] whether to lock control at its current value sigma_soft_start [optional] standard deviation (sigma) of a Gaussian soft-start to control (do_control from false to true) sigma_u_noise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal do_reset_at_control_onset [optional] whether to reset controller at control epoch onset (i.e., do_control from false to true)  Return: updated control signal\nUpdates the control signal (single-step), given previously-set y_ref. This method calculates the rest of the set point (u_ref, x_ref) that is required to for the system to be at y_ref at steady state. This is accomplished by linearly-constrained least-squares. For a single-output system, the solution should be exact within control saturation limits. For a multi-output system, it provides the least-squares comprimise across the outputs.\n sys #  inline const System \u0026amp; sys() const  Kc #  inline const armaMat \u0026amp; Kc() const  Kc_inty #  inline const armaMat \u0026amp; Kc_inty() const  Kc_u #  inline const armaMat \u0026amp; Kc_u() const  g_design #  inline const armaVec \u0026amp; g_design() const  u_ref #  inline const armaVec \u0026amp; u_ref() const  x_ref #  inline const armaVec \u0026amp; x_ref() const  y_ref #  inline const armaVec \u0026amp; y_ref() const  control_type #  inline size_t control_type() const  set_sys #  inline void set_sys( const System \u0026amp; sys )  set_g_design #  inline void set_g_design( const armaVec \u0026amp; g_design )  set_u_ref #  inline void set_u_ref( const armaVec \u0026amp; u_ref )  set_x_ref #  inline void set_x_ref( const armaVec \u0026amp; x_ref )  set_y_ref #  inline virtual void set_y_ref( const armaVec \u0026amp; y_ref ) Reimplemented by: lds::gaussian::Controller::set_y_ref, lds::gaussian::SwitchedController::set_y_ref, lds::poisson::Controller::set_y_ref, lds::poisson::SwitchedController::set_y_ref\n set_Kc #  inline void set_Kc( const armaMat \u0026amp; Kc )  set_Kc_inty #  inline void set_Kc_inty( const armaMat \u0026amp; Kc_inty )  set_Kc_u #  inline void set_Kc_u( const armaMat \u0026amp; Kc_u )  set_tau_awu #  inline void set_tau_awu( data_t tau )  set_control_type #  inline void set_control_type( size_t control_type ) Parameters:\n control_type control type bit mask  Template Parameters:\n System type derived from lds::System   Reset #  inline void Reset()  Print #  inline void Print()  Protected Attribute Details #  **sys_** #  System sys_;  **u_** #  armaVec u_;  **g_design_** #  armaVec g_design_;  **u_ref_** #  armaVec u_ref_;  **u_ref_prev_** #  armaVec u_ref_prev_;  **x_ref_** #  armaVec x_ref_;  **y_ref_** #  armaVec y_ref_;  **cx_ref_** #  armaVec cx_ref_;  **Kc_** #  armaMat Kc_;  **Kc_u_** #  armaMat Kc_u_;  **Kc_inty_** #  armaMat Kc_inty_;  **du_ref_** #  armaVec du_ref_;  **dv_ref_** #  armaVec dv_ref_;  **v_ref_** #  armaVec v_ref_;  **dv_** #  armaVec dv_;  **v_** #  armaVec v_;  **int_e_** #  armaVec int_e_;  **int_e_awu_adjust_** #  armaVec int_e_awu_adjust_;  **u_sat_** #  armaVec u_sat_;  **do_control_prev_** #  bool do_control_prev_ {};  **do_lock_control_prev_** #  bool do_lock_control_prev_ {};  **u_saturated_** #  bool u_saturated_ {};  **u_lb_** #  data_t u_lb_ {};  **u_ub_** #  data_t u_ub_ {};  **tau_awu_** #  data_t tau_awu_ {};  **k_awu_** #  data_t k_awu_ {};  **t_since_control_onset_** #  data_t t_since_control_onset_ {};  **control_type_** #  size_t control_type_ {};   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':28,'href':'/ldsctrlest/docs/api/classes/classlds_1_1fit__t/','title':"lds::fit_t",'section':"Classes",'content':"lds::fit_t #  LDS Fit Type. #include \u0026lt;lds_fit.h\u0026gt;\nInherited by lds::gaussian::fit_t, lds::poisson::fit_t\nPublic Functions #      Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes #      Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  fit_t #  inline fit_t()  fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate dt { parameter_description }   Public Attribute Details #  A #  armaMat A;  B #  armaMat B;  g #  armaVec g;  m #  armaVec m;  Q #  armaMat Q;  x0 #  armaVec x0;  P0 #  armaMat P0;  dt #  data_t dt;   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':29,'href':'/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/','title':"lds::gaussian",'section':"Namespaces",'content':"lds::gaussian #  Linear Dynamical Systems with Gaussian observations. Classes #      Name     class lds::gaussian::Controller Gaussian-observation Controller Type.   class lds::gaussian::fit_t GLDS Fit Type.   class lds::gaussian::emFit_t GLDS E-M Fit Type.   class lds::gaussian::ssidFit_t GLDS SSID Fit Type.   class lds::gaussian::SwitchedController Gaussian-observation SwitchedController Type.   class lds::gaussian::System Gaussian LDS Type.    Functions #      Name     emFit_t emFit_x_equals_y(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain, data_t dt, std::size_t maxIter =100, data_t tol =1e-3, data_t q0 =1e-6, bool calcAB =true, bool calcQ =true, bool calcR =true)\nPerform EM for special system where y = x + noise.   ssidFit_t ssidFit(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-kInf), bool force_unitNormC =false, SSIDWt wt =kNONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =kDefaultT0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity())\nFit a GLDS model using subspace identification (SSID)   armaVec calcD_silence(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, data_t dt, data_t tSilence =0.1, data_t threshSilence =0.001)\nUsing periods of silence in inputs (u), calculates the output \\ bias.   void createHankelMat_n4sid(armaMat \u0026amp; u, armaMat \u0026amp; z, std::size_t \u0026amp; nH, armaMat \u0026amp; D)\nCreate block-hankel data matrix for N4SID method.   void ssid_n4sid(std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; m, armaVec \u0026amp; d, armaVec \u0026amp; s, bool force_unitNormC, SSIDWt wt, data_t wtG0)\nN4SID method of SSID.   void ssid_n4sid_vanOverschee(std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; s, SSIDWt wt)\nN4SID method of SSID.   void recompute_extObs(armaMat \u0026amp; extObs, armaMat \u0026amp; A, armaMat \u0026amp; C, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH)\nRecompute extended observability matrix, given A, C.   void lq(armaMat \u0026amp; L, armaMat \u0026amp; Qt, armaMat \u0026amp; X)\nLQ decomposition.   armaMat calcCov(armaMat \u0026amp; A, armaMat \u0026amp; B)\nCalculate covariance matrix.   armaMat sqrtmat_svd(armaMat \u0026amp; X)    Function Details #  emFit_x_equals_y #  emFit_t emFit_x_equals_y( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain, data_t dt, std::size_t maxIter =100, data_t tol =1e-3, data_t q0 =1e-6, bool calcAB =true, bool calcQ =true, bool calcR =true ) Parameters:\n uTrain training input data zTrain training measurement data dt sample period maxIter [optional] maximum number of iterations tol [optional] convergence tolerance q0 [optional] initial diagonal elements of process noise covariance calcAB [optional] whether to calculate dynamics (A, B) calcQ [optional] whether to calculate process noise covariance calcR [optional] whether to calculate output noise covariance  Return: EM fit\nssidFit #  ssidFit_t ssidFit( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-kInf), bool force_unitNormC =false, SSIDWt wt =kNONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =kDefaultT0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity() ) Parameters:\n u inputs z measurements dt sample period nX number of states nH block-Hankel data matrix size d0 previous estimate of output bias (d) force_unitNormC force fitting where C has unit norm wt chosen weighting for SSID singular value \\ decomposition (NONE, MOESP, CVA) wtG0 chosen weighting for minimizing model error at \\ DC t0 start times for each trial of input/output data t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID  Return: the SSID-fit GLDS model.\nFit a GLDS model using subspace identification (SSID)\nReferences:\nvan Overschee P, de Moor B. (1996) Subspace Identification for Linear Systems.\ncalcD_silence #  armaVec calcD_silence( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, data_t dt, data_t tSilence =0.1, data_t threshSilence =0.001 ) Parameters:\n n measurements u inputs dt sample period tSilence threshold on period of time that qualifies as \u0026ldquo;silence\u0026rdquo; threshSilence threshold on input amplitude u that qualifies as \u0026ldquo;silence\u0026rdquo;  Return: d estimated output bias.\ncreateHankelMat_n4sid #  void createHankelMat_n4sid( armaMat \u0026amp; u, armaMat \u0026amp; z, std::size_t \u0026amp; nH, armaMat \u0026amp; D ) Parameters:\n u input data z measurement data nH block-Hankel matrix size D block-Hankel data matrix  ssid_n4sid #  void ssid_n4sid( std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; m, armaVec \u0026amp; d, armaVec \u0026amp; s, bool force_unitNormC, SSIDWt wt, data_t wtG0 ) Parameters:\n nX number of states nU number of inputs nY number of outputs nH block-Hankel matrix size uSSID input data zSSID measurement data A state matrix B input matrix C output matrix D feedthrough matrix Q process noise covariance R output noise covariance m process disturbance d output bias s singular values force_unitNormC whether to force C to be unit-norm wt weighting method for SVD (NONE, MOESP, CVA) wtG0 weight put on minimizing error at DC  ssid_n4sid_vanOverschee #  void ssid_n4sid_vanOverschee( std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; s, SSIDWt wt ) Parameters:\n nX number of state nU number of inputs nY number of outputs nH block-Hankel data matrix size uSSID input data zSSID measurement data A state matrix B input matrix C output matrix D feedthrough matrix Q process noise covariance R output noise covariance s singular values wt weighting method for SVD (NONE, MOESP, CVA)  N4SID method of SSID\nThis is a more direct implementation of van Overschee, de Moor (1996)\nrecompute_extObs #  void recompute_extObs( armaMat \u0026amp; extObs, armaMat \u0026amp; A, armaMat \u0026amp; C, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH ) Parameters:\n extObs Extended observability matrix A state matrix C output matrix nY number of outputs nH block-Hankel data matrix size  lq #  void lq( armaMat \u0026amp; L, armaMat \u0026amp; Qt, armaMat \u0026amp; X ) Parameters:\n L lower triangle matrix Qt orthonormal matrix (transposed cf QR decomp) X matrix being decomposed  calcCov #  armaMat calcCov( armaMat \u0026amp; A, armaMat \u0026amp; B ) Parameters:\n A some matrix B some other matrix  Return: covariance\nsqrtmat_svd #  armaMat sqrtmat_svd( armaMat \u0026amp; X ) Parameters:\n X some matrix  Return: approximate sqrtmat(X)\nApproximate sqrtmat by singular value decomposition.\nsvd(X) \u0026ndash;\u0026gt; U * sqrt(s) * V' ~= sqrtmat(X)\n Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':30,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_controller/','title':"lds::gaussian::Controller",'section':"Classes",'content':"lds::gaussian::Controller #  Gaussian-observation Controller Type. #include \u0026lt;lds_gaussian_ctrl.h\u0026gt;\nInherits from lds::Controller\u0026lt; System \u0026gt;\nPublic Functions #      Name     virtual void set_y_ref(const armaVec \u0026amp; y_ref) override\nSet reference output (y_ref)    Additional inherited members #  Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const armaVec \u0026amp; Control(const armaVec \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const armaVec \u0026amp; ControlOutputReference(const armaVec \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const armaMat \u0026amp; Kc() const\nGet state feedback controller gain.   const armaMat \u0026amp; Kc_inty() const\nGet integral controller gain.   const armaMat \u0026amp; Kc_u() const\nGet input feedback controller gain.   const armaVec \u0026amp; g_design() const\nGet input gain used in controller design.   const armaVec \u0026amp; u_ref() const\nGet reference input.   const armaVec \u0026amp; x_ref() const\nGet reference state.   const armaVec \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const armaVec \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const armaVec \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const armaVec \u0026amp; x_ref)\nSet reference state (x_ref)   void set_Kc(const armaMat \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const armaMat \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const armaMat \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   armaVec u_ control signal   armaVec g_design_ input gain of the system used for controller design   armaVec u_ref_ reference input   armaVec u_ref_prev_ reference input at previous time step   armaVec x_ref_ reference state   armaVec y_ref_ reference output   armaVec cx_ref_   armaMat Kc_ state controller gain   armaMat Kc_u_ input controller gain (optional when control updates \\deltaU)   armaMat Kc_inty_ integral controller gain   armaVec du_ref_   armaVec dv_ref_   armaVec v_ref_   armaVec dv_   armaVec v_ Control after g inversion (e.g., control in physical units)   armaVec int_e_ integrated error   armaVec int_e_awu_adjust_ anti-windup adjustment to intE   armaVec u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type      Public Function Details #  set_y_ref #  inline virtual void set_y_ref( const armaVec \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\n  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':31,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1em_fit__t/','title':"lds::gaussian::emFit_t",'section':"Classes",'content':"lds::gaussian::emFit_t #  GLDS E-M Fit Type. More\u0026hellip;\n\n#include \u0026lt;lds_gaussian_fit_em.h\u0026gt;\nInherits from lds::gaussian::fit_t, lds::fit_t\nPublic Functions #      Name      emFit_t()    emFit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new EM Fit Type.    emFit_t(data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new EM Fit Type.    emFit_t(ssidFit_t \u0026amp; fit0)   void reset(void )\nReset EM fit.   void runEM(bool calcAB =true, bool calcQ =true, bool calcInitial =true, bool calcC =true, bool calcd =true, bool calcR =true)\nRun Expectation-Maximization algorithm.   std::vector\u0026lt; armaMat \u0026gt; getX()\nGet state estimate.   std::vector\u0026lt; armaMat \u0026gt; getY()\nGet output estimate.   armaMat get_sum_E_xu_tm1_xu_tm1()   armaMat get_sum_E_xu_t_xu_tm1()   armaMat get_sum_E_xu_t_xu_t()   size_t getT()   void setY(std::vector\u0026lt; armaMat \u0026gt; yHat)\nSet output.    Protected Functions #      Name     armaVec getTheta()\nGet recalculated parameters (packed into vector)   void kalmanFilt()   void kalmanSmooth(bool forceCommonInitial)\nKalman smooth dataset (fixed-interval smoothing)   void Estep(bool forceCommonInitial =false)\nExpectation step.   void Mstep(bool calcAB =true, bool calcQ =true, bool calcInitial =false, bool calcC =false, bool calcd =false, bool calcR =true)\nMaximization step.    Public Attributes #      Name     data_t tol tolerance for convergence   size_t maxIter maximum number of EM iterations    Protected Attributes #      Name     std::vector\u0026lt; armaMat \u0026gt; xHat state estimate   std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P state estimate covariance   std::vector\u0026lt; armaMat \u0026gt; yHat output estimate   std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P_t_tm1 single-lag state covariance   armaMat sum_E_xu_t_xu_t state-input covariance (current time)   armaMat sum_E_xu_tm1_xu_tm1 state-input covariance (t-minus-1)   armaMat sum_E_xu_t_xu_tm1 single lag state-input covariance   size_t T    Additional inherited members #  Public Functions inherited from lds::gaussian::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit.    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit type.    Public Attributes inherited from lds::gaussian::fit_t\n    Name     armaMat C output matrix   armaMat D feedthrough matrix   armaVec d output bias   armaMat R output noise cov   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Public Functions inherited from lds::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period    Detailed Description #  class lds::gaussian::emFit_t;  This type is used in the process of fitting GLDS models by expectation-maximization (EM).   Public Function Details #  emFit_t #  inline emFit_t()  emFit_t #  emFit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias R output noise covariance dt sample period uTrain training input data zTrain training measurement data   emFit_t #  emFit_t( data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n dt sample period uTrain training input data zTrain training measurement data  Constructs a new EM Fit Type.\nInitializes the model to a random walk.\n emFit_t #  emFit_t( ssidFit_t \u0026amp; fit0 )  reset #  void reset( void )  runEM #  void runEM( bool calcAB =true, bool calcQ =true, bool calcInitial =true, bool calcC =true, bool calcd =true, bool calcR =true ) Parameters:\n calcAB [optional] whether to caclulate dynamics (A, B) calcQ [optional] whether to calculate process noise covariance calcInitial [optional] whether to calculate initial conditions calcC [optional] whether to calculate output matrix calcd [optional] whether to calculate output bias calcR [optional] whether to calculate output noise covariance   getX #  inline std::vector\u0026lt; armaMat \u0026gt; getX()  getY #  inline std::vector\u0026lt; armaMat \u0026gt; getY()  get_sum_E_xu_tm1_xu_tm1 #  inline armaMat get_sum_E_xu_tm1_xu_tm1()  get_sum_E_xu_t_xu_tm1 #  inline armaMat get_sum_E_xu_t_xu_tm1()  get_sum_E_xu_t_xu_t #  inline armaMat get_sum_E_xu_t_xu_t()  getT #  inline size_t getT()  setY #  inline void setY( std::vector\u0026lt; armaMat \u0026gt; yHat )  Protected Function Details #  getTheta #  armaVec getTheta()  kalmanFilt #  void kalmanFilt() Kalman filter dataset Estimate x[t] | z[0\u0026hellip;t]\n kalmanSmooth #  void kalmanSmooth( bool forceCommonInitial ) Parameters:\n forceCommonInitial whether to force common initial condition for all trials  Kalman smooth dataset (fixed-interval smoothing)\nEstimate x[t] | z[0\u0026hellip;T]\n Estep #  void Estep( bool forceCommonInitial =false ) Parameters:\n forceCommonInitial whether to force common initial condition for all trials   Mstep #  void Mstep( bool calcAB =true, bool calcQ =true, bool calcInitial =false, bool calcC =false, bool calcd =false, bool calcR =true ) Parameters:\n calcAB [optional] whether to caclulate dynamics (A, B) calcQ [optional] whether to calculate process noise covariance calcInitial [optional] whether to calculate initial conditions calcC [optional] whether to calculate output matrix calcd [optional] whether to calculate output bias calcR [optional] whether to calculate output noise covariance   Public Attribute Details #  tol #  data_t tol = 1e-3;  maxIter #  size_t maxIter = 100;  Protected Attribute Details #  xHat #  std::vector\u0026lt; armaMat \u0026gt; xHat;  P #  std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P;  yHat #  std::vector\u0026lt; armaMat \u0026gt; yHat;  P_t_tm1 #  std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P_t_tm1;  sum_E_xu_t_xu_t #  armaMat sum_E_xu_t_xu_t;  sum_E_xu_tm1_xu_tm1 #  armaMat sum_E_xu_tm1_xu_tm1;  sum_E_xu_t_xu_tm1 #  armaMat sum_E_xu_t_xu_tm1;  T #  size_t T;   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':32,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1fit__t/','title':"lds::gaussian::fit_t",'section':"Classes",'content':"lds::gaussian::fit_t #  GLDS Fit Type. #include \u0026lt;lds_gaussian_fit.h\u0026gt;\nInherits from lds::fit_t\nInherited by lds::gaussian::emFit_t, lds::gaussian::ssidFit_t\nPublic Functions #      Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit.    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit type.    Public Attributes #      Name     armaMat C output matrix   armaMat D feedthrough matrix   armaVec d output bias   armaMat R output noise cov   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Additional inherited members #  Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  fit_t #  inline fit_t()  fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix D feedthrough matrix d output bias R covariance of output noise dt sample period uTrain input training data zTrain measurement training data   fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias R covariance of output noise dt sample period uTrain input training data zTrain measurement training data   Public Attribute Details #  C #  armaMat C;  D #  armaMat D;  d #  armaVec d;  R #  armaMat R;  uTrain #  std::vector\u0026lt; armaMat \u0026gt; uTrain;  zTrain #  std::vector\u0026lt; armaMat \u0026gt; zTrain;   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':33,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ssid_fit__t/','title':"lds::gaussian::ssidFit_t",'section':"Classes",'content':"lds::gaussian::ssidFit_t #  GLDS SSID Fit Type. More\u0026hellip;\n\n#include \u0026lt;lds_gaussian_fit_ssid.h\u0026gt;\nInherits from lds::gaussian::fit_t, lds::fit_t\nPublic Functions #      Name      ssidFit_t()    ssidFit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS SSID fit type.    Public Attributes #      Name     std::vector\u0026lt; data_t \u0026gt; t0   data_t t_startSSID   data_t t_stopSSID   armaVec singVals    Additional inherited members #  Public Functions inherited from lds::gaussian::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit.    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit type.    Public Attributes inherited from lds::gaussian::fit_t\n    Name     armaMat C output matrix   armaMat D feedthrough matrix   armaVec d output bias   armaMat R output noise cov   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Public Functions inherited from lds::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period    Detailed Description #  class lds::gaussian::ssidFit_t;  This type is used in the process of fitting GLDS models by subspace identification (SSID).   Public Function Details #  ssidFit_t #  inline ssidFit_t()  ssidFit_t #  ssidFit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix D feedthrough matrix d output bias R output noise covariance dt sample period t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID singVals singular values from SSID SVD step t0 start times for each trial of input/output data uTrain training input data zTrain training measurement data   Public Attribute Details #  t0 #  std::vector\u0026lt; data_t \u0026gt; t0;  t_startSSID #  data_t t_startSSID;  t_stopSSID #  data_t t_stopSSID;  singVals #  armaVec singVals;   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':34,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_switched_controller/','title':"lds::gaussian::SwitchedController",'section':"Classes",'content':"lds::gaussian::SwitchedController #  Gaussian-observation SwitchedController Type. #include \u0026lt;lds_gaussian_sctrl.h\u0026gt;\nInherits from lds::SwitchedController\u0026lt; System \u0026gt;, lds::Controller\u0026lt; System \u0026gt;\nPublic Functions #      Name     virtual void set_y_ref(const armaVec \u0026amp; y_ref) override\nSet reference output (y_ref)    Additional inherited members #  Public Functions inherited from lds::SwitchedController\u0026lt; System \u0026gt;\n    Name      SwitchedController() =default    SwitchedController(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController.    SwitchedController(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController (moves systems).   void Switch(size_t idx)\nSwitch to a different sub-system/controller.   void set_Kc(const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc)   void set_Kc(std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc)   void set_Kc_inty(const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc_inty)   void set_Kc_inty(std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc_inty)   void set_Kc_u(const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc_u)   void set_Kc_u(std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc_u)   void set_g_design(const std::vector\u0026lt; armaVec \u0026gt; \u0026amp; g)   void set_g_design(std::vector\u0026lt; armaVec \u0026gt; \u0026amp;\u0026amp; g)    Protected Attributes inherited from lds::SwitchedController\u0026lt; System \u0026gt;\n    Name     std::vector\u0026lt; System \u0026gt; systems_ underlying sub-systems which are switched between   size_t n_sys_ number of systems   size_t idx_ current system/controller index.   std::vector\u0026lt; armaMat \u0026gt; Kc_vec_   std::vector\u0026lt; armaMat \u0026gt; Kc_inty_vec_   std::vector\u0026lt; armaMat \u0026gt; Kc_u_vec_   std::vector\u0026lt; armaVec \u0026gt; g_design_vec_    Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const armaVec \u0026amp; Control(const armaVec \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const armaVec \u0026amp; ControlOutputReference(const armaVec \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const armaMat \u0026amp; Kc() const\nGet state feedback controller gain.   const armaMat \u0026amp; Kc_inty() const\nGet integral controller gain.   const armaMat \u0026amp; Kc_u() const\nGet input feedback controller gain.   const armaVec \u0026amp; g_design() const\nGet input gain used in controller design.   const armaVec \u0026amp; u_ref() const\nGet reference input.   const armaVec \u0026amp; x_ref() const\nGet reference state.   const armaVec \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const armaVec \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const armaVec \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const armaVec \u0026amp; x_ref)\nSet reference state (x_ref)   void set_Kc(const armaMat \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const armaMat \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const armaMat \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   armaVec u_ control signal   armaVec g_design_ input gain of the system used for controller design   armaVec u_ref_ reference input   armaVec u_ref_prev_ reference input at previous time step   armaVec x_ref_ reference state   armaVec y_ref_ reference output   armaVec cx_ref_   armaMat Kc_ state controller gain   armaMat Kc_u_ input controller gain (optional when control updates \\deltaU)   armaMat Kc_inty_ integral controller gain   armaVec du_ref_   armaVec dv_ref_   armaVec v_ref_   armaVec dv_   armaVec v_ Control after g inversion (e.g., control in physical units)   armaVec int_e_ integrated error   armaVec int_e_awu_adjust_ anti-windup adjustment to intE   armaVec u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type      Public Function Details #  set_y_ref #  inline virtual void set_y_ref( const armaVec \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\n  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':35,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_system/','title':"lds::gaussian::System",'section':"Classes",'content':"lds::gaussian::System #  Gaussian LDS Type. #include \u0026lt;lds_gaussian_sys.h\u0026gt;\nInherits from lds::System\nPublic Functions #      Name      System() =default    System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0, data_t r0 =kDefaultR0)\nConstructs a new Gaussian System.   virtual const armaVec \u0026amp; Simulate(const armaVec \u0026amp; u_tm1) override\nSimulate system measurement.   const armaMat \u0026amp; R() const\nGet output noise covariance.   void set_Q(const armaMat \u0026amp; Q)   void set_R(const armaMat \u0026amp; R)\nSet output noise covariance.   void set_Ke(const armaMat \u0026amp; Ke)\nSet estimator gain.   void set_Ke_m(const armaMat \u0026amp; Ke_m)\nSet disturbance estimator gain.   void Print()\nPrint system variables to stdout.    Protected Functions #      Name     virtual void h() override\nSystem output function.   virtual void RecurseKe() override\nRecursively update estimator gain.    Protected Attributes #      Name     armaMat R_ covariance of output noise   bool do_recurse_Ke_ whether to recursively calculate estimator gain    Additional inherited members #  Public Functions inherited from lds::System\n    Name     void Filter(const armaVec \u0026amp; u_tm1, const armaVec \u0026amp; z)\nFilter data to produce causal state estimates.   void f(const armaVec \u0026amp; u, bool do_add_noise =false)\nsystem dynamics function   size_t n_u() const\nGet number of inputs.   size_t n_x() const\nGet number of states.   size_t n_y() const\nGet number of outputs.   data_t dt() const\nGet sample period.   const armaVec \u0026amp; x() const\nGet current state.   const armaMat \u0026amp; P() const\nGet covariance of state estimate.   const armaVec \u0026amp; m() const\nGet current process disturbance/bias.   const armaMat \u0026amp; P_m() const\nGet covariance of process disturbance estimate.   const armaVec \u0026amp; cx() const\nGet C*x.   const armaVec \u0026amp; y() const\nGet output.   const armaVec \u0026amp; x0() const\nGet initial state.   const armaVec \u0026amp; m0() const\nGet initial disturbance.   const armaMat \u0026amp; A() const\nGet state matrix.   const armaMat \u0026amp; B() const\nGet input matrix.   const armaVec \u0026amp; g() const\nGet input gain/conversion factor.   const armaMat \u0026amp; C() const\nGet output matrix.   const armaVec \u0026amp; d() const\nGet output bias.   const armaMat \u0026amp; Ke() const\nGet estimator gain.   const armaMat \u0026amp; Ke_m() const\nGet estimator gain for process disturbance (m)   void set_A(const armaMat \u0026amp; A)\nSet state matrix.   void set_B(const armaMat \u0026amp; B)\nSet input matrix.   void set_m(const armaVec \u0026amp; m)\nSet process disturbance.   void set_g(const armaVec \u0026amp; g)\nSet input gain.   void set_Q_m(const armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation.   void set_x0(const armaVec \u0026amp; x0)\nSet initial state.   void set_P0(const armaMat \u0026amp; P0)\nSet covariance of initial state.   void set_P0_m(const armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance.   void set_C(const armaMat \u0026amp; C)\nSet output matrix.   void set_d(const armaVec \u0026amp; d)\nSet output bias.   void Reset()\nReset system variables.    Public Attributes inherited from lds::System\n    Name     bool do_adapt_m whether to adaptively estimate disturbance m    Protected Attributes inherited from lds::System\n    Name     std::size_t n_x_ number of states   std::size_t n_u_ number of inputs   std::size_t n_y_ number of outputs   data_t dt_ sample period   armaVec x_ state   armaMat P_ covariance of state estimate   armaVec m_ process disturbance   armaMat P_m_ covariance of disturbance estimate   armaVec cx_ C*x.   armaVec y_ output   armaVec z_ measurement   armaVec x0_ initial state   armaMat P0_ covariance of initial state estimate   armaVec m0_ initial process disturbance   armaMat P0_m_ covariance of initial disturbance est.   armaMat A_ state matrix   armaMat B_ input matrix   armaVec g_ input gain   armaMat Q_ covariance of process noise   armaMat Q_m_ covariance of disturbance random walk   armaMat C_ output matrix   armaVec d_ output bias   armaMat Ke_ estimator gain   armaMat Ke_m_ estimator gain for process disturbance      Public Function Details #  System #  System() =default  System #  System( std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0, data_t r0 =kDefaultR0 ) Parameters:\n n_u number of inputs (u) n_x number of states (x) n_y number of outputs (y) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) r0 [optional] initial diagonal elements of output noise covariance (R)   Simulate #  virtual const armaVec \u0026amp; Simulate( const armaVec \u0026amp; u_tm1 ) override Parameters:\n u_tm1 input at t-1  Return: z measurement\nReimplements: lds::System::Simulate\nSimulate system and produce measurement\n R #  inline const armaMat \u0026amp; R() const  set_Q #  inline void set_Q( const armaMat \u0026amp; Q )  set_R #  inline void set_R( const armaMat \u0026amp; R )  set_Ke #  inline void set_Ke( const armaMat \u0026amp; Ke )  set_Ke_m #  inline void set_Ke_m( const armaMat \u0026amp; Ke_m )  Print #  void Print()  Protected Function Details #  h #  inline virtual void h() override Reimplements: lds::System::h\n RecurseKe #  virtual void RecurseKe() override Reimplements: lds::System::RecurseKe\n Protected Attribute Details #  **R_** #  armaMat R_;  **do_recurse_Ke_** #  bool do_recurse_Ke_ {};   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':36,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_matrix/','title':"lds::Matrix",'section':"Classes",'content':"lds::Matrix #  Inherits from arma::Mat\u0026lt; data_t \u0026gt;\n   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':37,'href':'/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/','title':"lds::poisson",'section':"Namespaces",'content':"lds::poisson #  Linear Dynamical Systems with Poisson observations. Classes #      Name     class lds::poisson::Controller PLDS Controller Type.   class lds::poisson::fit_t PLDS Fit Type.   class lds::poisson::ssidFit_t GLDS SSID Fit Type.   class lds::poisson::SwitchedController Poisson-observation SwitchedController Type.   class lds::poisson::System Poisson System type.    Functions #      Name     std::tuple\u0026lt; ssidFit_t, lds::gaussian::ssidFit_t \u0026gt; ssidFit(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-kInf), SSIDWt wt =kNONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =kDefaultT0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), bool assumeGaussian =true)\nFit a PLDS model using subspace identification (SSID)   void newtonSolveC_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nSolve for output matrix by Poisson MLE.   data_t newtonSolve_rescaleC_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nSolve for rescaled output matrix by Poisson MLE.   void calcD_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nCalculates output bias by Poisson MLE.   data_t calcD_newtonSolve_rescaleC_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nCalculates output bias and rescaled output matrix by Poisson MLE.   void fitOutput_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nCalculates exponential output function by Poisson MLE.    Function Details #  ssidFit #  std::tuple\u0026lt; ssidFit_t, lds::gaussian::ssidFit_t \u0026gt; ssidFit( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-kInf), SSIDWt wt =kNONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =kDefaultT0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), bool assumeGaussian =true ) Parameters:\n u inputs n { parameter_description } dt sample period nX number of states nH block-Hankel data matrix size d0 previous estimate of output bias (d) wt chosen weighting for SSID singular value \\ decomposition (NONE, MOESP, CVA) wtG0 chosen weighting for minimizing model error at \\ DC t0 start times for each trial of input/output data t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID assumeGaussian [NONFUNCTIONAL] whether to assume Gaussian observation model and fit by linear SSID first, then fit output nonlinearity by Poisson MLE z measurements  Return: tuple\u0026lt;PLDS fit, GLDS fit\u0026gt;\nFit PLDS model by subspace identification (SSID). System matrices (A,B,C) are fit by SSID assuming gaussian observations. Iteratively refits output function parameters (C, d) by Poisson MLE using Newton\u0026rsquo;s method.\nnewtonSolveC_mle #  void newtonSolveC_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Given dynamics and initial guess of output, solves for output matrix (C) by maximizing Poisson maximum likelihood using Newton\u0026rsquo;s method.\nnewtonSolve_rescaleC_mle #  data_t newtonSolve_rescaleC_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Return: negative log-likelihood\nGiven dynamics and initial guess of output, solves for a scaling factor to apply to output matrix (C) by maximizing Poisson maximum likelihood using Newton\u0026rsquo;s method.\nn.b., see Bussgang theorem (1952)\ncalcD_mle #  void calcD_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  calcD_newtonSolve_rescaleC_mle #  data_t calcD_newtonSolve_rescaleC_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Return: negative log-likelihood\nfitOutput_mle #  void fitOutput_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':38,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_controller/','title':"lds::poisson::Controller",'section':"Classes",'content':"lds::poisson::Controller #  PLDS Controller Type. #include \u0026lt;lds_poisson_ctrl.h\u0026gt;\nInherits from lds::Controller\u0026lt; System \u0026gt;\nPublic Functions #      Name     virtual void set_y_ref(const armaVec \u0026amp; y_ref) override\nSet reference output.    Additional inherited members #  Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const armaVec \u0026amp; Control(const armaVec \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const armaVec \u0026amp; ControlOutputReference(const armaVec \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const armaMat \u0026amp; Kc() const\nGet state feedback controller gain.   const armaMat \u0026amp; Kc_inty() const\nGet integral controller gain.   const armaMat \u0026amp; Kc_u() const\nGet input feedback controller gain.   const armaVec \u0026amp; g_design() const\nGet input gain used in controller design.   const armaVec \u0026amp; u_ref() const\nGet reference input.   const armaVec \u0026amp; x_ref() const\nGet reference state.   const armaVec \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const armaVec \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const armaVec \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const armaVec \u0026amp; x_ref)\nSet reference state (x_ref)   void set_Kc(const armaMat \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const armaMat \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const armaMat \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   armaVec u_ control signal   armaVec g_design_ input gain of the system used for controller design   armaVec u_ref_ reference input   armaVec u_ref_prev_ reference input at previous time step   armaVec x_ref_ reference state   armaVec y_ref_ reference output   armaVec cx_ref_   armaMat Kc_ state controller gain   armaMat Kc_u_ input controller gain (optional when control updates \\deltaU)   armaMat Kc_inty_ integral controller gain   armaVec du_ref_   armaVec dv_ref_   armaVec v_ref_   armaVec dv_   armaVec v_ Control after g inversion (e.g., control in physical units)   armaVec int_e_ integrated error   armaVec int_e_awu_adjust_ anti-windup adjustment to intE   armaVec u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type      Public Function Details #  set_y_ref #  inline virtual void set_y_ref( const armaVec \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\n  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':39,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1fit__t/','title':"lds::poisson::fit_t",'section':"Classes",'content':"lds::poisson::fit_t #  PLDS Fit Type. #include \u0026lt;lds_poisson_fit.h\u0026gt;\nInherits from lds::fit_t\nInherited by lds::poisson::ssidFit_t\nPublic Functions #      Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new PLDS fit.    Public Attributes #      Name     armaMat C output matrix   armaVec d output bias   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Additional inherited members #  Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  fit_t #  inline fit_t()  fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias dt sample period uTrain input training data zTrain measurement training data   Public Attribute Details #  C #  armaMat C;  d #  armaVec d;  uTrain #  std::vector\u0026lt; armaMat \u0026gt; uTrain;  zTrain #  std::vector\u0026lt; armaMat \u0026gt; zTrain;   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':40,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1ssid_fit__t/','title':"lds::poisson::ssidFit_t",'section':"Classes",'content':"lds::poisson::ssidFit_t #  GLDS SSID Fit Type. #include \u0026lt;lds_poisson_fit_ssid.h\u0026gt;\nInherits from lds::poisson::fit_t, lds::fit_t\nPublic Functions #      Name      ssidFit_t()    ssidFit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new PLDS SSID fit.    Public Attributes #      Name     std::vector\u0026lt; data_t \u0026gt; t0   data_t t_startSSID   data_t t_stopSSID   armaVec singVals    Additional inherited members #  Public Functions inherited from lds::poisson::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new PLDS fit.    Public Attributes inherited from lds::poisson::fit_t\n    Name     armaMat C output matrix   armaVec d output bias   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Public Functions inherited from lds::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  ssidFit_t #  inline ssidFit_t()  ssidFit_t #  ssidFit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias dt sample period t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID singVals singular values from SSID SVD step t0 start times for each trial of input/output data uTrain training input data zTrain training measurement data   Public Attribute Details #  t0 #  std::vector\u0026lt; data_t \u0026gt; t0;  t_startSSID #  data_t t_startSSID;  t_stopSSID #  data_t t_stopSSID;  singVals #  armaVec singVals;   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':41,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_switched_controller/','title':"lds::poisson::SwitchedController",'section':"Classes",'content':"lds::poisson::SwitchedController #  Poisson-observation SwitchedController Type. #include \u0026lt;lds_poisson_sctrl.h\u0026gt;\nInherits from lds::SwitchedController\u0026lt; System \u0026gt;, lds::Controller\u0026lt; System \u0026gt;\nPublic Functions #      Name     virtual void set_y_ref(const armaVec \u0026amp; y_ref) override\nSet reference output.    Additional inherited members #  Public Functions inherited from lds::SwitchedController\u0026lt; System \u0026gt;\n    Name      SwitchedController() =default    SwitchedController(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController.    SwitchedController(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController (moves systems).   void Switch(size_t idx)\nSwitch to a different sub-system/controller.   void set_Kc(const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc)   void set_Kc(std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc)   void set_Kc_inty(const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc_inty)   void set_Kc_inty(std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc_inty)   void set_Kc_u(const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc_u)   void set_Kc_u(std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc_u)   void set_g_design(const std::vector\u0026lt; armaVec \u0026gt; \u0026amp; g)   void set_g_design(std::vector\u0026lt; armaVec \u0026gt; \u0026amp;\u0026amp; g)    Protected Attributes inherited from lds::SwitchedController\u0026lt; System \u0026gt;\n    Name     std::vector\u0026lt; System \u0026gt; systems_ underlying sub-systems which are switched between   size_t n_sys_ number of systems   size_t idx_ current system/controller index.   std::vector\u0026lt; armaMat \u0026gt; Kc_vec_   std::vector\u0026lt; armaMat \u0026gt; Kc_inty_vec_   std::vector\u0026lt; armaMat \u0026gt; Kc_u_vec_   std::vector\u0026lt; armaVec \u0026gt; g_design_vec_    Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const armaVec \u0026amp; Control(const armaVec \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const armaVec \u0026amp; ControlOutputReference(const armaVec \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const armaMat \u0026amp; Kc() const\nGet state feedback controller gain.   const armaMat \u0026amp; Kc_inty() const\nGet integral controller gain.   const armaMat \u0026amp; Kc_u() const\nGet input feedback controller gain.   const armaVec \u0026amp; g_design() const\nGet input gain used in controller design.   const armaVec \u0026amp; u_ref() const\nGet reference input.   const armaVec \u0026amp; x_ref() const\nGet reference state.   const armaVec \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const armaVec \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const armaVec \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const armaVec \u0026amp; x_ref)\nSet reference state (x_ref)   void set_Kc(const armaMat \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const armaMat \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const armaMat \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   armaVec u_ control signal   armaVec g_design_ input gain of the system used for controller design   armaVec u_ref_ reference input   armaVec u_ref_prev_ reference input at previous time step   armaVec x_ref_ reference state   armaVec y_ref_ reference output   armaVec cx_ref_   armaMat Kc_ state controller gain   armaMat Kc_u_ input controller gain (optional when control updates \\deltaU)   armaMat Kc_inty_ integral controller gain   armaVec du_ref_   armaVec dv_ref_   armaVec v_ref_   armaVec dv_   armaVec v_ Control after g inversion (e.g., control in physical units)   armaVec int_e_ integrated error   armaVec int_e_awu_adjust_ anti-windup adjustment to intE   armaVec u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type      Public Function Details #  set_y_ref #  inline virtual void set_y_ref( const armaVec \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\n  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':42,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_system/','title':"lds::poisson::System",'section':"Classes",'content':"lds::poisson::System #  Poisson System type. #include \u0026lt;lds_poisson_sys.h\u0026gt;\nInherits from lds::System\nPublic Functions #      Name      System() =default    System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0)\nConstructs a new Poisson System.   virtual const armaVec \u0026amp; Simulate(const armaVec \u0026amp; u_tm1) override\nSimulate system measurement.    Protected Functions #      Name     virtual void h() override\nSystem output function.   virtual void RecurseKe() override\nRecursively recalculate estimator gain (Ke)    Additional inherited members #  Public Functions inherited from lds::System\n    Name     void Filter(const armaVec \u0026amp; u_tm1, const armaVec \u0026amp; z)\nFilter data to produce causal state estimates.   void f(const armaVec \u0026amp; u, bool do_add_noise =false)\nsystem dynamics function   size_t n_u() const\nGet number of inputs.   size_t n_x() const\nGet number of states.   size_t n_y() const\nGet number of outputs.   data_t dt() const\nGet sample period.   const armaVec \u0026amp; x() const\nGet current state.   const armaMat \u0026amp; P() const\nGet covariance of state estimate.   const armaVec \u0026amp; m() const\nGet current process disturbance/bias.   const armaMat \u0026amp; P_m() const\nGet covariance of process disturbance estimate.   const armaVec \u0026amp; cx() const\nGet C*x.   const armaVec \u0026amp; y() const\nGet output.   const armaVec \u0026amp; x0() const\nGet initial state.   const armaVec \u0026amp; m0() const\nGet initial disturbance.   const armaMat \u0026amp; A() const\nGet state matrix.   const armaMat \u0026amp; B() const\nGet input matrix.   const armaVec \u0026amp; g() const\nGet input gain/conversion factor.   const armaMat \u0026amp; C() const\nGet output matrix.   const armaVec \u0026amp; d() const\nGet output bias.   const armaMat \u0026amp; Ke() const\nGet estimator gain.   const armaMat \u0026amp; Ke_m() const\nGet estimator gain for process disturbance (m)   void set_A(const armaMat \u0026amp; A)\nSet state matrix.   void set_B(const armaMat \u0026amp; B)\nSet input matrix.   void set_m(const armaVec \u0026amp; m)\nSet process disturbance.   void set_g(const armaVec \u0026amp; g)\nSet input gain.   void set_Q(const armaMat \u0026amp; Q)\nSet process noise covariance.   void set_Q_m(const armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation.   void set_x0(const armaVec \u0026amp; x0)\nSet initial state.   void set_P0(const armaMat \u0026amp; P0)\nSet covariance of initial state.   void set_P0_m(const armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance.   void set_C(const armaMat \u0026amp; C)\nSet output matrix.   void set_d(const armaVec \u0026amp; d)\nSet output bias.   void Reset()\nReset system variables.   void Print()\nPrint system variables to stdout.    Public Attributes inherited from lds::System\n    Name     bool do_adapt_m whether to adaptively estimate disturbance m    Protected Attributes inherited from lds::System\n    Name     std::size_t n_x_ number of states   std::size_t n_u_ number of inputs   std::size_t n_y_ number of outputs   data_t dt_ sample period   armaVec x_ state   armaMat P_ covariance of state estimate   armaVec m_ process disturbance   armaMat P_m_ covariance of disturbance estimate   armaVec cx_ C*x.   armaVec y_ output   armaVec z_ measurement   armaVec x0_ initial state   armaMat P0_ covariance of initial state estimate   armaVec m0_ initial process disturbance   armaMat P0_m_ covariance of initial disturbance est.   armaMat A_ state matrix   armaMat B_ input matrix   armaVec g_ input gain   armaMat Q_ covariance of process noise   armaMat Q_m_ covariance of disturbance random walk   armaMat C_ output matrix   armaVec d_ output bias   armaMat Ke_ estimator gain   armaMat Ke_m_ estimator gain for process disturbance      Public Function Details #  System #  System() =default  System #  System( std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0 ) Parameters:\n n_u number of inputs n_x number of states n_y number of outputs dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q)   Simulate #  virtual const armaVec \u0026amp; Simulate( const armaVec \u0026amp; u_tm1 ) override Parameters:\n u_tm1 input at t-1  Return: z measurement\nReimplements: lds::System::Simulate\nSimulate system and produce measurement\n Protected Function Details #  h #  inline virtual void h() override Reimplements: lds::System::h\n RecurseKe #  virtual void RecurseKe() override Reimplements: lds::System::RecurseKe\nRecursively recalculate estimator gain (Ke).\nReferences:\nSmith AC, Brown EN. (2003) Estimating a State-Space Model from Point Process Observations. Neural Computation 15.\nEden UT, \u0026hellip;, Brown EN. (2004) Dynamic Analysis of Neural Encoding by Point Process Adaptive Filtering Neural Computation 16.\n  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':43,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_switched_controller/','title':"lds::SwitchedController",'section':"Classes",'content':"lds::SwitchedController #  SwitchedController Type. More\u0026hellip;\n\n#include \u0026lt;lds_sctrl.h\u0026gt;\nInherits from lds::Controller\u0026lt; System \u0026gt;\nInherited by lds::gaussian::SwitchedController, lds::poisson::SwitchedController\nPublic Functions #      Name      SwitchedController() =default    SwitchedController(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController.    SwitchedController(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController (moves systems).   void Switch(size_t idx)\nSwitch to a different sub-system/controller.   void set_Kc(const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc)   void set_Kc(std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc)   void set_Kc_inty(const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc_inty)   void set_Kc_inty(std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc_inty)   void set_Kc_u(const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc_u)   void set_Kc_u(std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc_u)   void set_g_design(const std::vector\u0026lt; armaVec \u0026gt; \u0026amp; g)   void set_g_design(std::vector\u0026lt; armaVec \u0026gt; \u0026amp;\u0026amp; g)    Protected Attributes #      Name     std::vector\u0026lt; System \u0026gt; systems_ underlying sub-systems which are switched between   size_t n_sys_ number of systems   size_t idx_ current system/controller index.   std::vector\u0026lt; armaMat \u0026gt; Kc_vec_   std::vector\u0026lt; armaMat \u0026gt; Kc_inty_vec_   std::vector\u0026lt; armaMat \u0026gt; Kc_u_vec_   std::vector\u0026lt; armaVec \u0026gt; g_design_vec_    Additional inherited members #  Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const armaVec \u0026amp; Control(const armaVec \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const armaVec \u0026amp; ControlOutputReference(const armaVec \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const armaMat \u0026amp; Kc() const\nGet state feedback controller gain.   const armaMat \u0026amp; Kc_inty() const\nGet integral controller gain.   const armaMat \u0026amp; Kc_u() const\nGet input feedback controller gain.   const armaVec \u0026amp; g_design() const\nGet input gain used in controller design.   const armaVec \u0026amp; u_ref() const\nGet reference input.   const armaVec \u0026amp; x_ref() const\nGet reference state.   const armaVec \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_u_ref(const armaVec \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const armaVec \u0026amp; x_ref)\nSet reference state (x_ref)   virtual void set_y_ref(const armaVec \u0026amp; y_ref)\nSet reference output (y_ref)   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   armaVec u_ control signal   armaVec g_design_ input gain of the system used for controller design   armaVec u_ref_ reference input   armaVec u_ref_prev_ reference input at previous time step   armaVec x_ref_ reference state   armaVec y_ref_ reference output   armaVec cx_ref_   armaMat Kc_ state controller gain   armaMat Kc_u_ input controller gain (optional when control updates \\deltaU)   armaMat Kc_inty_ integral controller gain   armaVec du_ref_   armaVec dv_ref_   armaVec v_ref_   armaVec dv_   armaVec v_ Control after g inversion (e.g., control in physical units)   armaVec int_e_ integrated error   armaVec int_e_awu_adjust_ anti-windup adjustment to intE   armaVec u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type    Detailed Description #  template \u0026lt;typename System \u0026gt; class lds::SwitchedController;   Public Function Details #  SwitchedController #  SwitchedController() =default  SwitchedController #  inline SwitchedController( const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\n systems vector of sub-systems u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask   SwitchedController #  inline SwitchedController( std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\n systems vector of sub-systems u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask   Switch #  inline void Switch( size_t idx ) Parameters:\n idx index   set_Kc #  inline void set_Kc( const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc )  set_Kc #  inline void set_Kc( std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc )  set_Kc_inty #  inline void set_Kc_inty( const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc_inty )  set_Kc_inty #  inline void set_Kc_inty( std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc_inty )  set_Kc_u #  inline void set_Kc_u( const std::vector\u0026lt; armaMat \u0026gt; \u0026amp; Kc_u )  set_Kc_u #  inline void set_Kc_u( std::vector\u0026lt; armaMat \u0026gt; \u0026amp;\u0026amp; Kc_u )  set_g_design #  inline void set_g_design( const std::vector\u0026lt; armaVec \u0026gt; \u0026amp; g )  set_g_design #  inline void set_g_design( std::vector\u0026lt; armaVec \u0026gt; \u0026amp;\u0026amp; g )  Protected Attribute Details #  **systems_** #  std::vector\u0026lt; System \u0026gt; systems_;  **n_sys_** #  size_t n_sys_ {};  **idx_** #  size_t idx_ {};  **Kc_vec_** #  std::vector\u0026lt; armaMat \u0026gt; Kc_vec_;  **Kc_inty_vec_** #  std::vector\u0026lt; armaMat \u0026gt; Kc_inty_vec_;  **Kc_u_vec_** #  std::vector\u0026lt; armaMat \u0026gt; Kc_u_vec_;  **g_design_vec_** #  std::vector\u0026lt; armaVec \u0026gt; g_design_vec_;   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':44,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_system/','title':"lds::System",'section':"Classes",'content':"lds::System #  Linear Dynamical System Type. #include \u0026lt;lds_sys.h\u0026gt;\nInherited by lds::gaussian::System, lds::poisson::System\nPublic Functions #      Name      System() =default    System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0)   void Filter(const armaVec \u0026amp; u_tm1, const armaVec \u0026amp; z)\nFilter data to produce causal state estimates.   virtual const armaVec \u0026amp; Simulate(const armaVec \u0026amp; u_tm1) =0\nsimulates system   void f(const armaVec \u0026amp; u, bool do_add_noise =false)\nsystem dynamics function   virtual void h() =0\nsystem output function   size_t n_u() const\nGet number of inputs.   size_t n_x() const\nGet number of states.   size_t n_y() const\nGet number of outputs.   data_t dt() const\nGet sample period.   const armaVec \u0026amp; x() const\nGet current state.   const armaMat \u0026amp; P() const\nGet covariance of state estimate.   const armaVec \u0026amp; m() const\nGet current process disturbance/bias.   const armaMat \u0026amp; P_m() const\nGet covariance of process disturbance estimate.   const armaVec \u0026amp; cx() const\nGet C*x.   const armaVec \u0026amp; y() const\nGet output.   const armaVec \u0026amp; x0() const\nGet initial state.   const armaVec \u0026amp; m0() const\nGet initial disturbance.   const armaMat \u0026amp; A() const\nGet state matrix.   const armaMat \u0026amp; B() const\nGet input matrix.   const armaVec \u0026amp; g() const\nGet input gain/conversion factor.   const armaMat \u0026amp; C() const\nGet output matrix.   const armaVec \u0026amp; d() const\nGet output bias.   const armaMat \u0026amp; Ke() const\nGet estimator gain.   const armaMat \u0026amp; Ke_m() const\nGet estimator gain for process disturbance (m)   void set_A(const armaMat \u0026amp; A)\nSet state matrix.   void set_B(const armaMat \u0026amp; B)\nSet input matrix.   void set_m(const armaVec \u0026amp; m)\nSet process disturbance.   void set_g(const armaVec \u0026amp; g)\nSet input gain.   void set_Q(const armaMat \u0026amp; Q)\nSet process noise covariance.   void set_Q_m(const armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation.   void set_x0(const armaVec \u0026amp; x0)\nSet initial state.   void set_P0(const armaMat \u0026amp; P0)\nSet covariance of initial state.   void set_P0_m(const armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance.   void set_C(const armaMat \u0026amp; C)\nSet output matrix.   void set_d(const armaVec \u0026amp; d)\nSet output bias.   void Reset()\nReset system variables.   void Print()\nPrint system variables to stdout.    Protected Functions #      Name     virtual void RecurseKe() =0\nRecursively recalculate estimator gain (Ke)    Public Attributes #      Name     bool do_adapt_m whether to adaptively estimate disturbance m    Protected Attributes #      Name     std::size_t n_x_ number of states   std::size_t n_u_ number of inputs   std::size_t n_y_ number of outputs   data_t dt_ sample period   armaVec x_ state   armaMat P_ covariance of state estimate   armaVec m_ process disturbance   armaMat P_m_ covariance of disturbance estimate   armaVec cx_ C*x.   armaVec y_ output   armaVec z_ measurement   armaVec x0_ initial state   armaMat P0_ covariance of initial state estimate   armaVec m0_ initial process disturbance   armaMat P0_m_ covariance of initial disturbance est.   armaMat A_ state matrix   armaMat B_ input matrix   armaVec g_ input gain   armaMat Q_ covariance of process noise   armaMat Q_m_ covariance of disturbance random walk   armaMat C_ output matrix   armaVec d_ output bias   armaMat Ke_ estimator gain   armaMat Ke_m_ estimator gain for process disturbance      Public Function Details #  System #  System() =default  System #  System( size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0 )  Filter #  void Filter( const armaVec \u0026amp; u_tm1, const armaVec \u0026amp; z ) Parameters:\n u_tm1 input at t-minus-1 z_t current measurement  Given current measurment and input, filter data to produce causal state estimates using Kalman filtering, which procedes by predicting the state and subsequently updating.\n Simulate #  virtual const armaVec \u0026amp; Simulate( const armaVec \u0026amp; u_tm1 ) =0 Parameters:\n u_tm1 input at time t-1  Return: simulated measurement at time t\nReimplemented by: lds::gaussian::System::Simulate, lds::poisson::System::Simulate\n f #  inline void f( const armaVec \u0026amp; u, bool do_add_noise =false ) Parameters:\n u input do_add_noise whether to add simulated process noise   h #  virtual void h() =0 Reimplemented by: lds::gaussian::System::h, lds::poisson::System::h\n n_u #  inline size_t n_u() const  n_x #  inline size_t n_x() const  n_y #  inline size_t n_y() const  dt #  inline data_t dt() const  x #  inline const armaVec \u0026amp; x() const  P #  inline const armaMat \u0026amp; P() const  m #  inline const armaVec \u0026amp; m() const  P_m #  inline const armaMat \u0026amp; P_m() const  cx #  inline const armaVec \u0026amp; cx() const  y #  inline const armaVec \u0026amp; y() const  x0 #  inline const armaVec \u0026amp; x0() const  m0 #  inline const armaVec \u0026amp; m0() const  A #  inline const armaMat \u0026amp; A() const  B #  inline const armaMat \u0026amp; B() const  g #  inline const armaVec \u0026amp; g() const  C #  inline const armaMat \u0026amp; C() const  d #  inline const armaVec \u0026amp; d() const  Ke #  inline const armaMat \u0026amp; Ke() const  Ke_m #  inline const armaMat \u0026amp; Ke_m() const  set_A #  inline void set_A( const armaMat \u0026amp; A )  set_B #  inline void set_B( const armaMat \u0026amp; B )  set_m #  inline void set_m( const armaVec \u0026amp; m )  set_g #  inline void set_g( const armaVec \u0026amp; g )  set_Q #  inline void set_Q( const armaMat \u0026amp; Q )  set_Q_m #  inline void set_Q_m( const armaMat \u0026amp; Q_m )  set_x0 #  inline void set_x0( const armaVec \u0026amp; x0 )  set_P0 #  inline void set_P0( const armaMat \u0026amp; P0 )  set_P0_m #  inline void set_P0_m( const armaMat \u0026amp; P0_m )  set_C #  inline void set_C( const armaMat \u0026amp; C )  set_d #  inline void set_d( const armaVec \u0026amp; d )  Reset #  void Reset()  Print #  void Print()  Protected Function Details #  RecurseKe #  virtual void RecurseKe() =0 Reimplemented by: lds::gaussian::System::RecurseKe, lds::poisson::System::RecurseKe\n Public Attribute Details #  do_adapt_m #  bool do_adapt_m {};  Protected Attribute Details #  **n_x_** #  std::size_t n_x_ {};  **n_u_** #  std::size_t n_u_ {};  **n_y_** #  std::size_t n_y_ {};  **dt_** #  data_t dt_ {};  **x_** #  armaVec x_;  **P_** #  armaMat P_;  **m_** #  armaVec m_;  **P_m_** #  armaMat P_m_;  **cx_** #  armaVec cx_;  **y_** #  armaVec y_;  **z_** #  armaVec z_;  **x0_** #  armaVec x0_;  **P0_** #  armaMat P0_;  **m0_** #  armaVec m0_;  **P0_m_** #  armaMat P0_m_;  **A_** #  armaMat A_;  **B_** #  armaMat B_;  **g_** #  armaVec g_;  **Q_** #  armaMat Q_;  **Q_m_** #  armaMat Q_m_;  **C_** #  armaMat C_;  **d_** #  armaVec d_;  **Ke_** #  armaMat Ke_;  **Ke_m_** #  armaMat Ke_m_;   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':45,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_vector/','title':"lds::Vector",'section':"Classes",'content':"lds::Vector #  Inherits from arma::Col\u0026lt; data_t \u0026gt;\n   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':46,'href':'/ldsctrlest/docs/api/files/dir_2755d76cbd49ca86cc5d9263eb253d5e/','title':"ldsCtrlEst_h",'section':"Files",'content':"ldsCtrlEst_h #  Files #     Name     ldsCtrlEst_h/lds.h lds namespace   ldsCtrlEst_h/lds_ctrl.h Controller.   ldsCtrlEst_h/lds_fit.h LDS base fit type.   ldsCtrlEst_h/lds_gaussian.h glds namespace   ldsCtrlEst_h/lds_gaussian_ctrl.h GLDS Controller.   ldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type.   ldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type.   ldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type.   ldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type.   ldsCtrlEst_h/lds_gaussian_sys.h GLDS base type.   ldsCtrlEst_h/lds_poisson.h plds namespace   ldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type.   ldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type.   ldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type.   ldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type.   ldsCtrlEst_h/lds_poisson_sys.h PLDS base type.   ldsCtrlEst_h/lds_sctrl.h SwitchedController type.   ldsCtrlEst_h/lds_sys.h LDS base type.   ldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API)   ldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API)     Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':47,'href':'/ldsctrlest/docs/api/files/lds_8h/','title':"ldsCtrlEst_h/lds.h",'section':"Files",'content':"ldsCtrlEst_h/lds.h #  lds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::Vector   class lds::Matrix    Detailed Description #  This file defines the lds namespace, which will be an umbrella for linear dynamical systems with Gaussian ([lds::gaussian](/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/)) or Poisson ([lds::poisson](/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/)) observations.\nSource code #  //===-- ldsCtrlEst_h/lds.h - Linear Dynmical System Namespace ---*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_H #define LDSCTRLEST_LDS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { using data_t = double; namespace fill = arma::fill; using stdVec = std::vector\u0026lt;data_t\u0026gt;; using armaVec = arma::Col\u0026lt;data_t\u0026gt;; using armaMat = arma::Mat\u0026lt;data_t\u0026gt;; using armaCube = arma::Cube\u0026lt;data_t\u0026gt;; using armaSubVec = arma::subview_col\u0026lt;data_t\u0026gt;; using armaSubMat = arma::subview\u0026lt;data_t\u0026gt;; static const std::size_t kControlTypeDeltaU = 0x1; static const std::size_t kControlTypeIntY = kControlTypeDeltaU \u0026lt;\u0026lt; 1; static const std::size_t kControlTypeAdaptM = kControlTypeDeltaU \u0026lt;\u0026lt; 2; static const data_t kInf = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(); static const data_t kPi = arma::datum::pi; static const data_t kDefaultP0 = 1e-6; static const data_t kDefaultQ0 = 1e-6; static const data_t kDefaultR0 = 1e-2; static std::vector\u0026lt;data_t\u0026gt; kDefaultT0 = std::vector\u0026lt;data_t\u0026gt;(1, 0.0); enum SSIDWt { kNONE, kMOESP, kCVA }; void Limit(stdVec\u0026amp; x, data_t lb, data_t ub); void Limit(armaVec\u0026amp; x, data_t lb, data_t ub); void Limit(armaMat\u0026amp; x, data_t lb, data_t ub); class Vector: arma::Col\u0026lt;data_t\u0026gt; { // get all the constructors.  using arma::Col\u0026lt;data_t\u0026gt;::Col; }; class Matrix: arma::Mat\u0026lt;data_t\u0026gt; { // get all the constructors.  using arma::Mat\u0026lt;data_t\u0026gt;::Mat; }; } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':48,'href':'/ldsctrlest/docs/api/files/lds__ctrl_8h/','title':"ldsCtrlEst_h/lds_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_ctrl.h #  Controller. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::Controller    Detailed Description #  This file declares the type for control of a linear dynamical system (lds::Controller).\nSource code #  //===-- ldsCtrlEst_h/lds_control.h - Controller --------------------*- C++ //-*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_CTRL_H #define LDSCTRLEST_LDS_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  // namespace #include \u0026#34;lds.h\u0026#34;// system type #include \u0026#34;lds_sys.h\u0026#34; namespace lds { template \u0026lt;typename System\u0026gt; class Controller { static_assert(std::is_base_of\u0026lt;lds::System, System\u0026gt;::value, \u0026#34;System must be derived from lds::System type.\u0026#34;); public: Controller() = default; Controller(const System\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type = 0); Controller(System\u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type = 0); const armaVec\u0026amp; Control(const armaVec\u0026amp; z, bool do_control = true, bool do_lock_control = false, data_t sigma_soft_start = 0, data_t sigma_u_noise = 0, bool do_reset_at_control_onset = true); const armaVec\u0026amp; ControlOutputReference( const armaVec\u0026amp; z, bool do_control = true, bool do_estimation = true, bool do_lock_control = false, data_t sigma_soft_start = 0, data_t sigma_u_noise = 0, bool do_reset_at_control_onset = true); // get methods:  const System\u0026amp; sys() const { return sys_; }; const armaMat\u0026amp; Kc() const { return Kc_; }; const armaMat\u0026amp; Kc_inty() const { return Kc_inty_; }; const armaMat\u0026amp; Kc_u() const { return Kc_u_; }; const armaVec\u0026amp; g_design() const { return g_design_; }; const armaVec\u0026amp; u_ref() const { return u_ref_; }; const armaVec\u0026amp; x_ref() const { return x_ref_; }; const armaVec\u0026amp; y_ref() const { return y_ref_; }; size_t control_type() const { return control_type_; }; // set methods  void set_sys(const System\u0026amp; sys) { // TODO(mfbolus): insert check for dimensionality. Otherwise, either throw  // exception or reset dimensionality of controller vars.  sys_ = sys; }; void set_g_design(const armaVec\u0026amp; g_design) { g_design_ = g_design; }; void set_u_ref(const armaVec\u0026amp; u_ref) { u_ref_ = u_ref; }; void set_x_ref(const armaVec\u0026amp; x_ref) { x_ref_ = x_ref; cx_ref_ = sys_.C() * x_ref_; }; // y_ref needs to be handled differently depending on output fn.  // (need to populate cx_ref_ too, which depends on output fn)  virtual void set_y_ref(const armaVec\u0026amp; y_ref) { y_ref_ = y_ref; }; void set_Kc(const armaMat\u0026amp; Kc) { Kc_ = Kc; }; void set_Kc_inty(const armaMat\u0026amp; Kc_inty) { Kc_inty_ = Kc_inty; }; void set_Kc_u(const armaMat\u0026amp; Kc_u) { Kc_u_ = Kc_u; }; void set_tau_awu(data_t tau) { tau_awu_ = tau; k_awu_ = sys_.dt() / tau_awu_; }; void set_control_type(size_t control_type); void Reset() { sys_.Reset(); u_ref_.zeros(); u_ref_prev_.zeros(); int_e_.zeros(); int_e_awu_adjust_.zeros(); u_sat_.zeros(); u_saturated_ = false; t_since_control_onset_ = 0.0; }; void Print() { sys_.Print(); std::cout \u0026lt;\u0026lt; \u0026#34;g_design : \u0026#34; \u0026lt;\u0026lt; g_design_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;u_lb : \u0026#34; \u0026lt;\u0026lt; u_lb_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;u_ub : \u0026#34; \u0026lt;\u0026lt; u_ub_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; protected: System sys_; armaVec u_; armaVec g_design_; // reference signals  armaVec u_ref_; // create no set method for this:  armaVec u_ref_prev_; armaVec x_ref_; armaVec y_ref_; armaVec cx_ref_; // Controller gains  armaMat Kc_; armaMat Kc_u_; armaMat Kc_inty_; // control after g inversion  // do not need set methods for these.  armaVec du_ref_; armaVec dv_ref_; armaVec v_ref_; armaVec dv_; armaVec v_; // integral error  // do not need set method for this  armaVec int_e_; armaVec int_e_awu_adjust_; armaVec u_sat_; bool do_control_prev_{}; bool do_lock_control_prev_{}; // whether the g of system has become inverted from what you think it is  // (gain_ref)  bool u_saturated_{}; // should be safe to have references here bc nothing needs to be done  // (like reset vars) when it changes...  data_t u_lb_{}; data_t u_ub_{}; data_t tau_awu_{}; data_t k_awu_{}; data_t t_since_control_onset_{}; size_t control_type_{}; private: void CalcControl(bool do_control = true, bool do_estimation = true, bool do_lock_control = false, data_t sigma_soft_start = 0, data_t sigma_u_noise = 0, bool do_reset_at_control_onset = true); void CalcSteadyStateSetPoint(); void AntiWindup(); void InitVars(); }; // Implement the above:  template \u0026lt;typename System\u0026gt; inline Controller\u0026lt;System\u0026gt;::Controller(const System\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type) : sys_(sys), u_lb_(u_lb), u_ub_(u_ub), control_type_(control_type), do_control_prev_(false), do_lock_control_prev_(false), u_saturated_(false), tau_awu_(lds::kInf), k_awu_(0), t_since_control_onset_(0) { InitVars(); } template \u0026lt;typename System\u0026gt; inline Controller\u0026lt;System\u0026gt;::Controller(System\u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type) : sys_(std::move(sys)), u_lb_(u_lb), u_ub_(u_ub), control_type_(control_type), do_control_prev_(false), do_lock_control_prev_(false), u_saturated_(false), tau_awu_(lds::kInf), k_awu_(0), t_since_control_onset_(0) { InitVars(); } template \u0026lt;typename System\u0026gt; inline void Controller\u0026lt;System\u0026gt;::set_control_type(size_t control_type) { if (control_type_ == control_type) { return; } // creating a blank slate...  control_type_ = 0; Kc_inty_.zeros(0, 0); Kc_u_.zeros(0, 0); int_e_.zeros(0, 0); int_e_awu_adjust_.zeros(0, 0); // controller was designed to minimize integral error  if (control_type \u0026amp; kControlTypeIntY) { Kc_inty_.zeros(sys_.n_u(), sys_.n_y()); int_e_.zeros(sys_.n_y()); int_e_awu_adjust_.zeros(sys_.n_u()); control_type_ = control_type_ | kControlTypeIntY; } // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (control_type \u0026amp; kControlTypeDeltaU) { Kc_u_.zeros(sys_.n_u(), sys_.n_u()); control_type_ = control_type_ | kControlTypeDeltaU; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (control_type \u0026amp; kControlTypeAdaptM) { if (sys_.do_adapt_m) // only if adapting m...  { control_type_ = control_type_ | kControlTypeAdaptM; } } } // set_control_type  template \u0026lt;typename System\u0026gt; inline const armaVec\u0026amp; Controller\u0026lt;System\u0026gt;::Control( const armaVec\u0026amp; z, bool do_control, bool do_lock_control, data_t sigma_soft_start, data_t sigma_u_noise, bool do_reset_at_control_onset) { // update state estimates, given latest measurement  sys_.Filter(u_, z); bool do_estimation = true; // always have estimator on in this case  // calculate control signal  CalcControl(do_control, do_estimation, do_lock_control, sigma_soft_start, sigma_u_noise, do_reset_at_control_onset); return u_; } template \u0026lt;typename System\u0026gt; inline const armaVec\u0026amp; Controller\u0026lt;System\u0026gt;::ControlOutputReference( const armaVec\u0026amp; z, bool do_control, bool do_estimation, bool do_lock_control, data_t sigma_soft_start, data_t sigma_u_noise, bool do_reset_at_control_onset) { // update state estimates, given latest measurement  if (do_estimation) { sys_.Filter(u_, z); } else { sys_.f(u_); } // calculate the set point  // solves for u_ref and x_ref when output is at y_ref at steady state.  if (do_control) { CalcSteadyStateSetPoint(); } // calculate control signal  CalcControl(do_control, do_estimation, do_lock_control, sigma_soft_start, sigma_u_noise, do_reset_at_control_onset); return u_; } template \u0026lt;typename System\u0026gt; inline void Controller\u0026lt;System\u0026gt;::CalcControl(bool do_control, bool do_estimation, bool do_lock_control, data_t sigma_soft_start, data_t sigma_u_noise, bool do_reset_at_control_onset) { if (do_control \u0026amp;\u0026amp; do_estimation) { if (!do_control_prev_) { if (do_reset_at_control_onset) { Reset(); } t_since_control_onset_ = 0.0; } else { t_since_control_onset_ += sys_.dt(); } // enforce softstart on control vars.  if (sigma_soft_start \u0026gt; 0) { // half-Gaussian soft-start scaling factor  data_t soft_start_sf = 1 - exp(-pow(t_since_control_onset_, 2) / (2 * pow(sigma_soft_start, 2))); u_ref_ *= soft_start_sf; // TODO(mfbolus): May be appropriate to soft-start x_ref, y_ref too  // x_ref_ *= soft_start_sf;  // cx_ref_ *= soft_start_sf;  // y_ref_ *= soft_start_sf;  } if (!do_lock_control) { du_ref_ = u_ref_ - u_ref_prev_; // first do u -\u0026gt; v change of vars. (v = g.*u)  // e.g., convert into physical units (e.g., v[=] mW/mm2 rather than driver  // control voltage u[=]V)  v_ref_ = g_design_ % u_ref_; dv_ref_ = g_design_ % du_ref_; // Given FB, calc. the change in control  if (control_type_ \u0026amp; kControlTypeDeltaU) { // if control designed to minimize not u but deltaU (i.e. state aug with  // u):  dv_ = dv_ref_; // nominally-optimal.  dv_ -= Kc_ * (sys_.x() - x_ref_); // instantaneous state error  dv_ -= Kc_u_ * (v_ - v_ref_); // penalty on amp u (rel to ref)  if (control_type_ \u0026amp; kControlTypeIntY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if(!uSaturated)  int_e_ += (sys_.cx() - cx_ref_) * sys_.dt(); // integrated error  dv_ -= Kc_inty_ * int_e_; // control for integrated error  } // update the control  v_ += dv_; } else { v_ = v_ref_; // nominally-optimal.  v_ -= Kc_ * (sys_.x() - x_ref_); // instantaneous state error  if (control_type_ \u0026amp; kControlTypeIntY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if (!uSaturated)  int_e_ += (sys_.cx() - cx_ref_) * sys_.dt(); // integrated error  v_ -= Kc_inty_ * int_e_; // control for integrated error  } } // convert back to control voltage u[=]V  u_ = v_ / sys_.g(); } // else do nothing until lock is low  // It may be desireable to make inputs more variable.  if (sigma_u_noise \u0026gt; 0.0) { u_ += sigma_u_noise * armaVec(sys_.n_u(), fill::randn); }; } else { // if not control  // feed through u_ref in open loop  u_ = u_ref_ % g_design_ / sys_.g(); u_ref_.zeros(); int_e_.zeros(); int_e_awu_adjust_.zeros(); u_sat_.zeros(); } // ends do_control  // enforce box constraints (and antiwindup)  AntiWindup(); do_control_prev_ = do_control; do_lock_control_prev_ = do_lock_control; } // CalcControl  template \u0026lt;typename System\u0026gt; inline void Controller\u0026lt;System\u0026gt;::CalcSteadyStateSetPoint() { // Linearly-constrained least squares (ls).  //  // _reference:  // Boyd \u0026amp; Vandenberghe (2018) Introduction to Applied Linear Algebra  //  armaMat a_ls = join_horiz(sys_.C(), armaMat(sys_.n_y(), sys_.n_u(), fill::zeros)); armaVec b_ls = cx_ref_; armaMat c_ls = join_horiz(sys_.A() - armaMat(sys_.n_x(), sys_.n_x(), fill::eye), sys_.B() * arma::diagmat(sys_.g())); armaVec d_ls = -sys_.m0(); if (control_type_ \u0026amp; kControlTypeAdaptM) { d_ls = -sys_.m(); // adapt setpoint calc with disturbance?  } armaMat a_ls_t = a_ls.t(); // TODO(mfbolus): not sure why but causes seg  // fault if I do not do this.  armaMat phi_ls = join_vert(join_horiz(2 * a_ls_t * a_ls, c_ls.t()), join_horiz(c_ls, armaMat(sys_.n_x(), sys_.n_x(), fill::zeros))); // TODO(mfbolus): should be actual inverse, rather than pseudo-inverse:  armaMat inv_phi = pinv(phi_ls); armaVec xulam = inv_phi * join_vert(2 * a_ls_t * b_ls, d_ls); x_ref_ = xulam.subvec(0, sys_.n_x() - 1); u_ref_ = xulam.subvec(sys_.n_x(), sys_.n_x() + sys_.n_u() - 1); cx_ref_ = sys_.C() * x_ref_; } // CalcSteadyStateSetPoint  template \u0026lt;typename System\u0026gt; void Controller\u0026lt;System\u0026gt;::AntiWindup() { u_saturated_ = false; u_sat_ = u_; // limit u and flag whether saturated  for (size_t k = 0; k \u0026lt; u_.n_elem; k++) { if (u_[k] \u0026lt; u_lb_) { u_sat_[k] = u_lb_; u_saturated_ = true; } if (u_[k] \u0026gt; u_ub_) { u_sat_[k] = u_ub_; u_saturated_ = true; } } if ((control_type_ \u0026amp; kControlTypeIntY) \u0026amp;\u0026amp; (tau_awu_ \u0026lt; lds::kInf)) { // one-step back-calculation (calculate intE for u=u_sat)  // (Astroem, Rundqwist 1989 warn against using this...)  // int_e_awu_adjust_ =  // solve(Kc_inty_, (u_ - u_sat_)); // pinv(Kc_inty) * (u-uSat);  // gradual: see Astroem, Rundqwist 1989  // this is a fudge for doing MIMO gradual  // n.b., went ahead and multiplied 1/T by dt so don\u0026#39;t have to do that here.  int_e_awu_adjust_ = k_awu_ * (sign(Kc_inty_).t() / sys_.n_u()) * (u_ - u_sat_); // int_e_awu_adjust_ = k_awu_ * (u_-u_sat_);  int_e_ += int_e_awu_adjust_; } // set u to saturated version  u_ = u_sat_; } template \u0026lt;typename System\u0026gt; void Controller\u0026lt;System\u0026gt;::InitVars() { // initialize to default values  u_ref_ = armaVec(sys_.n_u(), fill::zeros); u_ref_prev_ = armaVec(sys_.n_u(), fill::zeros); x_ref_ = armaVec(sys_.n_x(), fill::zeros); y_ref_ = armaVec(sys_.n_y(), fill::zeros); u_ = armaVec(sys_.n_u(), fill::zeros); u_sat_ = armaVec(sys_.n_u(), fill::zeros); // Might not need all these, so zero elements until later.  Kc_ = armaMat(sys_.n_u(), sys_.n_x(), fill::zeros); Kc_u_ = armaMat(0, 0, fill::zeros); Kc_inty_ = armaMat(0, 0, fill::zeros); g_design_ = sys_.g(); // by default, same as model  dv_ = armaVec(sys_.n_u(), fill::zeros); v_ = armaVec(sys_.n_u(), fill::zeros); du_ref_ = armaVec(sys_.n_u(), fill::zeros); dv_ref_ = armaVec(sys_.n_u(), fill::zeros); v_ref_ = armaVec(sys_.n_u(), fill::zeros); int_e_ = armaVec(0, fill::zeros); int_e_awu_adjust_ = armaVec(0, fill::zeros); set_control_type(control_type_); } } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':49,'href':'/ldsctrlest/docs/api/files/lds__fit_8h/','title':"ldsCtrlEst_h/lds_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_fit.h #  LDS base fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::fit_t LDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a linear dynamical system. It is expounded upon by variants with Gaussian and Poisson observation assumptions for fitting.\nSource code #  //===-- ldsCtrlEst_h/lds_fit.h - Fit Type for LDS ---------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDS_FIT_HPP #define LDS_FIT_HPP  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  // namespace #include \u0026#34;lds.h\u0026#34; namespace lds { class fit_t { public: fit_t(){}; fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, data_t\u0026amp; dt); // Dynamics  armaMat A; armaMat B; armaVec g; armaVec m; armaMat Q; armaVec x0; armaMat P0; data_t dt; }; } // namespace lds #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':50,'href':'/ldsctrlest/docs/api/files/lds__gaussian_8h/','title':"ldsCtrlEst_h/lds_gaussian.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian.h #  glds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Detailed Description #  This file declares and partially defines the namespace for linear dynamical systems with Gaussian observations ([lds::gaussian](/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian.h - LDS with Gaussian Output --*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_H #define LDSCTRLEST_LDS_GAUSSIAN_H  // namespace #include \u0026#34;lds.h\u0026#34; #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { // insert any Gaussian-specific things here... } // namespace gaussian } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':51,'href':'/ldsctrlest/docs/api/files/lds__gaussian__ctrl_8h/','title':"ldsCtrlEst_h/lds_gaussian_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_ctrl.h #  GLDS Controller. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::Controller Gaussian-observation Controller Type.    Detailed Description #  This file declares and partially defines the type for control of a gaussian-observation linear dynamical system (lds::gaussian::Controller). It inherits functionality from the underlying GLDS model type (lds::gaussian::System), including state estimation.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_ctrl.h - GLDS Controller ------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_CTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  // namespace #include \u0026#34;lds_gaussian.h\u0026#34;// system #include \u0026#34;lds_gaussian_sys.h\u0026#34;// controller #include \u0026#34;lds_ctrl.h\u0026#34; namespace lds { namespace gaussian { class Controller : lds::Controller\u0026lt;System\u0026gt; { public: void set_y_ref(const armaVec\u0026amp; y_ref) override { y_ref_ = y_ref; cx_ref_ = y_ref - sys_.d(); }; // make sure base class template methods available  using lds::Controller\u0026lt;System\u0026gt;::Controller; using lds::Controller\u0026lt;System\u0026gt;::Control; using lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference; using lds::Controller\u0026lt;System\u0026gt;::sys; using lds::Controller\u0026lt;System\u0026gt;::Kc; using lds::Controller\u0026lt;System\u0026gt;::Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::Kc_u; using lds::Controller\u0026lt;System\u0026gt;::g_design; using lds::Controller\u0026lt;System\u0026gt;::u_ref; using lds::Controller\u0026lt;System\u0026gt;::x_ref; using lds::Controller\u0026lt;System\u0026gt;::y_ref; using lds::Controller\u0026lt;System\u0026gt;::control_type; using lds::Controller\u0026lt;System\u0026gt;::set_sys; using lds::Controller\u0026lt;System\u0026gt;::set_g_design; using lds::Controller\u0026lt;System\u0026gt;::set_u_ref; using lds::Controller\u0026lt;System\u0026gt;::set_x_ref; using lds::Controller\u0026lt;System\u0026gt;::set_y_ref; using lds::Controller\u0026lt;System\u0026gt;::set_Kc; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_u; using lds::Controller\u0026lt;System\u0026gt;::set_tau_awu; using lds::Controller\u0026lt;System\u0026gt;::set_control_type; using lds::Controller\u0026lt;System\u0026gt;::Reset; using lds::Controller\u0026lt;System\u0026gt;::Print; }; } // namespace gaussian } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':52,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit.h #  GLDS fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::fit_t GLDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit.h - Fit Type for GLDS -----*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  // namespace #include \u0026#34;lds_gaussian.h\u0026#34;// fit type #include \u0026#34;lds_fit.h\u0026#34; namespace lds { namespace gaussian { class fit_t : public lds::fit_t { public: fit_t(){}; fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaMat\u0026amp; D, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); // Output  armaMat C; armaMat D; armaVec d; armaMat R; // input/output training data  std::vector\u0026lt;armaMat\u0026gt; uTrain; std::vector\u0026lt;armaMat\u0026gt; zTrain; }; }; // namespace gaussian } // namespace lds #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':53,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit__em_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit_em.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit_em.h #  GLDS E-M fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::emFit_t GLDS E-M Fit Type.    Detailed Description #  This file declares and partially defines a type by which Gaussian-output LDS models are fit by the expectation-maximization (EM) algorithm ([lds::gaussian::emFit_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1em_fit__t/)).\nReferences: [1] Shumway RH, Stoffer DS. (1982) An Approach to Time Series Smoothing and Forecasting Using the EM Algorithm.Journal of Time Series Analysis 3(2).\n[2] Ghahramani Z, Hinton GE. (1996) Parameter Estimation for Linear Dynamical Systems. Technical Report CRG-TR-96-2.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit_em.h - GLDS Fit (EM) ------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;lds_gaussian_fit.h\u0026#34; namespace lds { namespace gaussian { class emFit_t : public fit_t { public: emFit_t() : fit_t(){}; emFit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); emFit_t(data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); emFit_t(ssidFit_t\u0026amp; fit0); void reset(void); void runEM(bool calcAB = true, bool calcQ = true, bool calcInitial = true, bool calcC = true, bool calcd = true, bool calcR = true); data_t tol = 1e-3; size_t maxIter = 100; // get methods  std::vector\u0026lt;armaMat\u0026gt; getX() { return xHat; }; std::vector\u0026lt;armaMat\u0026gt; getY() { return yHat; }; // these are covariances that can be useful to the end-user  armaMat get_sum_E_xu_tm1_xu_tm1() { return sum_E_xu_tm1_xu_tm1; }; armaMat get_sum_E_xu_t_xu_tm1() { return sum_E_xu_t_xu_tm1; }; armaMat get_sum_E_xu_t_xu_t() { return sum_E_xu_t_xu_t; }; size_t getT() { return T; }; void setY(std::vector\u0026lt;armaMat\u0026gt; yHat) { this-\u0026gt;yHat = yHat; }; protected: armaVec getTheta(); void kalmanFilt(); void kalmanSmooth(bool forceCommonInitial); void Estep(bool forceCommonInitial = false); void Mstep(bool calcAB = true, bool calcQ = true, bool calcInitial = false, bool calcC = false, bool calcd = false, bool calcR = true); std::vector\u0026lt;armaMat\u0026gt; xHat; std::vector\u0026lt;arma::Cube\u0026lt;data_t\u0026gt;\u0026gt; P; std::vector\u0026lt;armaMat\u0026gt; yHat; std::vector\u0026lt;arma::Cube\u0026lt;data_t\u0026gt;\u0026gt; P_t_tm1; armaMat sum_E_xu_t_xu_t; armaMat sum_E_xu_tm1_xu_tm1; armaMat sum_E_xu_t_xu_tm1; size_t T; }; emFit_t emFit_x_equals_y(std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain, data_t dt, std::size_t maxIter = 100, data_t tol = 1e-3, data_t q0 = 1e-6, bool calcAB = true, bool calcQ = true, bool calcR = true); }; // namespace gaussian } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':54,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit__ssid_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit_ssid.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit_ssid.h #  GLDS SSID fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::ssidFit_t GLDS SSID Fit Type.    Detailed Description #  This file declares and partially defines a type by which Gaussian-output LDS models are fit by a subspace identification (SSID) algorithm ([lds::gaussian::ssidFit_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ssid_fit__t/)).\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit_ssid.h - GLDS Fit (SSID) --*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;lds_gaussian_fit.h\u0026#34; namespace lds { namespace gaussian { class ssidFit_t : public fit_t { public: ssidFit_t() : fit_t(){}; ssidFit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaMat\u0026amp; D, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec\u0026amp; singVals, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); std::vector\u0026lt;data_t\u0026gt; t0; data_t t_startSSID; data_t t_stopSSID; armaVec singVals; }; ssidFit_t ssidFit(std::vector\u0026lt;armaMat\u0026gt;\u0026amp; u, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; z, data_t dt, size_t nX, size_t nH = 25, armaVec d0 = armaVec(1).fill(-kInf), bool force_unitNormC = false, SSIDWt wt = kNONE, data_t wtG0 = 0.0, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0 = kDefaultT0, data_t t_startSSID = -std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(), data_t t_stopSSID = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity()); armaVec calcD_silence(std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; u, data_t dt, data_t tSilence = 0.1, data_t threshSilence = 0.001); void createHankelMat_n4sid(armaMat\u0026amp; u, armaMat\u0026amp; z, std::size_t\u0026amp; nH, armaMat\u0026amp; D); void ssid_n4sid(std::size_t\u0026amp; nX, std::size_t\u0026amp; nU, std::size_t\u0026amp; nY, std::size_t\u0026amp; nH, armaMat\u0026amp; uSSID, armaMat\u0026amp; zSSID, armaMat\u0026amp; A, armaMat\u0026amp; B, armaMat\u0026amp; C, armaMat\u0026amp; D, armaMat\u0026amp; Q, armaMat\u0026amp; R, armaVec\u0026amp; m, armaVec\u0026amp; d, armaVec\u0026amp; s, bool force_unitNormC, SSIDWt wt, data_t wtG0); void ssid_n4sid_vanOverschee(std::size_t\u0026amp; nX, std::size_t\u0026amp; nU, std::size_t\u0026amp; nY, std::size_t\u0026amp; nH, armaMat\u0026amp; uSSID, armaMat\u0026amp; zSSID, armaMat\u0026amp; A, armaMat\u0026amp; B, armaMat\u0026amp; C, armaMat\u0026amp; D, armaMat\u0026amp; Q, armaMat\u0026amp; R, armaVec\u0026amp; s, SSIDWt wt); void recompute_extObs(armaMat\u0026amp; extObs, armaMat\u0026amp; A, armaMat\u0026amp; C, std::size_t\u0026amp; nY, std::size_t\u0026amp; nH); void lq(armaMat\u0026amp; L, armaMat\u0026amp; Qt, armaMat\u0026amp; X); armaMat calcCov(armaMat\u0026amp; A, armaMat\u0026amp; B); armaMat sqrtmat_svd(armaMat\u0026amp; X); } // namespace gaussian } // namespace lds #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':55,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sctrl_8h/','title':"ldsCtrlEst_h/lds_gaussian_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_sctrl.h #  GLDS switched controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::SwitchedController Gaussian-observation SwitchedController Type.    Detailed Description #  This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Gaussian-output linear dynamical systems (lds::gaussian::SwitchedController).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_sctrl.h - Switched Controller -*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  // controller type #include \u0026#34;lds_gaussian_ctrl.h\u0026#34;// switched controller #include \u0026#34;lds_sctrl.h\u0026#34; namespace lds { namespace gaussian { class SwitchedController : lds::SwitchedController\u0026lt;System\u0026gt; { public: void set_y_ref(const armaVec\u0026amp; y_ref) override { y_ref_ = y_ref; cx_ref_ = y_ref - sys_.d(); } // make sure base class template methods available  using lds::SwitchedController\u0026lt;System\u0026gt;::SwitchedController; using lds::SwitchedController\u0026lt;System\u0026gt;::Switch; using lds::SwitchedController\u0026lt;System\u0026gt;::Control; using lds::SwitchedController\u0026lt;System\u0026gt;::ControlOutputReference; using lds::SwitchedController\u0026lt;System\u0026gt;::sys; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::set_g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::set_u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::set_tau_awu; using lds::SwitchedController\u0026lt;System\u0026gt;::set_control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::Reset; using lds::SwitchedController\u0026lt;System\u0026gt;::Print; }; // SwitchedController } // namespace gaussian } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':56,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sys_8h/','title':"ldsCtrlEst_h/lds_gaussian_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_sys.h #  GLDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::System Gaussian LDS Type.    Detailed Description #  This file declares and partially defines the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems ([lds::gaussian::System](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_system/)). It inherits functionality from the underlying linear dynamical system ([lds::System](/ldsctrlest/docs/api/classes/classlds_1_1_system/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_sys.h - GLDS ------------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_SYS_H #define LDSCTRLEST_LDS_GAUSSIAN_SYS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  // namespace #include \u0026#34;lds_gaussian.h\u0026#34;// system #include \u0026#34;lds_sys.h\u0026#34; namespace lds { namespace gaussian { class System : public lds::System { public: System() = default; System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0, data_t r0 = kDefaultR0); const armaVec\u0026amp; Simulate(const armaVec\u0026amp; u_tm1) override; // get methods  const armaMat\u0026amp; R() const { return R_; }; // set methods  void set_Q(const armaMat\u0026amp; Q) { lds::System::set_Q(Q); do_recurse_Ke_ = true; } void set_R(const armaMat\u0026amp; R) { R_ = R; do_recurse_Ke_ = true; }; void set_Ke(const armaMat\u0026amp; Ke) { Ke_ = Ke; // if users have set Ke, they must not want to calculate it online.  do_recurse_Ke_ = false; }; void set_Ke_m(const armaMat\u0026amp; Ke_m) { Ke_m_ = Ke_m; // if users have set Ke, they must not want to calculate it online.  do_recurse_Ke_ = false; }; void Print(); protected: void h() override { cx_ = C_ * x_; y_ = cx_ + d_; }; void RecurseKe() override; // Gaussian-output-specific  armaMat R_; bool do_recurse_Ke_{}; }; // System } // namespace gaussian } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':57,'href':'/ldsctrlest/docs/api/files/lds__poisson_8h/','title':"ldsCtrlEst_h/lds_poisson.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson.h #  plds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Detailed Description #  This file declares and partially defines the namespace for linear dynamical systems with Poisson observations ([lds::poisson](/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson.h - LDS with Poisson Output ----*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_H #define LDSCTRLEST_LDS_POISSON_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;lds.h\u0026#34; namespace lds { namespace poisson { // insert any Poisson-specific things here... } // namespace poisson } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':58,'href':'/ldsctrlest/docs/api/files/lds__poisson__ctrl_8h/','title':"ldsCtrlEst_h/lds_poisson_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_ctrl.h #  PLDS controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::Controller PLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for feedback control of a Poisson-output linear dynamical system ([lds::poisson::Controller](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_controller/)). It inherits functionality from the underlying PLDS model type ([lds::poisson::System](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_system/)), including state estimation.\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_ctrl.h - PLDS Controller -------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_CTRL_H #define LDSCTRLEST_LDS_POISSON_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  // namespace #include \u0026#34;lds_poisson.h\u0026#34;// system type #include \u0026#34;lds_poisson_sys.h\u0026#34;// control type #include \u0026#34;lds_ctrl.h\u0026#34; namespace lds { namespace poisson { class Controller : lds::Controller\u0026lt;System\u0026gt; { public: void set_y_ref(const armaVec\u0026amp; y_ref) override { y_ref_ = y_ref; lds::Limit(y_ref_, kYRefLb, lds::kInf); cx_ref_ = log(y_ref_) - sys_.d(); }; // make sure base class template methods available  using lds::Controller\u0026lt;System\u0026gt;::Controller; using lds::Controller\u0026lt;System\u0026gt;::Control; using lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference; using lds::Controller\u0026lt;System\u0026gt;::sys; using lds::Controller\u0026lt;System\u0026gt;::Kc; using lds::Controller\u0026lt;System\u0026gt;::Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::Kc_u; using lds::Controller\u0026lt;System\u0026gt;::g_design; using lds::Controller\u0026lt;System\u0026gt;::u_ref; using lds::Controller\u0026lt;System\u0026gt;::x_ref; using lds::Controller\u0026lt;System\u0026gt;::y_ref; using lds::Controller\u0026lt;System\u0026gt;::control_type; using lds::Controller\u0026lt;System\u0026gt;::set_sys; using lds::Controller\u0026lt;System\u0026gt;::set_g_design; using lds::Controller\u0026lt;System\u0026gt;::set_u_ref; using lds::Controller\u0026lt;System\u0026gt;::set_x_ref; using lds::Controller\u0026lt;System\u0026gt;::set_y_ref; using lds::Controller\u0026lt;System\u0026gt;::set_Kc; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_u; using lds::Controller\u0026lt;System\u0026gt;::set_tau_awu; using lds::Controller\u0026lt;System\u0026gt;::set_control_type; using lds::Controller\u0026lt;System\u0026gt;::Reset; using lds::Controller\u0026lt;System\u0026gt;::Print; private: constexpr static const data_t kYRefLb = 1e-4; }; } // namespace poisson } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':59,'href':'/ldsctrlest/docs/api/files/lds__poisson__fit_8h/','title':"ldsCtrlEst_h/lds_poisson_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_fit.h #  PLDS base fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::fit_t PLDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_fit.h - Fit Type for PLDS ------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_FIT_H #define LDSCTRLEST_LDS_POISSON_FIT_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  // namespace #include \u0026#34;lds_poisson.h\u0026#34;// fit #include \u0026#34;lds_fit.h\u0026#34; namespace lds { namespace poisson { class fit_t : public lds::fit_t { public: fit_t(){}; fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); // Output  armaMat C; armaVec d; // input/output training data  std::vector\u0026lt;armaMat\u0026gt; uTrain; std::vector\u0026lt;armaMat\u0026gt; zTrain; }; }; // namespace poisson } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':60,'href':'/ldsctrlest/docs/api/files/lds__poisson__fit__ssid_8h/','title':"ldsCtrlEst_h/lds_poisson_fit_ssid.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_fit_ssid.h #  PLDS SSID fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::ssidFit_t GLDS SSID Fit Type.    Detailed Description #  This file declares and partially defines a type by which Poisson-output LDS models are fit by a subspace identification (SSID) algorithm ([lds::gaussian::ssidFit_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ssid_fit__t/)). Currently, these models are fit assuming linear/Gaussian output, and then an exponential output is fit by maximum likelihood under the Poisson assumption. Future work should implement SSID after Poisson\u0026lt;-\u0026gt;Gaussian moment conversions as outlined in [2].\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer. [2] Buesing L, Macke JH, Sahani M. (2012) Spectral learning of linear dynamics from generalised-linear observations with application to neural population data. NIPS 25.\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_fit_ssid.h - PLDS Fit (SSID) ---*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_FIT_SSID_H #define LDSCTRLEST_LDS_POISSON_FIT_SSID_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;lds_poisson_fit.h\u0026#34; namespace lds { namespace poisson { class ssidFit_t : public fit_t { public: ssidFit_t() : fit_t(){}; ssidFit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec\u0026amp; singVals, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); std::vector\u0026lt;data_t\u0026gt; t0; data_t t_startSSID; data_t t_stopSSID; armaVec singVals; }; std::tuple\u0026lt;ssidFit_t, lds::gaussian::ssidFit_t\u0026gt; ssidFit( std::vector\u0026lt;armaMat\u0026gt;\u0026amp; u, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; z, data_t dt, size_t nX, size_t nH = 25, armaVec d0 = armaVec(1).fill(-kInf), SSIDWt wt = kNONE, data_t wtG0 = 0.0, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0 = kDefaultT0, data_t t_startSSID = -std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(), data_t t_stopSSID = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(), bool assumeGaussian = true); void newtonSolveC_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); data_t newtonSolve_rescaleC_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); void calcD_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); data_t calcD_newtonSolve_rescaleC_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); void fitOutput_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); } // namespace poisson } // namespace lds #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':61,'href':'/ldsctrlest/docs/api/files/lds__poisson__sctrl_8h/','title':"ldsCtrlEst_h/lds_poisson_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_sctrl.h #  PLDS switched controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::SwitchedController Poisson-observation SwitchedController Type.    Detailed Description #  This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Poisson-output linear dynamical systems (lds::poisson::SwitchedController).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_sctrl.h - Switched Controller --*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H #define LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;lds_poisson_ctrl.h\u0026#34; namespace lds { namespace poisson { class SwitchedController : lds::SwitchedController\u0026lt;System\u0026gt; { public: void set_y_ref(const armaVec\u0026amp; y_ref) override { y_ref_ = y_ref; lds::Limit(y_ref_, kYRefLB, lds::kInf); cx_ref_ = log(y_ref_) - sys_.d(); }; // make sure base class template methods available  using lds::SwitchedController\u0026lt;System\u0026gt;::SwitchedController; using lds::SwitchedController\u0026lt;System\u0026gt;::Switch; using lds::SwitchedController\u0026lt;System\u0026gt;::Control; using lds::SwitchedController\u0026lt;System\u0026gt;::ControlOutputReference; using lds::SwitchedController\u0026lt;System\u0026gt;::sys; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::set_g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::set_u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::set_tau_awu; using lds::SwitchedController\u0026lt;System\u0026gt;::set_control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::Reset; using lds::SwitchedController\u0026lt;System\u0026gt;::Print; private: constexpr static data_t kYRefLB = 1e-4; }; } // namespace poisson } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':62,'href':'/ldsctrlest/docs/api/files/lds__poisson__sys_8h/','title':"ldsCtrlEst_h/lds_poisson_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_sys.h #  PLDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::System Poisson System type.    Detailed Description #  This file declares and partially defines the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems ([lds::poisson::System](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_system/)). It inherits functionality from the underlying linear dynamical system ([lds::System](/ldsctrlest/docs/api/classes/classlds_1_1_system/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_sys.h - PLDS -------------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_SYS_H #define LDSCTRLEST_LDS_POISSON_SYS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  // namespace #include \u0026#34;lds_poisson.h\u0026#34;// system #include \u0026#34;lds_sys.h\u0026#34; namespace lds { namespace poisson { class System : public lds::System { public: System() = default; System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0); const armaVec\u0026amp; Simulate(const armaVec\u0026amp; u_tm1) override; protected: void h() override { cx_ = C_ * x_; y_ = exp(cx_ + d_); diag_y_.diag() = y_; }; void RecurseKe() override; private: // Poisson-output-specific  armaMat diag_y_; armaVec chance_; }; // System } // namespace poisson } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':63,'href':'/ldsctrlest/docs/api/files/lds__sctrl_8h/','title':"ldsCtrlEst_h/lds_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_sctrl.h #  SwitchedController type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::SwitchedController SwitchedController Type.    Detailed Description #  This file declares the type for switched control of a system approximated as multiple discrete Gaussian-output linear dynamical systems (lds::gaussian::SwitchedController).\nSource code #  //===-- ldsCtrlEst_h/lds_sctrl.h - Switched Controller ----------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_SCTRL_H #define LDSCTRLEST_LDS_SCTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;lds_ctrl.h\u0026#34; namespace lds { template \u0026lt;typename System\u0026gt; class SwitchedController : public Controller\u0026lt;System\u0026gt; { public: SwitchedController() = default; SwitchedController(const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type = 0); SwitchedController(std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type = 0); void Switch(size_t idx); void set_Kc(const std::vector\u0026lt;armaMat\u0026gt;\u0026amp; Kc) { Kc_vec_ = Kc; }; void set_Kc(std::vector\u0026lt;armaMat\u0026gt;\u0026amp;\u0026amp; Kc); void set_Kc_inty(const std::vector\u0026lt;armaMat\u0026gt;\u0026amp; Kc_inty) { Kc_inty_vec_ = Kc_inty; }; void set_Kc_inty(std::vector\u0026lt;armaMat\u0026gt;\u0026amp;\u0026amp; Kc_inty); void set_Kc_u(const std::vector\u0026lt;armaMat\u0026gt;\u0026amp; Kc_u) { Kc_u_vec_ = Kc_u; }; void set_Kc_u(std::vector\u0026lt;armaMat\u0026gt;\u0026amp;\u0026amp; Kc_u); void set_g_design(const std::vector\u0026lt;armaVec\u0026gt;\u0026amp; g) { g_design_vec_ = g; }; void set_g_design(std::vector\u0026lt;armaVec\u0026gt;\u0026amp;\u0026amp; g); // make sure base class template methods available  using lds::Controller\u0026lt;System\u0026gt;::Controller; using lds::Controller\u0026lt;System\u0026gt;::Control; using lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference; using lds::Controller\u0026lt;System\u0026gt;::sys; using lds::Controller\u0026lt;System\u0026gt;::Kc; using lds::Controller\u0026lt;System\u0026gt;::Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::Kc_u; using lds::Controller\u0026lt;System\u0026gt;::g_design; using lds::Controller\u0026lt;System\u0026gt;::u_ref; using lds::Controller\u0026lt;System\u0026gt;::x_ref; using lds::Controller\u0026lt;System\u0026gt;::y_ref; using lds::Controller\u0026lt;System\u0026gt;::control_type; using lds::Controller\u0026lt;System\u0026gt;::set_u_ref; using lds::Controller\u0026lt;System\u0026gt;::set_x_ref; using lds::Controller\u0026lt;System\u0026gt;::set_y_ref; using lds::Controller\u0026lt;System\u0026gt;::set_tau_awu; using lds::Controller\u0026lt;System\u0026gt;::set_control_type; using lds::Controller\u0026lt;System\u0026gt;::Reset; using lds::Controller\u0026lt;System\u0026gt;::Print; protected: std::vector\u0026lt;System\u0026gt; systems_; size_t n_sys_{}; size_t idx_{}; // controller gains could be different for each  std::vector\u0026lt;armaMat\u0026gt; Kc_vec_; std::vector\u0026lt;armaMat\u0026gt; Kc_inty_vec_; std::vector\u0026lt;armaMat\u0026gt; Kc_u_vec_; // design-phase input gain could also be different  std::vector\u0026lt;armaVec\u0026gt; g_design_vec_; // TODO(mfbolus): not sure why I need to do this.  using Controller\u0026lt;System\u0026gt;::Kc_; using Controller\u0026lt;System\u0026gt;::Kc_inty_; using Controller\u0026lt;System\u0026gt;::Kc_u_; using Controller\u0026lt;System\u0026gt;::g_design_; using Controller\u0026lt;System\u0026gt;::sys_; // using Controller\u0026lt;System\u0026gt;::u_ref_;  // using Controller\u0026lt;System\u0026gt;::x_ref_;  // using Controller\u0026lt;System\u0026gt;::y_ref_;  private: using lds::Controller\u0026lt;System\u0026gt;::set_sys; // using Controller\u0026lt;System\u0026gt;::set_Kc;  // using Controller\u0026lt;System\u0026gt;::set_Kc_inty;  // using Controller\u0026lt;System\u0026gt;::set_Kc_u;  // using Controller\u0026lt;System\u0026gt;::set_g_design; }; template \u0026lt;typename System\u0026gt; inline SwitchedController\u0026lt;System\u0026gt;::SwitchedController( const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type) : Controller\u0026lt;System\u0026gt;(systems[0], u_lb, u_ub, control_type), n_sys_(systems.size()), systems_(systems) { Kc_vec_ = std::vector\u0026lt;armaMat\u0026gt;(n_sys_, Kc_); Kc_inty_vec_ = std::vector\u0026lt;armaMat\u0026gt;(n_sys_, Kc_inty_); Kc_u_vec_ = std::vector\u0026lt;armaMat\u0026gt;(n_sys_, Kc_inty_); } template \u0026lt;typename System\u0026gt; inline SwitchedController\u0026lt;System\u0026gt;::SwitchedController( std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type) : Controller\u0026lt;System\u0026gt;(systems[0], u_lb, u_ub, control_type), n_sys_(systems.size()), systems_(std::move(systems)) { Kc_vec_ = std::vector\u0026lt;armaMat\u0026gt;(n_sys_, Kc_); Kc_inty_vec_ = std::vector\u0026lt;armaMat\u0026gt;(n_sys_, Kc_inty_); Kc_u_vec_ = std::vector\u0026lt;armaMat\u0026gt;(n_sys_, Kc_inty_); } // TODO(mfbolus): insert dimensionality checks to these moving set methods template \u0026lt;typename System\u0026gt; inline void SwitchedController\u0026lt;System\u0026gt;::set_Kc(std::vector\u0026lt;armaMat\u0026gt;\u0026amp;\u0026amp; Kc) { Kc_vec_ = std::move(Kc); } template \u0026lt;typename System\u0026gt; inline void SwitchedController\u0026lt;System\u0026gt;::set_Kc_inty( std::vector\u0026lt;armaMat\u0026gt;\u0026amp;\u0026amp; Kc_inty) { Kc_inty_vec_ = std::move(Kc_inty); } template \u0026lt;typename System\u0026gt; inline void SwitchedController\u0026lt;System\u0026gt;::set_Kc_u(std::vector\u0026lt;armaMat\u0026gt;\u0026amp;\u0026amp; Kc_u) { Kc_u_vec_ = std::move(Kc_u); } template \u0026lt;typename System\u0026gt; inline void SwitchedController\u0026lt;System\u0026gt;::set_g_design(std::vector\u0026lt;armaVec\u0026gt;\u0026amp;\u0026amp; g) { g_design_vec_ = std::move(g); } template \u0026lt;typename System\u0026gt; inline void SwitchedController\u0026lt;System\u0026gt;::Switch(size_t idx) { // Make sure system Idx in bounds  if ((idx + 1) \u0026gt; n_sys_) { throw std::runtime_error( \u0026#34;Provided switch index exceeds size of switched system.\u0026#34;); } if (idx == idx_) { return; // already there.  } // first, move system *back* to its place in the vector  systems_[idx_] = std::move(sys_); Kc_vec_[idx_] = std::move(Kc_); Kc_inty_vec_[idx_] = std::move(Kc_inty_); Kc_u_vec_[idx_] = std::move(Kc_u_); g_design_vec_[idx_] = std::move(g_design_); // then, get the new one out.  sys_ = std::move(systems_[idx]); Kc_ = std::move(Kc_vec_[idx]); Kc_inty_ = std::move(Kc_inty_vec_[idx]); Kc_u_ = std::move(Kc_u_vec_[idx]); g_design_ = std::move(g_design_vec_[idx]); idx_ = idx; } // Switch  } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':64,'href':'/ldsctrlest/docs/api/files/lds__sys_8h/','title':"ldsCtrlEst_h/lds_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_sys.h #  LDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::System Linear Dynamical System Type.    Detailed Description #  This file declares and partially defines the base type for linear dynamical systems ([lds::System](/ldsctrlest/docs/api/classes/classlds_1_1_system/)). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code #  //===-- ldsCtrlEst_h/lds_sys.h - LDS ----------------------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_SYS_H #define LDSCTRLEST_LDS_SYS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;lds.h\u0026#34; namespace lds { class System { public: System() = default; System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0); void Filter(const armaVec\u0026amp; u_tm1, const armaVec\u0026amp; z); virtual const armaVec\u0026amp; Simulate(const armaVec\u0026amp; u_tm1) = 0; void f(const armaVec\u0026amp; u, bool do_add_noise = false) { x_ = A_ * x_ + B_ * (g_ % u) + m_; if (do_add_noise) { x_ += arma::mvnrnd(armaVec(n_x_).fill(0), Q_); } }; virtual void h() = 0; size_t n_u() const { return n_u_; }; size_t n_x() const { return n_x_; }; size_t n_y() const { return n_y_; }; data_t dt() const { return dt_; }; const armaVec\u0026amp; x() const { return x_; }; const armaMat\u0026amp; P() const { return P_; }; const armaVec\u0026amp; m() const { return m_; }; const armaMat\u0026amp; P_m() const { return P_m_; }; const armaVec\u0026amp; cx() const { return cx_; }; const armaVec\u0026amp; y() const { return y_; }; const armaVec\u0026amp; x0() const { return x0_; }; const armaVec\u0026amp; m0() const { return m0_; }; const armaMat\u0026amp; A() const { return A_; }; const armaMat\u0026amp; B() const { return B_; }; const armaVec\u0026amp; g() const { return g_; }; const armaMat\u0026amp; C() const { return C_; }; const armaVec\u0026amp; d() const { return d_; }; const armaMat\u0026amp; Ke() const { return Ke_; }; const armaMat\u0026amp; Ke_m() const { return Ke_m_; }; void set_A(const armaMat\u0026amp; A) { A_ = A; }; void set_B(const armaMat\u0026amp; B) { B_ = B; }; void set_m(const armaVec\u0026amp; m) { m0_ = m; if (!do_adapt_m) { m_ = m; } }; void set_g(const armaVec\u0026amp; g) { g_ = g; }; void set_Q(const armaMat\u0026amp; Q) { Q_ = Q; }; void set_Q_m(const armaMat\u0026amp; Q_m) { Q_m_ = Q_m; }; void set_x0(const armaVec\u0026amp; x0) { x0_ = x0; }; void set_P0(const armaMat\u0026amp; P0) { P0_ = P0; }; void set_P0_m(const armaMat\u0026amp; P0_m) { P0_m_ = P0_m; }; void set_C(const armaMat\u0026amp; C) { C_ = C; }; void set_d(const armaVec\u0026amp; d) { d_ = d; }; void Reset(); void Print(); // safe to leave this public and non-const  bool do_adapt_m{}; protected: virtual void RecurseKe() = 0; std::size_t n_x_{}; std::size_t n_u_{}; std::size_t n_y_{}; data_t dt_{}; // Signals:  armaVec x_; armaMat P_; armaVec m_; armaMat P_m_; armaVec cx_; armaVec y_; armaVec z_; // Parameters:  armaVec x0_; armaMat P0_; armaVec m0_; armaMat P0_m_; armaMat A_; armaMat B_; armaVec g_; armaMat Q_; armaMat Q_m_; armaMat C_; armaVec d_; armaMat Ke_; armaMat Ke_m_; }; // System  } // namespace lds  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':65,'href':'/ldsctrlest/docs/api/files/mex__c__util_8h/','title':"ldsCtrlEst_h/mex_c_util.h",'section':"Files",'content':"ldsCtrlEst_h/mex_c_util.h #  arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API) More\u0026hellip;\nNamespaces #     Name     armamexc arma/mex interface using Matlab C API    Detailed Description #  This file defines utility functions for interoperability between armadillo and Matlab/Octave\u0026rsquo;s C mex API.\nSource code #  //===-- ldsCtrlEst_h/mex_c_util.h - Mex C API Utilities ---------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_MEXC_UTIL_H #define LDSCTRLEST_MEXC_UTIL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;mex.h\u0026#34; // // If Matlab_FOUND, include matrix.h. // // (Octave does not need/have it.) // #ifdef Matlab_FOUND // #include \u0026#34;matrix.h\u0026#34; // #endif  namespace armamexc { template \u0026lt;class T\u0026gt; inline auto m2T_scalar(const mxArray *matlab_scalar) -\u0026gt; T { if (mxGetData(matlab_scalar)) { return static_cast\u0026lt;T\u0026gt;(mxGetScalar(matlab_scalar)); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return 0; } template \u0026lt;class T\u0026gt; inline auto m2a_mat(const mxArray *matlab_mat, bool copy_aux_mem = false, bool strict = true) -\u0026gt; arma::Mat\u0026lt;T\u0026gt; { if (mxGetData(matlab_mat)) { const mwSize n_dim = mxGetNumberOfDimensions(matlab_mat); if (n_dim == 2) { return arma::Mat\u0026lt;T\u0026gt;(static_cast\u0026lt;double *\u0026gt;(mxGetData(matlab_mat)), mxGetM(matlab_mat), mxGetN(matlab_mat), copy_aux_mem, strict); } mexErrMsgTxt(\u0026#34;Number of dimensions must be 2.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } // TODO(mfbolus): make these templated.  inline auto a2m_mat(arma::Mat\u0026lt;double\u0026gt; const \u0026amp;arma_mat) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_mat.n_rows, arma_mat.n_cols, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;double *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;double *\u0026gt;(arma_mat.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy.  std::memcpy(dst_pointer, src_pointer, sizeof(double) * arma_mat.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Mat.\u0026#34;); return nullptr; } inline auto a2m_vec(arma::Col\u0026lt;double\u0026gt; const \u0026amp;arma_vec) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_vec.n_elem, 1, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;double *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;double *\u0026gt;(arma_vec.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy.  std::memcpy(dst_pointer, src_pointer, sizeof(double) * arma_vec.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Col.\u0026#34;); return nullptr; } } // namespace armamexc  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':66,'href':'/ldsctrlest/docs/api/files/mex__cpp__util_8h/','title':"ldsCtrlEst_h/mex_cpp_util.h",'section':"Files",'content':"ldsCtrlEst_h/mex_cpp_util.h #  arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API) More\u0026hellip;\nNamespaces #     Name     armamexcpp arma/mex interface using Matlab C++ API    Detailed Description #  This file defines utility functions for interoperability between armadillo and Matlab\u0026rsquo;s C++ mex API.\nSource code #  //===-- ldsCtrlEst_h/mex_cpp_util.h - Mex C++ API Utilities -----*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_MEXCPP_UTIL_H #define LDSCTRLEST_MEXCPP_UTIL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;mex.hpp\u0026#34;#include \u0026#34;mexAdapter.hpp\u0026#34; namespace armamexcpp { template \u0026lt;class T\u0026gt; auto m2a_cellmat(matlab::data::CellArray\u0026amp; matlab_cell) -\u0026gt; std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; { size_t n_cells = matlab_cell.getNumberOfElements(); std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; arma_mat(n_cells, arma::mat(1, 1, arma::fill::zeros)); for (size_t k = 0; k \u0026lt; n_cells; k++) { matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = matlab_cell[k]; auto dims = matlab_mat.getDimensions(); arma_mat[k] = arma::Mat\u0026lt;T\u0026gt;(matlab_mat.release().get(), dims[0], dims[1]); } return arma_mat; }; template \u0026lt;class T\u0026gt; auto m2s_vec(matlab::data::TypedArray\u0026lt;T\u0026gt;\u0026amp; matlab_array) -\u0026gt; std::vector\u0026lt;T\u0026gt; { size_t n_elem = matlab_array.getNumberOfElements(); double* ptr = matlab_array.release().get(); std::vector\u0026lt;T\u0026gt; vec(ptr, ptr + n_elem); return vec; }; template \u0026lt;class T\u0026gt; auto m2a_vec(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) -\u0026gt; arma::Col\u0026lt;T\u0026gt; { size_t n_elem = matlab_array.getNumberOfElements(); T* ptr = matlab_array.release().get(); arma::Col\u0026lt;T\u0026gt; vec(ptr, n_elem); //, false);  return vec; }; template \u0026lt;class T\u0026gt; auto m2a_mat(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) -\u0026gt; arma::Mat\u0026lt;T\u0026gt; { // ArrayDimensions == std::vector\u0026lt;size_t\u0026gt;  auto dims = matlab_array.getDimensions(); T* ptr = matlab_array.release().get(); // mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false)  arma::Mat\u0026lt;T\u0026gt; mat(ptr, dims[0], dims[1]); //, false);  return mat; }; template \u0026lt;class T\u0026gt; auto a2m_mat(arma::Mat\u0026lt;T\u0026gt;\u0026amp; arma_mat, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {arma_mat.n_rows, arma_mat.n_cols}, arma_mat.memptr(), arma_mat.memptr() + arma_mat.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; auto a2m_vec(arma::Col\u0026lt;T\u0026gt;\u0026amp; arma_vec, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;({arma_vec.n_elem, 1}, arma_vec.memptr(), arma_vec.memptr() + arma_vec.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; auto s2m_vec(std::vector\u0026lt;T\u0026gt;\u0026amp; std_vec, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {std_vec.size(), 1}, std_vec.data(), std_vec.data() + std_vec.size()); return matlab_mat; }; } // namespace armamexcpp  #endif  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':67,'href':'/ldsctrlest/docs/terminology/model/','title':"Models",'section':"LDS C+E Documentation",'content':"Model Definitions #  This library provides methods for control and estimation of linear dynamical systems (LDS) of the following form:   \\[\\mathbf{x}_{t\u0026#43;1} = f\\left( \\mathbf{x}_{t}, \\mathbf{v}_{t} \\right) = \\mathbf{A} \\mathbf{x}_{t} \u0026#43; \\mathbf{B} \\mathbf{v}_{t} \u0026#43; \\mathbf{m}_{t} \u0026#43; \\mathbf{w}_{t}\\]   \\[\\mathbf{y}_{t} = h\\left( \\mathbf{x}_{t} \\right)\\]  t : time index x : system state v = g%u : input (e.g., in physical units used for model fit) u : control signal sent to actuator (e.g., in Volts) y : system output m : process disturbance w ~ N(0, Q) : process noise/disturbance A : state matrix B : input coupling matrix g : input gain (e.g., for converting to control signal actuator voltage) n.b., assumes this conversion is linear Q : process noise covariance % : element-wise multiplication  LDS with Gaussian Observations #  For linear dynamical systems whose outputs are assumed to be corrupted by additive Gaussian noise before measurement (Gaussian LDS models), the output function takes the following form.\n \\[\\mathbf{y}_{t} = \\mathbf{C} \\mathbf{x}_{t} \u0026#43; \\mathbf{d}\\]   \\[\\mathbf{z}_{t} \\sim \\mathcal{N}\\left(\\mathbf{y}_{t} , \\mathbf{R} \\right)\\]  z : measurement C : output matrix d : output bias R : measurement noise covariance  LDS with Poisson Observations #  For linear dynamical systems whose outputs are assumed to be rates underlying measured count data derived from a Poisson distribution (Poisson LDS models), the output function takes the following form. Note an element-wise exponentiation is used to rectify the linear dynamics for the rate of the Poisson process.\n \\[y_{t}^{i} = \\exp \\left(\\mathbf{c}^i \\mathbf{x}_{t} \u0026#43; d^i\\right)\\]   \\[z_{t}^i \\sim \\rm{Poisson} \\left(y_{t}^i \\right)\\]  i : output index z : measurement (count data) c : i^th row of output matrix (C) d : output bias  "});index.add({'id':68,'href':'/ldsctrlest/docs/api/modules/','title':"Modules",'section':"LDS C+E Documentation",'content':"Modules #    Control Mode Bit Masks\n  Defaults\n   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':69,'href':'/ldsctrlest/docs/api/namespaces/','title':"Namespaces",'section':"LDS C+E Documentation",'content':"Namespaces #    arma\n  armamexc arma/mex interface using Matlab C API\n  armamexcpp arma/mex interface using Matlab C++ API\n  lds::gaussian Linear Dynamical Systems with Gaussian observations.\n  lds::poisson Linear Dynamical Systems with Poisson observations.\n   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':70,'href':'/ldsctrlest/docs/api/pages/','title':"Pages",'section':"LDS C+E Documentation",'content':"Pages #   Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':71,'href':'/ldsctrlest/docs/tutorials/eg_plds_state_estimation/','title':"PLDS State Estimation",'section':"LDS C+E Examples",'content':"PLDS State Estimation Tutorial #  This tutorial shows how to use this library to estimate the state of an LDS Poisson observations from input/output data. In place of a physical system, another PLDS model (lds::poisson::sys_t) receives random inputs and provides measurements for the state estimator. For the sake of example, the only parameter mismatch is assumed to be the process disturbance, which is adaptively re-estimated.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; Creating a simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation. When a system is initialized, rather than requiring all parameters to be provided at construction, only the dimensions and sample period are required and a default system is created.\n// construct ground truth system...  lds::poisson::sys_t system_true(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example,   \\[x_{t\u0026#43;1} = x_t \u0026#43; w_t\\]   \\[y_{t} = \\exp\\left(x_t\\right) \\; .\\]  Now, we\u0026rsquo;ll create non-default parameters for this model.\n// Model parameters  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); armaMat b_true = armaMat(n_x, n_u).fill(1e-2); armaVec m0_true = armaVec(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  armaVec x0_true = m0_true * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state Finally, assign the parameters using corresponding set-methods.\n// Assign params.  system_true.setA(a_true); system_true.setB(b_true); system_true.setX0(x0_true); system_true.setM(m0_true); system_true.reset(); Creating the estimator #  Now, create the estimator. The system type (sys_t) includes filtering functionality for state estimation, so create another lds::poisson::sys_t. As noted above, the only parameter mismatch in this simulation will be the process disturbance.\n// Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::sys_t system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  armaVec m0_est = m0_true * 2; system_estimator.setM(m0_est); // set new initial conditions  armaVec x0_est = m0_est * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.setX0(x0_est); system_estimator.reset(); // reset to initial condition. To ensure robust estimates, adaptively re-estimate the process disturbance.\n// turn on adaptive disturbance estimation  system_estimator.adaptM = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.setQ_m(q_m); Simulating estimation #  In this demonstration, random inputs are presented to the system, measurements are taken, and filtering is carried out in a for-loop.\n// Simlate the true system.  system_true.setU(u_k); system_true.simPredict(); // generate a measurement  armaVec z_k(z.colptr(t), z.n_rows, false, true); system_true.simMeasurement(z_k); // filter (predict -\u0026gt; update)  system_estimator.filter(z_k); Example simulation result #  Below are example results for this simulation, including outputs, latent states, process disturbance, and the input. The online estimates of the output, state, and disturbance are given in purple.\nWith this parameterization, it takes the estimator approximately 5 seconds to minimize state error. The state and output error distributions for the period after 5 seconds is shown below.\n"});index.add({'id':72,'href':'/ldsctrlest/docs/tutorials/eg_switched_plds_control/','title':"PLDS Switched Control",'section':"LDS C+E Examples",'content':"PLDS Switched Control Tutorial #  This tutorial shows how to use this library to control a system with a switched PLDS controller (lds::poisson::sctrl_t). This type of controller is applicable in scenarios where a physical system is not accurately captured by a LDS but has multiple discrete operating modes where the dynamics can be well-approximated as linear.\nIn the example that follows, another PLDS model (lds::poisson::sys_t) is used in place of a physical system. It receives control inputs and provides measurements for the simulated feedback control loop. This system stochastically flips between two input gains. In this example, the controller is assumed to have a perfect model of the switching system being controlled. Note that in practice, users would need to have a decoder that estimates operating mode of the physical system being controlled. This library does not currently include operating mode estimation.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; Creating the simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); The system\u0026rsquo;s input matrix (B) will be switched stochastically from one value (b1) to a less sensitive value (b2) according to the following probabilities.\n// for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1 Initially, the system will be in \u0026ldquo;mode\u0026rdquo; 1, where B = b2.\n// simulated system being controlled  lds::poisson::sys_t controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  armaMat a(n_x, n_x, arma::fill::eye); a[0] = 0.985; armaMat b1 = armaMat(n_x, n_u).fill(0.05); armaVec d = armaVec(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.setA(a); controlled_system.setB(b1); controlled_system.setD(d); controlled_system.reset(); // reset to initial conditions See the GLDS Control and PLDS State Estimation tutorials for more detail about sys_t creation.\nCreating the controller #  Now, create the controller. A switched-system controller (sctrl_t) essentially toggles between the parameters of its subsystems when the controller is told a switch has occured. The first thing the user needs to do is define these subsystems. In this example, there are two Poisson systems (sys1, sys2), which are the same save for their input gains.\n// create switched controller sub-systems  // system 1  data_t u_lb = 0.0; data_t u_ub = 5.0; lds::poisson::ctrl_t sys1(n_u, n_x, n_y, u_lb, u_ub, dt); // Control variables  armaVec y_ref0 = armaVec(n_y, arma::fill::zeros).fill(25.0 * dt); // controller gains for underlying system 1:  armaMat k_x1(n_u, n_x, arma::fill::ones); size_t control_type = 0; // no integral action, etc.  // setting initial mode to target to avoid large error at onset:  armaVec x0_controller = arma::log(y_ref0) - d; armaMat q_controller = armaMat(n_x, n_x, arma::fill::eye) * 5e-3; sys1.setControlType(control_type); sys1.setA(a); sys1.setB(b1); sys1.setD(d); sys1.setX0(x0_controller); sys1.setKc_x(k_x1); sys1.setQ(q_controller); // set process noise covariance  // system 2  lds::poisson::ctrl_t sys2 = sys1; // Let underlying system 1 be more sensitive than system 2  data_t scale_sys_b = 2; armaMat b2 = armaMat(n_x, n_u).fill(b1[0] / scale_sys_b); armaMat k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  // set parameters  sys2.setB(b2); sys2.setKc_x(k_x2); Now that the two subsystems are defined, instantiate the switched controller and set its members. Importantly, control references \u0026ldquo;belong\u0026rdquo; to the switched controller, so they need to be assigned to it, rather than its subsystems.\n// create 2-system composite switched-mode controller.  lds::poisson::sctrl_t switched_controller(2, n_u, n_x, n_y, u_lb, u_ub, dt); // assign the parameters of the sub-systems 1 and 2  switched_controller.setSystem(0, sys1); switched_controller.setSystem(1, sys2); switched_controller.switchSystem(0); // start with system 1  switched_controller.reset(); // reset to initial conditions  // reference belongs to super system. Set here.  switched_controller.setYRef(y_ref0); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  switched_controller.adaptM = true; Simulating control #  In this demonstration, we will use the steadyState_logLin_fbCtrl method which allows users to simply set the reference output event rate (y_ref) and supply the current measurement z_t. It then calculates the steady-state solution for the reference state/input. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system. Importantly, this method performs control in the linear state space (i.e., taking the logarithm of the output).\nThe control loop is carried out here in a simple for-loop, where a the controlled system is simulated, a measurement taken, and the control signal updated.\n// Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_k = armaVec(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_k); // perform control  switched_controller.steadyState_logLin_fbCtrl(z_k); Note that as the gain of the controlled system changes stochastically, the controller is informed of this change. In practice, a user must decode such changes in the system\u0026rsquo;s operating mode and call the switchSystem method accordingly. Such a decoder is not currently included in this library.\nExample simulation result #  Below are example results for this simulation, including outputs, latent states, mode switches, and the control signal. The controller\u0026rsquo;s online estimates of the output and state are shown in purple.\nNote that every time the operating mode of the system (here, a gain change) the controller immediately adjusts its inputs. In contrast, a non-switched controller with integral action would also compensate but do so in a comparitively sluggish fashion.\n"});index.add({'id':73,'href':'/ldsctrlest/docs/api/files/dir_68267d1309a1af8e8297ef4c3efbcdba/','title':"src",'section':"Files",'content':"src #  Files #     Name     src/lds.cpp misc lds namespace functions   src/lds_gaussian_sys.cpp GLDS base type.   src/lds_poisson_sys.cpp PLDS base type.   src/lds_sys.cpp LDS base type.     Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':74,'href':'/ldsctrlest/docs/api/files/lds_8cpp/','title':"src/lds.cpp",'section':"Files",'content':"src/lds.cpp #  misc lds namespace functions More\u0026hellip;\nDetailed Description #  This file implements miscellaneous lds namespace functions not bound to a class.\nSource code #  //===-- lds.cpp - LDS -----------------------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; void lds::Limit(std::vector\u0026lt;lds::data_t\u0026gt;\u0026amp; x, data_t lb, data_t ub) { for (double\u0026amp; k : x) { k = k \u0026lt; lb ? lb : k; k = k \u0026gt; ub ? ub : k; } } void lds::Limit(armaVec\u0026amp; x, data_t lb, data_t ub) { for (size_t k = 0; k \u0026lt; x.n_elem; k++) { x[k] = x[k] \u0026lt; lb ? lb : x[k]; x[k] = x[k] \u0026gt; ub ? ub : x[k]; } } void lds::Limit(armaMat\u0026amp; x, data_t lb, data_t ub) { for (size_t k = 0; k \u0026lt; x.n_elem; k++) { x[k] = x[k] \u0026lt; lb ? lb : x[k]; x[k] = x[k] \u0026gt; ub ? ub : x[k]; } }  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':75,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sys_8cpp/','title':"src/lds_gaussian_sys.cpp",'section':"Files",'content':"src/lds_gaussian_sys.cpp #  GLDS base type. More\u0026hellip;\nDetailed Description #  This file implements the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems (lds::gaussian::sys_t). It inherits functionality from the underlying linear dynamical system (lds::sys_t).\nSource code #  //===-- lds_gaussian_sys.cpp - GLDS ---------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; lds::gaussian::System::System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0, data_t q0, data_t r0) : lds::System(n_u, n_x, n_y, dt, p0, q0) { R_.zeros(n_y, n_y); R_.diag().fill(r0); do_recurse_Ke_=true; }; // recursively estimate Ke void lds::gaussian::System::RecurseKe() { if (!do_recurse_Ke_) { return; } // predict covariance  P_ = A_ * P_ * A_.t() + Q_; // calc Kalman gain  Ke_ = P_ * C_.t() * inv_sympd(C_ * P_ * C_.t() + R_); // update covariance  // Reference: Ghahramani et Hinton (1996)  P_ = P_ - Ke_ * C_ * P_; if (do_adapt_m) { P_m_ += Q_m_; // A_m = I (i.e., random walk)  Ke_m_ = P_m_ * C_.t() * inv_sympd(C_ * P_m_ * C_.t() + R_); P_m_ = P_m_ - Ke_m_ * C_ * P_m_; } } // Simulate const lds::armaVec\u0026amp; lds::gaussian::System::Simulate(const armaVec\u0026amp; u_tm1){ f(u_tm1, true);//simulate dynamics with noise added  h();//output  z_ = y_ + arma::mvnrnd(armaVec(n_y_).fill(0), R_);//measure  return z_; } void lds::gaussian::System::Print() { lds::System::Print(); std::cout \u0026lt;\u0026lt; \u0026#34;R: \\n\u0026#34; \u0026lt;\u0026lt; R_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':76,'href':'/ldsctrlest/docs/api/files/lds__poisson__sys_8cpp/','title':"src/lds_poisson_sys.cpp",'section':"Files",'content':"src/lds_poisson_sys.cpp #  PLDS base type. More\u0026hellip;\nDetailed Description #  This file implements the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems (lds::poisson::sys_t). It inherits functionality from the underlying linear dynamical system (lds::sys_t).\nSource code #  //===-- lds_poisson_sys.cpp - PLDS ----------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; lds::poisson::System::System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0, data_t q0) : lds::System(n_u, n_x, n_y, dt, p0, q0) { diag_y_ = diagmat(y_); chance_ = armaVec(n_y, fill::randu); }; // Correct: Given measurement (z) and current input (u), update estimate of the // state, covar, output. // // see Eden et al. 2004 void lds::poisson::System::RecurseKe() { // predict covariance  P_ = A_ * P_ * A_.t() + Q_; // update cov  P_ = pinv(pinv(P_) + C_.t() * diag_y_ * C_); Ke_ = P_ * C_.t(); if (do_adapt_m) { P_m_ += Q_m_; // predict (A_m = I)  P_m_ = pinv(pinv(P_m_) + C_.t() * diag_y_ * C_); // update  Ke_m_ = P_m_ * C_.t(); } } // Measurement: z ~ Poisson(y) // n.b., In reality, this is only Poisson where rate `y` and sample period `dt` // are sufficiently small there is only ever 0 or 1 events in a period. If // either of those is violated, results will be innacurate. // Simulate const lds::armaVec\u0026amp; lds::poisson::System::Simulate(const armaVec\u0026amp; u_tm1) { f(u_tm1, true); // simulate dynamics with noise added  h(); // output  chance_.randu(n_y_); z_.zeros(); for (std::size_t k = 0; k \u0026lt; n_y_; k++) { if ((y_[k]) \u0026gt; chance_[k]) { z_[k] = 1.0; } } return z_; } // ******************* SYS_T *******************  Updated on 8 March 2021 at 11:54:11 CST\n"});index.add({'id':77,'href':'/ldsctrlest/docs/api/files/lds__sys_8cpp/','title':"src/lds_sys.cpp",'section':"Files",'content':"src/lds_sys.cpp #  LDS base type. More\u0026hellip;\nDetailed Description #  This file implements the base type for linear dynamical systems (lds::System). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code #  //===-- lds_sys.cpp - LDS -------------------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; lds::System::System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0, data_t q0) : n_u_(n_u), n_x_(n_x), n_y_(n_y), dt_(dt) { // initial conditions.  x0_ = armaVec(n_x, fill::zeros); // includes bias (nY) and g (nU)  P0_ = p0 * armaMat(n_x, n_x, fill::eye); m0_ = x0_; P0_m_ = P0_; // signals  x_ = x0_; P_ = P0_; m_ = m0_; P_m_ = P0_m_; y_ = armaVec(n_y, fill::zeros); cx_ = armaVec(n_y, fill::zeros); z_ = armaVec(n_y, fill::zeros); // By default, random walk where each state is independent  // In this way, provides independent estimates of rate per channel of output.  A_ = armaMat(n_x, n_x, fill::eye); B_ = armaMat(n_x, n_u, fill::zeros); g_ = armaVec(n_u, fill::ones); Q_ = q0 * armaMat(n_x, n_x, fill::eye); Q_m_ = Q_; C_ = armaMat(n_y, n_x, fill::eye); // each state will map to an output by  d_ = armaVec(n_y, fill::zeros); Ke_ = armaMat(n_x, n_y, fill::zeros); // estimator gain.  Ke_m_ = armaMat(n_x, n_y, fill::zeros); // estimator gain for m adaptation.  do_adapt_m = false; } // Filter: Given measurement (`z`) and previous input (`u_tm1`), predict state // and update estimate of the state, covar, output using Kalman filter void lds::System::Filter(const armaVec\u0026amp; u_tm1, const armaVec\u0026amp; z_t) { // predict mean  f(u_tm1); // dynamics  h(); // output  // recursively calculate esimator gains (or just keep existing values)  // (also predicts+updates estimate covariance)  RecurseKe(); // update  x_ += Ke_ * (z_t - y_); if (do_adapt_m) { m_ += Ke_m_ * (z_t - y_); // adaptively estimating disturbance  } // With new state, estimate output.  h(); // --\u0026gt; posterior } void lds::System::Reset() { // reset to initial conditions  x_ = x0_; // mean  P_ = P0_; // cov of state estimate  m_ = m0_; // process disturbance  P_m_ = P0_m_; // cov of disturbance estimate  h(); } void lds::System::Print() { std::cout \u0026lt;\u0026lt; \u0026#34;\\n********** SYSTEM ********** \\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;x: \\n\u0026#34; \u0026lt;\u0026lt; x_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;P: \\n\u0026#34; \u0026lt;\u0026lt; P_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;A: \\n\u0026#34; \u0026lt;\u0026lt; A_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;B: \\n\u0026#34; \u0026lt;\u0026lt; B_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;g: \\n\u0026#34; \u0026lt;\u0026lt; g_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;m: \\n\u0026#34; \u0026lt;\u0026lt; m_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Q: \\n\u0026#34; \u0026lt;\u0026lt; Q_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Q_m: \\n\u0026#34; \u0026lt;\u0026lt; Q_m_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;d: \\n\u0026#34; \u0026lt;\u0026lt; d_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;C: \\n\u0026#34; \u0026lt;\u0026lt; C_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;y: \\n\u0026#34; \u0026lt;\u0026lt; y_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } //******************* SYS_T *******************  Updated on 8 March 2021 at 11:54:11 CST\n"});})();