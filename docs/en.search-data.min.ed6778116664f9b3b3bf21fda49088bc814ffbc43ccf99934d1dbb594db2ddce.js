'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/ldsctrlest/docs/','title':"LDS C+E Documentation",'section':"LDS Control \u0026 Estimation",'content':"LDS Control \u0026amp; Estimation Documentation #  "});index.add({'id':1,'href':'/ldsctrlest/docs/tutorials/','title':"LDS C+E Examples",'section':"LDS C+E Documentation",'content':"Examples #  "});index.add({'id':2,'href':'/ldsctrlest/acknowledgements/','title':"Acknowledgements",'section':"LDS Control \u0026 Estimation",'content':"Acknowledgements #  Development and publication of this library was supported in part by the NIH/NINDS Collaborative Research in Computational Neuroscience (CRCNS)/BRAIN Grant 5R01NS115327-02.\n"});index.add({'id':3,'href':'/ldsctrlest/docs/getting-started/','title':"Getting Started",'section':"LDS C+E Documentation",'content':"Downloading the Library #  The source code for this library can be downloaded from stanley-rozell/ldsCtrlEst either by downloading a snapshot or cloning the repository via git.\ngit clone https://github.com/stanley-rozell/ldsCtrlEst.git By default, this would check out the master branch. In most cases, we suggest downloading or checking out the latest release instead.\ncd /path/to/ldsCtrlEst git checkout 0.5.0 Dependencies #  Note that the primary dependencies of this project listed below must be installed along with their header files and with CMake config files or pkg-config files. The latter files are used to configure this project\u0026rsquo;s build. It is strongly encouraged to install the dependencies below using a package manager (e.g., apt, pacman, macports).\n For project configuration, install cmake as well as pkg-config. The latter is optional. The linear algebra library armadillo is used throughout this repository. The HDF5 library is used to save output from example test programs. For use of this library in Matlab executables (mex) on Linux operating systems, you will need OpenBlas, ensuring the static library libopenblas.a is installed. You will also need to install gfortran.  Compilation + Installation #  This project is configured/compiled/installed by way of CMake and (on Unix-based operating systems) GNU Make. For configuration with CMake, there are three available options.\n LDSCTRLEST_BUILD_EXAMPLES : [default= ON] whether to build example programs located under examples/ in the source tree LDSCTRLEST_BUILD_FIT : [default=OFF] whether to build the auxiliary fitting portion of the source code that is not pertinent to control implementation LDSCTRLEST_BUILD_STATIC : [default=OFF] whether to statically link against OpenBLAS and create a static ldsCtrlEst library for future use  n.b., If both options 2 and 3 are enabled, Matlab/Octave mex functions will be compiled for exposing some of the fitting functionality to Matlab/Octave.\nBelow are example usages of cmake/make to configure/build the library.\n  For basic project build \u0026amp; install\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake .. #configure build make #build the project sudo make install #[optional] installs to default location (OS-specific)   To set the install prefix\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DCMAKE_INSTALL_PREFIX=/your/install/prefix .. #configure build with chosen install location make #build the project make install #install to /your/install/prefix   To build the entire project including fit code, a static library for Matlab compatibility, and the included Matlab mex functions for fitting GLDS/PLDS models.\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DLDSCTRLEST_BUILD_FIT=1 -DLDSCTRLEST_STATIC_OPENBLAS=1 .. #configure to build the fitting portion of library and statically link openblas and ldsCtrlEst to mex files make #build the project n.b., If you choose not to install the library or install it to the non-default location, ensure you have updated the following environment variables on Unix-based operating systems.\n LD_LIBRARY_PATH: search path for dynamically loaded libraries PKG_CONFIG_PATH: search path for pkg-config tool CMAKE_PREFIX_PATH: search path of prefix where CMake will look for package config files  e.g., Assuming you set -DCMAKE_INSTALL_PREFIX=/your/install/prefix during project configuration and your login shell uses the ~/.profile startup file, open ~/.profile in a text editor and add \u0026hellip;\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/your/install/prefix/lib export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix/lib/pkgconfig export CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix   Common issues #   \u0026ldquo;I have installed all the dependencies including gfortran with a package manager as suggested; however, cmake complains it cannot find the gfortran library.\u0026rdquo;  When gfortran is installed, its library is usually not installed in a standard location like /usr/lib. gfortran is part of the gcc suite, so their libraries are organized together. e.g., When you install gfortran on Ubuntu using apt, its location is /usr/lib/gcc/x86_64-linux-gnu/9, in the case that gcc version 9 is installed. The build configuration script in ldsCtrlEst is written to add LD_LIBRARY_PATH (Unix) or PATH (Windows) to the CMake library search path on Unix or Windows systems, respectively. Therefore, to fix this issue, simply add the directory in which libgfortran was installed to the OS-appropriate environment variable. Continuing with the Ubuntu example above and assuming a Unix login shell whose startup file is ~/.profile, add the following to the file.\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/gcc/x86_64-linux-gnu/9 \u0026ldquo;I have built the library and installed it in a non-default location. In building my own project linking against ldsCtrlEst, cmake or pkg-config cannot find the library or its configuration information.\u0026rdquo;  If cmake and/or pkg-config cannot find the required configuration files for your project to link against ldsCtrlEst, make sure that these utilities know to look for them in the non-default location where you installed the library. For cmake this means adding your chosen install prefix to the environment variable CMAKE_PREFIX_PATH. Similarly, for pkg-config you need to add your/install/prefix/lib/pkgconfig to its search path, PKG_CONFIG_PATH. Assuming a Unix shell whose login startup file is ~/.profile and ldsCtrlEst was installed using prefix your/install/prefix, add the following to .profile.\nexport CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix "});index.add({'id':4,'href':'/ldsctrlest/issues-contributing/','title':"Issues Contributing",'section':"LDS Control \u0026 Estimation",'content':"Reporting Issues #  If you encounter bugs when using this library or have specific feature requests that you believe fall within the stated scope of this project, please open an issue on GitHub and use an appropriate issue template where possible. You may also fork the repository and submit pull-requests with your suggested changes.\nContributing #  We welcome any community contributions to this project. Please fork the repository and if possible use clang-format and clang-tidy to conform to the coding format/style of this repository.\n"});index.add({'id':5,'href':'/ldsctrlest/docs/api/namespaces/namespacearmamexc/','title':"armamexc",'section':"Namespaces",'content':"armamexc #  arma/mex interface using Matlab C API More\u0026hellip; Functions #      Name     template \u0026lt;class T \u0026gt; auto m2T_scalar(const mxArray * matlab_scalar)\nConvert Matlab mxArray to scalar of type T.   template \u0026lt;class T \u0026gt; auto m2a_mat(const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true)\nConvert matlab matrix to armadillo.   template \u0026lt;typename T \u0026gt; auto a2m_mat(arma::Mat\u0026lt; T \u0026gt; const \u0026amp; arma_mat)\nConvert armadillo to matlab matrix.   template \u0026lt;typename T \u0026gt; auto a2m_vec(arma::Col\u0026lt; T \u0026gt; const \u0026amp; arma_vec)\nConvert armadillo to matlab vector.    Detailed Description #  Utilities for arma/mex interface using Matlab C API\nFunction Details #  m2T_scalar #  template \u0026lt;class T \u0026gt; inline auto m2T_scalar( const mxArray * matlab_scalar ) Parameters:\n matlab_scalar matlab scalar  Template Parameters:\n T type  Return: scalar of type T\nm2a_mat #  template \u0026lt;class T \u0026gt; inline auto m2a_mat( const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true ) Parameters:\n matlab_mat matlab matrix copy_aux_mem [optional] whether to copy auxiliary memory strict [optional] strictly enforce the above  Template Parameters:\n T type  Return: armadillo matrix of type T\na2m_mat #  template \u0026lt;typename T \u0026gt; inline auto a2m_mat( arma::Mat\u0026lt; T \u0026gt; const \u0026amp; arma_mat ) Parameters:\n arma_mat armadillo matrix  Return: matlab matrix\na2m_vec #  template \u0026lt;typename T \u0026gt; inline auto a2m_vec( arma::Col\u0026lt; T \u0026gt; const \u0026amp; arma_vec ) Parameters:\n arma_vec armadillo vector  Return: matlab vector\n Updated on 22 March 2021 at 22:01:29 CDT\n"});index.add({'id':6,'href':'/ldsctrlest/docs/api/namespaces/namespacearmamexcpp/','title':"armamexcpp",'section':"Namespaces",'content':"armamexcpp #  arma/mex interface using Matlab C++ API More\u0026hellip; Functions #      Name     template \u0026lt;class T \u0026gt; auto m2a_cellmat(matlab::data::CellArray \u0026amp; matlab_cell)\nConvert matlab cell array to vector of armadillo matrices.   template \u0026lt;class T \u0026gt; auto m2s_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array)\nConvert matlab matrix to a vector of scalars.   template \u0026lt;class T \u0026gt; auto m2a_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo vector.   template \u0026lt;class T \u0026gt; auto m2a_mat(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo matrix.   template \u0026lt;class T \u0026gt; auto a2m_mat(const arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab matrix.   template \u0026lt;class T \u0026gt; auto a2m_vec(const arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab vector.   template \u0026lt;class T \u0026gt; auto s2m_vec(const std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert vector of scalar T to matlab matrix.    Detailed Description #  utilities for arma/mex interface using Matlab C++ API\nFunction Details #  m2a_cellmat #  template \u0026lt;class T \u0026gt; auto m2a_cellmat( matlab::data::CellArray \u0026amp; matlab_cell ) Parameters:\n matlab_cell matlab cell  Template Parameters:\n T type  Return: vector of armadillo matrices of type T\nm2s_vec #  template \u0026lt;class T \u0026gt; auto m2s_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array ) Parameters:\n matlab_array matlab array  Template Parameters:\n T type  Return: vector of type T\nm2a_vec #  template \u0026lt;class T \u0026gt; auto m2a_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\n matlab_array matlab array  Template Parameters:\n T type  Return: armadillo vector of type T\nm2a_mat #  template \u0026lt;class T \u0026gt; auto m2a_mat( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\n matlab_array matlab matrix  Template Parameters:\n T type  Return: armadillo matrix of type T\na2m_mat #  template \u0026lt;class T \u0026gt; auto a2m_mat( const arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n arma_mat arma matrix factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\na2m_vec #  template \u0026lt;class T \u0026gt; auto a2m_vec( const arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n arma_vec armadillo vector factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\ns2m_vec #  template \u0026lt;class T \u0026gt; auto s2m_vec( const std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n std_vec standard vector factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\n Updated on 22 March 2021 at 22:01:29 CDT\n"});index.add({'id':7,'href':'/ldsctrlest/docs/api/files/dir_4fef79e7177ba769987a8da36c892c5f/','title':"build",'section':"Files",'content':"build #  Directories #     Name     include     Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':8,'href':'/ldsctrlest/docs/terminology/control-estimation/','title':"C\u0026E",'section':"LDS C+E Documentation",'content':"Control \u0026amp; Estimation #  The control system provided by this library is comprised of a state estimator and a controller. The estimator is responsible for estimating the latent state of the system, given measurements up to and including the current time (i.e., filtering). At each time step, the controller then uses the resulting state feedback and an internal model of the system to update the inputs to the process being manipulated.\nState estimation #  In general, the filtering performed to estimate the underlying state proceeds recursively by first using the model dynamics to predict the state change at the next time step, followed by updating this prediction when a new measurement is available. For a LDS, this two-step process can be summarized by   \\[\\widehat{\\mathbf{x}}_{t|t-1} = \\mathbf{A}\\widehat{\\mathbf{x}}_{t-1|t-1} \u0026#43; \\mathbf{B} u_{t-1} \u0026#43; \\mathbf{m}_{t-1} \\;,\\]   \\[\\widehat{\\mathbf{x}}_{t|t} = \\widehat{\\mathbf{x}}_{t|t-1} \u0026#43; \\mathbf{K}^{\\rm e}_t \\left(\\mathbf{z}_t - \\widehat{\\mathbf{y}}_{t|t-1}\\right)\\;,\\]  where  \\( \\hat{\\left(\\cdot\\right)}_{t|j} \\)  indicates an estimate at time  \\( t \\)  given data up to time  \\( j \\)  inclusive,  \\( \\mathbf{K}^{\\rm e} \\)  is the estimator gain, and\n \\[ \\widehat{\\mathbf{y}}_{t|t-1} = h\\left( \\widehat{\\mathbf{x}}_{t|t-1} \\right) \\; .\\]  In the case of GLDS models, the estimator gain (called Ke in library) is calculated recursively by Kalman filtering, which requires knowledge of the process noise and measurement noise covariances (Q, R) in addition to the system matrices. For time-invariant GLDS models, the infinite horizon solution is often used, so this gain need not be time-varying. Users may instead set its pre-determined value with the lds::gaussian::System::set_Ke mutator.\nIn the case of PLDS models, there is a analogue of the Kalman filter developed for dynamical systems with point-process observations (Eden et al. 2004). This nonlinear filter recursively updates Ke at each time step and requires an estimate of the process noise covariance (Q) as well.\nAdaptive estimation of process disturbance #  Both the Kalman filter and point-process analogue are model-based; therefore, their performance can be sensitive to model mismatch, whether this be imperfect model fitting or true drifts in system behavior. A practical approach to improving robustness is parameter adaptation. To that end, this library provides dual state-parameter estimation. Specifically, an additive process disturbance (m) is adaptively re-estimated when the lds::System::do_adapt_m property is set to true. This effectively provides integral action on minimizing state estimation error that could either be due to model mismatch or a true disturbance.\nWhen parameter adaptation is enabled, this process disturbance is assumed to vary stochastically on a random walk  \\[\\mathbf{m}_{t} = \\mathbf{m}_{t-1} \u0026#43; \\mathbf{w}^m_{t-1} \\;,\\]  where  \\( \\mathbf{w}^m \\sim \\mathcal{N}\\left(0, \\mathbf{Q}_m\\right)\\)  . Kalman filtering or the point-process analogue are then used to estimate this disturbance in parallel with the state.\nControl #  Given the estimated state, the controller updates the inputs to the system according to the following law:  \\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\]  where  \\( \\left( \\cdot \\right)^{\\rm ref} \\)  correspond to reference/target signals and  \\( \\mathbf{K}^c_x \\)  is the state feedback controller gain. Recall that these controller gains are assumed to have been designed before the experiment using, for example, LQR.\nIf users are employing integral action for more robust tracking at DC and did not use the approach of augmenting the state vector and system matrices accordingly, there is an option to include the integral term as\n \\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right) - \\mathbf{K}^c_{\\rm inty} \\sum_{j=1}^{t}\\left( \\widehat{\\mathbf{y}}_j - \\mathbf{y}^{\\rm ref}_j \\right) \\;.\\]  An additional option available to users is a control law that updates the change in u,\n \\[\\Delta\\mathbf{u}_{t} = \\Delta\\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\]   \\[\\mathbf{u}_{t} = \\mathbf{u}_{t-1} \u0026#43; \\Delta\\mathbf{u}_{t} \\; .\\]  This can be useful in cases where users have designed the controller gains by LQR to minimize not the amplitude of the input, but the change in input, by augmenting the state vector with the input during LQR design.\nIntegral action and the  \\( \\Delta \\mathbf{u} \\)  control law can be combined. The library keeps track of the controller type by way of bit masks which can be bit-wise OR\u0026rsquo;d to use in combination.\nCalculating reference state-control from output #  In cases where an output reference is supplied and the goal is to track either a static or slowly varying output, users do not have to produce  \\( \\mathbf{x}^{\\rm ref} \\)  and  \\( \\mathbf{u}^{\\rm ref} \\)  . Methods are provided for calculating the state and control that would be required to reach the reference output at steady state (lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference). This is achieved by linearly-constrained least squares. For single-output systems, it results in an exact solution; however, for multi-output solutions it provides a least squares comprimise across outputs.\n"});index.add({'id':9,'href':'/ldsctrlest/docs/api/classes/','title':"Classes",'section':"LDS C+E Documentation",'content':"Classes #    lds::Controller\n  lds::EMax\n  lds::Fit LDS Fit Type.\n  lds::SSID\n  lds::SwitchedController SwitchedController Type.\n  lds::System Linear Dynamical System Type.\n  lds::UniformMatrixList\n  lds::UniformSystemList\n  lds::UniformVectorList\n  lds::gaussian::Controller Gaussian-observation Controller Type.\n  lds::gaussian::Fit GLDS Fit Type.\n  lds::gaussian::FitEM GLDS E-M Fit Type.\n  lds::gaussian::FitSSID Subspace Identification (SSID) for GLDS.\n  lds::gaussian::SwitchedController Gaussian-observation SwitchedController Type.\n  lds::gaussian::System Gaussian LDS Type.\n  lds::poisson::Controller PLDS Controller Type.\n  lds::poisson::Fit PLDS Fit Type.\n  lds::poisson::FitEM PLDS E-M Fit Type.\n  lds::poisson::FitSSID Subspace Identification (SSID) for PLDS.\n  lds::poisson::SwitchedController Poisson-observation SwitchedController Type.\n  lds::poisson::System Poisson System type.\n   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':10,'href':'/ldsctrlest/docs/api/modules/group__control__masks/','title':"Control Mode Bit Masks",'section':"Modules",'content':"Control Mode Bit Masks #  provides fill types for constructing new armadillo vectors, matrices More\u0026hellip; Attributes #      Name     const std::size_t kControlTypeDeltaU control designed to penalize change in input   const std::size_t kControlTypeIntY control using integral action   const std::size_t kControlTypeAdaptM adapt control setpoint with re-estimated disturbance m    Detailed Description #  Control mode bit masks. These can be bit-wise OR\u0026rsquo;d to use in combination.\nAttribute Details #  kControlTypeDeltaU #  static const std::size_t kControlTypeDeltaU = 0x1; Control was designed to penalize change in input (i.e., the state was augmented with input u)\nkControlTypeIntY #  static const std::size_t kControlTypeIntY = kControlTypeDeltaU \u0026lt;\u0026lt; 1; Control using integral action (i.e., the state was augmented with output y during design)\nkControlTypeAdaptM #  static const std::size_t kControlTypeAdaptM = kControlTypeDeltaU \u0026lt;\u0026lt; 2; Adapt control setpoint adapted with re-estimated process disturbance m.\n Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':11,'href':'/ldsctrlest/docs/api/modules/group__defaults/','title':"Defaults",'section':"Modules",'content':"Defaults #  \nMore\u0026hellip; Attributes #      Name     const data_t kDefaultP0 default state estimate covar   const data_t kDefaultQ0 default process noise covar   const data_t kDefaultR0 default output noise covar   std::vector\u0026lt; data_t \u0026gt; kDefaultT0    Detailed Description #  Default values for common variables (e.g., default diagonal elements of covariances)\nAttribute Details #  kDefaultP0 #  static const data_t kDefaultP0 = 1e-6; kDefaultQ0 #  static const data_t kDefaultQ0 = 1e-6; kDefaultR0 #  static const data_t kDefaultR0 = 1e-2; kDefaultT0 #  static std::vector\u0026lt; data_t \u0026gt; kDefaultT0 = std::vector\u0026lt;data_t\u0026gt;(1, 0.0);  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':12,'href':'/ldsctrlest/docs/api/examples/eg_glds_ctrl_8cpp-example/','title':"eg_glds_ctrl.cpp",'section':"Examples",'content':"eg_glds_ctrl.cpp #  Example GLDS Control\n//===-- eg_glds_ctrl.cpp - Example GLDS Control ---------------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS Control ********** \\n\\n\u0026#34;; // Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); // construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::System controlled_system(n_u, n_x, n_y, dt); // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); Matrix b_true = Matrix(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  Vector g_true = Vector(n_y).fill(10.0); // output noise covariance  Matrix r_true = Matrix(n_y, n_y, arma::fill::eye) * 1e-4; size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  Vector m0_true = Vector(n_y).fill(m_low); // Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_R(r_true); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // make a controller  lds::gaussian::Controller controller; { // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  Matrix b_controller = b_true / 2; // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  Vector m_controller = Vector(n_x, arma::fill::zeros); // for this demo, just use arbitrary default R  Matrix r_controller = Matrix(n_y, n_y, arma::fill::eye) * lds::kDefaultR0; lds::gaussian::System controller_system(controlled_system); controller_system.set_B(b_controller); controller_system.set_m(m_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m  controller_system.Print(); // going to adaptively re-estimate the disturbance  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; controller_system.set_Q_m(q_m); // create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); } // Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  Vector y_ref0 = Vector(n_y).fill(20.0 * dt); Matrix k_x = Matrix(n_u, n_x).fill(100); // gains on state error  Matrix k_inty = Matrix(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  Vector x0 = Vector(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::kControlTypeAdaptM; } else { // use integral action to minimize DC error  control_type = control_type | lds::kControlTypeIntY; } // set controller type  controller.set_control_type(control_type); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  Vector g_design = Vector(n_u).fill(9); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_g_design(g_design); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // set up variables for simulation  // create Matrixrix to save outputs in...  Matrix y_ref = Matrix(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements  Matrix z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  Matrix u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_y, n_t, arma::fill::zeros); // get initial val  y_hat.submat(0, 0, n_y - 1, 0) = controller.sys().y(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.y(); x_hat.submat(0, 0, n_x - 1, 0) = controller.sys().x(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.x(); m_hat.submat(0, 0, n_x - 1, 0) = controller.sys().m(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  Vector chance = arma::randu\u0026lt;Vector\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // input  Vector u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  z.col(t) = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Therefore, it is only  // applicable to regulation problems or cases where reference trajectory  // changes slowly compared to system dynamics.  u.col(t) = controller.ControlOutputReference(z.col(t)); // save the signals  y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; } Filename: eg_glds_ctrl.cpp\n Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':13,'href':'/ldsctrlest/docs/api/examples/eg_plds_ctrl_8cpp-example/','title':"eg_plds_ctrl.cpp",'section':"Examples",'content':"eg_plds_ctrl.cpp #  Example PLDS Control\n//===-- eg_plds_ctrl.cpp - Example PLDS Control ---------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Control ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(10.0 / dt); // Control variables: _reference/target output, controller gains  // n.b., Can either use Vector (arma::Col) or std::vector  Vector y_ref0 = Vector(n_y, arma::fill::ones) * 30.0 * dt; Matrix k_x = Matrix(n_u, n_x, arma::fill::zeros) + 1; // gains on state error  Matrix k_inty = Matrix(n_u, n_y, arma::fill::zeros) + 10; // gains on integrated output err  // Set control type bit mask, so controller knows what to do  size_t control_type = lds::kControlTypeIntY; // integral action  // // uncomment to use control that was designed to minimize change in control  // // signal, rather than instantaneous amplitude  // control_type = control_type | lds::kControlTypeDeltaU;  // if (control_type \u0026amp; lds::kControlTypeDeltaU) {  // k_x *= dt*10;  // k_inty *= 0;  // }  // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = 0.986; Matrix b_true(n_x, n_u, arma::fill::zeros); b_true[0] = 0.054; Vector x0_true = Vector(n_x, arma::fill::ones) * log(1 * dt); size_t which_m = 0; data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; Vector m0_true = Vector(n_y, arma::fill::ones) * m_low; // construct ground truth system to be controlled...  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_x0(x0_true); // reset to initial conditions  controlled_system.Reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create the controller  lds::poisson::Controller controller; { // Create model used for control.  lds::poisson::System controller_system(controlled_system); // for this example, assume model correct, except disturbance  Vector m0_controller = Vector(n_y, arma::fill::ones) * m_low; Vector x0_controller = arma::log(y_ref0); controller_system.set_m(m0_controller); controller_system.set_x0(x0_controller); controller_system.Reset(); //reset to new init condition  // adaptively re-estimate process disturbance (m)  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-5; controller_system.set_Q_m(q_m); data_t u_lb = 0.0; data_t u_ub = 5.0; controller = std::move( lds::poisson::Controller(std::move(controller_system), u_lb, u_ub)); } // set controller type  controller.set_control_type(control_type); // set controller gains  controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); // to protect against integral windup when output is consistently above  // target:  data_t tau_awu(0.1); controller.set_tau_awu(tau_awu); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create Matrixrix to save outputs in...  Matrix y_ref = Matrix(n_y, n_t, arma::fill::zeros); y_ref.each_col() += y_ref0; // Simulated measurements  Matrix z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  Matrix u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_y, n_t, arma::fill::zeros); // set initial val  y_hat.col(0) = controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = controller.sys().x(); x_true.col(0) = controlled_system.x(); m_hat.col(0) = controller.sys().m(); m_true.col(0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  Vector chance = arma::randu\u0026lt;Vector\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // e.g., use sinusoidal reference  data_t f = 0.5; // freq [=] Hz  Vector t_vec = Vector(n_y, arma::fill::ones) * t; y_ref.col(t) += y_ref0 % arma::sin(f * 2 * lds::kPi * dt * t_vec - lds::kPi / 4); // Simulate the true system.  z.col(t)=controlled_system.Simulate(u.col(t-1)); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Notably, it does this in the  // log-linear space (i.e., log(y)).  //  // Therefore, it is only applicable to regulation problems or cases where  // reference trajectory changes slowly compared to system dynamics.  controller.set_y_ref(y_ref.col(t)); u.col(t)=controller.ControlOutputReference(z.col(t)); y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } Filename: eg_plds_ctrl.cpp\n Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':14,'href':'/ldsctrlest/docs/api/examples/eg_plds_est_8cpp-example/','title':"eg_plds_est.cpp",'section':"Examples",'content':"eg_plds_est.cpp #  Example PLDS Estimation\n//===-- eg_plds_est.cpp - Example PLDS Estimation -------------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; // for generating random input Matrix random_walk(size_t n_t, const Matrix\u0026amp; Q, const Vector\u0026amp; x0); int main() { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Estimation ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation.  // construct ground truth system...  lds::poisson::System system_true(n_u, n_x, n_y, dt); // Model parameters  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); Matrix b_true = Matrix(n_x, n_u).fill(1e-2); Vector m0_true = Vector(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  Vector x0_true = m0_true * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state  // Assign params.  system_true.set_A(a_true); system_true.set_B(b_true); system_true.set_x0(x0_true); system_true.set_m(m0_true); system_true.Reset(); // Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::System system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  Vector m0_est = m0_true * 2; system_estimator.set_m(m0_est); // set new initial conditions  Vector x0_est = m0_est * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.set_x0(x0_est); system_estimator.Reset(); // reset to initial condition.  // turn on adaptive disturbance estimation  system_estimator.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.set_Q_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;estimator:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; system_estimator.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Set up simulation :  // Simulated measurements  Matrix z(n_y, n_t, arma::fill::zeros); // Stimulus (generate random stimulus)  Matrix q_u = Matrix(n_u, n_u, arma::fill::eye) * 1e-3; // cov of random walk  Matrix u = random_walk(n_t, q_u, Vector(n_u, arma::fill::zeros)); // create matrix to save outputs in...  Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix y_true(n_y, n_t, arma::fill::zeros); // states and disturbance params  Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_x, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_y, n_t, arma::fill::zeros); // initial conditions  y_hat.col(0) = system_estimator.y(); y_true.col(0) = system_true.y(); x_hat.col(0) = system_estimator.x(); x_true.col(0) = system_true.x(); m_hat.col(0) = system_estimator.m(); m_true.col(0) = system_true.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simlation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Simlate the true system.  z.col(t) = system_true.Simulate(u.col(t - 1)); // Filter (predict -\u0026gt; update)  system_estimator.Filter(u.col(t - 1), z.col(t)); // save signals  y_hat.col(t) = system_estimator.y(); y_true.col(t) = system_true.y(); x_true.col(t) = system_true.x(); m_true.col(t) = system_true.m(); x_hat.col(t) = system_estimator.x(); m_hat.col(t) = system_estimator.m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simlation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;dt\u0026#34;)); u.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } // for generating random input Matrix random_walk(size_t n_t, const Matrix\u0026amp; Q, const Vector\u0026amp; x0) { size_t n = Q.n_rows; if ((n != Q.n_cols) || (Q.n_cols != Q.n_rows)) { throw std::logic_error(\u0026#34;Q must be `n` x `n`.\u0026#34;); } Matrix x(n, n_t, arma::fill::zeros); x.col(0) = x0; for (size_t t = 1; t \u0026lt; n_t; t++) { x.col(t) = x.col(t - 1) + arma::mvnrnd(Vector(n, arma::fill::zeros), Q); } return x; } Filename: eg_plds_est.cpp\n Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':15,'href':'/ldsctrlest/docs/api/examples/eg_plds_switched_ctrl_8cpp-example/','title':"eg_plds_switched_ctrl.cpp",'section':"Examples",'content':"eg_plds_switched_ctrl.cpp #  Example Switched PLDS Control\n//===-- eg_plds_switched_ctrl.cpp - Example Switched PLDS Control ---===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::data_t; using lds::Matrix; using lds::Vector; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Switched Poisson LDS Control ********** \\n\\n\u0026#34;; // whether to do switched control  bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); // for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1  // simulated system being controlled  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  data_t scale_sys_b = 2; Matrix a(n_x, n_x, arma::fill::eye); a[0] = 0.985; Matrix b1 = Matrix(n_x, n_u).fill(0.05); Vector d = Vector(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.set_A(a); controlled_system.set_B(b1); controlled_system.set_d(d); controlled_system.Reset(); // reset to initial conditions  // reference  Vector y_ref0 = Vector(n_y, arma::fill::zeros).fill(25.0 * dt); // Let underlying system 1 be more sensitive than system 2  Matrix b2 = Matrix(n_x, n_u).fill(b1[0] / scale_sys_b); // create switched controller  lds::poisson::SwitchedController switched_controller; lds::UniformMatrixList\u0026lt;\u0026gt; k_x; // feedback controller gains  { // create switched controller sub-systems  // system 1  lds::poisson::System sys1(controlled_system); // set process noise covariance  Matrix q_controller = Matrix(n_x, n_x, arma::fill::eye) * 5e-3; sys1.set_Q(q_controller); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  sys1.do_adapt_m = true; // setting initial mode to target to avoid large error at onset:  Vector x0_controller = arma::log(y_ref0) - d; sys1.set_x0(x0_controller); sys1.Reset(); // reset to initial conditions  cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys1.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // system 2  lds::poisson::System sys2 = sys1; // set parameters  sys2.set_B(b2); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys2.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; lds::UniformSystemList\u0026lt;lds::poisson::System\u0026gt; systems({sys1, sys2}); // controller gains for underlying system s:  Matrix k_x1(n_u, n_x, arma::fill::ones); Matrix k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  k_x = lds::UniformMatrixList\u0026lt;\u0026gt;({k_x1, k_x2}); data_t u_lb = 0.0; data_t u_ub = 5.0; switched_controller = std::move( lds::poisson::SwitchedController(std::move(systems), u_lb, u_ub)); } // Control variables  size_t control_type = 0; // no integral action, etc  switched_controller.set_control_type(control_type); switched_controller.set_Kc(std::move(k_x)); switched_controller.set_y_ref(y_ref0); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;switched_controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; switched_controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Fake measurements  Matrix z(n_y, n_t, arma::fill::zeros); // Will later contain control.  Matrix u(n_u, n_t, arma::fill::zeros); // create Matrixrix to save outputs in...  Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix y_ref = Matrix(n_y, n_t).fill(y_ref0[0]); // modes and gain/disturbance params  Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix mode(1, n_t, arma::fill::ones); // set initial val  y_hat.col(0) = switched_controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = switched_controller.sys().x(); x_true.col(0) = controlled_system.x(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Let the controlled system stachastically change gain  // Assume another algorithm decodes this mode change and signals the  // switched_controller  Vector chance(1, arma::fill::randu); if (which_mode == 1) // mode1  { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.set_B(b2); if (do_switch_ctrl) { switched_controller.Switch(1); } } } else { // mode2  if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.set_B(b1); if (do_switch_ctrl) { switched_controller.Switch(0); } } } // Simulate the true system.  z.col(t) = controlled_system.Simulate(u.col(t - 1)); // perform control  u.col(t) = switched_controller.ControlOutputReference(z.col(t)); mode.col(t) = which_mode; y_ref.col(t) = y_ref0; y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); y_hat.col(t) = switched_controller.sys().y(); x_hat.col(t) = switched_controller.sys().x(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); mode.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;mode\u0026#34;, replace)); return 0; } Filename: eg_plds_switched_ctrl.cpp\n Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':16,'href':'/ldsctrlest/docs/api/examples/','title':"Examples",'section':"LDS C+E Documentation",'content':"Examples #    eg_glds_ctrl.cpp Example GLDS Control.\n  eg_plds_ctrl.cpp Example PLDS Control.\n  eg_plds_est.cpp Example PLDS Estimation.\n  eg_plds_switched_ctrl.cpp Example Switched PLDS Control.\n   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':17,'href':'/ldsctrlest/docs/api/files/dir_d28a4824dc47e487b107a5db32ef43c4/','title':"examples",'section':"Files",'content':"examples #  Files #     Name     examples/eg_glds_ctrl.cpp   examples/eg_plds_ctrl.cpp   examples/eg_plds_est.cpp   examples/eg_plds_switched_ctrl.cpp     Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':18,'href':'/ldsctrlest/docs/api/files/eg__glds__ctrl_8cpp/','title':"examples/eg_glds_ctrl.cpp",'section':"Files",'content':"examples/eg_glds_ctrl.cpp #  Functions #      Name     auto main()    Function Details #  main #  auto main() Going to simulate a switching disturbance (m) acting on system\nSource code #  //===-- eg_glds_ctrl.cpp - Example GLDS Control ---------------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS Control ********** \\n\\n\u0026#34;; // Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); // construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::System controlled_system(n_u, n_x, n_y, dt); // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); Matrix b_true = Matrix(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  Vector g_true = Vector(n_y).fill(10.0); // output noise covariance  Matrix r_true = Matrix(n_y, n_y, arma::fill::eye) * 1e-4; size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  Vector m0_true = Vector(n_y).fill(m_low); // Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_R(r_true); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // make a controller  lds::gaussian::Controller controller; { // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  Matrix b_controller = b_true / 2; // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  Vector m_controller = Vector(n_x, arma::fill::zeros); // for this demo, just use arbitrary default R  Matrix r_controller = Matrix(n_y, n_y, arma::fill::eye) * lds::kDefaultR0; lds::gaussian::System controller_system(controlled_system); controller_system.set_B(b_controller); controller_system.set_m(m_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m  controller_system.Print(); // going to adaptively re-estimate the disturbance  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; controller_system.set_Q_m(q_m); // create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); } // Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  Vector y_ref0 = Vector(n_y).fill(20.0 * dt); Matrix k_x = Matrix(n_u, n_x).fill(100); // gains on state error  Matrix k_inty = Matrix(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  Vector x0 = Vector(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::kControlTypeAdaptM; } else { // use integral action to minimize DC error  control_type = control_type | lds::kControlTypeIntY; } // set controller type  controller.set_control_type(control_type); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  Vector g_design = Vector(n_u).fill(9); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_g_design(g_design); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // set up variables for simulation  // create Matrixrix to save outputs in...  Matrix y_ref = Matrix(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements  Matrix z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  Matrix u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_y, n_t, arma::fill::zeros); // get initial val  y_hat.submat(0, 0, n_y - 1, 0) = controller.sys().y(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.y(); x_hat.submat(0, 0, n_x - 1, 0) = controller.sys().x(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.x(); m_hat.submat(0, 0, n_x - 1, 0) = controller.sys().m(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  Vector chance = arma::randu\u0026lt;Vector\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // input  Vector u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  z.col(t) = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Therefore, it is only  // applicable to regulation problems or cases where reference trajectory  // changes slowly compared to system dynamics.  u.col(t) = controller.ControlOutputReference(z.col(t)); // save the signals  y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; }  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':19,'href':'/ldsctrlest/docs/api/files/eg__plds__ctrl_8cpp/','title':"examples/eg_plds_ctrl.cpp",'section':"Files",'content':"examples/eg_plds_ctrl.cpp #  Functions #      Name     auto main()    Function Details #  main #  auto main() Going to simulate a switching disturbance (m) acting on system\nSource code #  //===-- eg_plds_ctrl.cpp - Example PLDS Control ---------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Control ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(10.0 / dt); // Control variables: _reference/target output, controller gains  // n.b., Can either use Vector (arma::Col) or std::vector  Vector y_ref0 = Vector(n_y, arma::fill::ones) * 30.0 * dt; Matrix k_x = Matrix(n_u, n_x, arma::fill::zeros) + 1; // gains on state error  Matrix k_inty = Matrix(n_u, n_y, arma::fill::zeros) + 10; // gains on integrated output err  // Set control type bit mask, so controller knows what to do  size_t control_type = lds::kControlTypeIntY; // integral action  // // uncomment to use control that was designed to minimize change in control  // // signal, rather than instantaneous amplitude  // control_type = control_type | lds::kControlTypeDeltaU;  // if (control_type \u0026amp; lds::kControlTypeDeltaU) {  // k_x *= dt*10;  // k_inty *= 0;  // }  // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = 0.986; Matrix b_true(n_x, n_u, arma::fill::zeros); b_true[0] = 0.054; Vector x0_true = Vector(n_x, arma::fill::ones) * log(1 * dt); size_t which_m = 0; data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; Vector m0_true = Vector(n_y, arma::fill::ones) * m_low; // construct ground truth system to be controlled...  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_x0(x0_true); // reset to initial conditions  controlled_system.Reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create the controller  lds::poisson::Controller controller; { // Create model used for control.  lds::poisson::System controller_system(controlled_system); // for this example, assume model correct, except disturbance  Vector m0_controller = Vector(n_y, arma::fill::ones) * m_low; Vector x0_controller = arma::log(y_ref0); controller_system.set_m(m0_controller); controller_system.set_x0(x0_controller); controller_system.Reset(); //reset to new init condition  // adaptively re-estimate process disturbance (m)  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-5; controller_system.set_Q_m(q_m); data_t u_lb = 0.0; data_t u_ub = 5.0; controller = std::move( lds::poisson::Controller(std::move(controller_system), u_lb, u_ub)); } // set controller type  controller.set_control_type(control_type); // set controller gains  controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); // to protect against integral windup when output is consistently above  // target:  data_t tau_awu(0.1); controller.set_tau_awu(tau_awu); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create Matrixrix to save outputs in...  Matrix y_ref = Matrix(n_y, n_t, arma::fill::zeros); y_ref.each_col() += y_ref0; // Simulated measurements  Matrix z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  Matrix u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_y, n_t, arma::fill::zeros); // set initial val  y_hat.col(0) = controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = controller.sys().x(); x_true.col(0) = controlled_system.x(); m_hat.col(0) = controller.sys().m(); m_true.col(0) = controlled_system.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  Vector chance = arma::randu\u0026lt;Vector\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = std::vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.set_m(m0_true); // e.g., use sinusoidal reference  data_t f = 0.5; // freq [=] Hz  Vector t_vec = Vector(n_y, arma::fill::ones) * t; y_ref.col(t) += y_ref0 % arma::sin(f * 2 * lds::kPi * dt * t_vec - lds::kPi / 4); // Simulate the true system.  z.col(t)=controlled_system.Simulate(u.col(t-1)); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Notably, it does this in the  // log-linear space (i.e., log(y)).  //  // Therefore, it is only applicable to regulation problems or cases where  // reference trajectory changes slowly compared to system dynamics.  controller.set_y_ref(y_ref.col(t)); u.col(t)=controller.ControlOutputReference(z.col(t)); y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); m_true.col(t) = controlled_system.m(); y_hat.col(t) = controller.sys().y(); x_hat.col(t) = controller.sys().x(); m_hat.col(t) = controller.sys().m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; }  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':20,'href':'/ldsctrlest/docs/api/files/eg__plds__est_8cpp/','title':"examples/eg_plds_est.cpp",'section':"Files",'content':"examples/eg_plds_est.cpp #  Functions #      Name     Matrix random_walk(size_t n_t, const Matrix \u0026amp; Q, const Vector \u0026amp; x0)   int main()    Function Details #  random_walk #  Matrix random_walk( size_t n_t, const Matrix \u0026amp; Q, const Vector \u0026amp; x0 ) main #  int main() Source code #  //===-- eg_plds_est.cpp - Example PLDS Estimation -------------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; // for generating random input Matrix random_walk(size_t n_t, const Matrix\u0026amp; Q, const Vector\u0026amp; x0); int main() { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Estimation ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation.  // construct ground truth system...  lds::poisson::System system_true(n_u, n_x, n_y, dt); // Model parameters  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); Matrix b_true = Matrix(n_x, n_u).fill(1e-2); Vector m0_true = Vector(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  Vector x0_true = m0_true * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state  // Assign params.  system_true.set_A(a_true); system_true.set_B(b_true); system_true.set_x0(x0_true); system_true.set_m(m0_true); system_true.Reset(); // Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::System system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  Vector m0_est = m0_true * 2; system_estimator.set_m(m0_est); // set new initial conditions  Vector x0_est = m0_est * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.set_x0(x0_est); system_estimator.Reset(); // reset to initial condition.  // turn on adaptive disturbance estimation  system_estimator.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.set_Q_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;estimator:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; system_estimator.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Set up simulation :  // Simulated measurements  Matrix z(n_y, n_t, arma::fill::zeros); // Stimulus (generate random stimulus)  Matrix q_u = Matrix(n_u, n_u, arma::fill::eye) * 1e-3; // cov of random walk  Matrix u = random_walk(n_t, q_u, Vector(n_u, arma::fill::zeros)); // create matrix to save outputs in...  Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix y_true(n_y, n_t, arma::fill::zeros); // states and disturbance params  Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix m_hat(n_x, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix m_true(n_y, n_t, arma::fill::zeros); // initial conditions  y_hat.col(0) = system_estimator.y(); y_true.col(0) = system_true.y(); x_hat.col(0) = system_estimator.x(); x_true.col(0) = system_true.x(); m_hat.col(0) = system_estimator.m(); m_true.col(0) = system_true.m(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simlation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Simlate the true system.  z.col(t) = system_true.Simulate(u.col(t - 1)); // Filter (predict -\u0026gt; update)  system_estimator.Filter(u.col(t - 1), z.col(t)); // save signals  y_hat.col(t) = system_estimator.y(); y_true.col(t) = system_true.y(); x_true.col(t) = system_true.x(); m_true.col(t) = system_true.m(); x_hat.col(t) = system_estimator.x(); m_hat.col(t) = system_estimator.m(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simlation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;dt\u0026#34;)); u.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } // for generating random input Matrix random_walk(size_t n_t, const Matrix\u0026amp; Q, const Vector\u0026amp; x0) { size_t n = Q.n_rows; if ((n != Q.n_cols) || (Q.n_cols != Q.n_rows)) { throw std::logic_error(\u0026#34;Q must be `n` x `n`.\u0026#34;); } Matrix x(n, n_t, arma::fill::zeros); x.col(0) = x0; for (size_t t = 1; t \u0026lt; n_t; t++) { x.col(t) = x.col(t - 1) + arma::mvnrnd(Vector(n, arma::fill::zeros), Q); } return x; }  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':21,'href':'/ldsctrlest/docs/api/files/eg__plds__switched__ctrl_8cpp/','title':"examples/eg_plds_switched_ctrl.cpp",'section':"Files",'content':"examples/eg_plds_switched_ctrl.cpp #  Functions #      Name     auto main()    Function Details #  main #  auto main() Source code #  //===-- eg_plds_switched_ctrl.cpp - Example Switched PLDS Control ---===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::data_t; using lds::Matrix; using lds::Vector; using std::cout; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Switched Poisson LDS Control ********** \\n\\n\u0026#34;; // whether to do switched control  bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); // for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1  // simulated system being controlled  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  data_t scale_sys_b = 2; Matrix a(n_x, n_x, arma::fill::eye); a[0] = 0.985; Matrix b1 = Matrix(n_x, n_u).fill(0.05); Vector d = Vector(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.set_A(a); controlled_system.set_B(b1); controlled_system.set_d(d); controlled_system.Reset(); // reset to initial conditions  // reference  Vector y_ref0 = Vector(n_y, arma::fill::zeros).fill(25.0 * dt); // Let underlying system 1 be more sensitive than system 2  Matrix b2 = Matrix(n_x, n_u).fill(b1[0] / scale_sys_b); // create switched controller  lds::poisson::SwitchedController switched_controller; lds::UniformMatrixList\u0026lt;\u0026gt; k_x; // feedback controller gains  { // create switched controller sub-systems  // system 1  lds::poisson::System sys1(controlled_system); // set process noise covariance  Matrix q_controller = Matrix(n_x, n_x, arma::fill::eye) * 5e-3; sys1.set_Q(q_controller); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  sys1.do_adapt_m = true; // setting initial mode to target to avoid large error at onset:  Vector x0_controller = arma::log(y_ref0) - d; sys1.set_x0(x0_controller); sys1.Reset(); // reset to initial conditions  cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys1.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // system 2  lds::poisson::System sys2 = sys1; // set parameters  sys2.set_B(b2); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys2.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; lds::UniformSystemList\u0026lt;lds::poisson::System\u0026gt; systems({sys1, sys2}); // controller gains for underlying system s:  Matrix k_x1(n_u, n_x, arma::fill::ones); Matrix k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  k_x = lds::UniformMatrixList\u0026lt;\u0026gt;({k_x1, k_x2}); data_t u_lb = 0.0; data_t u_ub = 5.0; switched_controller = std::move( lds::poisson::SwitchedController(std::move(systems), u_lb, u_ub)); } // Control variables  size_t control_type = 0; // no integral action, etc  switched_controller.set_control_type(control_type); switched_controller.set_Kc(std::move(k_x)); switched_controller.set_y_ref(y_ref0); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;switched_controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; switched_controller.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Fake measurements  Matrix z(n_y, n_t, arma::fill::zeros); // Will later contain control.  Matrix u(n_u, n_t, arma::fill::zeros); // create Matrixrix to save outputs in...  Matrix y_hat(n_y, n_t, arma::fill::zeros); Matrix y_true(n_y, n_t, arma::fill::zeros); Matrix y_ref = Matrix(n_y, n_t).fill(y_ref0[0]); // modes and gain/disturbance params  Matrix x_hat(n_x, n_t, arma::fill::zeros); Matrix x_true(n_x, n_t, arma::fill::zeros); Matrix mode(1, n_t, arma::fill::ones); // set initial val  y_hat.col(0) = switched_controller.sys().y(); y_true.col(0) = controlled_system.y(); x_hat.col(0) = switched_controller.sys().x(); x_true.col(0) = controlled_system.x(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Let the controlled system stachastically change gain  // Assume another algorithm decodes this mode change and signals the  // switched_controller  Vector chance(1, arma::fill::randu); if (which_mode == 1) // mode1  { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.set_B(b2); if (do_switch_ctrl) { switched_controller.Switch(1); } } } else { // mode2  if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.set_B(b1); if (do_switch_ctrl) { switched_controller.Switch(0); } } } // Simulate the true system.  z.col(t) = controlled_system.Simulate(u.col(t - 1)); // perform control  u.col(t) = switched_controller.ControlOutputReference(z.col(t)); mode.col(t) = which_mode; y_ref.col(t) = y_ref0; y_true.col(t) = controlled_system.y(); x_true.col(t) = controlled_system.x(); y_hat.col(t) = switched_controller.sys().y(); x_hat.col(t) = switched_controller.sys().x(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = Vector(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); mode.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;mode\u0026#34;, replace)); return 0; }  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':22,'href':'/ldsctrlest/docs/api/files/','title':"Files",'section':"LDS C+E Documentation",'content':"Files #    ldsCtrlEst_h/lds.h lds namespace\n  ldsCtrlEst_h/lds_ctrl.h Controller.\n  ldsCtrlEst_h/lds_fit.h LDS base fit type.\n  ldsCtrlEst_h/lds_fit_em.h subspace identification\n  ldsCtrlEst_h/lds_fit_ssid.h subspace identification\n  ldsCtrlEst_h/lds_gaussian.h glds namespace\n  ldsCtrlEst_h/lds_gaussian_ctrl.h GLDS Controller.\n  ldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type.\n  ldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type.\n  ldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type.\n  ldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type.\n  ldsCtrlEst_h/lds_gaussian_sys.h GLDS base type.\n  ldsCtrlEst_h/lds_poisson.h plds namespace\n  ldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type.\n  ldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type.\n  ldsCtrlEst_h/lds_poisson_fit_em.h PLDS E-M fit type.\n  ldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type.\n  ldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type.\n  ldsCtrlEst_h/lds_poisson_sys.h PLDS base type.\n  ldsCtrlEst_h/lds_sctrl.h SwitchedController type.\n  ldsCtrlEst_h/lds_sys.h LDS base type.\n  ldsCtrlEst_h/lds_uniform_mats.h List of uniformly sized matrices.\n  ldsCtrlEst_h/lds_uniform_systems.h List of uniformly sized Systems.\n  ldsCtrlEst_h/lds_uniform_vecs.h List of uniformly sized vectors.\n  ldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API)\n  ldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API)\n  examples/eg_glds_ctrl.cpp\n  examples/eg_plds_ctrl.cpp\n  examples/eg_plds_est.cpp\n  examples/eg_plds_switched_ctrl.cpp\n  src/lds.cpp misc lds namespace functions\n  src/lds_gaussian_sys.cpp GLDS base type.\n  src/lds_poisson_sys.cpp PLDS base type.\n  src/lds_sys.cpp LDS base type.\n  src/lds_uniform_vecs.cpp Uniformly sized vectors.\n   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':23,'href':'/ldsctrlest/docs/tutorials/eg_glds_control/','title':"GLDS Control",'section':"LDS C+E Examples",'content':"GLDS Control Tutorial #  This tutorial shows how to use this library to control a system with a Gaussian LDS controller (lds::gaussian::Controller). In place of a physical system, a GLDS model (lds::gaussian::System) receives control inputs and simulates measurements for the feedback control loop. The controller is assumed to have an imperfect model of the system being controlled (here, a gain mismatch), and there is a stochastic, unmeasured disturbance acting on the system. A combination of integral action and adaptive estimation of this process disturbance is used to perform control.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; Note that lds::Matrix and lds::Vector are typedefs for arma::Mat\u0026lt;data_t\u0026gt; and arma::Col\u0026lt;data_t\u0026gt;, where the data type is double by default. May be changed to float in include/ldsCtrlEst_h/lds.h if there are memory constraints (e.g., large-scale MIMO control problems).\nCreating a simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 5 seconds.\n// Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); When a system is initialized, rather than requiring all parameters be provided at construction, users may create a default system by setting only the dimensions and sample period.\n// construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::System controlled_system(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example,   \\[x_{t\u0026#43;1} = x_t \u0026#43; w_t\\]   \\[y_{t} = x_t\\]  where  \\( w_{t} \\sim \\mathcal{N}\\left( 0, Q \\right) \\)  .\nNow, create non-default parameters for this model.\n// Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); Matrix b_true = Matrix(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  Vector g_true = Vector(n_y).fill(10.0); // output noise covariance  Matrix r_true = Matrix(n_y, n_y, arma::fill::eye) * 1e-4; As mentioned above, this example will feature a stochastic disturbance. More specifically, a process disturbance will randomly change between two values.\n/// Going to simulate a switching disturbance (m) acting on system  size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  Vector m0_true = Vector(n_y).fill(m_low); Finally, assign the parameters using corresponding set-methods.\n// Assign params.  controlled_system.set_A(a_true); controlled_system.set_B(b_true); controlled_system.set_m(m0_true); controlled_system.set_g(g_true); controlled_system.set_R(r_true); Creating the controller #  Now, create the controller. This requires first constructing the system model that the control uses for estimating state feedback and updating the control signal. A controller is then constructed from this lds::gaussian::System object and upper/lower bounds on the control signal (u_lb, u_ub below), past which the control saturates. Here, the control signal is command voltage sent to an analog driver (e.g., for an LED). Its limits are 0 to 5 V. If your actuator does not saturate somehow, simply set the lower and upper bounds to -lds::kInf and lds::kInf, respectively. Simple saturation is currently the only actuator model in this library.\nFor the sake of this simulation, the system model input matrix is set to an incorrect value. We also assume that the controller feedback gains were designed with an actuator whose conversion factor from volts to physical units (e.g., mW/mm2 optical intensity) differed from the actuator being used in the current experiment.\n// make a controller  lds::gaussian::Controller controller; { // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  Matrix b_controller = b_true / 2; // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  Vector m_controller = Vector(n_x, arma::fill::zeros); // for this demo, just use arbitrary default R  Matrix r_controller = Matrix(n_y, n_y, arma::fill::eye) * lds::kDefaultR0; lds::gaussian::System controller_system(controlled_system); controller_system.set_B(b_controller); controller_system.set_m(m_controller); controller_system.set_R(r_controller); controller_system.Reset(); // reset to new m  // going to adaptively re-estimate the disturbance  controller_system.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise  // acting on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; controller_system.set_Q_m(q_m); // create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  controller = std::move( lds::gaussian::Controller(std::move(controller_system), u_lb, u_ub)); } Note that the above code block demonstrates how move semantics can be used for assignment/construction. Copy assignment/construction is of course also allowed.\nWith the controller constructed, control variables may be set.\n// Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  Vector y_ref0 = Vector(n_y).fill(20.0 * dt); Matrix k_x = Matrix(n_u, n_x).fill(100); // gains on state error  Matrix k_inty = Matrix(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  Vector x0 = Vector(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::kControlTypeAdaptM; } else { // use integral action to minimize DC error  control_type = control_type | lds::kControlTypeIntY; } // set controller type  controller.set_control_type(control_type); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  Vector g_design = Vector(n_u).fill(9); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.set_y_ref(y_ref0); controller.set_Kc(k_x); controller.set_Kc_inty(k_inty); controller.set_g_design(g_design); Simulating control #  In this demonstration, we will use the ControlOutputReference method which allows users to simply set the reference output and supply the current measurement z. It then calculates the solution for the state/input required to track the reference output at steady state. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system.\nThe control loop is carried out here in a simple for-loop, where a the controlled system is simulated, a measurement taken, and the control signal updated.\n// Simulate the true system.  z.col(t) = controlled_system.Simulate(u_tm1); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Therefore, it is only  // applicable to regulation problems or cases where reference trajectory  // changes slowly compared to system dynamics.  u.col(t) = controller.ControlOutputReference(z.col(t)); Example simulation result #  Below are example results for this simulation, including outputs, latent states, process disturbance, and the control signal. The controller\u0026rsquo;s online estimates of the output, state, and disturbance are given in purple.\n"});index.add({'id':24,'href':'/ldsctrlest/docs/api/files/dir_8f2980731aba7ec7b9fcae5764f196e3/','title':"include",'section':"Files",'content':"include #  Directories #     Name     ldsCtrlEst_h     Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':25,'href':'/ldsctrlest/docs/api/namespaces/namespacelds/','title':"lds",'section':"Namespaces",'content':"lds #  Linear Dynamical Systems (LDS) namespace. Namespaces #     Name     lds::gaussian Linear Dynamical Systems with Gaussian observations.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::Controller   class lds::Fit LDS Fit Type.   class lds::EMax   class lds::SSID   class lds::SwitchedController SwitchedController Type.   class lds::System Linear Dynamical System Type.   class lds::UniformMatrixList   class lds::UniformSystemList   class lds::UniformVectorList    Types #      Name     enum SSIDWt { kSSIDNone, kSSIDMOESP, kSSIDCVA}\nweighting options for SSID   enum MatrixListFreeDim { kMatFreeDimNone, kMatFreeDim1, kMatFreeDim2}   using double data_t   using arma::Col\u0026lt; data_t \u0026gt; Vector   using arma::Mat\u0026lt; data_t \u0026gt; Matrix   using arma::Cube\u0026lt; data_t \u0026gt; Cube   using arma::subview\u0026lt; data_t \u0026gt; View    Functions #      Name     void Limit(std::vector\u0026lt; data_t \u0026gt; \u0026amp; x, data_t lb, data_t ub)   void Limit(Vector \u0026amp; x, data_t lb, data_t ub)   void Limit(Matrix \u0026amp; x, data_t lb, data_t ub)   void Reassign(Vector \u0026amp; some, const Vector \u0026amp; other, const std::string \u0026amp; parenthetical =\u0026ldquo;Reassign\u0026rdquo;)\nreassigns contents of some Vector in place   void Reassign(Matrix \u0026amp; some, const Matrix \u0026amp; other, const std::string \u0026amp; parenthetical =\u0026ldquo;Reassign\u0026rdquo;)\nreassigns contents of some Matrix in place   void ForceSymPD(Matrix \u0026amp; X)\nforces matrix to be symmetric positive-definite   void ForceSymMinEig(Matrix \u0026amp; X, data_t eig_min =0)\nforces matrix to be symmetric and have a minimum eigenvalue   void lq(Matrix \u0026amp; L, Matrix \u0026amp; Qt, const Matrix \u0026amp; X)\nLQ decomposition.   Matrix calcCov(const Matrix \u0026amp; A, const Matrix \u0026amp; B)\nCalculate covariance matrix.    Attributes #      Name     const std::size_t kControlTypeDeltaU control designed to penalize change in input   const std::size_t kControlTypeIntY control using integral action   const std::size_t kControlTypeAdaptM adapt control setpoint with re-estimated disturbance m   const data_t kInf Some useful numbers.   const data_t kPi   const data_t kDefaultP0 default state estimate covar   const data_t kDefaultQ0 default process noise covar   const data_t kDefaultR0 default output noise covar   std::vector\u0026lt; data_t \u0026gt; kDefaultT0    Type Details #  SSIDWt #     Enumerator Value Description     kSSIDNone  None.   kSSIDMOESP  MOESP (AKA \u0026ldquo;robust method\u0026rdquo; in van Overschee 1996)   kSSIDCVA  CVA \u0026ldquo;Canonical Variate Analysis\u0026rdquo;.    Weighting options for singular value decomposition performed during subspace identification (SSID)\nReference:\nvan Overschee, de Moor. 1996. Subspace Identification for Linear Systems.\nMatrixListFreeDim #     Enumerator Value Description     kMatFreeDimNone  neither dim free to be hetero in mat list   kMatFreeDim1  allow 1st dim of mats in list to be hetero   kMatFreeDim2  allow 2nd dim of mats in list to be hetero    data_t #  using lds::data_t = typedef double; Type of all data in library. If need 32b, change double to float. This could be potentially useful for large scale problems where there are memory constraints.\nVector #  using lds::Vector = typedef arma::Col\u0026lt;data_t\u0026gt;; Matrix #  using lds::Matrix = typedef arma::Mat\u0026lt;data_t\u0026gt;; Cube #  using lds::Cube = typedef arma::Cube\u0026lt;data_t\u0026gt;; View #  using lds::View = typedef arma::subview\u0026lt;data_t\u0026gt;; Function Details #  Limit #  inline void Limit( std::vector\u0026lt; data_t \u0026gt; \u0026amp; x, data_t lb, data_t ub ) Limit #  inline void Limit( Vector \u0026amp; x, data_t lb, data_t ub ) Limit #  inline void Limit( Matrix \u0026amp; x, data_t lb, data_t ub ) Reassign #  inline void Reassign( Vector \u0026amp; some, const Vector \u0026amp; other, const std::string \u0026amp; parenthetical =\u0026#34;Reassign\u0026#34; ) Parameters:\n some some Vector other other Vector parenthetical optional description provided by caller to ease debugging  Reassign #  inline void Reassign( Matrix \u0026amp; some, const Matrix \u0026amp; other, const std::string \u0026amp; parenthetical =\u0026#34;Reassign\u0026#34; ) Parameters:\n some some Matrix other other Matrix parenthetical optional description provided by caller to ease debugging  ForceSymPD #  void ForceSymPD( Matrix \u0026amp; X ) Parameters:\n X mutated matrix  ForceSymMinEig #  void ForceSymMinEig( Matrix \u0026amp; X, data_t eig_min =0 ) Parameters:\n X mutated matrix eig_min [optional] minimum eigen value  lq #  void lq( Matrix \u0026amp; L, Matrix \u0026amp; Qt, const Matrix \u0026amp; X ) Parameters:\n L lower triangle matrix Qt orthonormal matrix (transposed cf QR decomp) X matrix being decomposed  calcCov #  Matrix calcCov( const Matrix \u0026amp; A, const Matrix \u0026amp; B ) Parameters:\n A some matrix B some other matrix  Return: covariance\nAttribute Details #  kControlTypeDeltaU #  static const std::size_t kControlTypeDeltaU = 0x1; Control was designed to penalize change in input (i.e., the state was augmented with input u)\nkControlTypeIntY #  static const std::size_t kControlTypeIntY = kControlTypeDeltaU \u0026lt;\u0026lt; 1; Control using integral action (i.e., the state was augmented with output y during design)\nkControlTypeAdaptM #  static const std::size_t kControlTypeAdaptM = kControlTypeDeltaU \u0026lt;\u0026lt; 2; Adapt control setpoint adapted with re-estimated process disturbance m.\nkInf #  static const data_t kInf = std::numeric_limits\u0026lt;[data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#using-data_t)\u0026gt;::infinity(); kPi #  static const data_t kPi = arma::datum::pi; kDefaultP0 #  static const data_t kDefaultP0 = 1e-6; kDefaultQ0 #  static const data_t kDefaultQ0 = 1e-6; kDefaultR0 #  static const data_t kDefaultR0 = 1e-2; kDefaultT0 #  static std::vector\u0026lt; data_t \u0026gt; kDefaultT0 = std::vector\u0026lt;[data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#using-data_t)\u0026gt;(1, 0.0);  Updated on 22 March 2021 at 22:01:29 CDT\n"});index.add({'id':26,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_controller/','title':"lds::Controller",'section':"Classes",'content':"lds::Controller #  More\u0026hellip;\nInherited by lds::SwitchedController\u0026lt; System \u0026gt;, lds::gaussian::Controller, lds::poisson::Controller\nPublic Functions #      Name      Controller() =default\nConstructs a new Controller.    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const Matrix \u0026amp; Kc() const\nGet state feedback controller gain.   const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain.   const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain.   const Vector \u0026amp; g_design() const\nGet input gain used in controller design.   const Vector \u0026amp; u_ref() const\nGet reference input.   const Vector \u0026amp; x_ref() const\nGet reference state.   const Vector \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref)   virtual void set_y_ref(const Vector \u0026amp; y_ref)\nSet reference output (y_ref)   void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()\nprints variables to stdout    Protected Attributes #      Name     System sys_ underlying LDS   Vector u_ control signal   Vector g_design_ input gain of the system used for controller design   Vector u_ref_ reference input   Vector u_ref_prev_ reference input at previous time step   Vector x_ref_ reference state   Vector y_ref_ reference output   Vector cx_ref_   Matrix Kc_ state controller gain   Matrix Kc_u_ input controller gain (optional when control updates \\deltaU)   Matrix Kc_inty_ integral controller gain   Vector du_ref_   Vector dv_ref_   Vector v_ref_   Vector dv_   Vector v_ Control after g inversion (e.g., control in physical units)   Vector int_e_ integrated error   Vector int_e_awu_adjust_ anti-windup adjustment to intE   Vector u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type    Detailed Description #  template \u0026lt;typename System \u0026gt; class lds::Controller;   Public Function Details #  Controller #  Controller() =default  Controller #  inline Controller( const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\n sys System (derived from lds::System) u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask  Template Parameters:\n System type derived from lds::System   Controller #  inline Controller( System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\n sys System (derived from lds::System) u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask  Template Parameters:\n System type derived from lds::System   Control #  inline const Vector \u0026amp; Control( const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true ) Parameters:\n z measurement do_control [optional] whether to update control (true) or simply feed through u_ref (false) do_lock_control [optional] whether to lock control at its current value sigma_soft_start [optional] standard deviation (sigma) of a Gaussian soft-start to control (do_control from false to true) sigma_u_noise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal do_reset_at_control_onset [optional] whether to reset controller at control epoch onset (i.e., do_control from false to true)  Return: updated control signal\nUpdates the control signal (single-step). This is the most flexible option, but requires user to have set the controller\u0026rsquo;s y_ref, x_ref, and u_ref variables.\n ControlOutputReference #  inline const Vector \u0026amp; ControlOutputReference( const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true ) Parameters:\n z measurement do_control [optional] whether to update control (true) or simply feed through u_ref (false) do_estimation [optional] whether to update state estimate (if false, effectively open-loop control) do_lock_control [optional] whether to lock control at its current value sigma_soft_start [optional] standard deviation (sigma) of a Gaussian soft-start to control (do_control from false to true) sigma_u_noise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal do_reset_at_control_onset [optional] whether to reset controller at control epoch onset (i.e., do_control from false to true)  Return: updated control signal\nUpdates the control signal (single-step), given previously-set y_ref. This method calculates the rest of the set point (u_ref, x_ref) that is required to for the system to be at y_ref at steady state. This is accomplished by linearly-constrained least-squares. For a single-output system, the solution should be exact within control saturation limits. For a multi-output system, it provides the least-squares comprimise across the outputs.\n sys #  inline const System \u0026amp; sys() const  Kc #  inline const Matrix \u0026amp; Kc() const  Kc_inty #  inline const Matrix \u0026amp; Kc_inty() const  Kc_u #  inline const Matrix \u0026amp; Kc_u() const  g_design #  inline const Vector \u0026amp; g_design() const  u_ref #  inline const Vector \u0026amp; u_ref() const  x_ref #  inline const Vector \u0026amp; x_ref() const  y_ref #  inline const Vector \u0026amp; y_ref() const  control_type #  inline size_t control_type() const  set_sys #  inline void set_sys( const System \u0026amp; sys )  set_g_design #  inline void set_g_design( const Vector \u0026amp; g_design )  set_u_ref #  inline void set_u_ref( const Vector \u0026amp; u_ref )  set_x_ref #  inline void set_x_ref( const Vector \u0026amp; x_ref )  set_y_ref #  inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) Reimplemented by: lds::gaussian::Controller::set_y_ref, lds::gaussian::SwitchedController::set_y_ref, lds::poisson::Controller::set_y_ref, lds::poisson::SwitchedController::set_y_ref\n set_Kc #  inline void set_Kc( const Matrix \u0026amp; Kc )  set_Kc_inty #  inline void set_Kc_inty( const Matrix \u0026amp; Kc_inty )  set_Kc_u #  inline void set_Kc_u( const Matrix \u0026amp; Kc_u )  set_tau_awu #  inline void set_tau_awu( data_t tau )  set_control_type #  inline void set_control_type( size_t control_type ) Parameters:\n control_type control type bit mask  Template Parameters:\n System type derived from lds::System   Reset #  inline void Reset()  Print #  inline void Print()  Protected Attribute Details #  **sys_** #  System sys_;  **u_** #  Vector u_;  **g_design_** #  Vector g_design_;  **u_ref_** #  Vector u_ref_;  **u_ref_prev_** #  Vector u_ref_prev_;  **x_ref_** #  Vector x_ref_;  **y_ref_** #  Vector y_ref_;  **cx_ref_** #  Vector cx_ref_;  **Kc_** #  Matrix Kc_;  **Kc_u_** #  Matrix Kc_u_;  **Kc_inty_** #  Matrix Kc_inty_;  **du_ref_** #  Vector du_ref_;  **dv_ref_** #  Vector dv_ref_;  **v_ref_** #  Vector v_ref_;  **dv_** #  Vector dv_;  **v_** #  Vector v_;  **int_e_** #  Vector int_e_;  **int_e_awu_adjust_** #  Vector int_e_awu_adjust_;  **u_sat_** #  Vector u_sat_;  **do_control_prev_** #  bool do_control_prev_ = false;  **do_lock_control_prev_** #  bool do_lock_control_prev_ = false;  **u_saturated_** #  bool u_saturated_ = false;  **u_lb_** #  data_t u_lb_ {};  **u_ub_** #  data_t u_ub_ {};  **tau_awu_** #  data_t tau_awu_ {};  **k_awu_** #  data_t k_awu_ = 0;  **t_since_control_onset_** #  data_t t_since_control_onset_ = 0;  **control_type_** #  size_t control_type_ {};   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':27,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_e_max/','title':"lds::EMax",'section':"Classes",'content':"lds::EMax #  More\u0026hellip;\nInherited by lds::gaussian::FitEM, lds::poisson::FitEM\nPublic Functions #      Name      EMax() =default\nConstructs a new EMaxFit type.    EMax(size_t n_x, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMaxFit type.    EMax(const Fit \u0026amp; fit0, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMaxFit type.   const Fit \u0026amp; Run(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =true, bool calc_output =true, bool calc_measurement =true, size_t max_iter =100, data_t tol =1e-2)\nRuns fitting by Expectation(E)-Maximizaiton(Max)   std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the input/output data to caller.   const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; x() const\ngets estimated state (over time)   const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; y() const\ngets estimated output (over time)   const Matrix \u0026amp; sum_E_x_t_x_t() const\ngets state-input covariance   const Matrix \u0026amp; sum_E_xu_tm1_xu_tm1() const\ngets state-input covariance (t-minus-1)   const Matrix \u0026amp; sum_E_xu_t_xu_tm1() const\ngets single lag state-input covariance   size_t n_t_tot()\ntotal number of time samples   const Vector \u0026amp; theta() const\ngets parameters updated in M step    Protected Functions #      Name     void Expectation(bool force_common_initial =false)\nExpectation step.   void Maximization(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =false, bool calc_output =false, bool calc_measurement =false)\nMaximization step.   void MaximizeDynamics()   void MaximizeQ()   void MaximizeInitial()   virtual void MaximizeOutput() =0   virtual void MaximizeMeasurement() =0   void Smooth(bool force_common_initial)\nget smoothed estimates   virtual void RecurseKe(Matrix \u0026amp; Ke, Cube \u0026amp; P_pre, Cube \u0026amp; P_post, size_t t) =0\nrecursively update estimator gain Ke   void Reset()\nreset to initial conditions   void InitVars()\nInitializes the variables.   Vector UpdateTheta()\nupdates parameter list, theta    Protected Attributes #      Name     UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data   UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data   std::vector\u0026lt; Matrix \u0026gt; x_ state estimate   std::vector\u0026lt; Cube \u0026gt; P_ state estimate cov   std::vector\u0026lt; Cube \u0026gt; P_t_tm1_ single-lag state covariance   std::vector\u0026lt; Matrix \u0026gt; y_ output estimate   Matrix diag_y_   Matrix sum_E_x_t_x_t_ state covariance (current time)   Matrix sum_E_xu_tm1_xu_tm1_ state-input covariance (t-minus-1)   Matrix sum_E_xu_t_xu_tm1_ single lag state-input covariance   Fit fit_   Vector theta_   data_t dt_ sample period   size_t n_u_ number of inputs   size_t n_x_ number of states   size_t n_y_ number of outputs   size_t n_trials_ number of input/output data sequences   std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps   size_t n_t_tot_ total number of time steps across trials    Detailed Description #  template \u0026lt;typename Fit \u0026gt; class lds::EMax;   Public Function Details #  EMax #  EMax() =default  EMax #  EMax( size_t n_x, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train ) Parameters:\n n_x number of states dt sample period u_train input training data z_train measurement training data   EMax #  EMax( const Fit \u0026amp; fit0, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train ) Parameters:\n fit0 initial fit u_train input training data z_train measurement training data   Run #  const Fit \u0026amp; Run( bool calc_dynamics =true, bool calc_Q =true, bool calc_init =true, bool calc_output =true, bool calc_measurement =true, size_t max_iter =100, data_t tol =1e-2 ) Parameters:\n calc_dynamics [optional] whether to caclulate dynamics (A, B) calc_Q [optional] whether to calculate process noise covariance calc_init [optional] whether to calculate initial conditions calc_output [optional] whether to calculate output function calc_measurement [optional] whether to calculate parameters for measurement/observation law max_iter max number of iterations tol convergence tolerance (max fractional abs change)  Return: Fit\n ReturnData #  inline std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData() Return: tuple(input data, output data)\n x #  inline const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; x() const  y #  inline const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; y() const  sum_E_x_t_x_t #  inline const Matrix \u0026amp; sum_E_x_t_x_t() const  sum_E_xu_tm1_xu_tm1 #  inline const Matrix \u0026amp; sum_E_xu_tm1_xu_tm1() const  sum_E_xu_t_xu_tm1 #  inline const Matrix \u0026amp; sum_E_xu_t_xu_tm1() const  n_t_tot #  inline size_t n_t_tot()  theta #  inline const Vector \u0026amp; theta() const  Protected Function Details #  Expectation #  void Expectation( bool force_common_initial =false ) Parameters:\n force_common_initial whether to force common initial condition for all trials   Maximization #  void Maximization( bool calc_dynamics =true, bool calc_Q =true, bool calc_init =false, bool calc_output =false, bool calc_measurement =false ) Parameters:\n calc_dynamics [optional] whether to caclulate dynamics (A, B) calc_Q [optional] whether to calculate process noise covariance calc_init [optional] whether to calculate initial conditions calc_output [optional] whether to calculate output function calc_measurement [optional] whether to calculate parameters for measurement/observation law   MaximizeDynamics #  void MaximizeDynamics()  MaximizeQ #  void MaximizeQ()  MaximizeInitial #  void MaximizeInitial()  MaximizeOutput #  virtual void MaximizeOutput() =0 Reimplemented by: lds::gaussian::FitEM::MaximizeOutput, lds::poisson::FitEM::MaximizeOutput\n MaximizeMeasurement #  virtual void MaximizeMeasurement() =0 Reimplemented by: lds::gaussian::FitEM::MaximizeMeasurement, lds::poisson::FitEM::MaximizeMeasurement\n Smooth #  void Smooth( bool force_common_initial ) Parameters:\n force_common_initial whether to force common initial conditions   RecurseKe #  virtual void RecurseKe( Matrix \u0026amp; Ke, Cube \u0026amp; P_pre, Cube \u0026amp; P_post, size_t t ) =0 Parameters:\n Ke estimator gain P_pre cov of predicted state est. P_post cov of postior sate est. t time  Reimplemented by: lds::gaussian::FitEM::RecurseKe, lds::poisson::FitEM::RecurseKe\n Reset #  void Reset()  InitVars #  void InitVars()  UpdateTheta #  Vector UpdateTheta() Return: parameter list\n Protected Attribute Details #  **u_** #  UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_;  **z_** #  UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_;  **x_** #  std::vector\u0026lt; Matrix \u0026gt; x_;  **P_** #  std::vector\u0026lt; Cube \u0026gt; P_;  **P_t_tm1_** #  std::vector\u0026lt; Cube \u0026gt; P_t_tm1_;  **y_** #  std::vector\u0026lt; Matrix \u0026gt; y_;  **diag_y_** #  Matrix diag_y_;  **sum_E_x_t_x_t_** #  Matrix sum_E_x_t_x_t_;  **sum_E_xu_tm1_xu_tm1_** #  Matrix sum_E_xu_tm1_xu_tm1_;  **sum_E_xu_t_xu_tm1_** #  Matrix sum_E_xu_t_xu_tm1_;  **fit_** #  Fit fit_;  **theta_** #  Vector theta_;  **dt_** #  data_t dt_ {};  **n_u_** #  size_t n_u_ {};  **n_x_** #  size_t n_x_ {};  **n_y_** #  size_t n_y_ {};  **n_trials_** #  size_t n_trials_ {};  **n_t_** #  std::vector\u0026lt; size_t \u0026gt; n_t_;  **n_t_tot_** #  size_t n_t_tot_ {};   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':28,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_fit/','title':"lds::Fit",'section':"Classes",'content':"lds::Fit #  LDS Fit Type. #include \u0026lt;lds_fit.h\u0026gt;\nInherited by lds::gaussian::Fit, lds::poisson::Fit\nPublic Functions #      Name      Fit() =default\nConstructs a new Fit.    Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt)\nConstructs a new Fit.   size_t n_u() const\ngets number of inputs   size_t n_x() const\ngets number of states   size_t n_y() const\ngets number of outputs   data_t dt() const\ngets sample period   const Matrix \u0026amp; A() const\ngets state matrix   const Matrix \u0026amp; B() const\ngets input matrix   const Vector \u0026amp; g() const\ngets input gain   const Vector \u0026amp; m() const\ngets process disturbance   const Matrix \u0026amp; Q() const\ngets process noise covariance   const Vector \u0026amp; x0() const\ngets initial state estimate   const Matrix \u0026amp; P0() const\ngets covariance of initial state estimate   const Matrix \u0026amp; C() const\ngets output matrix   const Vector \u0026amp; d() const\ngets output bias   virtual const Matrix \u0026amp; R() const =0   void set_A(const Matrix \u0026amp; A)\nsets state matrix   void set_B(const Matrix \u0026amp; B)\nsets input matrix   void set_g(const Vector \u0026amp; g)\nsets input gain/conversion factor   void set_m(const Vector \u0026amp; m)\nsets process disturbance   void set_Q(const Matrix \u0026amp; Q)\nsets process noise covariance   virtual void set_R(const Matrix \u0026amp; R) =0\nsets output noise covariance (if any)   void set_x0(const Vector \u0026amp; x0)\nsets initial state estimate   void set_P0(const Matrix \u0026amp; P0)\nsets intial state estimate covariance   void set_C(const Matrix \u0026amp; C)\nsets output matrix   void set_d(const Vector \u0026amp; d)\nsets output bias   View f(Matrix \u0026amp; x, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function   View f(Matrix \u0026amp; x_pre, const Matrix \u0026amp; x_post, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function   virtual View h(Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t) =0\noutput function    Protected Attributes #      Name     data_t dt_ sample period   Matrix A_ state matrix   Matrix B_ input matrix   Vector g_ input gain   Vector m_ process noise mean   Matrix Q_ process noise cov   Matrix C_ output matrix   Vector d_ output bias   Matrix R_ measurement noise   Vector x0_ initial state   Matrix P0_ initial covar   size_t n_u_ number of inputs   size_t n_x_ number of states   size_t n_y_ number of outputs      Public Function Details #  Fit #  Fit() =default  Fit #  Fit( size_t n_u, size_t n_x, size_t n_y, data_t dt ) Parameters:\n n_u number of inputs n_x number of states n_y number of outputs dt sample period   n_u #  inline size_t n_u() const  n_x #  inline size_t n_x() const  n_y #  inline size_t n_y() const  dt #  inline data_t dt() const  A #  inline const Matrix \u0026amp; A() const  B #  inline const Matrix \u0026amp; B() const  g #  inline const Vector \u0026amp; g() const  m #  inline const Vector \u0026amp; m() const  Q #  inline const Matrix \u0026amp; Q() const  x0 #  inline const Vector \u0026amp; x0() const  P0 #  inline const Matrix \u0026amp; P0() const  C #  inline const Matrix \u0026amp; C() const  d #  inline const Vector \u0026amp; d() const  R #  virtual const Matrix \u0026amp; R() const =0 Reimplemented by: lds::gaussian::Fit::R, lds::poisson::Fit::R\n set_A #  inline void set_A( const Matrix \u0026amp; A )  set_B #  inline void set_B( const Matrix \u0026amp; B )  set_g #  inline void set_g( const Vector \u0026amp; g )  set_m #  inline void set_m( const Vector \u0026amp; m )  set_Q #  inline void set_Q( const Matrix \u0026amp; Q )  set_R #  virtual void set_R( const Matrix \u0026amp; R ) =0 Reimplemented by: lds::gaussian::Fit::set_R, lds::poisson::Fit::set_R\n set_x0 #  inline void set_x0( const Vector \u0026amp; x0 )  set_P0 #  inline void set_P0( const Matrix \u0026amp; P0 )  set_C #  inline void set_C( const Matrix \u0026amp; C )  set_d #  inline void set_d( const Vector \u0026amp; d )  f #  inline View f( Matrix \u0026amp; x, const Matrix \u0026amp; u, size_t t ) Parameters:\n x state estimate (over time) u input (over time) t time index  Return: view of updated state\n f #  inline View f( Matrix \u0026amp; x_pre, const Matrix \u0026amp; x_post, const Matrix \u0026amp; u, size_t t ) Parameters:\n x_pre predicted state est. x_post posterior state est. u input (over time) t time index  Return: view of predicted state\n h #  virtual View h( Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t ) =0 Parameters:\n y output estimate (over time) x state estimate (over time) t time index  Return: output\nReimplemented by: lds::gaussian::Fit::h, lds::poisson::Fit::h\n Protected Attribute Details #  **dt_** #  data_t dt_ {};  **A_** #  Matrix A_;  **B_** #  Matrix B_;  **g_** #  Vector g_;  **m_** #  Vector m_;  **Q_** #  Matrix Q_;  **C_** #  Matrix C_;  **d_** #  Vector d_;  **R_** #  Matrix R_;  **x0_** #  Vector x0_;  **P0_** #  Matrix P0_;  **n_u_** #  size_t n_u_ {};  **n_x_** #  size_t n_x_ {};  **n_y_** #  size_t n_y_ {};   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':29,'href':'/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/','title':"lds::gaussian",'section':"Namespaces",'content':"lds::gaussian #  Linear Dynamical Systems with Gaussian observations. Classes #      Name     class lds::gaussian::Controller Gaussian-observation Controller Type.   class lds::gaussian::Fit GLDS Fit Type.   class lds::gaussian::FitEM GLDS E-M Fit Type.   class lds::gaussian::FitSSID Subspace Identification (SSID) for GLDS.   class lds::gaussian::SwitchedController Gaussian-observation SwitchedController Type.   class lds::gaussian::System Gaussian LDS Type.     Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':30,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_controller/','title':"lds::gaussian::Controller",'section':"Classes",'content':"lds::gaussian::Controller #  Gaussian-observation Controller Type. #include \u0026lt;lds_gaussian_ctrl.h\u0026gt;\nInherits from lds::Controller\u0026lt; System \u0026gt;\nPublic Functions #      Name     virtual void set_y_ref(const Vector \u0026amp; y_ref) override\nsets reference output    Additional inherited members #  Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default\nConstructs a new Controller.    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const Matrix \u0026amp; Kc() const\nGet state feedback controller gain.   const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain.   const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain.   const Vector \u0026amp; g_design() const\nGet input gain used in controller design.   const Vector \u0026amp; u_ref() const\nGet reference input.   const Vector \u0026amp; x_ref() const\nGet reference state.   const Vector \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref)   void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()\nprints variables to stdout    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   Vector u_ control signal   Vector g_design_ input gain of the system used for controller design   Vector u_ref_ reference input   Vector u_ref_prev_ reference input at previous time step   Vector x_ref_ reference state   Vector y_ref_ reference output   Vector cx_ref_   Matrix Kc_ state controller gain   Matrix Kc_u_ input controller gain (optional when control updates \\deltaU)   Matrix Kc_inty_ integral controller gain   Vector du_ref_   Vector dv_ref_   Vector v_ref_   Vector dv_   Vector v_ Control after g inversion (e.g., control in physical units)   Vector int_e_ integrated error   Vector int_e_awu_adjust_ anti-windup adjustment to intE   Vector u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type      Public Function Details #  set_y_ref #  inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':31,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_fit/','title':"lds::gaussian::Fit",'section':"Classes",'content':"lds::gaussian::Fit #  GLDS Fit Type. #include \u0026lt;lds_gaussian_fit.h\u0026gt;\nInherits from lds::Fit\nPublic Functions #      Name      Fit() =default    Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt)\nConstructs a new Fit.   virtual const Matrix \u0026amp; R() const override\ngets measurement noise covariance   virtual void set_R(const Matrix \u0026amp; R) override\nsets measurement noise covariance   virtual View h(Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t) override\noutput function    Additional inherited members #  Public Functions inherited from lds::Fit\n    Name     size_t n_u() const\ngets number of inputs   size_t n_x() const\ngets number of states   size_t n_y() const\ngets number of outputs   data_t dt() const\ngets sample period   const Matrix \u0026amp; A() const\ngets state matrix   const Matrix \u0026amp; B() const\ngets input matrix   const Vector \u0026amp; g() const\ngets input gain   const Vector \u0026amp; m() const\ngets process disturbance   const Matrix \u0026amp; Q() const\ngets process noise covariance   const Vector \u0026amp; x0() const\ngets initial state estimate   const Matrix \u0026amp; P0() const\ngets covariance of initial state estimate   const Matrix \u0026amp; C() const\ngets output matrix   const Vector \u0026amp; d() const\ngets output bias   void set_A(const Matrix \u0026amp; A)\nsets state matrix   void set_B(const Matrix \u0026amp; B)\nsets input matrix   void set_g(const Vector \u0026amp; g)\nsets input gain/conversion factor   void set_m(const Vector \u0026amp; m)\nsets process disturbance   void set_Q(const Matrix \u0026amp; Q)\nsets process noise covariance   void set_x0(const Vector \u0026amp; x0)\nsets initial state estimate   void set_P0(const Matrix \u0026amp; P0)\nsets intial state estimate covariance   void set_C(const Matrix \u0026amp; C)\nsets output matrix   void set_d(const Vector \u0026amp; d)\nsets output bias   View f(Matrix \u0026amp; x, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function   View f(Matrix \u0026amp; x_pre, const Matrix \u0026amp; x_post, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function    Protected Attributes inherited from lds::Fit\n    Name     data_t dt_ sample period   Matrix A_ state matrix   Matrix B_ input matrix   Vector g_ input gain   Vector m_ process noise mean   Matrix Q_ process noise cov   Matrix C_ output matrix   Vector d_ output bias   Matrix R_ measurement noise   Vector x0_ initial state   Matrix P0_ initial covar   size_t n_u_ number of inputs   size_t n_x_ number of states   size_t n_y_ number of outputs      Public Function Details #  Fit #  Fit() =default  Fit #  Fit( size_t n_u, size_t n_x, size_t n_y, data_t dt ) Parameters:\n n_u number of inputs n_x number of states n_y number of outputs dt sample period   R #  inline virtual const Matrix \u0026amp; R() const override Reimplements: lds::Fit::R\n set_R #  inline virtual void set_R( const Matrix \u0026amp; R ) override Reimplements: lds::Fit::set_R\n h #  inline virtual View h( Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t ) override Parameters:\n y output estimate (over time) x state estimate (over time) t time index  Return: output\nReimplements: lds::Fit::h\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':32,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_fit_e_m/','title':"lds::gaussian::FitEM",'section':"Classes",'content':"lds::gaussian::FitEM #  GLDS E-M Fit Type. More\u0026hellip;\n\n#include \u0026lt;lds_gaussian_fit_em.h\u0026gt;\nInherits from lds::EMax\u0026lt; Fit \u0026gt;\nAdditional inherited members #  Public Functions inherited from lds::EMax\u0026lt; Fit \u0026gt;\n    Name      EMax() =default\nConstructs a new EMaxFit type.    EMax(size_t n_x, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMaxFit type.    EMax(const Fit \u0026amp; fit0, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMaxFit type.   const Fit \u0026amp; Run(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =true, bool calc_output =true, bool calc_measurement =true, size_t max_iter =100, data_t tol =1e-2)\nRuns fitting by Expectation(E)-Maximizaiton(Max)   std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the input/output data to caller.   const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; x() const\ngets estimated state (over time)   const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; y() const\ngets estimated output (over time)   const Matrix \u0026amp; sum_E_x_t_x_t() const\ngets state-input covariance   const Matrix \u0026amp; sum_E_xu_tm1_xu_tm1() const\ngets state-input covariance (t-minus-1)   const Matrix \u0026amp; sum_E_xu_t_xu_tm1() const\ngets single lag state-input covariance   size_t n_t_tot()\ntotal number of time samples   const Vector \u0026amp; theta() const\ngets parameters updated in M step    Protected Functions inherited from lds::EMax\u0026lt; Fit \u0026gt;\n    Name     void Expectation(bool force_common_initial =false)\nExpectation step.   void Maximization(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =false, bool calc_output =false, bool calc_measurement =false)\nMaximization step.   void MaximizeDynamics()   void MaximizeQ()   void MaximizeInitial()   void Smooth(bool force_common_initial)\nget smoothed estimates   void Reset()\nreset to initial conditions   void InitVars()\nInitializes the variables.   Vector UpdateTheta()\nupdates parameter list, theta    Protected Attributes inherited from lds::EMax\u0026lt; Fit \u0026gt;\n    Name     UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data   UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data   std::vector\u0026lt; Matrix \u0026gt; x_ state estimate   std::vector\u0026lt; Cube \u0026gt; P_ state estimate cov   std::vector\u0026lt; Cube \u0026gt; P_t_tm1_ single-lag state covariance   std::vector\u0026lt; Matrix \u0026gt; y_ output estimate   Matrix diag_y_   Matrix sum_E_x_t_x_t_ state covariance (current time)   Matrix sum_E_xu_tm1_xu_tm1_ state-input covariance (t-minus-1)   Matrix sum_E_xu_t_xu_tm1_ single lag state-input covariance   Fit fit_   Vector theta_   data_t dt_ sample period   size_t n_u_ number of inputs   size_t n_x_ number of states   size_t n_y_ number of outputs   size_t n_trials_ number of input/output data sequences   std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps   size_t n_t_tot_ total number of time steps across trials    Detailed Description #  class lds::gaussian::FitEM;  This type is used in the process of fitting GLDS models by expectation-maximization (EM).    Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':33,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_fit_s_s_i_d/','title':"lds::gaussian::FitSSID",'section':"Classes",'content':"lds::gaussian::FitSSID #  Subspace Identification (SSID) for GLDS. #include \u0026lt;lds_gaussian_fit_ssid.h\u0026gt;\nInherits from lds::SSID\u0026lt; Fit \u0026gt;\nAdditional inherited members #  Public Functions inherited from lds::SSID\u0026lt; Fit \u0026gt;\n    Name      SSID() =default\nConstructs a new SSIDFit type.    SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train, const Vector \u0026amp; d =Vector(1).fill(-kInf))\nConstructs a new SSIDFit type.   std::tuple\u0026lt; Fit, Vector \u0026gt; Run(SSIDWt ssid_wt)\nRuns fitting by subspace identification (SSID)   std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the I/O data to caller.    Protected Functions inherited from lds::SSID\u0026lt; Fit \u0026gt;\n    Name     void CalcD(data_t t_silence =0.1, data_t thresh_silence =0.001)\nUsing periods of silence in inputs (u), calculates the output \\ bias (d)   void CreateHankelDataMat()\nCreates the block-hankel I/O data matrix.   void CalcSVD(SSIDWt wt)\nperforms the singular value decomposition (SVD)   void Solve(data_t wt_dc)\nsolves for LDS parameters   void RecomputeExtObs()\nrecompute extended observability matrix from estimates of A, C    Protected Attributes inherited from lds::SSID\u0026lt; Fit \u0026gt;\n    Name     UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data   UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data   Matrix D_ block-Hankel I/O data matrix   Fit fit_ fit   Matrix g_dc_ I/O gain @ DC.   data_t dt_ sample period   size_t n_u_ number of inputs   size_t n_x_ number of states   size_t n_y_ number of outputs   size_t n_h_   size_t n_trials_ number of input/output data sequences   std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps   size_t n_t_tot_ total number of time steps across trials   Matrix L_ lower triangle decomp of covariance matrix   Vector s_ singular values   Matrix ext_obs_t_ extended observability matrix       Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':34,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_switched_controller/','title':"lds::gaussian::SwitchedController",'section':"Classes",'content':"lds::gaussian::SwitchedController #  Gaussian-observation SwitchedController Type. #include \u0026lt;lds_gaussian_sctrl.h\u0026gt;\nInherits from lds::SwitchedController\u0026lt; System \u0026gt;, lds::Controller\u0026lt; System \u0026gt;\nPublic Functions #      Name     virtual void set_y_ref(const Vector \u0026amp; y_ref) override\nsets reference output    Additional inherited members #  Public Functions inherited from lds::SwitchedController\u0026lt; System \u0026gt;\n    Name      SwitchedController() =default\nConstructs a new SwitchedController.    SwitchedController(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController.    SwitchedController(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController (moves systems).   void Switch(size_t idx, bool do_force_switch =false)\nSwitch to a different sub-system/controller.   void set_Kc(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc)\nsets state feedback gains   void set_Kc(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc)\nsets state feedback gains (moving)   void set_Kc_inty(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_inty)\nsets integral feedback gains   void set_Kc_inty(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_inty)\nsets integral feedback gains (moving)   void set_Kc_u(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_u)\nsets input feedback gains   void set_Kc_u(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_u)\nsets input feedback gains (moving)   void set_g_design(const UniformVectorList \u0026amp; g)\nsets input gain used during controller design   void set_g_design(UniformVectorList \u0026amp;\u0026amp; g)\nsets input gain used during controller design (moving)    Protected Attributes inherited from lds::SwitchedController\u0026lt; System \u0026gt;\n    Name     std::vector\u0026lt; System \u0026gt; systems_ underlying sub-systems which are switched between   size_t n_sys_ number of systems   size_t idx_ current system/controller index.   UniformMatrixList Kc_list_   UniformMatrixList Kc_inty_list_   UniformMatrixList Kc_u_list_   UniformVectorList g_design_list_    Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default\nConstructs a new Controller.    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const Matrix \u0026amp; Kc() const\nGet state feedback controller gain.   const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain.   const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain.   const Vector \u0026amp; g_design() const\nGet input gain used in controller design.   const Vector \u0026amp; u_ref() const\nGet reference input.   const Vector \u0026amp; x_ref() const\nGet reference state.   const Vector \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref)   void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()\nprints variables to stdout    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   Vector u_ control signal   Vector g_design_ input gain of the system used for controller design   Vector u_ref_ reference input   Vector u_ref_prev_ reference input at previous time step   Vector x_ref_ reference state   Vector y_ref_ reference output   Vector cx_ref_   Matrix Kc_ state controller gain   Matrix Kc_u_ input controller gain (optional when control updates \\deltaU)   Matrix Kc_inty_ integral controller gain   Vector du_ref_   Vector dv_ref_   Vector v_ref_   Vector dv_   Vector v_ Control after g inversion (e.g., control in physical units)   Vector int_e_ integrated error   Vector int_e_awu_adjust_ anti-windup adjustment to intE   Vector u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type      Public Function Details #  set_y_ref #  inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':35,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_system/','title':"lds::gaussian::System",'section':"Classes",'content':"lds::gaussian::System #  Gaussian LDS Type. #include \u0026lt;lds_gaussian_sys.h\u0026gt;\nInherits from lds::System\nPublic Functions #      Name      System() =default\nConstructs a new System.    System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0, data_t r0 =kDefaultR0)\nConstructs a new Gaussian System.   virtual const Vector \u0026amp; Simulate(const Vector \u0026amp; u_tm1) override\nSimulate system measurement.   const Matrix \u0026amp; R() const\nGet output noise covariance.   void set_Q(const Matrix \u0026amp; Q)   void set_R(const Matrix \u0026amp; R)\nSet output noise covariance.   void set_Ke(const Matrix \u0026amp; Ke)\nSet estimator gain.   void set_Ke_m(const Matrix \u0026amp; Ke_m)\nSet disturbance estimator gain.   void Print()\nPrint system variables to stdout.    Protected Functions #      Name     virtual void h() override\nSystem output function.   virtual void RecurseKe() override\nRecursively update estimator gain.    Protected Attributes #      Name     Matrix R_ covariance of output noise   bool do_recurse_Ke_ whether to recursively calculate estimator gain    Additional inherited members #  Public Functions inherited from lds::System\n    Name     void Filter(const Vector \u0026amp; u_tm1, const Vector \u0026amp; z)\nFilter data to produce causal state estimates.   void f(const Vector \u0026amp; u, bool do_add_noise =false)\nsystem dynamics function   size_t n_u() const\nGet number of inputs.   size_t n_x() const\nGet number of states.   size_t n_y() const\nGet number of outputs.   data_t dt() const\nGet sample period.   const Vector \u0026amp; x() const\nGet current state.   const Matrix \u0026amp; P() const\nGet covariance of state estimate.   const Vector \u0026amp; m() const\nGet current process disturbance/bias.   const Matrix \u0026amp; P_m() const\nGet covariance of process disturbance estimate.   const Vector \u0026amp; cx() const\nGet C*x.   const Vector \u0026amp; y() const\nGet output.   const Vector \u0026amp; x0() const\nGet initial state.   const Vector \u0026amp; m0() const\nGet initial disturbance.   const Matrix \u0026amp; A() const\nGet state matrix.   const Matrix \u0026amp; B() const\nGet input matrix.   const Vector \u0026amp; g() const\nGet input gain/conversion factor.   const Matrix \u0026amp; C() const\nGet output matrix.   const Vector \u0026amp; d() const\nGet output bias.   const Matrix \u0026amp; Ke() const\nGet estimator gain.   const Matrix \u0026amp; Ke_m() const\nGet estimator gain for process disturbance (m)   void set_A(const Matrix \u0026amp; A)\nSet state matrix.   void set_B(const Matrix \u0026amp; B)\nSet input matrix.   void set_m(const Vector \u0026amp; m)\nSet process disturbance.   void set_g(const Vector \u0026amp; g)\nSet input gain.   void set_Q_m(const Matrix \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation.   void set_x0(const Vector \u0026amp; x0)\nSet initial state.   void set_P0(const Matrix \u0026amp; P0)\nSet covariance of initial state.   void set_P0_m(const Matrix \u0026amp; P0_m)\nSet covariance of initial process disturbance.   void set_C(const Matrix \u0026amp; C)\nSet output matrix.   void set_d(const Vector \u0026amp; d)\nSet output bias.   void Reset()\nReset system variables.    Protected Functions inherited from lds::System\n    Name     void InitVars(data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0)    Public Attributes inherited from lds::System\n    Name     bool do_adapt_m whether to adaptively estimate disturbance m    Protected Attributes inherited from lds::System\n    Name     std::size_t n_x_ number of states   std::size_t n_u_ number of inputs   std::size_t n_y_ number of outputs   data_t dt_ sample period   Vector x_ state   Matrix P_ covariance of state estimate   Vector m_ process disturbance   Matrix P_m_ covariance of disturbance estimate   Vector cx_ C*x.   Vector y_ output   Vector z_ measurement   Vector x0_ initial state   Matrix P0_ covariance of initial state estimate   Vector m0_ initial process disturbance   Matrix P0_m_ covariance of initial disturbance est.   Matrix A_ state matrix   Matrix B_ input matrix   Vector g_ input gain   Matrix Q_ covariance of process noise   Matrix Q_m_ covariance of disturbance random walk   Matrix C_ output matrix   Vector d_ output bias   Matrix Ke_ estimator gain   Matrix Ke_m_ estimator gain for process disturbance      Public Function Details #  System #  System() =default  System #  System( std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0, data_t r0 =kDefaultR0 ) Parameters:\n n_u number of inputs (u) n_x number of states (x) n_y number of outputs (y) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) r0 [optional] initial diagonal elements of output noise covariance (R)   Simulate #  virtual const Vector \u0026amp; Simulate( const Vector \u0026amp; u_tm1 ) override Parameters:\n u_tm1 input at t-1  Return: z measurement\nReimplements: lds::System::Simulate\nSimulate system and produce measurement\n R #  inline const Matrix \u0026amp; R() const  set_Q #  inline void set_Q( const Matrix \u0026amp; Q )  set_R #  inline void set_R( const Matrix \u0026amp; R )  set_Ke #  inline void set_Ke( const Matrix \u0026amp; Ke )  set_Ke_m #  inline void set_Ke_m( const Matrix \u0026amp; Ke_m )  Print #  void Print()  Protected Function Details #  h #  inline virtual void h() override Reimplements: lds::System::h\n RecurseKe #  virtual void RecurseKe() override Reimplements: lds::System::RecurseKe\n Protected Attribute Details #  **R_** #  Matrix R_;  **do_recurse_Ke_** #  bool do_recurse_Ke_ {};   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':36,'href':'/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/','title':"lds::poisson",'section':"Namespaces",'content':"lds::poisson #  Linear Dynamical Systems with Poisson observations. Classes #      Name     class lds::poisson::Controller PLDS Controller Type.   class lds::poisson::Fit PLDS Fit Type.   class lds::poisson::FitEM PLDS E-M Fit Type.   class lds::poisson::FitSSID Subspace Identification (SSID) for PLDS.   class lds::poisson::SwitchedController Poisson-observation SwitchedController Type.   class lds::poisson::System Poisson System type.     Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':37,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_controller/','title':"lds::poisson::Controller",'section':"Classes",'content':"lds::poisson::Controller #  PLDS Controller Type. #include \u0026lt;lds_poisson_ctrl.h\u0026gt;\nInherits from lds::Controller\u0026lt; System \u0026gt;\nPublic Functions #      Name     virtual void set_y_ref(const Vector \u0026amp; y_ref) override\nSet reference output.    Additional inherited members #  Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default\nConstructs a new Controller.    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const Matrix \u0026amp; Kc() const\nGet state feedback controller gain.   const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain.   const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain.   const Vector \u0026amp; g_design() const\nGet input gain used in controller design.   const Vector \u0026amp; u_ref() const\nGet reference input.   const Vector \u0026amp; x_ref() const\nGet reference state.   const Vector \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref)   void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()\nprints variables to stdout    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   Vector u_ control signal   Vector g_design_ input gain of the system used for controller design   Vector u_ref_ reference input   Vector u_ref_prev_ reference input at previous time step   Vector x_ref_ reference state   Vector y_ref_ reference output   Vector cx_ref_   Matrix Kc_ state controller gain   Matrix Kc_u_ input controller gain (optional when control updates \\deltaU)   Matrix Kc_inty_ integral controller gain   Vector du_ref_   Vector dv_ref_   Vector v_ref_   Vector dv_   Vector v_ Control after g inversion (e.g., control in physical units)   Vector int_e_ integrated error   Vector int_e_awu_adjust_ anti-windup adjustment to intE   Vector u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type      Public Function Details #  set_y_ref #  inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':38,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_fit/','title':"lds::poisson::Fit",'section':"Classes",'content':"lds::poisson::Fit #  PLDS Fit Type. #include \u0026lt;lds_poisson_fit.h\u0026gt;\nInherits from lds::Fit\nPublic Functions #      Name      Fit() =default    Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt)\nConstructs a new Fit.   virtual View h(Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t) override\noutput function   virtual void set_R(const Matrix \u0026amp; R) override\nsets output noise covariance (if any)   virtual const Matrix \u0026amp; R() const override    Additional inherited members #  Public Functions inherited from lds::Fit\n    Name     size_t n_u() const\ngets number of inputs   size_t n_x() const\ngets number of states   size_t n_y() const\ngets number of outputs   data_t dt() const\ngets sample period   const Matrix \u0026amp; A() const\ngets state matrix   const Matrix \u0026amp; B() const\ngets input matrix   const Vector \u0026amp; g() const\ngets input gain   const Vector \u0026amp; m() const\ngets process disturbance   const Matrix \u0026amp; Q() const\ngets process noise covariance   const Vector \u0026amp; x0() const\ngets initial state estimate   const Matrix \u0026amp; P0() const\ngets covariance of initial state estimate   const Matrix \u0026amp; C() const\ngets output matrix   const Vector \u0026amp; d() const\ngets output bias   void set_A(const Matrix \u0026amp; A)\nsets state matrix   void set_B(const Matrix \u0026amp; B)\nsets input matrix   void set_g(const Vector \u0026amp; g)\nsets input gain/conversion factor   void set_m(const Vector \u0026amp; m)\nsets process disturbance   void set_Q(const Matrix \u0026amp; Q)\nsets process noise covariance   void set_x0(const Vector \u0026amp; x0)\nsets initial state estimate   void set_P0(const Matrix \u0026amp; P0)\nsets intial state estimate covariance   void set_C(const Matrix \u0026amp; C)\nsets output matrix   void set_d(const Vector \u0026amp; d)\nsets output bias   View f(Matrix \u0026amp; x, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function   View f(Matrix \u0026amp; x_pre, const Matrix \u0026amp; x_post, const Matrix \u0026amp; u, size_t t)\nsystem dynamics function    Protected Attributes inherited from lds::Fit\n    Name     data_t dt_ sample period   Matrix A_ state matrix   Matrix B_ input matrix   Vector g_ input gain   Vector m_ process noise mean   Matrix Q_ process noise cov   Matrix C_ output matrix   Vector d_ output bias   Matrix R_ measurement noise   Vector x0_ initial state   Matrix P0_ initial covar   size_t n_u_ number of inputs   size_t n_x_ number of states   size_t n_y_ number of outputs      Public Function Details #  Fit #  Fit() =default  Fit #  inline Fit( size_t n_u, size_t n_x, size_t n_y, data_t dt ) Parameters:\n n_u number of inputs n_x number of states n_y number of outputs dt sample period   h #  inline virtual View h( Matrix \u0026amp; y, const Matrix \u0026amp; x, size_t t ) override Parameters:\n y output estimate (over time) x state estimate (over time) t time index  Return: output\nReimplements: lds::Fit::h\n set_R #  inline virtual void set_R( const Matrix \u0026amp; R ) override Reimplements: lds::Fit::set_R\n R #  inline virtual const Matrix \u0026amp; R() const override Reimplements: lds::Fit::R\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':39,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_fit_e_m/','title':"lds::poisson::FitEM",'section':"Classes",'content':"lds::poisson::FitEM #  PLDS E-M Fit Type. More\u0026hellip;\n\n#include \u0026lt;lds_poisson_fit_em.h\u0026gt;\nInherits from lds::EMax\u0026lt; Fit \u0026gt;\nAdditional inherited members #  Public Functions inherited from lds::EMax\u0026lt; Fit \u0026gt;\n    Name      EMax() =default\nConstructs a new EMaxFit type.    EMax(size_t n_x, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMaxFit type.    EMax(const Fit \u0026amp; fit0, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train)\nConstructs a new EMaxFit type.   const Fit \u0026amp; Run(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =true, bool calc_output =true, bool calc_measurement =true, size_t max_iter =100, data_t tol =1e-2)\nRuns fitting by Expectation(E)-Maximizaiton(Max)   std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the input/output data to caller.   const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; x() const\ngets estimated state (over time)   const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; y() const\ngets estimated output (over time)   const Matrix \u0026amp; sum_E_x_t_x_t() const\ngets state-input covariance   const Matrix \u0026amp; sum_E_xu_tm1_xu_tm1() const\ngets state-input covariance (t-minus-1)   const Matrix \u0026amp; sum_E_xu_t_xu_tm1() const\ngets single lag state-input covariance   size_t n_t_tot()\ntotal number of time samples   const Vector \u0026amp; theta() const\ngets parameters updated in M step    Protected Functions inherited from lds::EMax\u0026lt; Fit \u0026gt;\n    Name     void Expectation(bool force_common_initial =false)\nExpectation step.   void Maximization(bool calc_dynamics =true, bool calc_Q =true, bool calc_init =false, bool calc_output =false, bool calc_measurement =false)\nMaximization step.   void MaximizeDynamics()   void MaximizeQ()   void MaximizeInitial()   void Smooth(bool force_common_initial)\nget smoothed estimates   void Reset()\nreset to initial conditions   void InitVars()\nInitializes the variables.   Vector UpdateTheta()\nupdates parameter list, theta    Protected Attributes inherited from lds::EMax\u0026lt; Fit \u0026gt;\n    Name     UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data   UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data   std::vector\u0026lt; Matrix \u0026gt; x_ state estimate   std::vector\u0026lt; Cube \u0026gt; P_ state estimate cov   std::vector\u0026lt; Cube \u0026gt; P_t_tm1_ single-lag state covariance   std::vector\u0026lt; Matrix \u0026gt; y_ output estimate   Matrix diag_y_   Matrix sum_E_x_t_x_t_ state covariance (current time)   Matrix sum_E_xu_tm1_xu_tm1_ state-input covariance (t-minus-1)   Matrix sum_E_xu_t_xu_tm1_ single lag state-input covariance   Fit fit_   Vector theta_   data_t dt_ sample period   size_t n_u_ number of inputs   size_t n_x_ number of states   size_t n_y_ number of outputs   size_t n_trials_ number of input/output data sequences   std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps   size_t n_t_tot_ total number of time steps across trials    Detailed Description #  class lds::poisson::FitEM;  This type is used in the process of fitting PLDS models by expectation-maximization (EM).    Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':40,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_fit_s_s_i_d/','title':"lds::poisson::FitSSID",'section':"Classes",'content':"lds::poisson::FitSSID #  Subspace Identification (SSID) for PLDS. #include \u0026lt;lds_poisson_fit_ssid.h\u0026gt;\nInherits from lds::SSID\u0026lt; Fit \u0026gt;\nAdditional inherited members #  Public Functions inherited from lds::SSID\u0026lt; Fit \u0026gt;\n    Name      SSID() =default\nConstructs a new SSIDFit type.    SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train, const Vector \u0026amp; d =Vector(1).fill(-kInf))\nConstructs a new SSIDFit type.   std::tuple\u0026lt; Fit, Vector \u0026gt; Run(SSIDWt ssid_wt)\nRuns fitting by subspace identification (SSID)   std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the I/O data to caller.    Protected Functions inherited from lds::SSID\u0026lt; Fit \u0026gt;\n    Name     void CalcD(data_t t_silence =0.1, data_t thresh_silence =0.001)\nUsing periods of silence in inputs (u), calculates the output \\ bias (d)   void CreateHankelDataMat()\nCreates the block-hankel I/O data matrix.   void CalcSVD(SSIDWt wt)\nperforms the singular value decomposition (SVD)   void Solve(data_t wt_dc)\nsolves for LDS parameters   void RecomputeExtObs()\nrecompute extended observability matrix from estimates of A, C    Protected Attributes inherited from lds::SSID\u0026lt; Fit \u0026gt;\n    Name     UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data   UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data   Matrix D_ block-Hankel I/O data matrix   Fit fit_ fit   Matrix g_dc_ I/O gain @ DC.   data_t dt_ sample period   size_t n_u_ number of inputs   size_t n_x_ number of states   size_t n_y_ number of outputs   size_t n_h_   size_t n_trials_ number of input/output data sequences   std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps   size_t n_t_tot_ total number of time steps across trials   Matrix L_ lower triangle decomp of covariance matrix   Vector s_ singular values   Matrix ext_obs_t_ extended observability matrix       Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':41,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_switched_controller/','title':"lds::poisson::SwitchedController",'section':"Classes",'content':"lds::poisson::SwitchedController #  Poisson-observation SwitchedController Type. #include \u0026lt;lds_poisson_sctrl.h\u0026gt;\nInherits from lds::SwitchedController\u0026lt; System \u0026gt;, lds::Controller\u0026lt; System \u0026gt;\nPublic Functions #      Name     virtual void set_y_ref(const Vector \u0026amp; y_ref) override\nSet reference output.    Additional inherited members #  Public Functions inherited from lds::SwitchedController\u0026lt; System \u0026gt;\n    Name      SwitchedController() =default\nConstructs a new SwitchedController.    SwitchedController(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController.    SwitchedController(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController (moves systems).   void Switch(size_t idx, bool do_force_switch =false)\nSwitch to a different sub-system/controller.   void set_Kc(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc)\nsets state feedback gains   void set_Kc(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc)\nsets state feedback gains (moving)   void set_Kc_inty(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_inty)\nsets integral feedback gains   void set_Kc_inty(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_inty)\nsets integral feedback gains (moving)   void set_Kc_u(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_u)\nsets input feedback gains   void set_Kc_u(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_u)\nsets input feedback gains (moving)   void set_g_design(const UniformVectorList \u0026amp; g)\nsets input gain used during controller design   void set_g_design(UniformVectorList \u0026amp;\u0026amp; g)\nsets input gain used during controller design (moving)    Protected Attributes inherited from lds::SwitchedController\u0026lt; System \u0026gt;\n    Name     std::vector\u0026lt; System \u0026gt; systems_ underlying sub-systems which are switched between   size_t n_sys_ number of systems   size_t idx_ current system/controller index.   UniformMatrixList Kc_list_   UniformMatrixList Kc_inty_list_   UniformMatrixList Kc_u_list_   UniformVectorList g_design_list_    Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default\nConstructs a new Controller.    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const Matrix \u0026amp; Kc() const\nGet state feedback controller gain.   const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain.   const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain.   const Vector \u0026amp; g_design() const\nGet input gain used in controller design.   const Vector \u0026amp; u_ref() const\nGet reference input.   const Vector \u0026amp; x_ref() const\nGet reference state.   const Vector \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_g_design(const Vector \u0026amp; g_design)\nSet input gain used in controller design (g_design)   void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref)   void set_Kc(const Matrix \u0026amp; Kc)\nSet state controller gain.   void set_Kc_inty(const Matrix \u0026amp; Kc_inty)\nSet integral controller gain.   void set_Kc_u(const Matrix \u0026amp; Kc_u)\nSet input controller gain.   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()\nprints variables to stdout    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   Vector u_ control signal   Vector g_design_ input gain of the system used for controller design   Vector u_ref_ reference input   Vector u_ref_prev_ reference input at previous time step   Vector x_ref_ reference state   Vector y_ref_ reference output   Vector cx_ref_   Matrix Kc_ state controller gain   Matrix Kc_u_ input controller gain (optional when control updates \\deltaU)   Matrix Kc_inty_ integral controller gain   Vector du_ref_   Vector dv_ref_   Vector v_ref_   Vector dv_   Vector v_ Control after g inversion (e.g., control in physical units)   Vector int_e_ integrated error   Vector int_e_awu_adjust_ anti-windup adjustment to intE   Vector u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type      Public Function Details #  set_y_ref #  inline virtual void set_y_ref( const Vector \u0026amp; y_ref ) override Reimplements: lds::Controller::set_y_ref\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':42,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_system/','title':"lds::poisson::System",'section':"Classes",'content':"lds::poisson::System #  Poisson System type. #include \u0026lt;lds_poisson_sys.h\u0026gt;\nInherits from lds::System\nPublic Functions #      Name      System() =default\nConstructs a new System.    System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0)\nConstructs a new Poisson System.   virtual const Vector \u0026amp; Simulate(const Vector \u0026amp; u_tm1) override\nSimulate system measurement.    Protected Functions #      Name     virtual void h() override\nSystem output function.   virtual void RecurseKe() override\nRecursively recalculate estimator gain (Ke)    Additional inherited members #  Public Functions inherited from lds::System\n    Name     void Filter(const Vector \u0026amp; u_tm1, const Vector \u0026amp; z)\nFilter data to produce causal state estimates.   void f(const Vector \u0026amp; u, bool do_add_noise =false)\nsystem dynamics function   size_t n_u() const\nGet number of inputs.   size_t n_x() const\nGet number of states.   size_t n_y() const\nGet number of outputs.   data_t dt() const\nGet sample period.   const Vector \u0026amp; x() const\nGet current state.   const Matrix \u0026amp; P() const\nGet covariance of state estimate.   const Vector \u0026amp; m() const\nGet current process disturbance/bias.   const Matrix \u0026amp; P_m() const\nGet covariance of process disturbance estimate.   const Vector \u0026amp; cx() const\nGet C*x.   const Vector \u0026amp; y() const\nGet output.   const Vector \u0026amp; x0() const\nGet initial state.   const Vector \u0026amp; m0() const\nGet initial disturbance.   const Matrix \u0026amp; A() const\nGet state matrix.   const Matrix \u0026amp; B() const\nGet input matrix.   const Vector \u0026amp; g() const\nGet input gain/conversion factor.   const Matrix \u0026amp; C() const\nGet output matrix.   const Vector \u0026amp; d() const\nGet output bias.   const Matrix \u0026amp; Ke() const\nGet estimator gain.   const Matrix \u0026amp; Ke_m() const\nGet estimator gain for process disturbance (m)   void set_A(const Matrix \u0026amp; A)\nSet state matrix.   void set_B(const Matrix \u0026amp; B)\nSet input matrix.   void set_m(const Vector \u0026amp; m)\nSet process disturbance.   void set_g(const Vector \u0026amp; g)\nSet input gain.   void set_Q(const Matrix \u0026amp; Q)\nSet process noise covariance.   void set_Q_m(const Matrix \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation.   void set_x0(const Vector \u0026amp; x0)\nSet initial state.   void set_P0(const Matrix \u0026amp; P0)\nSet covariance of initial state.   void set_P0_m(const Matrix \u0026amp; P0_m)\nSet covariance of initial process disturbance.   void set_C(const Matrix \u0026amp; C)\nSet output matrix.   void set_d(const Vector \u0026amp; d)\nSet output bias.   void Reset()\nReset system variables.   void Print()\nPrint system variables to stdout.    Protected Functions inherited from lds::System\n    Name     void InitVars(data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0)    Public Attributes inherited from lds::System\n    Name     bool do_adapt_m whether to adaptively estimate disturbance m    Protected Attributes inherited from lds::System\n    Name     std::size_t n_x_ number of states   std::size_t n_u_ number of inputs   std::size_t n_y_ number of outputs   data_t dt_ sample period   Vector x_ state   Matrix P_ covariance of state estimate   Vector m_ process disturbance   Matrix P_m_ covariance of disturbance estimate   Vector cx_ C*x.   Vector y_ output   Vector z_ measurement   Vector x0_ initial state   Matrix P0_ covariance of initial state estimate   Vector m0_ initial process disturbance   Matrix P0_m_ covariance of initial disturbance est.   Matrix A_ state matrix   Matrix B_ input matrix   Vector g_ input gain   Matrix Q_ covariance of process noise   Matrix Q_m_ covariance of disturbance random walk   Matrix C_ output matrix   Vector d_ output bias   Matrix Ke_ estimator gain   Matrix Ke_m_ estimator gain for process disturbance      Public Function Details #  System #  System() =default  System #  System( std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0 ) Parameters:\n n_u number of inputs n_x number of states n_y number of outputs dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q)   Simulate #  virtual const Vector \u0026amp; Simulate( const Vector \u0026amp; u_tm1 ) override Parameters:\n u_tm1 input at t-1  Return: z measurement\nReimplements: lds::System::Simulate\nSimulate system and produce measurement\n Protected Function Details #  h #  inline virtual void h() override Reimplements: lds::System::h\n RecurseKe #  virtual void RecurseKe() override Reimplements: lds::System::RecurseKe\nRecursively recalculate estimator gain (Ke).\nReferences:\nSmith AC, Brown EN. (2003) Estimating a State-Space Model from Point Process Observations. Neural Computation 15.\nEden UT, \u0026hellip;, Brown EN. (2004) Dynamic Analysis of Neural Encoding by Point Process Adaptive Filtering Neural Computation 16.\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':43,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_s_s_i_d/','title':"lds::SSID",'section':"Classes",'content':"lds::SSID #  More\u0026hellip;\nInherited by lds::gaussian::FitSSID, lds::poisson::FitSSID\nPublic Functions #      Name      SSID() =default\nConstructs a new SSIDFit type.    SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train, const Vector \u0026amp; d =Vector(1).fill(-kInf))\nConstructs a new SSIDFit type.   std::tuple\u0026lt; Fit, Vector \u0026gt; Run(SSIDWt ssid_wt)\nRuns fitting by subspace identification (SSID)   std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData()\nReturns the I/O data to caller.    Protected Functions #      Name     void CalcD(data_t t_silence =0.1, data_t thresh_silence =0.001)\nUsing periods of silence in inputs (u), calculates the output \\ bias (d)   void CreateHankelDataMat()\nCreates the block-hankel I/O data matrix.   virtual void DecomposeData()\nDecompose data to lower-triangular matrix (used in Solve)   void CalcSVD(SSIDWt wt)\nperforms the singular value decomposition (SVD)   void Solve(data_t wt_dc)\nsolves for LDS parameters   void RecomputeExtObs()\nrecompute extended observability matrix from estimates of A, C    Protected Attributes #      Name     UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_ input training data   UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_ measurement training data   Matrix D_ block-Hankel I/O data matrix   Fit fit_ fit   Matrix g_dc_ I/O gain @ DC.   data_t dt_ sample period   size_t n_u_ number of inputs   size_t n_x_ number of states   size_t n_y_ number of outputs   size_t n_h_   size_t n_trials_ number of input/output data sequences   std::vector\u0026lt; size_t \u0026gt; n_t_ number of time steps   size_t n_t_tot_ total number of time steps across trials   Matrix L_ lower triangle decomp of covariance matrix   Vector s_ singular values   Matrix ext_obs_t_ extended observability matrix    Detailed Description #  template \u0026lt;typename Fit \u0026gt; class lds::SSID;   Public Function Details #  SSID #  SSID() =default  SSID #  SSID( size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026amp;\u0026amp; z_train, const Vector \u0026amp; d =Vector(1).fill(-kInf) ) Parameters:\n n_x number of states n_h size of block-hankel data matrix dt sample period u_train input training data z_train measurement training data d output bias   Run #  std::tuple\u0026lt; Fit, Vector \u0026gt; Run( SSIDWt ssid_wt ) Parameters:\n ssid_wt weight for singular value decomp  Return: tuple (Fit, singular values)\n ReturnData #  inline std::tuple\u0026lt; UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt;, UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; \u0026gt; ReturnData() Return: tuple(input data, output data)\n Protected Function Details #  CalcD #  void CalcD( data_t t_silence =0.1, data_t thresh_silence =0.001 ) Parameters:\n t_silence threshold on period of time that qualifies as \u0026ldquo;silence\u0026rdquo; thresh_silence threshold on input amplitude u that qualifies as \u0026ldquo;silence\u0026rdquo;   CreateHankelDataMat #  void CreateHankelDataMat() Creates the block-hankel I/O data matrix. Also calculates I/O gain @ DC.\n DecomposeData #  virtual void DecomposeData() Reimplemented by: lds::gaussian::FitSSID::DecomposeData, lds::poisson::FitSSID::DecomposeData\n CalcSVD #  void CalcSVD( SSIDWt wt ) Parameters:\n ssid_wt weight for SVD   Solve #  void Solve( data_t wt_dc ) Parameters:\n wt_dc weight placed on getting correct DC I/O gain   RecomputeExtObs #  void RecomputeExtObs()  Protected Attribute Details #  **u_** #  UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; u_;  **z_** #  UniformMatrixList\u0026lt; kMatFreeDim2 \u0026gt; z_;  **D_** #  Matrix D_;  **fit_** #  Fit fit_;  **g_dc_** #  Matrix g_dc_;  **dt_** #  data_t dt_ {};  **n_u_** #  size_t n_u_ {};  **n_x_** #  size_t n_x_ {};  **n_y_** #  size_t n_y_ {};  **n_h_** #  size_t n_h_ {};  **n_trials_** #  size_t n_trials_ {};  **n_t_** #  std::vector\u0026lt; size_t \u0026gt; n_t_;  **n_t_tot_** #  size_t n_t_tot_ {};  **L_** #  Matrix L_;  **s_** #  Vector s_;  **ext_obs_t_** #  Matrix ext_obs_t_;   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':44,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_switched_controller/','title':"lds::SwitchedController",'section':"Classes",'content':"lds::SwitchedController #  SwitchedController Type. More\u0026hellip;\n\n#include \u0026lt;lds_sctrl.h\u0026gt;\nInherits from lds::Controller\u0026lt; System \u0026gt;\nInherited by lds::gaussian::SwitchedController, lds::poisson::SwitchedController\nPublic Functions #      Name      SwitchedController() =default\nConstructs a new SwitchedController.    SwitchedController(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController.    SwitchedController(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new SwitchedController (moves systems).   void Switch(size_t idx, bool do_force_switch =false)\nSwitch to a different sub-system/controller.   void set_Kc(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc)\nsets state feedback gains   void set_Kc(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc)\nsets state feedback gains (moving)   void set_Kc_inty(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_inty)\nsets integral feedback gains   void set_Kc_inty(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_inty)\nsets integral feedback gains (moving)   void set_Kc_u(const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_u)\nsets input feedback gains   void set_Kc_u(UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_u)\nsets input feedback gains (moving)   void set_g_design(const UniformVectorList \u0026amp; g)\nsets input gain used during controller design   void set_g_design(UniformVectorList \u0026amp;\u0026amp; g)\nsets input gain used during controller design (moving)    Protected Attributes #      Name     std::vector\u0026lt; System \u0026gt; systems_ underlying sub-systems which are switched between   size_t n_sys_ number of systems   size_t idx_ current system/controller index.   UniformMatrixList Kc_list_   UniformMatrixList Kc_inty_list_   UniformMatrixList Kc_u_list_   UniformVectorList g_design_list_    Additional inherited members #  Public Functions inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name      Controller() =default\nConstructs a new Controller.    Controller(const System \u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller.    Controller(System \u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type =0)\nConstructs a new Controller by moving the system object.   const Vector \u0026amp; Control(const Vector \u0026amp; z, bool do_control =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal (single-step)   const Vector \u0026amp; ControlOutputReference(const Vector \u0026amp; z, bool do_control =true, bool do_estimation =true, bool do_lock_control =false, data_t sigma_soft_start =0, data_t sigma_u_noise =0, bool do_reset_at_control_onset =true)\nupdates control signal, given previously-set (single-step)   const System \u0026amp; sys() const   const Matrix \u0026amp; Kc() const\nGet state feedback controller gain.   const Matrix \u0026amp; Kc_inty() const\nGet integral controller gain.   const Matrix \u0026amp; Kc_u() const\nGet input feedback controller gain.   const Vector \u0026amp; g_design() const\nGet input gain used in controller design.   const Vector \u0026amp; u_ref() const\nGet reference input.   const Vector \u0026amp; x_ref() const\nGet reference state.   const Vector \u0026amp; y_ref() const\nGet reference output.   size_t control_type() const\nGet controller type.   void set_sys(const System \u0026amp; sys)\nSet system.   void set_u_ref(const Vector \u0026amp; u_ref)\nSet reference input (u_ref)   void set_x_ref(const Vector \u0026amp; x_ref)\nSet reference state (x_ref)   virtual void set_y_ref(const Vector \u0026amp; y_ref)\nSet reference output (y_ref)   void set_tau_awu(data_t tau)\nSet time constant of anti-integral-windup.   void set_control_type(size_t control_type)\nSets the control type.   void Reset()\nreset system and control variables.   void Print()\nprints variables to stdout    Protected Attributes inherited from lds::Controller\u0026lt; System \u0026gt;\n    Name     System sys_ underlying LDS   Vector u_ control signal   Vector g_design_ input gain of the system used for controller design   Vector u_ref_ reference input   Vector u_ref_prev_ reference input at previous time step   Vector x_ref_ reference state   Vector y_ref_ reference output   Vector cx_ref_   Matrix Kc_ state controller gain   Matrix Kc_u_ input controller gain (optional when control updates \\deltaU)   Matrix Kc_inty_ integral controller gain   Vector du_ref_   Vector dv_ref_   Vector v_ref_   Vector dv_   Vector v_ Control after g inversion (e.g., control in physical units)   Vector int_e_ integrated error   Vector int_e_awu_adjust_ anti-windup adjustment to intE   Vector u_sat_ control signal after saturation (for antiWindup)   bool do_control_prev_   bool do_lock_control_prev_   bool u_saturated_ whether control signal has reached saturation limits   data_t u_lb_ lower bound on control   data_t u_ub_ upper bound on control   data_t tau_awu_ antiwindup time constant   data_t k_awu_   data_t t_since_control_onset_ time since control epoch onset   size_t control_type_ controller type    Detailed Description #  template \u0026lt;typename System \u0026gt; class lds::SwitchedController;   Public Function Details #  SwitchedController #  SwitchedController() =default  SwitchedController #  inline SwitchedController( const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\n systems vector of sub-systems u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask   SwitchedController #  inline SwitchedController( std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type =0 ) Parameters:\n systems vector of sub-systems u_lb lower bound on control (u) u_ub upper bound on control (u) control_type [optional] control type bit mask   Switch #  inline void Switch( size_t idx, bool do_force_switch =false ) Parameters:\n idx index do_force_switch whether to force a system switch even if already there.   set_Kc #  inline void set_Kc( const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc )  set_Kc #  inline void set_Kc( UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc )  set_Kc_inty #  inline void set_Kc_inty( const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_inty )  set_Kc_inty #  inline void set_Kc_inty( UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_inty )  set_Kc_u #  inline void set_Kc_u( const UniformMatrixList\u0026lt;\u0026gt; \u0026amp; Kc_u )  set_Kc_u #  inline void set_Kc_u( UniformMatrixList\u0026lt;\u0026gt; \u0026amp;\u0026amp; Kc_u )  set_g_design #  inline void set_g_design( const UniformVectorList \u0026amp; g )  set_g_design #  inline void set_g_design( UniformVectorList \u0026amp;\u0026amp; g )  Protected Attribute Details #  **systems_** #  std::vector\u0026lt; System \u0026gt; systems_;  **n_sys_** #  size_t n_sys_ {};  **idx_** #  size_t idx_ {};  **Kc_list_** #  UniformMatrixList Kc_list_;  **Kc_inty_list_** #  UniformMatrixList Kc_inty_list_;  **Kc_u_list_** #  UniformMatrixList Kc_u_list_;  **g_design_list_** #  UniformVectorList g_design_list_;   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':45,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_system/','title':"lds::System",'section':"Classes",'content':"lds::System #  Linear Dynamical System Type. #include \u0026lt;lds_sys.h\u0026gt;\nInherited by lds::gaussian::System, lds::poisson::System\nPublic Functions #      Name      System() =default\nConstructs a new System.    System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0)\nconstructs a new System    System(const Matrix \u0026amp; A, const Matrix \u0026amp; B, const Vector \u0026amp; g, const Vector \u0026amp; m, const Matrix \u0026amp; Q, const Matrix \u0026amp; C, const Vector \u0026amp; d, const Vector \u0026amp; x0, const Matrix \u0026amp; P0, data_t dt)   void Filter(const Vector \u0026amp; u_tm1, const Vector \u0026amp; z)\nFilter data to produce causal state estimates.   virtual const Vector \u0026amp; Simulate(const Vector \u0026amp; u_tm1) =0\nsimulates system (single time step)   void f(const Vector \u0026amp; u, bool do_add_noise =false)\nsystem dynamics function   virtual void h() =0\nsystem output function   size_t n_u() const\nGet number of inputs.   size_t n_x() const\nGet number of states.   size_t n_y() const\nGet number of outputs.   data_t dt() const\nGet sample period.   const Vector \u0026amp; x() const\nGet current state.   const Matrix \u0026amp; P() const\nGet covariance of state estimate.   const Vector \u0026amp; m() const\nGet current process disturbance/bias.   const Matrix \u0026amp; P_m() const\nGet covariance of process disturbance estimate.   const Vector \u0026amp; cx() const\nGet C*x.   const Vector \u0026amp; y() const\nGet output.   const Vector \u0026amp; x0() const\nGet initial state.   const Vector \u0026amp; m0() const\nGet initial disturbance.   const Matrix \u0026amp; A() const\nGet state matrix.   const Matrix \u0026amp; B() const\nGet input matrix.   const Vector \u0026amp; g() const\nGet input gain/conversion factor.   const Matrix \u0026amp; C() const\nGet output matrix.   const Vector \u0026amp; d() const\nGet output bias.   const Matrix \u0026amp; Ke() const\nGet estimator gain.   const Matrix \u0026amp; Ke_m() const\nGet estimator gain for process disturbance (m)   void set_A(const Matrix \u0026amp; A)\nSet state matrix.   void set_B(const Matrix \u0026amp; B)\nSet input matrix.   void set_m(const Vector \u0026amp; m)\nSet process disturbance.   void set_g(const Vector \u0026amp; g)\nSet input gain.   void set_Q(const Matrix \u0026amp; Q)\nSet process noise covariance.   void set_Q_m(const Matrix \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation.   void set_x0(const Vector \u0026amp; x0)\nSet initial state.   void set_P0(const Matrix \u0026amp; P0)\nSet covariance of initial state.   void set_P0_m(const Matrix \u0026amp; P0_m)\nSet covariance of initial process disturbance.   void set_C(const Matrix \u0026amp; C)\nSet output matrix.   void set_d(const Vector \u0026amp; d)\nSet output bias.   void Reset()\nReset system variables.   void Print()\nPrint system variables to stdout.    Protected Functions #      Name     virtual void RecurseKe() =0\nRecursively recalculate estimator gain (Ke)   void InitVars(data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0)    Public Attributes #      Name     bool do_adapt_m whether to adaptively estimate disturbance m    Protected Attributes #      Name     std::size_t n_x_ number of states   std::size_t n_u_ number of inputs   std::size_t n_y_ number of outputs   data_t dt_ sample period   Vector x_ state   Matrix P_ covariance of state estimate   Vector m_ process disturbance   Matrix P_m_ covariance of disturbance estimate   Vector cx_ C*x.   Vector y_ output   Vector z_ measurement   Vector x0_ initial state   Matrix P0_ covariance of initial state estimate   Vector m0_ initial process disturbance   Matrix P0_m_ covariance of initial disturbance est.   Matrix A_ state matrix   Matrix B_ input matrix   Vector g_ input gain   Matrix Q_ covariance of process noise   Matrix Q_m_ covariance of disturbance random walk   Matrix C_ output matrix   Vector d_ output bias   Matrix Ke_ estimator gain   Matrix Ke_m_ estimator gain for process disturbance      Public Function Details #  System #  System() =default  System #  System( size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0 ) Parameters:\n n_u number of inputs n_x number of states n_y number of outputs dt sample period p0 diagonal elements for state estimate covariance q0 diagonal elements for process noise covariance   System #  System( const Matrix \u0026amp; A, const Matrix \u0026amp; B, const Vector \u0026amp; g, const Vector \u0026amp; m, const Matrix \u0026amp; Q, const Matrix \u0026amp; C, const Vector \u0026amp; d, const Vector \u0026amp; x0, const Matrix \u0026amp; P0, data_t dt )  Filter #  void Filter( const Vector \u0026amp; u_tm1, const Vector \u0026amp; z ) Parameters:\n u_tm1 input at t-minus-1 z_t current measurement  Given current measurment and input, filter data to produce causal state estimates using Kalman filtering, which procedes by predicting the state and subsequently updating.\n Simulate #  virtual const Vector \u0026amp; Simulate( const Vector \u0026amp; u_tm1 ) =0 Parameters:\n u_tm1 input at time t-1  Return: simulated measurement at time t\nReimplemented by: lds::gaussian::System::Simulate, lds::poisson::System::Simulate\n f #  inline void f( const Vector \u0026amp; u, bool do_add_noise =false ) Parameters:\n u input do_add_noise whether to add simulated process noise   h #  virtual void h() =0 Reimplemented by: lds::gaussian::System::h, lds::poisson::System::h\n n_u #  inline size_t n_u() const  n_x #  inline size_t n_x() const  n_y #  inline size_t n_y() const  dt #  inline data_t dt() const  x #  inline const Vector \u0026amp; x() const  P #  inline const Matrix \u0026amp; P() const  m #  inline const Vector \u0026amp; m() const  P_m #  inline const Matrix \u0026amp; P_m() const  cx #  inline const Vector \u0026amp; cx() const  y #  inline const Vector \u0026amp; y() const  x0 #  inline const Vector \u0026amp; x0() const  m0 #  inline const Vector \u0026amp; m0() const  A #  inline const Matrix \u0026amp; A() const  B #  inline const Matrix \u0026amp; B() const  g #  inline const Vector \u0026amp; g() const  C #  inline const Matrix \u0026amp; C() const  d #  inline const Vector \u0026amp; d() const  Ke #  inline const Matrix \u0026amp; Ke() const  Ke_m #  inline const Matrix \u0026amp; Ke_m() const  set_A #  inline void set_A( const Matrix \u0026amp; A )  set_B #  inline void set_B( const Matrix \u0026amp; B )  set_m #  inline void set_m( const Vector \u0026amp; m )  set_g #  inline void set_g( const Vector \u0026amp; g )  set_Q #  inline void set_Q( const Matrix \u0026amp; Q )  set_Q_m #  inline void set_Q_m( const Matrix \u0026amp; Q_m )  set_x0 #  inline void set_x0( const Vector \u0026amp; x0 )  set_P0 #  inline void set_P0( const Matrix \u0026amp; P0 )  set_P0_m #  inline void set_P0_m( const Matrix \u0026amp; P0_m )  set_C #  inline void set_C( const Matrix \u0026amp; C )  set_d #  inline void set_d( const Vector \u0026amp; d )  Reset #  void Reset()  Print #  void Print()  Protected Function Details #  RecurseKe #  virtual void RecurseKe() =0 Reimplemented by: lds::gaussian::System::RecurseKe, lds::poisson::System::RecurseKe\n InitVars #  void InitVars( data_t p0 =kDefaultP0, data_t q0 =kDefaultQ0 )  Public Attribute Details #  do_adapt_m #  bool do_adapt_m {};  Protected Attribute Details #  **n_x_** #  std::size_t n_x_ {};  **n_u_** #  std::size_t n_u_ {};  **n_y_** #  std::size_t n_y_ {};  **dt_** #  data_t dt_ {};  **x_** #  Vector x_;  **P_** #  Matrix P_;  **m_** #  Vector m_;  **P_m_** #  Matrix P_m_;  **cx_** #  Vector cx_;  **y_** #  Vector y_;  **z_** #  Vector z_;  **x0_** #  Vector x0_;  **P0_** #  Matrix P0_;  **m0_** #  Vector m0_;  **P0_m_** #  Matrix P0_m_;  **A_** #  Matrix A_;  **B_** #  Matrix B_;  **g_** #  Vector g_;  **Q_** #  Matrix Q_;  **Q_m_** #  Matrix Q_m_;  **C_** #  Matrix C_;  **d_** #  Vector d_;  **Ke_** #  Matrix Ke_;  **Ke_m_** #  Matrix Ke_m_;   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':46,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_uniform_matrix_list/','title':"lds::UniformMatrixList",'section':"Classes",'content':"lds::UniformMatrixList #  More\u0026hellip;\nInherits from std::vector\u0026lt; Matrix \u0026gt;\nPublic Functions #      Name      UniformMatrixList() =default\nConstructs a new UniformMatrixList.    UniformMatrixList(const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0})\nConstructs a new UniformMatrixList by copying existing vector of Matrix if dimensions consistent.    UniformMatrixList(std::vector\u0026lt; Matrix \u0026gt; \u0026amp;\u0026amp; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0})\nConstructs a new UniformMatrixList by moving existing vector of Matrix if dimensions consistent.    UniformMatrixList(std::initializer_list\u0026lt; Matrix \u0026gt; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0})\nConstructs a new UniformMatrixList from initializer_list of Matrix if dimensions consistent.    UniformMatrixList(const UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; that)\nConstructs a new UniformMatrixList (copy).    UniformMatrixList(UniformMatrixList\u0026lt; D \u0026gt; \u0026amp;\u0026amp; that)\nConstructs a new UniformMatrixList (move).    ~UniformMatrixList() =default\nDestroys the object.   const std::array\u0026lt; size_t, 2 \u0026gt; \u0026amp; dim(size_t n =0) const\ngets dimensions of uniformly sized matrices   size_t size()\nsize of container   const Matrix \u0026amp; at(size_t n)\ngets reference to n^th element   void Swap(Matrix \u0026amp; that, size_t n)\nswaps input matrix with n^th matrix of list   UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; operator=(const UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; that)\nassigns the contents (copy)   UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; operator=(UniformMatrixList\u0026lt; D \u0026gt; \u0026amp;\u0026amp; that)\nassigns the contents (move)    Detailed Description #  template \u0026lt;MatrixListFreeDim D =kMatFreeDimNone\u0026gt; class lds::UniformMatrixList;   Public Function Details #  UniformMatrixList #  UniformMatrixList() =default  UniformMatrixList #  explicit UniformMatrixList( const std::vector\u0026lt; Matrix \u0026gt; \u0026amp; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0} ) Parameters:\n mats input matrices dim dimensions   UniformMatrixList #  explicit UniformMatrixList( std::vector\u0026lt; Matrix \u0026gt; \u0026amp;\u0026amp; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0} ) Parameters:\n mats input matrices dim dimensions   UniformMatrixList #  UniformMatrixList( std::initializer_list\u0026lt; Matrix \u0026gt; mats, std::array\u0026lt; size_t, 2 \u0026gt; dim ={0, 0} ) Parameters:\n mats input matrices dim dimensions   UniformMatrixList #  UniformMatrixList( const UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; that ) Parameters:\n that another UniformMatrixList   UniformMatrixList #  UniformMatrixList( UniformMatrixList\u0026lt; D \u0026gt; \u0026amp;\u0026amp; that ) Parameters:\n that another UniformMatrixList   ~UniformMatrixList #  ~UniformMatrixList() =default  dim #  inline const std::array\u0026lt; size_t, 2 \u0026gt; \u0026amp; dim( size_t n =0 ) const Parameters:\n n [optional] index in list of matrices  Return: dimensions\n size #  inline size_t size()  at #  inline const Matrix \u0026amp; at( size_t n )  Swap #  inline void Swap( Matrix \u0026amp; that, size_t n ) Parameters:\n that input matrix n index where the matrix is moved   operator= #  inline UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; operator=( const UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; that ) Parameters:\n that another UniformMatrixList  Return: reference to object\n operator= #  inline UniformMatrixList\u0026lt; D \u0026gt; \u0026amp; operator=( UniformMatrixList\u0026lt; D \u0026gt; \u0026amp;\u0026amp; that ) Parameters:\n that another UniformMatrixList  Return: reference to object\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':47,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_uniform_system_list/','title':"lds::UniformSystemList",'section':"Classes",'content':"lds::UniformSystemList #  More\u0026hellip;\nInherits from std::vector\u0026lt; System \u0026gt;\nPublic Functions #      Name      UniformSystemList() =default\nConstructs a new UniformSystemList.    UniformSystemList(const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0})\nConstructs a new UniformSystemList by copying existing vector of System if dimensions consistent.    UniformSystemList(std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0})\nConstructs a new UniformSystemList by moving existing vector of System if dimensions consistent.    UniformSystemList(std::initializer_list\u0026lt; System \u0026gt; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0})\nConstructs a new UniformSystemList from initializer_list of System if dimensions consistent.    UniformSystemList(const UniformSystemList \u0026amp; that)\nConstructs a new UniformSystemList (copy).    UniformSystemList(UniformSystemList \u0026amp;\u0026amp; that)\nConstructs a new UniformSystemList (move).    ~UniformSystemList() =default\nDestroys the object.   const std::array\u0026lt; size_t, 3 \u0026gt; \u0026amp; dim() const\ngets dimensions of the uniformly sized systems   size_t size()\nsize of container   const System \u0026amp; at(size_t n)\ngets reference to n^th element   void Swap(System \u0026amp; that, size_t n)\nswaps input system with n^th system of list   UniformSystemList \u0026amp; operator=(const UniformSystemList \u0026amp; that)\nassigns the contents (copy)   UniformSystemList \u0026amp; operator=(UniformSystemList \u0026amp;\u0026amp; that)\nassigns the contents (move)    Detailed Description #  template \u0026lt;typename System \u0026gt; class lds::UniformSystemList;   Public Function Details #  UniformSystemList #  UniformSystemList() =default  UniformSystemList #  explicit UniformSystemList( const std::vector\u0026lt; System \u0026gt; \u0026amp; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0} ) Parameters:\n systems input systems dim dimensions (n_u, n_x, n_y)   UniformSystemList #  explicit UniformSystemList( std::vector\u0026lt; System \u0026gt; \u0026amp;\u0026amp; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0} ) Parameters:\n systems input systems dim dimensions (n_u, n_x, n_y)   UniformSystemList #  UniformSystemList( std::initializer_list\u0026lt; System \u0026gt; systems, std::array\u0026lt; size_t, 3 \u0026gt; dim ={0, 0, 0} ) Parameters:\n systems input systems dim dimensions (n_u, n_x, n_y)   UniformSystemList #  UniformSystemList( const UniformSystemList \u0026amp; that ) Parameters:\n that another UniformSystemList   UniformSystemList #  UniformSystemList( UniformSystemList \u0026amp;\u0026amp; that ) Parameters:\n that another UniformSystemList   ~UniformSystemList #  ~UniformSystemList() =default  dim #  inline const std::array\u0026lt; size_t, 3 \u0026gt; \u0026amp; dim() const  size #  inline size_t size()  at #  inline const System \u0026amp; at( size_t n )  Swap #  inline void Swap( System \u0026amp; that, size_t n ) Parameters:\n that input system n index where the system is moved   operator= #  inline UniformSystemList \u0026amp; operator=( const UniformSystemList \u0026amp; that ) Parameters:\n that another UniformSystemList  Return: reference to object\n operator= #  inline UniformSystemList \u0026amp; operator=( UniformSystemList \u0026amp;\u0026amp; that ) Parameters:\n that another UniformSystemList  Return: reference to object\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':48,'href':'/ldsctrlest/docs/api/classes/classlds_1_1_uniform_vector_list/','title':"lds::UniformVectorList",'section':"Classes",'content':"lds::UniformVectorList #  Inherits from std::vector\u0026lt; Vector \u0026gt;\nPublic Functions #      Name      UniformVectorList() =default\nConstructs a new UniformVectorList.    UniformVectorList(const std::vector\u0026lt; Vector \u0026gt; \u0026amp; vecs, size_t dim =0)\nConstructs a new UniformVectorList by copying existing vector of Vector if dimensions consistent.    UniformVectorList(std::vector\u0026lt; Vector \u0026gt; \u0026amp;\u0026amp; vecs, size_t dim =0)\nConstructs a new UniformVectorList by moving existing vector of Vector if dimensions consistent.    UniformVectorList(std::initializer_list\u0026lt; Vector \u0026gt; vecs, size_t dim =0)\nConstructs a new UniformVectorList from initializer_list of Vector if dimensions consistent.    UniformVectorList(const UniformVectorList \u0026amp; that)\nConstructs a new UniformVectorList (copy)    UniformVectorList(UniformVectorList \u0026amp;\u0026amp; that)\nConstructs a new UniformVectorList (move)    ~UniformVectorList() =default\nDestroys the object.   size_t dim() const\ngets dimensions of the uniformly sized matrices   size_t size()\nsize of container   const Vector \u0026amp; at(size_t n)\ngets reference to n^th element   void Swap(Vector \u0026amp; that, size_t n)\nswaps input matrix with n^th vector of list   UniformVectorList \u0026amp; operator=(const UniformVectorList \u0026amp; that)\nassigns the contents (copy)   UniformVectorList \u0026amp; operator=(UniformVectorList \u0026amp;\u0026amp; that)\nassigns the contents (move)      Public Function Details #  UniformVectorList #  UniformVectorList() =default  UniformVectorList #  explicit UniformVectorList( const std::vector\u0026lt; Vector \u0026gt; \u0026amp; vecs, size_t dim =0 ) Parameters:\n vecs input vectors dims dimension   UniformVectorList #  explicit UniformVectorList( std::vector\u0026lt; Vector \u0026gt; \u0026amp;\u0026amp; vecs, size_t dim =0 ) Parameters:\n vecs input vectors dim dimension   UniformVectorList #  UniformVectorList( std::initializer_list\u0026lt; Vector \u0026gt; vecs, size_t dim =0 ) Parameters:\n vecs input vectors dim dimension   UniformVectorList #  UniformVectorList( const UniformVectorList \u0026amp; that ) Parameters:\n that another UniformVectorList   UniformVectorList #  UniformVectorList( UniformVectorList \u0026amp;\u0026amp; that ) Parameters:\n that another UniformVectorList   ~UniformVectorList #  ~UniformVectorList() =default  dim #  inline size_t dim() const  size #  inline size_t size()  at #  inline const Vector \u0026amp; at( size_t n )  Swap #  inline void Swap( Vector \u0026amp; that, size_t n ) Parameters:\n that input vector n index where the vector is moved   operator= #  inline UniformVectorList \u0026amp; operator=( const UniformVectorList \u0026amp; that ) Parameters:\n that another UniformVectorList  Return: reference to object\n operator= #  inline UniformVectorList \u0026amp; operator=( UniformVectorList \u0026amp;\u0026amp; that ) Parameters:\n that another UniformVectorList  Return: reference to object\n  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':49,'href':'/ldsctrlest/docs/api/files/dir_2755d76cbd49ca86cc5d9263eb253d5e/','title':"ldsCtrlEst_h",'section':"Files",'content':"ldsCtrlEst_h #  Files #     Name     ldsCtrlEst_h/lds.h lds namespace   ldsCtrlEst_h/lds_ctrl.h Controller.   ldsCtrlEst_h/lds_fit.h LDS base fit type.   ldsCtrlEst_h/lds_fit_em.h subspace identification   ldsCtrlEst_h/lds_fit_ssid.h subspace identification   ldsCtrlEst_h/lds_gaussian.h glds namespace   ldsCtrlEst_h/lds_gaussian_ctrl.h GLDS Controller.   ldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type.   ldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type.   ldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type.   ldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type.   ldsCtrlEst_h/lds_gaussian_sys.h GLDS base type.   ldsCtrlEst_h/lds_poisson.h plds namespace   ldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type.   ldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type.   ldsCtrlEst_h/lds_poisson_fit_em.h PLDS E-M fit type.   ldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type.   ldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type.   ldsCtrlEst_h/lds_poisson_sys.h PLDS base type.   ldsCtrlEst_h/lds_sctrl.h SwitchedController type.   ldsCtrlEst_h/lds_sys.h LDS base type.   ldsCtrlEst_h/lds_uniform_mats.h List of uniformly sized matrices.   ldsCtrlEst_h/lds_uniform_systems.h List of uniformly sized Systems.   ldsCtrlEst_h/lds_uniform_vecs.h List of uniformly sized vectors.   ldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API)   ldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API)     Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':50,'href':'/ldsctrlest/docs/api/files/lds_8h/','title':"ldsCtrlEst_h/lds.h",'section':"Files",'content':"ldsCtrlEst_h/lds.h #  lds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Detailed Description #  This file defines the lds namespace, which will be an umbrella for linear dynamical systems with Gaussian ([lds::gaussian](/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/)) or Poisson ([lds::poisson](/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/)) observations.\nSource code #  //===-- ldsCtrlEst_h/lds.h - Linear Dynmical System Namespace ---*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_H #define LDSCTRLEST_LDS_H  // #ifndef LDSCTRLEST // #include \u0026lt;ldsCtrlEst\u0026gt; // #endif  #include \u0026lt;armadillo\u0026gt; namespace lds { using data_t = double; // may change to float (but breaks mex functions) using Vector = arma::Col\u0026lt;data_t\u0026gt;; using Matrix = arma::Mat\u0026lt;data_t\u0026gt;; using Cube = arma::Cube\u0026lt;data_t\u0026gt;; using View = arma::subview\u0026lt;data_t\u0026gt;; namespace fill = arma::fill; static const std::size_t kControlTypeDeltaU = 0x1; static const std::size_t kControlTypeIntY = kControlTypeDeltaU \u0026lt;\u0026lt; 1; static const std::size_t kControlTypeAdaptM = kControlTypeDeltaU \u0026lt;\u0026lt; 2; static const data_t kInf = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(); static const data_t kPi = arma::datum::pi; static const data_t kDefaultP0 = 1e-6; static const data_t kDefaultQ0 = 1e-6; static const data_t kDefaultR0 = 1e-2; static std::vector\u0026lt;data_t\u0026gt; kDefaultT0 = std::vector\u0026lt;data_t\u0026gt;(1, 0.0); enum SSIDWt { kSSIDNone, kSSIDMOESP, kSSIDCVA }; enum MatrixListFreeDim { kMatFreeDimNone, kMatFreeDim1, kMatFreeDim2 }; // TODO(mfbolus): for SwitchedController, may want systems to have differing // numbers of states. Use this enum as template parameter? // enum SystemListFreeDim { // kSysFreeDimNone, // kSysFreeDimX ///\u0026lt; allow state dim (x) of systems in list to be hetero // };  // place hard limits on contents of vecors/mats void Limit(std::vector\u0026lt;data_t\u0026gt;\u0026amp; x, data_t lb, data_t ub); void Limit(Vector\u0026amp; x, data_t lb, data_t ub); void Limit(Matrix\u0026amp; x, data_t lb, data_t ub); // in-place assign that errs if there are dimension mismatches: void Reassign(Vector\u0026amp; some, const Vector\u0026amp; other, const std::string\u0026amp; parenthetical = \u0026#34;Reassign\u0026#34;); void Reassign(Matrix\u0026amp; some, const Matrix\u0026amp; other, const std::string\u0026amp; parenthetical = \u0026#34;Reassign\u0026#34;); // TODO(mfbolus): this is a fudge, but for some reason, cov mats often going // numerically asymm.  void ForceSymPD(Matrix\u0026amp; X); void ForceSymMinEig(Matrix\u0026amp; X, data_t eig_min = 0); void lq(Matrix\u0026amp; L, Matrix\u0026amp; Qt, const Matrix\u0026amp; X); Matrix calcCov(const Matrix\u0026amp; A, const Matrix\u0026amp; B); inline void Limit(std::vector\u0026lt;data_t\u0026gt;\u0026amp; x, data_t lb, data_t ub) { for (data_t\u0026amp; el : x) { el = el \u0026lt; lb ? lb : el; el = el \u0026gt; ub ? ub : el; } } inline void Limit(Vector\u0026amp; x, data_t lb, data_t ub) { for (data_t\u0026amp; el : x) { el = el \u0026lt; lb ? lb : el; el = el \u0026gt; ub ? ub : el; } } inline void Limit(Matrix\u0026amp; x, data_t lb, data_t ub) { for (data_t\u0026amp; el : x) { el = el \u0026lt; lb ? lb : el; el = el \u0026gt; ub ? ub : el; } } inline void Reassign(Vector\u0026amp; some, const Vector\u0026amp; other, const std::string\u0026amp; parenthetical) { // check dimensions  if (other.n_elem != some.n_elem) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign vector of size \u0026#34; \u0026lt;\u0026lt; some.n_elem \u0026lt;\u0026lt; \u0026#34; with vector of size \u0026#34; \u0026lt;\u0026lt; other.n_elem \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; parenthetical \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; throw std::runtime_error(ss.str()); } for (size_t k = 0; k \u0026lt; some.n_elem; k++) { some[k] = other[k]; } } inline void Reassign(Matrix\u0026amp; some, const Matrix\u0026amp; other, const std::string\u0026amp; parenthetical) { // check dimensions  if ((other.n_rows != some.n_rows) || (other.n_cols != some.n_cols)) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign matrix of size \u0026#34; \u0026lt;\u0026lt; some.n_rows \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; some.n_cols \u0026lt;\u0026lt; \u0026#34; with matrix of size \u0026#34; \u0026lt;\u0026lt; other.n_rows \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; other.n_cols \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; parenthetical \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; throw std::runtime_error(ss.str()); } for (size_t k = 0; k \u0026lt; some.n_elem; k++) { some[k] = other[k]; } } } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':51,'href':'/ldsctrlest/docs/api/files/lds__ctrl_8h/','title':"ldsCtrlEst_h/lds_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_ctrl.h #  Controller. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::Controller    Detailed Description #  This file declares the type for control of a linear dynamical system (lds::Controller).\nSource code #  //===-- ldsCtrlEst_h/lds_control.h - Controller -----------------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_CTRL_H #define LDSCTRLEST_LDS_CTRL_H  // namespace #include \u0026#34;lds.h\u0026#34;// system type #include \u0026#34;lds_sys.h\u0026#34; namespace lds { template \u0026lt;typename System\u0026gt; class Controller { static_assert(std::is_base_of\u0026lt;lds::System, System\u0026gt;::value, \u0026#34;System must be derived from lds::System type.\u0026#34;); public: Controller() = default; Controller(const System\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type = 0); Controller(System\u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type = 0); const Vector\u0026amp; Control(const Vector\u0026amp; z, bool do_control = true, bool do_lock_control = false, data_t sigma_soft_start = 0, data_t sigma_u_noise = 0, bool do_reset_at_control_onset = true); const Vector\u0026amp; ControlOutputReference(const Vector\u0026amp; z, bool do_control = true, bool do_estimation = true, bool do_lock_control = false, data_t sigma_soft_start = 0, data_t sigma_u_noise = 0, bool do_reset_at_control_onset = true); // get methods:  const System\u0026amp; sys() const { return sys_; }; const Matrix\u0026amp; Kc() const { return Kc_; }; const Matrix\u0026amp; Kc_inty() const { return Kc_inty_; }; const Matrix\u0026amp; Kc_u() const { return Kc_u_; }; const Vector\u0026amp; g_design() const { return g_design_; }; const Vector\u0026amp; u_ref() const { return u_ref_; }; const Vector\u0026amp; x_ref() const { return x_ref_; }; const Vector\u0026amp; y_ref() const { return y_ref_; }; size_t control_type() const { return control_type_; }; // set methods  void set_sys(const System\u0026amp; sys) { bool does_match = sys_.n_u() == sys.n_u(); does_match = does_match \u0026amp;\u0026amp; (sys_.n_x() == sys.n_x()); does_match = does_match \u0026amp;\u0026amp; (sys_.n_y() == sys.n_y()); if (does_match) { sys_ = sys; } else { throw std::runtime_error( \u0026#34;new system argument to `set_sys` does not match dimensionality of \u0026#34; \u0026#34;existing system\u0026#34;); } }; void set_g_design(const Vector\u0026amp; g_design) { Reassign(g_design_, g_design); }; void set_u_ref(const Vector\u0026amp; u_ref) { Reassign(u_ref_, u_ref); }; void set_x_ref(const Vector\u0026amp; x_ref) { Reassign(x_ref_, x_ref); cx_ref_ = sys_.C() * x_ref_; }; // y_ref needs to be handled differently depending on output fn.  // (need to populate cx_ref_ too, which depends on output fn)  virtual void set_y_ref(const Vector\u0026amp; y_ref) { Reassign(y_ref_, y_ref); }; void set_Kc(const Matrix\u0026amp; Kc) { Reassign(Kc_, Kc); }; void set_Kc_inty(const Matrix\u0026amp; Kc_inty) { Reassign(Kc_inty_, Kc_inty); }; void set_Kc_u(const Matrix\u0026amp; Kc_u) { Reassign(Kc_u_, Kc_u); }; void set_tau_awu(data_t tau) { tau_awu_ = tau; k_awu_ = sys_.dt() / tau_awu_; }; void set_control_type(size_t control_type); void Reset() { sys_.Reset(); u_ref_.zeros(); u_ref_prev_.zeros(); int_e_.zeros(); int_e_awu_adjust_.zeros(); u_sat_.zeros(); u_saturated_ = false; t_since_control_onset_ = 0.0; }; void Print() { sys_.Print(); std::cout \u0026lt;\u0026lt; \u0026#34;g_design : \u0026#34; \u0026lt;\u0026lt; g_design_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;u_lb : \u0026#34; \u0026lt;\u0026lt; u_lb_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;u_ub : \u0026#34; \u0026lt;\u0026lt; u_ub_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; protected: System sys_; Vector u_; Vector g_design_; // reference signals  Vector u_ref_; // create no set method for this:  Vector u_ref_prev_; Vector x_ref_; Vector y_ref_; Vector cx_ref_; // Controller gains  Matrix Kc_; Matrix Kc_u_; Matrix Kc_inty_; // control after g inversion  // do not need set methods for these.  Vector du_ref_; Vector dv_ref_; Vector v_ref_; Vector dv_; Vector v_; // integral error  // do not need set method for this  Vector int_e_; Vector int_e_awu_adjust_; Vector u_sat_; bool do_control_prev_ = false; bool do_lock_control_prev_ = false; // whether the g of system has become inverted from what you think it is  // (gain_ref)  bool u_saturated_ = false; // should be safe to have references here bc nothing needs to be done  // (like reset vars) when it changes...  data_t u_lb_{}; data_t u_ub_{}; data_t tau_awu_{}; data_t k_awu_ = 0; data_t t_since_control_onset_ = 0; size_t control_type_{}; private: void CalcControl(bool do_control = true, bool do_estimation = true, bool do_lock_control = false, data_t sigma_soft_start = 0, data_t sigma_u_noise = 0, bool do_reset_at_control_onset = true); void CalcSteadyStateSetPoint(); void AntiWindup(); void InitVars(); }; // Implement the above:  template \u0026lt;typename System\u0026gt; inline Controller\u0026lt;System\u0026gt;::Controller(const System\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type) : sys_(sys), u_lb_(u_lb), u_ub_(u_ub), control_type_(control_type), tau_awu_(lds::kInf) { InitVars(); } template \u0026lt;typename System\u0026gt; inline Controller\u0026lt;System\u0026gt;::Controller(System\u0026amp;\u0026amp; sys, data_t u_lb, data_t u_ub, size_t control_type) : sys_(std::move(sys)), u_lb_(u_lb), u_ub_(u_ub), control_type_(control_type), tau_awu_(lds::kInf) { InitVars(); } template \u0026lt;typename System\u0026gt; inline void Controller\u0026lt;System\u0026gt;::set_control_type(size_t control_type) { if (control_type_ == control_type) { return; } // creating a blank slate...  control_type_ = 0; Kc_inty_.zeros(0, 0); Kc_u_.zeros(0, 0); int_e_.zeros(0, 0); int_e_awu_adjust_.zeros(0, 0); // controller was designed to minimize integral error  if (control_type \u0026amp; kControlTypeIntY) { Kc_inty_.zeros(sys_.n_u(), sys_.n_y()); int_e_.zeros(sys_.n_y()); int_e_awu_adjust_.zeros(sys_.n_u()); control_type_ = control_type_ | kControlTypeIntY; } // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (control_type \u0026amp; kControlTypeDeltaU) { Kc_u_.zeros(sys_.n_u(), sys_.n_u()); control_type_ = control_type_ | kControlTypeDeltaU; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (control_type \u0026amp; kControlTypeAdaptM) { if (sys_.do_adapt_m) // only if adapting m...  { control_type_ = control_type_ | kControlTypeAdaptM; } } } // set_control_type  template \u0026lt;typename System\u0026gt; inline const Vector\u0026amp; Controller\u0026lt;System\u0026gt;::Control( const Vector\u0026amp; z, bool do_control, bool do_lock_control, data_t sigma_soft_start, data_t sigma_u_noise, bool do_reset_at_control_onset) { // update state estimates, given latest measurement  sys_.Filter(u_, z); bool do_estimation = true; // always have estimator on in this case  // calculate control signal  CalcControl(do_control, do_estimation, do_lock_control, sigma_soft_start, sigma_u_noise, do_reset_at_control_onset); return u_; } template \u0026lt;typename System\u0026gt; inline const Vector\u0026amp; Controller\u0026lt;System\u0026gt;::ControlOutputReference( const Vector\u0026amp; z, bool do_control, bool do_estimation, bool do_lock_control, data_t sigma_soft_start, data_t sigma_u_noise, bool do_reset_at_control_onset) { // update state estimates, given latest measurement  if (do_estimation) { sys_.Filter(u_, z); } else { sys_.f(u_); } // calculate the set point  // solves for u_ref and x_ref when output is at y_ref at steady state.  if (do_control) { CalcSteadyStateSetPoint(); } // calculate control signal  CalcControl(do_control, do_estimation, do_lock_control, sigma_soft_start, sigma_u_noise, do_reset_at_control_onset); return u_; } template \u0026lt;typename System\u0026gt; inline void Controller\u0026lt;System\u0026gt;::CalcControl(bool do_control, bool do_estimation, bool do_lock_control, data_t sigma_soft_start, data_t sigma_u_noise, bool do_reset_at_control_onset) { if (do_control \u0026amp;\u0026amp; do_estimation) { if (!do_control_prev_) { if (do_reset_at_control_onset) { Reset(); } t_since_control_onset_ = 0.0; } else { t_since_control_onset_ += sys_.dt(); } // enforce softstart on control vars.  if (sigma_soft_start \u0026gt; 0) { // half-Gaussian soft-start scaling factor  data_t soft_start_sf = 1 - exp(-pow(t_since_control_onset_, 2) / (2 * pow(sigma_soft_start, 2))); u_ref_ *= soft_start_sf; // TODO(mfbolus): May be appropriate to soft-start x_ref, y_ref too  // x_ref_ *= soft_start_sf;  // cx_ref_ *= soft_start_sf;  // y_ref_ *= soft_start_sf;  } if (!do_lock_control) { du_ref_ = u_ref_ - u_ref_prev_; // first do u -\u0026gt; v change of vars. (v = g.*u)  // e.g., convert into physical units (e.g., v[=] mW/mm2 rather than driver  // control voltage u[=]V)  v_ref_ = g_design_ % u_ref_; dv_ref_ = g_design_ % du_ref_; // Given FB, calc. the change in control  if (control_type_ \u0026amp; kControlTypeDeltaU) { // if control designed to minimize not u but deltaU (i.e. state aug with  // u):  dv_ = dv_ref_; // nominally-optimal.  dv_ -= Kc_ * (sys_.x() - x_ref_); // instantaneous state error  dv_ -= Kc_u_ * (v_ - v_ref_); // penalty on amp u (rel to ref)  if (control_type_ \u0026amp; kControlTypeIntY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if(!uSaturated)  int_e_ += (sys_.cx() - cx_ref_) * sys_.dt(); // integrated error  dv_ -= Kc_inty_ * int_e_; // control for integrated error  } // update the control  v_ += dv_; } else { v_ = v_ref_; // nominally-optimal.  v_ -= Kc_ * (sys_.x() - x_ref_); // instantaneous state error  if (control_type_ \u0026amp; kControlTypeIntY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if (!uSaturated)  int_e_ += (sys_.cx() - cx_ref_) * sys_.dt(); // integrated error  v_ -= Kc_inty_ * int_e_; // control for integrated error  } } // convert back to control voltage u[=]V  u_ = v_ / sys_.g(); } // else do nothing until lock is low  // It may be desireable to make inputs more variable.  if (sigma_u_noise \u0026gt; 0.0) { u_ += sigma_u_noise * Vector(sys_.n_u(), fill::randn); }; } else { // if not control  // feed through u_ref in open loop  u_ = u_ref_ % g_design_ / sys_.g(); u_ref_.zeros(); int_e_.zeros(); int_e_awu_adjust_.zeros(); u_sat_.zeros(); } // ends do_control  // enforce box constraints (and antiwindup)  AntiWindup(); do_control_prev_ = do_control; do_lock_control_prev_ = do_lock_control; } // CalcControl  template \u0026lt;typename System\u0026gt; inline void Controller\u0026lt;System\u0026gt;::CalcSteadyStateSetPoint() { // Linearly-constrained least squares (ls).  //  // _reference:  // Boyd \u0026amp; Vandenberghe (2018) Introduction to Applied Linear Algebra  //  Matrix a_ls = join_horiz(sys_.C(), Matrix(sys_.n_y(), sys_.n_u(), fill::zeros)); Vector b_ls = cx_ref_; Matrix c_ls = join_horiz(sys_.A() - Matrix(sys_.n_x(), sys_.n_x(), fill::eye), sys_.B() * arma::diagmat(sys_.g())); Vector d_ls = -sys_.m0(); if (control_type_ \u0026amp; kControlTypeAdaptM) { d_ls = -sys_.m(); // adapt setpoint calc with disturbance?  } Matrix a_ls_t = a_ls.t(); // TODO(mfbolus): not sure why but causes seg  // fault if I do not do this.  Matrix phi_ls = join_vert(join_horiz(2 * a_ls_t * a_ls, c_ls.t()), join_horiz(c_ls, Matrix(sys_.n_x(), sys_.n_x(), fill::zeros))); // TODO(mfbolus): should be actual inverse, rather than pseudo-inverse:  Matrix inv_phi = pinv(phi_ls); Vector xulam = inv_phi * join_vert(2 * a_ls_t * b_ls, d_ls); x_ref_ = xulam.subvec(0, sys_.n_x() - 1); u_ref_ = xulam.subvec(sys_.n_x(), sys_.n_x() + sys_.n_u() - 1); cx_ref_ = sys_.C() * x_ref_; } // CalcSteadyStateSetPoint  template \u0026lt;typename System\u0026gt; void Controller\u0026lt;System\u0026gt;::AntiWindup() { u_saturated_ = false; u_sat_ = u_; // limit u and flag whether saturated  for (size_t k = 0; k \u0026lt; u_.n_elem; k++) { if (u_[k] \u0026lt; u_lb_) { u_sat_[k] = u_lb_; u_saturated_ = true; } if (u_[k] \u0026gt; u_ub_) { u_sat_[k] = u_ub_; u_saturated_ = true; } } if ((control_type_ \u0026amp; kControlTypeIntY) \u0026amp;\u0026amp; (tau_awu_ \u0026lt; lds::kInf)) { // one-step back-calculation (calculate intE for u=u_sat)  // (Astroem, Rundqwist 1989 warn against using this...)  // int_e_awu_adjust_ =  // solve(Kc_inty_, (u_ - u_sat_)); // pinv(Kc_inty) * (u-uSat);  // gradual: see Astroem, Rundqwist 1989  // this is a fudge for doing MIMO gradual  // n.b., went ahead and multiplied 1/T by dt so don\u0026#39;t have to do that here.  int_e_awu_adjust_ = k_awu_ * (sign(Kc_inty_).t() / sys_.n_u()) * (u_ - u_sat_); // int_e_awu_adjust_ = k_awu_ * (u_-u_sat_);  int_e_ += int_e_awu_adjust_; } // set u to saturated version  u_ = u_sat_; } template \u0026lt;typename System\u0026gt; void Controller\u0026lt;System\u0026gt;::InitVars() { // initialize to default values  u_ref_ = Vector(sys_.n_u(), fill::zeros); u_ref_prev_ = Vector(sys_.n_u(), fill::zeros); x_ref_ = Vector(sys_.n_x(), fill::zeros); y_ref_ = Vector(sys_.n_y(), fill::zeros); u_ = Vector(sys_.n_u(), fill::zeros); u_sat_ = Vector(sys_.n_u(), fill::zeros); // Might not need all these, so zero elements until later.  Kc_ = Matrix(sys_.n_u(), sys_.n_x(), fill::zeros); Kc_u_ = Matrix(0, 0, fill::zeros); Kc_inty_ = Matrix(0, 0, fill::zeros); g_design_ = sys_.g(); // by default, same as model  dv_ = Vector(sys_.n_u(), fill::zeros); v_ = Vector(sys_.n_u(), fill::zeros); du_ref_ = Vector(sys_.n_u(), fill::zeros); dv_ref_ = Vector(sys_.n_u(), fill::zeros); v_ref_ = Vector(sys_.n_u(), fill::zeros); int_e_ = Vector(0, fill::zeros); int_e_awu_adjust_ = Vector(0, fill::zeros); set_control_type(control_type_); } } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':52,'href':'/ldsctrlest/docs/api/files/lds__fit_8h/','title':"ldsCtrlEst_h/lds_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_fit.h #  LDS base fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::Fit LDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a linear dynamical system. It is expounded upon by variants with Gaussian and Poisson observation assumptions for fitting.\nSource code #  //===-- ldsCtrlEst_h/lds_fit.h - Fit Type for LDS ---------------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDS_FIT_HPP #define LDS_FIT_HPP  // namespace #include \u0026#34;lds.h\u0026#34;#include \u0026#34;lds_uniform_mats.h\u0026#34; namespace lds { class Fit { public: Fit() = default; Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt); // get methods  size_t n_u() const { return n_u_; }; size_t n_x() const { return n_x_; }; size_t n_y() const { return n_y_; }; data_t dt() const { return dt_; }; const Matrix\u0026amp; A() const { return A_; }; const Matrix\u0026amp; B() const { return B_; }; const Vector\u0026amp; g() const { return g_; }; const Vector\u0026amp; m() const { return m_; }; const Matrix\u0026amp; Q() const { return Q_; }; const Vector\u0026amp; x0() const { return x0_; }; const Matrix\u0026amp; P0() const { return P0_; }; const Matrix\u0026amp; C() const { return C_; }; const Vector\u0026amp; d() const { return d_; }; // gets measurement noise  virtual const Matrix\u0026amp; R() const = 0; // set methods (e.g., seeding initial fit values)  void set_A(const Matrix\u0026amp; A) { Reassign(A_, A); }; void set_B(const Matrix\u0026amp; B) { Reassign(B_, B); }; void set_g(const Vector\u0026amp; g) { Reassign(g_, g); }; void set_m(const Vector\u0026amp; m) { Reassign(m_, m); }; void set_Q(const Matrix\u0026amp; Q) { Reassign(Q_, Q); ForceSymPD(Q_); }; virtual void set_R(const Matrix\u0026amp; R) = 0; void set_x0(const Vector\u0026amp; x0) { Reassign(x0_, x0); }; void set_P0(const Matrix\u0026amp; P0) { Reassign(P0_, P0); ForceSymPD(P0_); }; void set_C(const Matrix\u0026amp; C) { Reassign(C_, C); }; void set_d(const Vector\u0026amp; d) { Reassign(d_, d); }; View f(Matrix\u0026amp; x, const Matrix\u0026amp; u, size_t t) { x.col(t) = A_ * x.col(t - 1) + B_ * (g_ % u.col(t - 1)) + m_; return x.col(t); }; View f(Matrix\u0026amp; x_pre, const Matrix\u0026amp; x_post, const Matrix\u0026amp; u, size_t t) { x_pre.col(t) = A_ * x_post.col(t - 1) + B_ * (g_ % u.col(t - 1)) + m_; return x_pre.col(t); }; virtual View h(Matrix\u0026amp; y, const Matrix\u0026amp; x, size_t t) = 0; protected: data_t dt_{}; // Dynamics  Matrix A_; Matrix B_; Vector g_; Vector m_; Matrix Q_; // Output  Matrix C_; Vector d_; Matrix R_; // initial conditions  Vector x0_; Matrix P0_; size_t n_u_{}; size_t n_x_{}; size_t n_y_{}; }; } // namespace lds #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':53,'href':'/ldsctrlest/docs/api/files/lds__fit__em_8h/','title':"ldsCtrlEst_h/lds_fit_em.h",'section':"Files",'content':"ldsCtrlEst_h/lds_fit_em.h #  subspace identification More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::EMax    Detailed Description #  This file declares the type for fitting a linear dynamical system by expectation-maximization (lds::EMax).\nSource code #  //===-- ldsCtrlEst_h/lds_fit_em.h - EM Fit ----------------------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_EMAX_H #define LDSCTRLEST_LDS_EMAX_H  #include \u0026#34;lds_fit.h\u0026#34; namespace lds { template \u0026lt;typename Fit\u0026gt; class EMax { static_assert(std::is_base_of\u0026lt;lds::Fit, Fit\u0026gt;::value, \u0026#34;Fit must be derived from lds::Fit type.\u0026#34;); public: EMax() = default; EMax(size_t n_x, data_t dt, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train); EMax(const Fit\u0026amp; fit0, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train); const Fit\u0026amp; Run(bool calc_dynamics = true, bool calc_Q = true, bool calc_init = true, bool calc_output = true, bool calc_measurement = true, size_t max_iter = 100, data_t tol = 1e-2); std::tuple\u0026lt;UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026gt; ReturnData() { std::cout \u0026lt;\u0026lt; \u0026#34;in returndata\\n\u0026#34;; // auto tuple = std::make_tuple(std::move(u_), std::move(z_));  auto tuple = std::make_tuple(u_, z_); std::cout \u0026lt;\u0026lt; \u0026#34;made tuple\\n\u0026#34;; u_ = UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;(); z_ = UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;(); std::cout \u0026lt;\u0026lt; \u0026#34;constructed default replacements\\n\u0026#34;; return tuple; } const std::vector\u0026lt;Matrix\u0026gt;\u0026amp; x() const { return x_; }; const std::vector\u0026lt;Matrix\u0026gt;\u0026amp; y() const { return y_; }; const Matrix\u0026amp; sum_E_x_t_x_t() const { return sum_E_x_t_x_t_; }; const Matrix\u0026amp; sum_E_xu_tm1_xu_tm1() const { return sum_E_xu_tm1_xu_tm1_; }; const Matrix\u0026amp; sum_E_xu_t_xu_tm1() const { return sum_E_xu_t_xu_tm1_; }; size_t n_t_tot() { return n_t_tot_; } const Vector\u0026amp; theta() const { return theta_; }; protected: void Expectation(bool force_common_initial = false); void Maximization(bool calc_dynamics = true, bool calc_Q = true, bool calc_init = false, bool calc_output = false, bool calc_measurement = false); void MaximizeDynamics(); void MaximizeQ(); void MaximizeInitial(); virtual void MaximizeOutput() = 0; virtual void MaximizeMeasurement() = 0; void Smooth(bool force_common_initial); virtual void RecurseKe(Matrix\u0026amp; Ke, Cube\u0026amp; P_pre, Cube\u0026amp; P_post, size_t t) = 0; void Reset(); void InitVars(); Vector UpdateTheta(); // input/output training data  UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; u_; UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; z_; std::vector\u0026lt;Matrix\u0026gt; x_; std::vector\u0026lt;Cube\u0026gt; P_; std::vector\u0026lt;Cube\u0026gt; P_t_tm1_; std::vector\u0026lt;Matrix\u0026gt; y_; Matrix diag_y_; // expectations calculated in E-step  Matrix sum_E_x_t_x_t_; Matrix sum_E_xu_tm1_xu_tm1_; Matrix sum_E_xu_t_xu_tm1_; Fit fit_; Vector theta_; data_t dt_{}; size_t n_u_{}; size_t n_x_{}; size_t n_y_{}; size_t n_trials_{}; std::vector\u0026lt;size_t\u0026gt; n_t_; size_t n_t_tot_{}; }; template \u0026lt;typename Fit\u0026gt; EMax\u0026lt;Fit\u0026gt;::EMax(size_t n_x, data_t dt, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train) { n_u_ = u_train.at(0).n_rows; n_y_ = z_train.at(0).n_rows; fit_ = Fit(n_u_, n_x, n_y_, dt); u_ = std::move(u_train); z_ = std::move(z_train); InitVars(); } template \u0026lt;typename Fit\u0026gt; EMax\u0026lt;Fit\u0026gt;::EMax(const Fit\u0026amp; fit0, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train) { // make sure fit dims match I/O data  if (fit0.n_u() != u_train.at(0).n_rows) { throw std::runtime_error( \u0026#34;Initial fit and input training data have inconsistent dimensions\u0026#34;); } if (fit0.n_y() != z_train.at(0).n_rows) { throw std::runtime_error( \u0026#34;Initial fit and output training data have inconsistent dimensions\u0026#34;); } fit_ = fit0; u_ = std::move(u_train); z_ = std::move(z_train); InitVars(); } template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::InitVars() { // check input/output data dimensions are consistent  if (z_.size() != u_.size()) { throw std::runtime_error( \u0026#34;I/O training data have different number of trials.\u0026#34;); } n_trials_ = u_.size(); n_t_tot_ = 0; n_t_ = std::vector\u0026lt;size_t\u0026gt;(n_trials_); for (size_t trial = 0; trial \u0026lt; n_trials_; trial++) { if (z_.at(trial).n_cols != u_.at(trial).n_cols) { throw std::runtime_error( \u0026#34;I/O training data have different number of time steps.\u0026#34;); } n_t_[trial] = u_.at(trial).n_cols; n_t_tot_ += n_t_[trial]; } n_u_ = fit_.n_u(); n_x_ = fit_.n_x(); n_y_ = fit_.n_y(); dt_ = fit_.dt(); x_ = std::vector\u0026lt;Matrix\u0026gt;(n_trials_); P_ = std::vector\u0026lt;Cube\u0026gt;(n_trials_); P_t_tm1_ = std::vector\u0026lt;Cube\u0026gt;(n_trials_); y_ = std::vector\u0026lt;Matrix\u0026gt;(n_trials_); for (size_t trial = 0; trial \u0026lt; n_trials_; trial++) { x_[trial] = Matrix(n_x_, n_t_[trial], fill::zeros); P_[trial] = Cube(n_x_, n_x_, n_t_[trial], fill::zeros); P_t_tm1_[trial] = Cube(n_x_, n_x_, n_t_[trial], fill::zeros); y_[trial] = Matrix(n_y_, n_t_[trial], fill::zeros); } diag_y_ = Matrix(n_y_, n_y_, fill::zeros); // covariances in expectation step  sum_E_x_t_x_t_ = Matrix(n_x_, n_x_, fill::zeros); sum_E_xu_tm1_xu_tm1_ = Matrix(n_x_ + n_u_, n_x_ + n_u_, fill::zeros); sum_E_xu_t_xu_tm1_ = Matrix(n_x_ + n_u_, n_x_ + n_u_, fill::zeros); } template \u0026lt;typename Fit\u0026gt; const Fit\u0026amp; EMax\u0026lt;Fit\u0026gt;::Run(bool calc_dynamics, bool calc_Q, bool calc_init, bool calc_output, bool calc_measurement, size_t max_iter, data_t tol) { Reset(); // to initial conditions  size_t n_params = 3 * n_x_ * n_x_ + n_x_ * n_u_ + n_x_ + n_y_ * n_x_ + n_y_ * n_y_; Vector theta(n_params); Vector theta_new(n_params); data_t max_dtheta = 1; // if solving for initial conditions, allow them be varied.  // otherwise, freeze at provided values.  bool force_common_initial = !calc_init; // go until parameter convergence  for (size_t l = 0; l \u0026lt; max_iter; l++) { theta_ = UpdateTheta(); std::cout \u0026lt;\u0026lt; \u0026#34;Iteration \u0026#34; \u0026lt;\u0026lt; l + 1 \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; max_iter \u0026lt;\u0026lt; \u0026#34; ...\\n\u0026#34;; Expectation(force_common_initial); Maximization(calc_dynamics, calc_Q, calc_init, calc_output, calc_measurement); // check convergence  theta_new = UpdateTheta(); Vector dtheta = abs(theta_new - theta_) / abs(theta_); // some parameters could be zero...  arma::uvec ubi_finite = find_finite(dtheta); max_dtheta = max(dtheta.elem(ubi_finite)); std::cout \u0026lt;\u0026lt; \u0026#34;max dtheta: \u0026#34; \u0026lt;\u0026lt; max_dtheta \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; if (max_dtheta \u0026lt; tol) { std::cout \u0026lt;\u0026lt; \u0026#34;Converged.\\n\u0026#34;; break; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return fit_; } template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::Smooth(bool force_common_initial) { Matrix k_e(n_x_, n_y_); // estimator gain  Cube k_backfilt; // back-filtering gains  // TODO(mfbolus): this loop could be made parallel  for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { Matrix x_pre(n_x_, n_t_[trial], fill::zeros); Cube p_pre(n_x_, n_x_, n_t_[trial], fill::zeros); Matrix x_post(n_x_, n_t_[trial], fill::zeros); Cube p_post(n_x_, n_x_, n_t_[trial], fill::zeros); if (force_common_initial) // forces all trials to have same initial  // conditions.  { x_[trial].col(0) = fit_.x0(); P_[trial].slice(0) = fit_.P0(); } y_[trial].col(0) = fit_.C() * x_[trial].col(0) + fit_.d(); // This *should not* be necessary but make sure P is symmetric.  ForceSymPD(P_[trial].slice(0)); x_pre.col(0) = x_[trial].col(0); p_pre.slice(0) = P_[trial].slice(0); x_post.col(0) = x_[trial].col(0); p_post.slice(0) = P_[trial].slice(0); // filter  for (size_t t = 1; t \u0026lt; n_t_[trial]; t++) { // predict  fit_.f(x_pre, x_post, u_.at(trial), t); fit_.h(y_[trial], x_pre, t); diag_y_.diag() = y_[trial].col(t); // TODO(mfbolus): change if parallel  // update --\u0026gt; posterior estimation  RecurseKe(k_e, p_pre, p_post, t); x_post.col(t) = x_pre.col(t) + k_e * (z_.at(trial).col(t) - y_[trial].col(t)); y_[trial].col(t) = fit_.C() * x_post.col(t) + fit_.d(); } ForceSymPD(P_[trial].slice(n_t_[trial] - 1)); // backfilter -\u0026gt; Smoothed estimate  // Reference:  // Shumway et Stoffer (1982)  k_backfilt = Cube(n_x_, n_x_, n_t_[trial], fill::zeros); x_[trial].col(n_t_[trial] - 1) = x_post.col(n_t_[trial] - 1); P_[trial].slice(n_t_[trial] - 1) = p_post.slice(n_t_[trial] - 1); for (size_t t = (n_t_[trial] - 1); t \u0026gt; 0; t--) { k_backfilt.slice(t - 1) = p_post.slice(t - 1) * fit_.A().t() * inv_sympd(p_pre.slice(t)); x_[trial].col(t - 1) = x_post.col(t - 1) + k_backfilt.slice(t - 1) * (x_[trial].col(t) - x_pre.col(t)); P_[trial].slice(t - 1) = p_post.slice(t - 1) + k_backfilt.slice(t - 1) * (P_[trial].slice(t) - p_pre.slice(t)) * k_backfilt.slice(t - 1).t(); } // do the same for P_t_tm1  Matrix id(n_x_, n_x_, fill::eye); P_t_tm1_[trial].slice(n_t_[trial] - 1) = (id - k_e * fit_.C()) * fit_.A() * p_post.slice(n_t_[trial] - 2); for (size_t t = (n_t_[trial] - 1); t \u0026gt; 1; t--) { P_t_tm1_[trial].slice(t - 1) = p_post.slice(t - 1) * k_backfilt.slice(t - 2).t() + k_backfilt.slice(t - 1) * (P_t_tm1_[trial].slice(t) - fit_.A() * p_post.slice(t - 1)) * k_backfilt.slice(t - 2).t(); } // finally, get smoothed estimate of output  for (size_t t = 0; t \u0026lt; n_t_[trial]; t++) { fit_.h(y_[trial], x_[trial], t); } // samps loop  } // trial loop } // Smooth  // template \u0026lt;typename Fit\u0026gt; // void EMax\u0026lt;Fit\u0026gt;::RecurseKe(Matrix\u0026amp; Ke, Cube\u0026amp; P_pre, Cube\u0026amp; P_post, size_t t) { // // predict covar // P_pre.slice(t) = fit_.A() * P_post.slice(t - 1) * fit_.A().t() + fit_.Q();  // // update Ke // Ke = P_pre.slice(t) * fit_.C().t() * // inv_sympd(fit_.C() * P_pre.slice(t) * fit_.C().t() + fit_.R());  // // update cov // // Reference: Ghahramani et Hinton (1996) // P_post.slice(t) = P_pre.slice(t) - Ke * fit_.C() * P_pre.slice(t);  // // // n.b. for poisson : // // P_pre.slice(t) = fit_.A() * P_post.slice(t - 1) * fit_.A().t() + // fit_.Q(); // // // update cov // // P_post.slice(t) = pinv(pinv(P_pre.slice(t)) + fit_.C().t() * diag_y_ * // // fit_.C()); // // // update Ke // // Ke = P_post.slice(t) * fit_.C(); // }  template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::Expectation(bool force_common_initial) { // calculate the mean/cov of state needed for maximizing E[pr(z|theta)]  Smooth(force_common_initial); // now get the various forms of sum(E[xx\u0026#39;]) needed  // n.b. Going to start at t=1 rather than 0 bc most max terms need that.  // so really \u0026#34;n_t_tot_\u0026#34; is (n_t_tot_-1)  n_t_tot_ = 0; sum_E_x_t_x_t_ = Matrix(n_x_, n_x_, fill::zeros); sum_E_xu_tm1_xu_tm1_ = Matrix(n_x_ + n_u_, n_x_ + n_u_, fill::zeros); sum_E_xu_t_xu_tm1_ = Matrix(n_x_ + n_u_, n_x_ + n_u_, fill::zeros); Vector xu_tm1(n_x_ + n_u_, fill::zeros); Vector xu_t(n_x_ + n_u_, fill::zeros); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { for (size_t t = 1; t \u0026lt; n_t_[trial]; t++) { // ------------ sum_E_x_t_x_t ------------  sum_E_x_t_x_t_ += x_[trial].col(t) * x_[trial].col(t).t(); sum_E_x_t_x_t_ += P_[trial].slice(t); // ------------ sum_E_xu_tm1_xu_tm1 ------------  xu_tm1 = join_vert(x_[trial].col(t - 1), u_.at(trial).col(t - 1)); sum_E_xu_tm1_xu_tm1_ += xu_tm1 * xu_tm1.t(); sum_E_xu_tm1_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ - 1) += P_[trial].slice(t - 1); // ------------ sum_E_xu_t_xu_tm1 ------------  xu_t = join_vert(x_[trial].col(t), u_.at(trial).col(t)); sum_E_xu_t_xu_tm1_ += xu_t * xu_tm1.t(); sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ - 1) += P_t_tm1_[trial].slice(t); n_t_tot_ += 1; } // time  } // trial } // Expectation  template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::Maximization(bool calc_dynamics, bool calc_Q, bool calc_init, bool calc_output, bool calc_measurement) { if (calc_output) { MaximizeOutput(); } if (calc_measurement) { MaximizeMeasurement(); } if (calc_dynamics) { MaximizeDynamics(); } if (calc_Q) { MaximizeQ(); } if (calc_init) { MaximizeInitial(); } } // Maximization  template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::MaximizeDynamics() { // Shumway, Stoffer (1982); Ghahgramani, Hinton (1996)  Matrix ab = sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1) * inv_sympd(sum_E_xu_tm1_xu_tm1_); fit_.set_A(ab.submat(0, 0, n_x_ - 1, n_x_ - 1)); fit_.set_B(ab.submat(0, n_x_, n_x_ - 1, n_x_ + n_u_ - 1)); std::cout \u0026lt;\u0026lt; \u0026#34;A_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.A()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;B_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.B()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::MaximizeQ() { // // Shumway, Stoffer (1982); Ghahgramani, Hinton (1996)  // View sum_e_x_t_xu_tm1 =  // sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1);  // Matrix q = sum_E_x_t_x_t_ - sum_e_x_t_xu_tm1 *  // inv_sympd(sum_E_xu_tm1_xu_tm1_) *  // sum_e_x_t_xu_tm1.t();  // q /= n_t_tot_;  // this way is same as above iff dynamics were just updated:  // View sum_e_x_t_xu_tm1 =  // sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ + n_u_ - 1);  // Matrix ab = arma::join_horiz(fit_.A(), fit_.B());  // Matrix q = sum_E_x_t_x_t_ - ab * sum_e_x_t_xu_tm1.t();  // q /= n_t_tot_;  // From scratch method:  // Q is covariance of the error between state and dynamics-predicted state  // (aka process noise)  // Q* = E[(x_t - Ax_{t-1} - Bu_{t-1})*(x_t - Ax_{t-1} - Bu_{t-1})\u0026#39;]  // t-1 terms:  View sum_e_x_tm1_x_tm1 = sum_E_xu_tm1_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ - 1); View sum_e_u_tm1_u_tm1 = sum_E_xu_tm1_xu_tm1_.submat(n_x_, n_x_, n_x_ + n_u_ - 1, n_x_ + n_u_ - 1); View sum_e_x_tm1_u_tm1 = sum_E_xu_tm1_xu_tm1_.submat(0, n_x_, n_x_ - 1, n_x_ + n_u_ - 1); // t, t-1 terms:  View sum_e_x_t_x_tm1 = sum_E_xu_t_xu_tm1_.submat(0, 0, n_x_ - 1, n_x_ - 1); View sum_e_x_t_u_tm1 = sum_E_xu_t_xu_tm1_.submat(0, n_x_, n_x_ - 1, n_x_ + n_u_ - 1); Matrix q = sum_E_x_t_x_t_; q += fit_.A() * sum_e_x_tm1_x_tm1 * fit_.A().t(); q -= sum_e_x_t_x_tm1 * fit_.A().t(); q -= fit_.A() * sum_e_x_t_x_tm1.t(); // input-related terms:  q += fit_.B() * sum_e_u_tm1_u_tm1 * fit_.B().t(); q -= sum_e_x_t_u_tm1 * fit_.B().t(); q -= fit_.B() * sum_e_x_t_u_tm1.t(); q += fit_.A() * sum_e_x_tm1_u_tm1 * fit_.B().t(); q += fit_.B() * sum_e_x_tm1_u_tm1.t() * fit_.A().t(); q /= n_t_tot_; fit_.set_Q(q); std::cout \u0026lt;\u0026lt; \u0026#34;Q_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.Q()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // std::cout \u0026lt;\u0026lt; \u0026#34;Q_new: \\n\u0026#34; \u0026lt;\u0026lt; fit_.Q() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::MaximizeInitial() { Vector x0 = fit_.x0(); x0.zeros(); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { x0 += x_[trial].col(0); } x0 /= z_.size(); std::cout \u0026lt;\u0026lt; \u0026#34;x0_new[0]: \u0026#34; \u0026lt;\u0026lt; x0[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // always recalc P0 even if the initial state is fixed (at zero, for  // example)  Matrix e_var(n_x_, n_x_, fill::zeros); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { e_var += (x_[trial].col(0) - x0) * (x_[trial].col(0) - x0).t(); } e_var /= z_.size(); // go ahead and subtract x0*x0\u0026#39; so don\u0026#39;t have to below.  e_var -= x0 * x0.t(); // To get P0, going to get initial P_ per trial and average.  // (which might be wrong, but need a single number)  Matrix p0 = fit_.P0(); p0.zeros(); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { p0 += (x_[trial].col(0) * x_[trial].col(0).t()) + P_[trial].slice(0) + e_var; } p0 /= z_.size(); fit_.set_P0(p0); std::cout \u0026lt;\u0026lt; \u0026#34;P0_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.P0()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::MaximizeOutput() { // solve for C+d:  Matrix sum_zx(n_y_, n_x_ + 1, fill::zeros); Vector x1(n_x_ + 1, fill::zeros); x1[n_x_] = 1.0; // augment with one to solve for bias  Matrix sum_e_x1_x1(n_x_ + 1, n_x_ + 1, fill::zeros); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { for (size_t t = 1; t \u0026lt; n_t_[trial]; t++) { x1.subvec(0, n_x_ - 1) = x_[trial].col(t); sum_zx += z_.at(trial).col(t) * x1.t(); sum_e_x1_x1 += x1 * x1.t(); sum_e_x1_x1.submat(0, 0, n_x_ - 1, n_x_ - 1) += P_[trial].slice(t); } } Matrix cd = sum_zx * inv_sympd(sum_e_x1_x1); fit_.set_C(cd.submat(0, 0, n_y_ - 1, n_x_ - 1)); fit_.set_d(vectorise(cd.submat(0, n_x_, n_y_ - 1, n_x_))); std::cout \u0026lt;\u0026lt; \u0026#34;C_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.C()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;d_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.d()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::MaximizeMeasurement() { // Solve for measurement noise covar  size_t n_t_tot = 0; // Ghahgramani, Hinton 1996:  Matrix sum_zz(n_y_, n_y_, fill::zeros); Matrix sum_yz(n_y_, n_y_, fill::zeros); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { for (size_t t = 1; t \u0026lt; n_t_[trial]; t++) { sum_zz += z_.at(trial).col(t) * z_.at(trial).col(t).t(); // Use Cnew:  sum_yz += (fit_.C() * x_[trial].col(t) + fit_.d()) * z_.at(trial).col(t).t(); n_t_tot += 1; } } fit_.set_R((sum_zz - sum_yz) / n_t_tot); std::cout \u0026lt;\u0026lt; \u0026#34;R_new[0]: \u0026#34; \u0026lt;\u0026lt; fit_.R()[0] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } template \u0026lt;typename Fit\u0026gt; void EMax\u0026lt;Fit\u0026gt;::Reset() { // reset to initial conditions  for (size_t trial = 0; trial \u0026lt; n_trials_; trial++) { x_[trial].col(0) = fit_.x0(); P_[trial].slice(0) = fit_.P0(); y_[trial].col(0) = fit_.C() * x_[trial].col(0) + fit_.d(); } } template \u0026lt;typename Fit\u0026gt; Vector EMax\u0026lt;Fit\u0026gt;::UpdateTheta() { // TODO(mfbolus): This should include n_y_ more params for d.  size_t n_params = 3 * n_x_ * n_x_ + n_x_ * n_u_ + n_x_ + n_y_ * n_x_ + n_y_; if (fit_.R().n_elem \u0026gt; 0) { n_params += n_y_ * n_y_; } Vector theta(n_params); size_t idx_start = 0; theta.subvec(idx_start, idx_start + n_x_ * n_x_ - 1) = vectorise(fit_.A()); idx_start += n_x_ * n_x_; theta.subvec(idx_start, idx_start + n_x_ * n_u_ - 1) = vectorise(fit_.B()); idx_start += n_x_ * n_u_; theta.subvec(idx_start, idx_start + n_x_ * n_x_ - 1) = vectorise(fit_.Q()); idx_start += n_x_ * n_x_; theta.subvec(idx_start, idx_start + n_x_ - 1) = vectorise(fit_.x0()); idx_start += n_x_; theta.subvec(idx_start, idx_start + n_x_ * n_x_ - 1) = vectorise(fit_.P0()); idx_start += n_x_ * n_x_; theta.subvec(idx_start, idx_start + n_y_ * n_x_ - 1) = vectorise(fit_.C()); idx_start += n_y_ * n_x_; theta.subvec(idx_start, idx_start + n_y_ - 1) = vectorise(fit_.d()); idx_start += n_y_; if (fit_.R().n_elem \u0026gt; 0) { theta.subvec(idx_start, idx_start + n_y_ * n_y_ - 1) = vectorise(fit_.R()); } return theta; } } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':54,'href':'/ldsctrlest/docs/api/files/lds__fit__ssid_8h/','title':"ldsCtrlEst_h/lds_fit_ssid.h",'section':"Files",'content':"ldsCtrlEst_h/lds_fit_ssid.h #  subspace identification More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::SSID    Detailed Description #  This file declares and partially defines a template type by which LDS models are fit by a subspace identification (SSID) algorithm ([lds::SSID](/ldsctrlest/docs/api/classes/classlds_1_1_s_s_i_d/)\u0026lt;Fit\u0026gt;).\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer.\nSource code #  //===-- ldsCtrlEst_h/lds_fit_ssid.h - SSID Fit ------------------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_FIT_SSID_H #define LDSCTRLEST_LDS_FIT_SSID_H  #include \u0026#34;lds_fit.h\u0026#34; namespace lds { template \u0026lt;typename Fit\u0026gt; class SSID { static_assert(std::is_base_of\u0026lt;lds::Fit, Fit\u0026gt;::value, \u0026#34;Fit must be derived from lds::Fit type.\u0026#34;); public: SSID() = default; SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train, const Vector\u0026amp; d = Vector(1).fill(-kInf)); std::tuple\u0026lt;Fit, Vector\u0026gt; Run(SSIDWt ssid_wt); std::tuple\u0026lt;UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026gt; ReturnData() { auto tuple = std::make_tuple(std::move(u_), std::move(z_)); u_ = UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;(); z_ = UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;(); return tuple; } protected: void CalcD(data_t t_silence = 0.1, data_t thresh_silence = 0.001); void CreateHankelDataMat(); virtual void DecomposeData(); void CalcSVD(SSIDWt wt); void Solve(data_t wt_dc); void RecomputeExtObs(); // input/output training data  UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; u_; UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt; z_; Matrix D_; Fit fit_; Matrix g_dc_; data_t dt_{}; size_t n_u_{}; size_t n_x_{}; size_t n_y_{}; size_t n_h_{}; size_t n_trials_{}; std::vector\u0026lt;size_t\u0026gt; n_t_; size_t n_t_tot_{}; Matrix L_; Vector s_; Matrix ext_obs_t_; }; template \u0026lt;typename Fit\u0026gt; SSID\u0026lt;Fit\u0026gt;::SSID(size_t n_x, size_t n_h, data_t dt, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; u_train, UniformMatrixList\u0026lt;kMatFreeDim2\u0026gt;\u0026amp;\u0026amp; z_train, const Vector\u0026amp; d) { // check input/output data dimensions are consistent  if (z_train.size() != u_train.size()) { throw std::runtime_error( \u0026#34;I/O training data have different number of trials.\u0026#34;); } n_trials_ = u_train.size(); n_t_tot_ = 0; n_t_ = std::vector\u0026lt;size_t\u0026gt;(n_trials_); for (size_t trial = 0; trial \u0026lt; n_trials_; trial++) { if (z_train.at(trial).n_cols != u_train.at(trial).n_cols) { throw std::runtime_error( \u0026#34;I/O training data have different number of time steps.\u0026#34;); } n_t_[trial] = u_train.at(trial).n_cols; n_t_tot_ += n_t_[trial]; } dt_ = dt; n_x_ = n_x; n_u_ = u_train.at(0).n_rows; n_y_ = z_train.at(0).n_rows; n_h_ = n_h; // dimensionality check for eventual block-hankel data matrix  size_t len = n_t_tot_ - 2 * n_h_ + 1; if (len \u0026lt; (2 * n_h_ * (n_u_ + n_y_))) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;Dataset problem! More rows than columns in block-hankel data \u0026#34; \u0026#34;matrix: 2*(n_u+n_y)*n_h \u0026gt; data-length! Need higher data-length or \u0026#34; \u0026#34;lower n_h.\u0026#34;; throw std::runtime_error(ss.str()); } fit_ = Fit(n_u_, n_x_, n_y_, dt_); u_ = std::move(u_train); z_ = std::move(z_train); if (!d.is_finite() || (d.n_rows != n_y_)) { // TODO(mfbolus): implement least-square solution for impulse response with  // a second input of ones. Data-driven way of accounting for offset *not*  // driven by an input.  //  // For now, calculate output bias (d) as the  // output wherever the stimulus has not been on for some amount of time.  // convolve u with rectangle and take all samples. This is a reasonable  // approach, since often when autonomous systems are fit (i.e., systems with  // no input), they will subtract off the mean of the output. This  // essentially amounts to setting output bias to the mean of the output when  // there is no stimulation.  data_t t_silence = 0.1; data_t thresh_silence = 0.001; CalcD(t_silence, thresh_silence); } else { fit_.set_d(d); } } template \u0026lt;typename Fit\u0026gt; std::tuple\u0026lt;Fit, Vector\u0026gt; SSID\u0026lt;Fit\u0026gt;::Run(SSIDWt ssid_wt) { // the weight on minimizing dc I/O gain only works for gaussian,  // and hopefully not necessary with appropriate dataset.  data_t wt_dc = 0; CreateHankelDataMat(); DecomposeData(); CalcSVD(ssid_wt); Solve(wt_dc); return std::make_tuple(fit_, s_); } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::CalcD(data_t t_silence, data_t thresh_silence) { Vector d(z_.at(0).n_rows, fill::zeros); Vector win(static_cast\u0026lt;size_t\u0026gt;(t_silence / dt_), fill::ones); Vector sum_z_silence(n_y_, fill::zeros); size_t n_silence(0); for (size_t trial = 0; trial \u0026lt; u_.size(); trial++) { // find silent samples  // start by convolving with  Vector sum_u = vectorise(sum(abs(u_.at(trial)), 0)); Vector u_conv = conv(sum_u, win, \u0026#34;same\u0026#34;); // get only the samples that are silent...  arma::uvec ubi_silence = find(u_conv \u0026lt;= thresh_silence); if (ubi_silence.n_elem \u0026gt; 0) { sum_z_silence += arma::sum(z_.at(trial).cols(ubi_silence), 1); n_silence += ubi_silence.n_elem; } } if (n_silence \u0026gt; 0) { d = sum_z_silence / n_silence; } fit_.set_d(d); } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::CreateHankelDataMat() { // temporary copy of data  Matrix z(n_y_, n_t_tot_, fill::zeros); Matrix u(n_u_, n_t_tot_, fill::zeros); size_t so_far(0); for (size_t trial = 0; trial \u0026lt; z_.size(); trial++) { z.submat(0, so_far, n_y_ - 1, so_far + n_t_.at(trial) - 1) = z_.at(trial); u.submat(0, so_far, n_u_ - 1, so_far + n_t_.at(trial) - 1) = u_.at(trial); so_far += n_t_.at(trial); } // remove output bias  z.each_col() -= fit_.d(); // calculate I/O gain @ DC while data in convenient form  g_dc_ = z * pinv(u); // create hankel data matrix  size_t len = z.n_cols - 2 * n_h_ + 1; // data length in hankel mat  // block-hankel data matrix  D_ = Matrix(2 * n_h_ * (n_u_ + n_y_), len); // past input  auto u_p = D_.submat(0, 0, n_h_ * n_u_ - 1, len - 1); // future input  auto u_f = D_.submat(n_h_ * n_u_, 0, 2 * n_h_ * n_u_ - 1, len - 1); // past output  auto y_p = D_.submat(2 * n_h_ * n_u_, 0, n_h_ * (2 * n_u_ + n_y_) - 1, len - 1); // future output  auto y_f = D_.submat(n_h_ * (2 * n_u_ + n_y_), 0, 2 * n_h_ * (n_u_ + n_y_) - 1, len - 1); size_t idx = 0; for (size_t k = 0; k \u0026lt; len; k++) { idx = 0; for (size_t kk = k; kk \u0026lt; (n_h_ + k); kk++) { u_p.col(k).subvec(idx, idx + n_u_ - 1) = u.col(kk); idx += n_u_; } idx = 0; for (size_t kk = (n_h_ + k); kk \u0026lt; (2 * n_h_ + k); kk++) { u_f.col(k).subvec(idx, idx + n_u_ - 1) = u.col(kk); idx += n_u_; } idx = 0; for (size_t kk = k; kk \u0026lt; (n_h_ + k); kk++) { y_p.col(k).subvec(idx, idx + n_y_ - 1) = z.col(kk); idx += n_y_; } idx = 0; for (size_t kk = (n_h_ + k); kk \u0026lt; (2 * n_h_ + k); kk++) { y_f.col(k).subvec(idx, idx + n_y_ - 1) = z.col(kk); idx += n_y_; } } // TODO(mfbolus): subtract mean?  // Vector m = mean(D_,1);  // D_.each_col() -= m;  D_ /= sqrt(static_cast\u0026lt;data_t\u0026gt;(len)); } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::DecomposeData() { // // do LQ decomp instead of calculating covariance expensive way  // // Note that \u0026#34;R\u0026#34; in van Overschee is lower-triangular (L), not \u0026#34;R\u0026#34; in QR  // // decomp. Very confusing.  // Matrix q_t;  // lq(L_, q_t, D_);  // // van Overschee zeros out the other elements.  // L_ = trimatl(L_);  // Depending on dataset, this may be faster:  // Calculate covariance of the data matrix  Matrix cov = D_ * D_.t(); // retro-actively do mean subtraction  Vector mu_d = arma::mean(D_, 1); cov -= mu_d * mu_d.t() * D_.n_cols; L_ = arma::chol(cov, \u0026#34;lower\u0026#34;); L_ = trimatl(L_); } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::CalcSVD(SSIDWt wt) { // submats that will be needed:  auto R_14_14 = L_.submat(0, 0, n_h_ * (2 * n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_11_14 = L_.submat(0, 0, n_h_ * n_u_ - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_11_13 = L_.submat(0, 0, n_h_ * n_u_ - 1, n_h_ * (2 * n_u_) - 1); auto R_23_13 = L_.submat(n_h_ * n_u_, 0, 2 * n_h_ * n_u_ - 1, 2 * n_h_ * n_u_ - 1); auto R_44_14 = L_.submat(2 * n_u_ * n_h_, 0, n_h_ * (2 * n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_44_13 = L_.submat(2 * n_u_ * n_h_, 0, n_h_ * (2 * n_u_ + n_y_) - 1, n_h_ * (2 * n_u_) - 1); auto R_44 = L_.submat(2 * n_u_ * n_h_, 2 * n_u_ * n_h_, n_h_ * (2 * n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_56_14 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, n_h_ * (2 * n_u_ + 2 * n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); Matrix Lup_Luf_Lyp = R_56_14 * pinv(R_14_14); auto Lup = Lup_Luf_Lyp.submat(0, 0, n_h_ * n_y_ - 1, n_h_ * n_u_ - 1); auto Luf = Lup_Luf_Lyp.submat(0, n_h_ * n_u_, n_h_ * n_y_ - 1, 2 * n_h_ * n_u_ - 1); auto Lyp = Lup_Luf_Lyp.submat(0, 2 * n_h_ * n_u_, n_h_ * n_y_ - 1, n_h_ * (2 * n_u_ + n_y_) - 1); // aka: R_f  Matrix R_56_16 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, 2 * n_h_ * (n_u_ + n_y_) - 1, L_.n_cols - 1); // from van Overschee subid.m:  // Rf = R((2*m+l)*i+1:2*(m+l)*i,:); % Future outputs  Matrix U; Matrix V; switch (wt) { case kSSIDNone: { // No weighting. (what van Overschee calls \u0026#34;N4SID\u0026#34;)  Matrix O_k_sans_Qt = Lup * R_11_14 + Lyp * R_44_14; arma::svd(U, s_, V, O_k_sans_Qt); } break; case kSSIDMOESP: { // MOESP weighting  // This is what they use in the \u0026#34;robust\u0026#34; algorithm van Overschee, de Moor  // 1996  Matrix Pi = Matrix(2 * n_h_ * n_u_, 2 * n_h_ * n_u_, fill::eye) - R_23_13.t() * inv(R_23_13 * R_23_13.t()) * R_23_13; Matrix O_k_ortho_Uf_sans_Qt = join_horiz((Lup * R_11_13 + Lyp * R_44_13) * Pi, Lyp * R_44); svd(U, s_, V, O_k_ortho_Uf_sans_Qt); } break; case kSSIDCVA: { // CVA weighting  // See van Overschee\u0026#39;s matlab code (subid.m):  // https://www.mathworks.com/matlabcentral/fileexchange/2290-subspace-identification-for-linear-systems  Matrix Pi = Matrix(2 * n_h_ * n_u_, 2 * n_h_ * n_u_, fill::eye) - R_23_13.t() * inv(R_23_13 * R_23_13.t()) * R_23_13; Matrix O_k_ortho_Uf_sans_Qt = join_horiz((Lup * R_11_13 + Lyp * R_44_13) * Pi, Lyp * R_44); Matrix inv_w1; Matrix qt1; lq(inv_w1, qt1, R_56_16); // lq decomp of R_f (future output data)  inv_w1 = trimatl(inv_w1); inv_w1 = inv_w1.submat(0, 0, n_y_ * n_h_ - 1, n_y_ * n_h_ - 1); Matrix w_o_w = arma::solve( inv_w1, O_k_ortho_Uf_sans_Qt); // alternatively  // pinv(inv_W1)*O_k_ortho_Uf_sans_Qt  svd(U, s_, V, w_o_w); U = inv_w1 * U; break; } } // Truncate to model order (heart of ssid method)  auto s_hat = s_.subvec(0, n_x_ - 1); Matrix diag_sqrt_s = diagmat(sqrt(s_hat)); auto u_hat = U.submat(0, 0, U.n_rows - 1, n_x_ - 1); // get extended observability and controllability mats  ext_obs_t_ = u_hat * diag_sqrt_s; // extended observability matrix } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::Solve(data_t wt_dc) { // required submats  auto R_56_14 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, n_h_ * (2 * n_u_ + 2 * n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) - 1); auto R_23_15 = L_.submat(n_h_ * n_u_, 0, 2 * n_h_ * n_u_ - 1, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1); auto R_66_15 = L_.submat(n_h_ * (2 * n_u_ + n_y_) + n_y_, 0, 2 * n_h_ * (n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1); auto R_55_15 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1); auto R_56_15 = L_.submat(n_h_ * (2 * n_u_ + n_y_), 0, 2 * n_h_ * (n_u_ + n_y_) - 1, n_h_ * (2 * n_u_ + n_y_) + n_y_ - 1); // Solve for params using appropriate algorithm:  // robust deterministic/stochastic algorithm in van Overschee 1996  // algorithm that the authors say \u0026#34;works\u0026#34; in practice.  auto ext_obs_tm1 = ext_obs_t_.submat( 0, 0, ext_obs_t_.n_rows - 1 - n_y_, ext_obs_t_.n_cols - 1); // extended observability matrix  // This is what textbook (1996) says:  //  // Matrix Tr = join_vert(pinv(ext_obs_t_) * R_56_15, R_23_15);  //  // HOWEVER, do not know why but have to fill the last place with zeros like  // authors\u0026#39; matlab implementation (see `subid.m`)  // Otherwise, get ridiculous covariances (although A,C estimates are close to  // same...)  Matrix Tr = join_vert( join_horiz(pinv(ext_obs_t_) * R_56_14, Matrix(n_x_, n_y_, fill::zeros)), R_23_15); Matrix Tl = join_vert(pinv(ext_obs_tm1) * R_66_15, R_55_15); Matrix S = Tl * pinv(Tr); // Use alternative in van Overschee 1996, p. 129. Apparently, should ensure  // stability.  fit_.set_C(ext_obs_t_.submat(0, 0, n_y_ - 1, ext_obs_t_.n_cols - 1)); Matrix ext_obs_t_p1 = join_vert( ext_obs_t_.submat(n_y_, 0, ext_obs_t_.n_rows - 1, ext_obs_t_.n_cols - 1), Matrix(n_y_, ext_obs_t_.n_cols, fill::zeros)); fit_.set_A(pinv(ext_obs_t_) * ext_obs_t_p1); // At this point, van Overschee \u0026amp; de Moor suggest re-calculating ext_obs_t_,  // ext_obs_tm1 from (A, C) because it was just an approximation. This is  RecomputeExtObs(); ext_obs_tm1 = ext_obs_t_.submat( 0, 0, ext_obs_t_.n_rows - 1 - n_y_, ext_obs_t_.n_cols - 1); // extended observability matrix  Tl = join_vert(pinv(ext_obs_tm1) * R_66_15, R_55_15); Tr = join_vert( join_horiz(pinv(ext_obs_t_) * R_56_14, Matrix(n_x_, n_y_, fill::zeros)), R_23_15); S = Tl * pinv(Tr); Matrix Lcurly = S.submat(0, 0, n_x_ + n_y_ - 1, n_x_ - 1) * pinv(ext_obs_t_); Matrix Mcurly = pinv(ext_obs_tm1); Matrix Pcurly = Tl - Lcurly * R_56_15; Vector Pvec = vectorise(Pcurly); Matrix Qcurly = R_23_15; // Identify [D; B], assuming D=0 and ensuring DC gain is correct  Matrix sum_QcurlyT_kron_Ncurly( (n_h_ * (2 * n_u_ + n_y_) + n_y_) * (n_y_ + n_x_), n_u_ * (n_y_ + n_x_), fill::zeros); Matrix eye_ext_obs_tm1(n_y_ + ext_obs_tm1.n_rows, n_y_ + ext_obs_tm1.n_cols, fill::eye); eye_ext_obs_tm1.submat(n_y_, n_y_, eye_ext_obs_tm1.n_rows - 1, eye_ext_obs_tm1.n_cols - 1) = ext_obs_tm1; // van Overschee (1996) p. 126  Matrix N1_Tl = -Lcurly; N1_Tl.submat(0, 0, n_x_ - 1, N1_Tl.n_cols - 1) += join_horiz(Matrix(n_x_, n_y_, fill::zeros), Mcurly); N1_Tl.submat(n_x_, 0, n_x_ + n_y_ - 1, n_y_ - 1) += Matrix(n_y_, n_y_, fill::eye); Matrix Nk_Tl(N1_Tl.n_rows, N1_Tl.n_cols, fill::zeros); Matrix N_k; for (size_t k = 0; k \u0026lt; n_h_; k++) { auto Qcurly_k = Qcurly.submat(n_u_ * k, 0, n_u_ * (k + 1) - 1, Qcurly.n_cols - 1); Nk_Tl.zeros(); Nk_Tl.submat(0, 0, n_x_ + n_y_ - 1, Nk_Tl.n_cols - k * n_y_ - 1) = N1_Tl.submat(0, k * n_y_, N1_Tl.n_rows - 1, N1_Tl.n_cols - 1); N_k = Nk_Tl * eye_ext_obs_tm1; sum_QcurlyT_kron_Ncurly += kron(Qcurly_k.t(), N_k); } Matrix err_vec; if (wt_dc \u0026gt; 0) { // Constraints enforced by weighted least squares  //  // Reference:  //  // Privara S, ..., Ferkl L_. (2010) Subspace Identification of Poorly  // Excited Industrial Systems. Conference in Decision and Control.  // constraint 1: assume D=0 --\u0026gt; remove the components for Dvec (this is  // actually a hard constraint in that it ignores D)  Matrix sum_QcurlyT_kron_Ncurly_db = sum_QcurlyT_kron_Ncurly; sum_QcurlyT_kron_Ncurly = Matrix(sum_QcurlyT_kron_Ncurly_db.n_rows, n_x_ * n_u_); size_t kkk = 0; for (size_t k = 1; k \u0026lt; (n_u_ + 1); k++) { size_t start_idx = k * (n_y_ + n_x_) - n_x_; for (size_t kk = 0; kk \u0026lt; n_x_; kk++) { sum_QcurlyT_kron_Ncurly.col(kkk) = sum_QcurlyT_kron_Ncurly_db.col(start_idx + kk); kkk++; } } // constraint 2: Make sure DC I/O gain is correct  Matrix b_to_g0 = fit_.C() * inv(Matrix(n_x_, n_x_, fill::eye) - fit_.A()); Matrix Pvec_Gvec = join_vert(Pvec, vectorise(g_dc_)); Matrix eye_kron_b_to_g0 = kron(Matrix(n_u_, n_u_, fill::eye), b_to_g0); Matrix sum_QcurlyT_kron_Ncurly_b_to_g0 = join_vert(sum_QcurlyT_kron_Ncurly, eye_kron_b_to_g0); // WEIGHTED LS  // Important in practice because I care a lot about at least getting the DC  // gain correct. Put x weight on minimizing error at DC, relative to others  Matrix w(sum_QcurlyT_kron_Ncurly_b_to_g0.n_rows, sum_QcurlyT_kron_Ncurly_b_to_g0.n_rows, fill::eye); // Make weight on minimizing DC error immense so at least that  // should be nailed.  size_t start_row = sum_QcurlyT_kron_Ncurly.n_rows; size_t start_col = sum_QcurlyT_kron_Ncurly.n_rows; size_t stop_row = w.n_rows - 1; size_t stop_col = w.n_cols - 1; // w.submat(start_row, start_col, stop_row, stop_col) *= wt_dc*N;// scale  // weight with data length?  w.submat(start_row, start_col, stop_row, stop_col) *= wt_dc; Vector b_vec = inv(sum_QcurlyT_kron_Ncurly_b_to_g0.t() * w * sum_QcurlyT_kron_Ncurly_b_to_g0) * sum_QcurlyT_kron_Ncurly_b_to_g0.t() * w * Pvec_Gvec; fit_.set_B(Matrix(b_vec.memptr(), n_x_, n_u_)); // Calculate residuals and their cov.  // Because I\u0026#39;ve added constraints, I need to re-calculate the right term  // with b_vec instead of how van Overschee do in final algorithm.  err_vec = Pvec - sum_QcurlyT_kron_Ncurly * b_vec; } else { // default way: *no* constraint on G0 or D=0  Vector db_vec = pinv(sum_QcurlyT_kron_Ncurly) * Pvec; // TODO(mfbolus) n.b., this gets thrown away...  // Matrix D = Matrix(db_vec.memptr(), n_y_, n_u_);  fit_.set_B(Matrix(db_vec.memptr() + (n_u_ * n_y_), n_x_, n_u_)); err_vec = Pvec - sum_QcurlyT_kron_Ncurly * db_vec; } // Matrix err = Matrix(err_vec.memptr(), Pcurly.n_rows, Pcurly.n_cols);  // TODO(mfbolus): Something is wrong with the error calculation above.  // Use the way van overschee does it in `subid.m`  // WARNING: this ignores any above constraints, so Q, R will be approximate...  Matrix err = Tl - S * Tr; Matrix cov_err = err * err.t(); fit_.set_Q(cov_err.submat(0, 0, n_x_ - 1, n_x_ - 1)); fit_.set_R(cov_err.submat(n_x_, n_x_, n_x_ + n_y_ - 1, n_x_ + n_y_ - 1)); } template \u0026lt;typename Fit\u0026gt; void SSID\u0026lt;Fit\u0026gt;::RecomputeExtObs() { ext_obs_t_.submat(0, 0, n_y_ - 1, ext_obs_t_.n_cols - 1) = fit_.C(); for (size_t k = 2; k \u0026lt; (n_h_ + 1); k++) { ext_obs_t_.submat((k - 1) * n_y_, 0, k * n_y_ - 1, ext_obs_t_.n_cols - 1) = ext_obs_t_.submat((k - 2) * n_y_, 0, (k - 1) * n_y_ - 1, ext_obs_t_.n_cols - 1) * fit_.A(); } } } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':55,'href':'/ldsctrlest/docs/api/files/lds__gaussian_8h/','title':"ldsCtrlEst_h/lds_gaussian.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian.h #  glds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Detailed Description #  This file declares and partially defines the namespace for linear dynamical systems with Gaussian observations ([lds::gaussian](/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian.h - LDS with Gaussian Output --*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_H #define LDSCTRLEST_LDS_GAUSSIAN_H  // namespace #include \u0026#34;lds.h\u0026#34; namespace lds { namespace gaussian { // insert any Gaussian-specific things here... } // namespace gaussian } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':56,'href':'/ldsctrlest/docs/api/files/lds__gaussian__ctrl_8h/','title':"ldsCtrlEst_h/lds_gaussian_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_ctrl.h #  GLDS Controller. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::Controller Gaussian-observation Controller Type.    Detailed Description #  This file declares and partially defines the type for control of a gaussian-observation linear dynamical system (lds::gaussian::Controller). It inherits functionality from the underlying GLDS model type (lds::gaussian::System), including state estimation.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_ctrl.h - GLDS Controller ------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_CTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_CTRL_H  // namespace #include \u0026#34;lds_gaussian.h\u0026#34;// system #include \u0026#34;lds_gaussian_sys.h\u0026#34;// controller #include \u0026#34;lds_ctrl.h\u0026#34; namespace lds { namespace gaussian { class Controller : public lds::Controller\u0026lt;System\u0026gt; { public: void set_y_ref(const Vector\u0026amp; y_ref) override { Reassign(y_ref_,y_ref); cx_ref_ = y_ref - sys_.d(); }; // make sure base class template methods available  using lds::Controller\u0026lt;System\u0026gt;::Controller; using lds::Controller\u0026lt;System\u0026gt;::Control; using lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference; using lds::Controller\u0026lt;System\u0026gt;::sys; using lds::Controller\u0026lt;System\u0026gt;::Kc; using lds::Controller\u0026lt;System\u0026gt;::Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::Kc_u; using lds::Controller\u0026lt;System\u0026gt;::g_design; using lds::Controller\u0026lt;System\u0026gt;::u_ref; using lds::Controller\u0026lt;System\u0026gt;::x_ref; using lds::Controller\u0026lt;System\u0026gt;::y_ref; using lds::Controller\u0026lt;System\u0026gt;::control_type; using lds::Controller\u0026lt;System\u0026gt;::set_sys; using lds::Controller\u0026lt;System\u0026gt;::set_g_design; using lds::Controller\u0026lt;System\u0026gt;::set_u_ref; using lds::Controller\u0026lt;System\u0026gt;::set_x_ref; using lds::Controller\u0026lt;System\u0026gt;::set_y_ref; using lds::Controller\u0026lt;System\u0026gt;::set_Kc; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_u; using lds::Controller\u0026lt;System\u0026gt;::set_tau_awu; using lds::Controller\u0026lt;System\u0026gt;::set_control_type; using lds::Controller\u0026lt;System\u0026gt;::Reset; using lds::Controller\u0026lt;System\u0026gt;::Print; }; } // namespace gaussian } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':57,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit.h #  GLDS fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::Fit GLDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit.h - Fit Type for GLDS -----*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_H  // namespace #include \u0026#34;lds_gaussian.h\u0026#34;// fit type #include \u0026#34;lds_fit.h\u0026#34; namespace lds { namespace gaussian { class Fit : public lds::Fit { public: Fit() = default; Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt); const Matrix\u0026amp; R() const override { return R_; }; void set_R(const Matrix\u0026amp; R) override { Reassign(R_, R); ForceSymPD(R_); }; View h(Matrix\u0026amp; y, const Matrix\u0026amp; x, size_t t) override { y.col(t) = C_ * x.col(t) + d_; return y.col(t); }; }; }; // namespace gaussian } // namespace lds #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':58,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit__em_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit_em.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit_em.h #  GLDS E-M fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::FitEM GLDS E-M Fit Type.    Detailed Description #  This file declares and partially defines a type by which Gaussian-output LDS models are fit by the expectation-maximization (EM) algorithm (lds::gaussian::emFit_t).\nReferences: [1] Shumway RH, Stoffer DS. (1982) An Approach to Time Series Smoothing and Forecasting Using the EM Algorithm.Journal of Time Series Analysis 3(2).\n[2] Ghahramani Z, Hinton GE. (1996) Parameter Estimation for Linear Dynamical Systems. Technical Report CRG-TR-96-2.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit_em.h - GLDS Fit (EM) ------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H  #include \u0026#34;lds_fit_em.h\u0026#34;#include \u0026#34;lds_gaussian_fit.h\u0026#34; namespace lds { namespace gaussian { class FitEM : public EMax\u0026lt;Fit\u0026gt; { public: using EMax\u0026lt;Fit\u0026gt;::EMax; private: void MaximizeOutput() override; void MaximizeMeasurement() override; void RecurseKe(Matrix\u0026amp; Ke, Cube\u0026amp; P_pre, Cube\u0026amp; P_post, size_t t) override; }; } // namespace gaussian } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':59,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit__ssid_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit_ssid.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit_ssid.h #  GLDS SSID fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::FitSSID Subspace Identification (SSID) for GLDS.    Detailed Description #  This file declares and partially defines a type by which Gaussian-output LDS models are fit by a subspace identification (SSID) algorithm (lds::gaussian::ssidFit_t).\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit_ssid.h - GLDS Fit (SSID) --*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H  #include \u0026#34;lds_fit_ssid.h\u0026#34;#include \u0026#34;lds_gaussian_fit.h\u0026#34; namespace lds { namespace gaussian { class FitSSID : public SSID\u0026lt;Fit\u0026gt; { public: using SSID\u0026lt;Fit\u0026gt;::SSID; using SSID\u0026lt;Fit\u0026gt;::Run; private: using SSID\u0026lt;Fit\u0026gt;::CreateHankelDataMat; using SSID\u0026lt;Fit\u0026gt;::CalcSVD; using SSID\u0026lt;Fit\u0026gt;::Solve; void DecomposeData() override; void SolveVanOverschee(); }; } // namespace gaussian } // namespace lds #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':60,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sctrl_8h/','title':"ldsCtrlEst_h/lds_gaussian_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_sctrl.h #  GLDS switched controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::SwitchedController Gaussian-observation SwitchedController Type.    Detailed Description #  This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Gaussian-output linear dynamical systems (lds::gaussian::SwitchedController).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_sctrl.h - Switched Controller -*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H  // controller type #include \u0026#34;lds_gaussian_ctrl.h\u0026#34;// switched controller #include \u0026#34;lds_sctrl.h\u0026#34; namespace lds { namespace gaussian { class SwitchedController : public lds::SwitchedController\u0026lt;System\u0026gt; { public: void set_y_ref(const Vector\u0026amp; y_ref) override { Reassign(y_ref_, y_ref); cx_ref_ = y_ref - sys_.d(); } // make sure base class template methods available  using lds::SwitchedController\u0026lt;System\u0026gt;::SwitchedController; using lds::SwitchedController\u0026lt;System\u0026gt;::Switch; using lds::SwitchedController\u0026lt;System\u0026gt;::Control; using lds::SwitchedController\u0026lt;System\u0026gt;::ControlOutputReference; using lds::SwitchedController\u0026lt;System\u0026gt;::sys; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::set_g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::set_u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::set_tau_awu; using lds::SwitchedController\u0026lt;System\u0026gt;::set_control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::Reset; using lds::SwitchedController\u0026lt;System\u0026gt;::Print; }; // SwitchedController } // namespace gaussian } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':61,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sys_8h/','title':"ldsCtrlEst_h/lds_gaussian_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_sys.h #  GLDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::System Gaussian LDS Type.    Detailed Description #  This file declares and partially defines the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems ([lds::gaussian::System](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_system/)). It inherits functionality from the underlying linear dynamical system ([lds::System](/ldsctrlest/docs/api/classes/classlds_1_1_system/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_sys.h - GLDS ------------------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_SYS_H #define LDSCTRLEST_LDS_GAUSSIAN_SYS_H  // namespace #include \u0026#34;lds_gaussian.h\u0026#34;// system #include \u0026#34;lds_sys.h\u0026#34; namespace lds { namespace gaussian { class System : public lds::System { public: System() = default; System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0, data_t r0 = kDefaultR0); const Vector\u0026amp; Simulate(const Vector\u0026amp; u_tm1) override; // get methods  const Matrix\u0026amp; R() const { return R_; }; // set methods  void set_Q(const Matrix\u0026amp; Q) { lds::System::set_Q(Q); do_recurse_Ke_ = true; } void set_R(const Matrix\u0026amp; R) { Reassign(R_,R); do_recurse_Ke_ = true; }; void set_Ke(const Matrix\u0026amp; Ke) { Reassign(Ke_,Ke); // if users have set Ke, they must not want to calculate it online.  do_recurse_Ke_ = false; }; void set_Ke_m(const Matrix\u0026amp; Ke_m) { Reassign(Ke_m_,Ke_m); // if users have set Ke, they must not want to calculate it online.  do_recurse_Ke_ = false; }; void Print(); protected: void h() override { cx_ = C_ * x_; y_ = cx_ + d_; }; void RecurseKe() override; // Gaussian-output-specific  Matrix R_; bool do_recurse_Ke_{}; }; // System } // namespace gaussian } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':62,'href':'/ldsctrlest/docs/api/files/lds__poisson_8h/','title':"ldsCtrlEst_h/lds_poisson.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson.h #  plds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Detailed Description #  This file declares and partially defines the namespace for linear dynamical systems with Poisson observations ([lds::poisson](/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson.h - LDS with Poisson Output ----*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_H #define LDSCTRLEST_LDS_POISSON_H  #include \u0026#34;lds.h\u0026#34; namespace lds { namespace poisson { // insert any Poisson-specific things here... } // namespace poisson } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':63,'href':'/ldsctrlest/docs/api/files/lds__poisson__ctrl_8h/','title':"ldsCtrlEst_h/lds_poisson_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_ctrl.h #  PLDS controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::Controller PLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for feedback control of a Poisson-output linear dynamical system ([lds::poisson::Controller](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_controller/)). It inherits functionality from the underlying PLDS model type ([lds::poisson::System](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_system/)), including state estimation.\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_ctrl.h - PLDS Controller -------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_CTRL_H #define LDSCTRLEST_LDS_POISSON_CTRL_H  // namespace #include \u0026#34;lds_poisson.h\u0026#34;// system type #include \u0026#34;lds_poisson_sys.h\u0026#34;// control type #include \u0026#34;lds_ctrl.h\u0026#34; namespace lds { namespace poisson { class Controller : public lds::Controller\u0026lt;System\u0026gt; { public: void set_y_ref(const Vector\u0026amp; y_ref) override { Reassign(y_ref_, y_ref); lds::Limit(y_ref_, kYRefLb, lds::kInf); cx_ref_ = log(y_ref_) - sys_.d(); }; // make sure base class template methods available  using lds::Controller\u0026lt;System\u0026gt;::Controller; using lds::Controller\u0026lt;System\u0026gt;::Control; using lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference; using lds::Controller\u0026lt;System\u0026gt;::sys; using lds::Controller\u0026lt;System\u0026gt;::Kc; using lds::Controller\u0026lt;System\u0026gt;::Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::Kc_u; using lds::Controller\u0026lt;System\u0026gt;::g_design; using lds::Controller\u0026lt;System\u0026gt;::u_ref; using lds::Controller\u0026lt;System\u0026gt;::x_ref; using lds::Controller\u0026lt;System\u0026gt;::y_ref; using lds::Controller\u0026lt;System\u0026gt;::control_type; using lds::Controller\u0026lt;System\u0026gt;::set_sys; using lds::Controller\u0026lt;System\u0026gt;::set_g_design; using lds::Controller\u0026lt;System\u0026gt;::set_u_ref; using lds::Controller\u0026lt;System\u0026gt;::set_x_ref; using lds::Controller\u0026lt;System\u0026gt;::set_y_ref; using lds::Controller\u0026lt;System\u0026gt;::set_Kc; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::set_Kc_u; using lds::Controller\u0026lt;System\u0026gt;::set_tau_awu; using lds::Controller\u0026lt;System\u0026gt;::set_control_type; using lds::Controller\u0026lt;System\u0026gt;::Reset; using lds::Controller\u0026lt;System\u0026gt;::Print; private: constexpr static const data_t kYRefLb = 1e-4; }; } // namespace poisson } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':64,'href':'/ldsctrlest/docs/api/files/lds__poisson__fit_8h/','title':"ldsCtrlEst_h/lds_poisson_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_fit.h #  PLDS base fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::Fit PLDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_fit.h - Fit Type for PLDS ------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_FIT_H #define LDSCTRLEST_LDS_POISSON_FIT_H  // namespace #include \u0026#34;lds_poisson.h\u0026#34;// fit #include \u0026#34;lds_fit.h\u0026#34; namespace lds { namespace poisson { class Fit : public lds::Fit { public: Fit() = default; Fit(size_t n_u, size_t n_x, size_t n_y, data_t dt) : lds::Fit(n_u, n_x, n_y, dt){}; View h(Matrix\u0026amp; y, const Matrix\u0026amp; x, size_t t) override { y.col(t) = exp(C_ * x.col(t) + d_); return y.col(t); }; void set_R(const Matrix\u0026amp; R) override { std::cerr \u0026lt;\u0026lt; \u0026#34;WARNING: Cannot set R (R[0] = \u0026#34; \u0026lt;\u0026lt; R.at(0) \u0026lt;\u0026lt; \u0026#34;). No Gaussian measurement noise in Poisson observation model.\\n\u0026#34;; }; const Matrix\u0026amp; R() const override { return R_; }; }; }; // namespace poisson } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':65,'href':'/ldsctrlest/docs/api/files/lds__poisson__fit__em_8h/','title':"ldsCtrlEst_h/lds_poisson_fit_em.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_fit_em.h #  PLDS E-M fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::FitEM PLDS E-M Fit Type.    Detailed Description #  This file declares and partially defines a type by which Gaussian-output LDS models are fit by the expectation-maximization (EM) algorithm (lds::gaussian::emFit_t).\nReferences: [1] Shumway RH, Stoffer DS. (1982) An Approach to Time Series Smoothing and Forecasting Using the EM Algorithm.Journal of Time Series Analysis 3(2).\n[2] Ghahramani Z, Hinton GE. (1996) Parameter Estimation for Linear Dynamical Systems. Technical Report CRG-TR-96-2.\n[3] Smith A, Brown E. (2003) Estimating a State-Space Model from Point Process Observations. Neural Computation.\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_fit_em.h - PLDS Fit (EM) -------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_FIT_EM_H #define LDSCTRLEST_LDS_POISSON_FIT_EM_H  #include \u0026#34;lds_fit_em.h\u0026#34;#include \u0026#34;lds_poisson_fit.h\u0026#34; namespace lds { namespace poisson { class FitEM : public EMax\u0026lt;Fit\u0026gt; { public: using EMax\u0026lt;Fit\u0026gt;::EMax; private: void MaximizeOutput() override; void MaximizeMeasurement() override{}; void RecurseKe(Matrix\u0026amp; Ke, Cube\u0026amp; P_pre, Cube\u0026amp; P_post, size_t t) override; data_t NewtonSolveC(); void AnalyticalSolveD(); }; } // namespace poisson } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':66,'href':'/ldsctrlest/docs/api/files/lds__poisson__fit__ssid_8h/','title':"ldsCtrlEst_h/lds_poisson_fit_ssid.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_fit_ssid.h #  PLDS SSID fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::FitSSID Subspace Identification (SSID) for PLDS.    Detailed Description #  This file declares and partially defines a type by which Poisson-output LDS models are fit by a subspace identification (SSID) algorithm ([lds::gaussian::FitSSID](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1_fit_s_s_i_d/)).\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer. [2] Buesing L, Macke JH, Sahani M. (2012) Spectral learning of linear dynamics from generalised-linear observations with application to neural population data. NIPS 25.\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_fit_ssid.h - PLDS Fit (SSID) ---*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_FIT_SSID_H #define LDSCTRLEST_LDS_POISSON_FIT_SSID_H  #include \u0026#34;lds_fit_ssid.h\u0026#34;#include \u0026#34;lds_poisson_fit.h\u0026#34; namespace lds { namespace poisson { class FitSSID : public SSID\u0026lt;Fit\u0026gt; { public: using SSID\u0026lt;Fit\u0026gt;::SSID; private: void DecomposeData() override; void CalcCov(); void PoissonToGaussianMoments(); Matrix cov_; }; } // namespace poisson } // namespace lds #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':67,'href':'/ldsctrlest/docs/api/files/lds__poisson__sctrl_8h/','title':"ldsCtrlEst_h/lds_poisson_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_sctrl.h #  PLDS switched controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::SwitchedController Poisson-observation SwitchedController Type.    Detailed Description #  This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Poisson-output linear dynamical systems (lds::poisson::SwitchedController).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_sctrl.h - Switched Controller --*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H #define LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H  #include \u0026#34;lds_poisson_ctrl.h\u0026#34; namespace lds { namespace poisson { class SwitchedController : public lds::SwitchedController\u0026lt;System\u0026gt; { public: void set_y_ref(const Vector\u0026amp; y_ref) override { Reassign(y_ref_,y_ref); lds::Limit(y_ref_, kYRefLB, lds::kInf); cx_ref_ = log(y_ref_) - sys_.d(); }; // make sure base class template methods available  using lds::SwitchedController\u0026lt;System\u0026gt;::SwitchedController; using lds::SwitchedController\u0026lt;System\u0026gt;::Switch; using lds::SwitchedController\u0026lt;System\u0026gt;::Control; using lds::SwitchedController\u0026lt;System\u0026gt;::ControlOutputReference; using lds::SwitchedController\u0026lt;System\u0026gt;::sys; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::set_g_design; using lds::SwitchedController\u0026lt;System\u0026gt;::set_u_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_x_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_y_ref; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_inty; using lds::SwitchedController\u0026lt;System\u0026gt;::set_Kc_u; using lds::SwitchedController\u0026lt;System\u0026gt;::set_tau_awu; using lds::SwitchedController\u0026lt;System\u0026gt;::set_control_type; using lds::SwitchedController\u0026lt;System\u0026gt;::Reset; using lds::SwitchedController\u0026lt;System\u0026gt;::Print; private: constexpr static data_t kYRefLB = 1e-4; }; } // namespace poisson } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':68,'href':'/ldsctrlest/docs/api/files/lds__poisson__sys_8h/','title':"ldsCtrlEst_h/lds_poisson_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_sys.h #  PLDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::System Poisson System type.    Detailed Description #  This file declares and partially defines the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems ([lds::poisson::System](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1_system/)). It inherits functionality from the underlying linear dynamical system ([lds::System](/ldsctrlest/docs/api/classes/classlds_1_1_system/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_sys.h - PLDS -------------------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_SYS_H #define LDSCTRLEST_LDS_POISSON_SYS_H  // namespace #include \u0026#34;lds_poisson.h\u0026#34;// system #include \u0026#34;lds_sys.h\u0026#34; namespace lds { namespace poisson { class System : public lds::System { public: System() = default; System(std::size_t n_u, std::size_t n_x, std::size_t n_y, data_t dt, data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0); const Vector\u0026amp; Simulate(const Vector\u0026amp; u_tm1) override; protected: void h() override { cx_ = C_ * x_; y_ = exp(cx_ + d_); diag_y_.diag() = y_; }; void RecurseKe() override; private: // Poisson-output-specific  Matrix diag_y_; Vector chance_; }; // System } // namespace poisson } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':69,'href':'/ldsctrlest/docs/api/files/lds__sctrl_8h/','title':"ldsCtrlEst_h/lds_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_sctrl.h #  SwitchedController type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::SwitchedController SwitchedController Type.    Detailed Description #  This file declares the type for switched control of a system approximated as multiple discrete Gaussian-output linear dynamical systems (lds::gaussian::SwitchedController).\nSource code #  //===-- ldsCtrlEst_h/lds_sctrl.h - Switched Controller ----------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_SCTRL_H #define LDSCTRLEST_LDS_SCTRL_H  #include \u0026#34;lds_ctrl.h\u0026#34; namespace lds { template \u0026lt;typename System\u0026gt; class SwitchedController : public Controller\u0026lt;System\u0026gt; { public: SwitchedController() = default; SwitchedController(const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type = 0); SwitchedController(std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type = 0); void Switch(size_t idx, bool do_force_switch = false); void set_Kc(const UniformMatrixList\u0026lt;\u0026gt;\u0026amp; Kc) { Kc_list_ = Kc; Kc_ = Kc_list_.at(0); // set to first  if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc(UniformMatrixList\u0026lt;\u0026gt;\u0026amp;\u0026amp; Kc) { Kc_list_ = std::move(Kc); Kc_ = Kc_list_.at(0); // set to first  if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc_inty(const UniformMatrixList\u0026lt;\u0026gt;\u0026amp; Kc_inty) { Kc_inty_list_ = Kc_inty; Kc_inty_ = Kc_inty_list_.at(0); // set to first  if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc_inty(UniformMatrixList\u0026lt;\u0026gt;\u0026amp;\u0026amp; Kc_inty) { Kc_inty_list_ = std::move(Kc_inty); Kc_inty_ = Kc_inty_list_.at(0); // set to first  if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc_u(const UniformMatrixList\u0026lt;\u0026gt;\u0026amp; Kc_u) { Kc_u_list_ = Kc_u; Kc_u_ = Kc_u_list_.at(0); // set to first  if (idx_ != 0) { Switch(idx_, true); } }; void set_Kc_u(UniformMatrixList\u0026lt;\u0026gt;\u0026amp;\u0026amp; Kc_u) { Kc_u_list_ = std::move(Kc_u); Kc_u_ = Kc_u_list_.at(0); // set to first  if (idx_ != 0) { Switch(idx_, true); } }; void set_g_design(const UniformVectorList\u0026amp; g) { g_design_list_ = g; g_design_ = g_design_list_.at(0); // set to first  if (idx_ != 0) { Switch(idx_, true); } }; void set_g_design(UniformVectorList\u0026amp;\u0026amp; g) { g_design_list_ = std::move(g); g_design_ = g_design_list_.at(0); // set to first  if (idx_ != 0) { Switch(idx_, true); } }; // make sure base class template methods available  using lds::Controller\u0026lt;System\u0026gt;::Controller; using lds::Controller\u0026lt;System\u0026gt;::Control; using lds::Controller\u0026lt;System\u0026gt;::ControlOutputReference; using lds::Controller\u0026lt;System\u0026gt;::sys; using lds::Controller\u0026lt;System\u0026gt;::Kc; using lds::Controller\u0026lt;System\u0026gt;::Kc_inty; using lds::Controller\u0026lt;System\u0026gt;::Kc_u; using lds::Controller\u0026lt;System\u0026gt;::g_design; using lds::Controller\u0026lt;System\u0026gt;::u_ref; using lds::Controller\u0026lt;System\u0026gt;::x_ref; using lds::Controller\u0026lt;System\u0026gt;::y_ref; using lds::Controller\u0026lt;System\u0026gt;::control_type; using lds::Controller\u0026lt;System\u0026gt;::set_u_ref; using lds::Controller\u0026lt;System\u0026gt;::set_x_ref; using lds::Controller\u0026lt;System\u0026gt;::set_y_ref; using lds::Controller\u0026lt;System\u0026gt;::set_tau_awu; using lds::Controller\u0026lt;System\u0026gt;::set_control_type; using lds::Controller\u0026lt;System\u0026gt;::Reset; using lds::Controller\u0026lt;System\u0026gt;::Print; protected: std::vector\u0026lt;System\u0026gt; systems_; size_t n_sys_{}; size_t idx_{}; // controller gains could be different for each  UniformMatrixList\u0026lt;\u0026gt; Kc_list_; UniformMatrixList\u0026lt;\u0026gt; Kc_inty_list_; UniformMatrixList\u0026lt;\u0026gt; Kc_u_list_; // design-phase input gain could also be different  UniformVectorList g_design_list_; // TODO(mfbolus): not sure why I need to do this.  using Controller\u0026lt;System\u0026gt;::Kc_; using Controller\u0026lt;System\u0026gt;::Kc_inty_; using Controller\u0026lt;System\u0026gt;::Kc_u_; using Controller\u0026lt;System\u0026gt;::g_design_; using Controller\u0026lt;System\u0026gt;::sys_; // using Controller\u0026lt;System\u0026gt;::u_ref_;  // using Controller\u0026lt;System\u0026gt;::x_ref_;  // using Controller\u0026lt;System\u0026gt;::y_ref_;  //  using Controller\u0026lt;System\u0026gt;::control_type_; private: void InitVars(); using lds::Controller\u0026lt;System\u0026gt;::set_sys; // using Controller\u0026lt;System\u0026gt;::set_Kc;  // using Controller\u0026lt;System\u0026gt;::set_Kc_inty;  // using Controller\u0026lt;System\u0026gt;::set_Kc_u;  // using Controller\u0026lt;System\u0026gt;::set_g_design; }; template \u0026lt;typename System\u0026gt; inline SwitchedController\u0026lt;System\u0026gt;::SwitchedController( const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type) : Controller\u0026lt;System\u0026gt;(systems.at(0), u_lb, u_ub, control_type), systems_(systems) { InitVars(); } template \u0026lt;typename System\u0026gt; inline SwitchedController\u0026lt;System\u0026gt;::SwitchedController( std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, data_t u_lb, data_t u_ub, size_t control_type) : Controller\u0026lt;System\u0026gt;(System(systems.at(0).n_u(), systems.at(0).n_x(), systems.at(0).n_y(), systems.at(0).dt()), u_lb, u_ub, control_type), systems_(std::move(systems)) { InitVars(); } template \u0026lt;typename System\u0026gt; inline void SwitchedController\u0026lt;System\u0026gt;::InitVars() { n_sys_ = systems_.size(); sys_ = systems_.at(0); Kc_list_ = UniformMatrixList\u0026lt;\u0026gt;(std::vector\u0026lt;Matrix\u0026gt;(n_sys_, Kc_)); Kc_inty_list_ = UniformMatrixList\u0026lt;\u0026gt;(std::vector\u0026lt;Matrix\u0026gt;(n_sys_, Kc_inty_)); Kc_u_list_ = UniformMatrixList\u0026lt;\u0026gt;(std::vector\u0026lt;Matrix\u0026gt;(n_sys_, Kc_inty_)); g_design_list_ = UniformVectorList(std::vector\u0026lt;Vector\u0026gt;(n_sys_, g_design_)); } template \u0026lt;typename System\u0026gt; inline void SwitchedController\u0026lt;System\u0026gt;::Switch(size_t idx, bool do_force_switch) { if ((idx == idx_) \u0026amp;\u0026amp; !do_force_switch) { return; // already there.  } // put old up and get new one out  systems_.at(idx_) = std::move(sys_); sys_ = std::move(systems_.at(idx)); Kc_list_.Swap(Kc_, idx_); Kc_list_.Swap(Kc_, idx); if (control_type_ \u0026amp; kControlTypeIntY) { Kc_inty_list_.Swap(Kc_inty_, idx_); Kc_inty_list_.Swap(Kc_inty_, idx); } if (control_type_ \u0026amp; kControlTypeDeltaU) { Kc_u_list_.Swap(Kc_u_, idx_); Kc_u_list_.Swap(Kc_u_, idx); } g_design_list_.Swap(g_design_, idx_); g_design_list_.Swap(g_design_, idx); idx_ = idx; } // Switch  } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':70,'href':'/ldsctrlest/docs/api/files/lds__sys_8h/','title':"ldsCtrlEst_h/lds_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_sys.h #  LDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::System Linear Dynamical System Type.    Detailed Description #  This file declares and partially defines the base type for linear dynamical systems ([lds::System](/ldsctrlest/docs/api/classes/classlds_1_1_system/)). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code #  //===-- ldsCtrlEst_h/lds_sys.h - LDS ----------------------------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_SYS_H #define LDSCTRLEST_LDS_SYS_H  #include \u0026#34;lds.h\u0026#34; namespace lds { class System { public: System() = default; System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0); /* * @brief constructs a new System * * @param A state matrix * @param B input matrix * @param g input gain/conversion factor * @param m process disturbance * @param Q process noise covariance * @param C output matrix * @param d output bias * @param x0 initial state * @param P0 covariance of initial state estimate * @param dt sample period */ System(const Matrix\u0026amp; A, const Matrix\u0026amp; B, const Vector\u0026amp; g, const Vector\u0026amp; m, const Matrix\u0026amp; Q, const Matrix\u0026amp; C, const Vector\u0026amp; d, const Vector\u0026amp; x0, const Matrix\u0026amp; P0, data_t dt); void Filter(const Vector\u0026amp; u_tm1, const Vector\u0026amp; z); virtual const Vector\u0026amp; Simulate(const Vector\u0026amp; u_tm1) = 0; void f(const Vector\u0026amp; u, bool do_add_noise = false) { x_ = A_ * x_ + B_ * (g_ % u) + m_; if (do_add_noise) { x_ += arma::mvnrnd(Vector(n_x_).fill(0), Q_); } }; virtual void h() = 0; size_t n_u() const { return n_u_; }; size_t n_x() const { return n_x_; }; size_t n_y() const { return n_y_; }; data_t dt() const { return dt_; }; const Vector\u0026amp; x() const { return x_; }; const Matrix\u0026amp; P() const { return P_; }; const Vector\u0026amp; m() const { return m_; }; const Matrix\u0026amp; P_m() const { return P_m_; }; const Vector\u0026amp; cx() const { return cx_; }; const Vector\u0026amp; y() const { return y_; }; const Vector\u0026amp; x0() const { return x0_; }; const Vector\u0026amp; m0() const { return m0_; }; const Matrix\u0026amp; A() const { return A_; }; const Matrix\u0026amp; B() const { return B_; }; const Vector\u0026amp; g() const { return g_; }; const Matrix\u0026amp; C() const { return C_; }; const Vector\u0026amp; d() const { return d_; }; const Matrix\u0026amp; Ke() const { return Ke_; }; const Matrix\u0026amp; Ke_m() const { return Ke_m_; }; void set_A(const Matrix\u0026amp; A) { Reassign(A_, A); }; void set_B(const Matrix\u0026amp; B) { Reassign(B_, B); }; void set_m(const Vector\u0026amp; m) { Reassign(m0_, m); if (!do_adapt_m) { Reassign(m_, m); } }; void set_g(const Vector\u0026amp; g) { Reassign(g_, g); }; void set_Q(const Matrix\u0026amp; Q) { Reassign(Q_, Q); }; void set_Q_m(const Matrix\u0026amp; Q_m) { Reassign(Q_m_, Q_m); }; void set_x0(const Vector\u0026amp; x0) { Reassign(x0_, x0); }; void set_P0(const Matrix\u0026amp; P0) { Reassign(P0_, P0); }; void set_P0_m(const Matrix\u0026amp; P0_m) { Reassign(P0_m_, P0_m); }; void set_C(const Matrix\u0026amp; C) { Reassign(C_, C); }; void set_d(const Vector\u0026amp; d) { Reassign(d_, d); }; void Reset(); void Print(); // safe to leave this public and non-const  bool do_adapt_m{}; protected: virtual void RecurseKe() = 0; void InitVars(data_t p0 = kDefaultP0, data_t q0 = kDefaultQ0); std::size_t n_x_{}; std::size_t n_u_{}; std::size_t n_y_{}; data_t dt_{}; // Signals:  Vector x_; Matrix P_; Vector m_; Matrix P_m_; Vector cx_; Vector y_; Vector z_; // Parameters:  Vector x0_; Matrix P0_; Vector m0_; Matrix P0_m_; Matrix A_; Matrix B_; Vector g_; Matrix Q_; Matrix Q_m_; Matrix C_; Vector d_; Matrix Ke_; Matrix Ke_m_; }; // System  } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':71,'href':'/ldsctrlest/docs/api/files/lds__uniform__mats_8h/','title':"ldsCtrlEst_h/lds_uniform_mats.h",'section':"Files",'content':"ldsCtrlEst_h/lds_uniform_mats.h #  List of uniformly sized matrices. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::UniformMatrixList    Detailed Description #  This file provides a container for uniformly sized matrices. Users may specify one dimension to be free to vary in the list.\nSource code #  //===-- ldsCtrlEst_h/lds_uniform_mats.h - Uniform Matrices ------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_UNIFORM_MATS_H #define LDSCTRLEST_LDS_UNIFORM_MATS_H  #include \u0026lt;array\u0026gt; // std::array#include \u0026lt;vector\u0026gt; // std::vector #include \u0026#34;lds.h\u0026#34; namespace lds { template \u0026lt;MatrixListFreeDim D = kMatFreeDimNone\u0026gt; class UniformMatrixList : public std::vector\u0026lt;Matrix\u0026gt; { private: using std::vector\u0026lt;Matrix\u0026gt;::vector; using std::vector\u0026lt;Matrix\u0026gt;::operator=; using std::vector\u0026lt;Matrix\u0026gt;::operator[]; using std::vector\u0026lt;Matrix\u0026gt;::at; using std::vector\u0026lt;Matrix\u0026gt;::begin; using std::vector\u0026lt;Matrix\u0026gt;::end; using std::vector\u0026lt;Matrix\u0026gt;::size; public: UniformMatrixList() = default; explicit UniformMatrixList(const std::vector\u0026lt;Matrix\u0026gt;\u0026amp; mats, std::array\u0026lt;size_t, 2\u0026gt; dim = {0, 0}); explicit UniformMatrixList(std::vector\u0026lt;Matrix\u0026gt;\u0026amp;\u0026amp; mats, std::array\u0026lt;size_t, 2\u0026gt; dim = {0, 0}); UniformMatrixList(std::initializer_list\u0026lt;Matrix\u0026gt; mats, std::array\u0026lt;size_t, 2\u0026gt; dim = {0, 0}); UniformMatrixList(const UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; that); UniformMatrixList(UniformMatrixList\u0026lt;D\u0026gt;\u0026amp;\u0026amp; that) noexcept; ~UniformMatrixList() = default; const std::array\u0026lt;size_t, 2\u0026gt;\u0026amp; dim(size_t n = 0) const { return dim_.at(n); } size_t size() { return std::vector\u0026lt;Matrix\u0026gt;::size(); }; const Matrix\u0026amp; at(size_t n) { return std::vector\u0026lt;Matrix\u0026gt;::at(n); }; void Swap(Matrix\u0026amp; that, size_t n); UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; operator=(const UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; that); UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; operator=(UniformMatrixList\u0026lt;D\u0026gt;\u0026amp;\u0026amp; that) noexcept; private: void CheckDimensions(std::array\u0026lt;size_t, 2\u0026gt; dim); std::vector\u0026lt;std::array\u0026lt;size_t, 2\u0026gt;\u0026gt; dim_; }; template \u0026lt;MatrixListFreeDim D\u0026gt; inline void UniformMatrixList\u0026lt;D\u0026gt;::Swap(Matrix\u0026amp; that, size_t n) { // make sure request in range  if (n \u0026gt;= this-\u0026gt;size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Requested UniformMatrixList element out of bounds. Skipping.\\n\u0026#34;; return; } // check dim  bool does_match = true; if (!(D == kMatFreeDim1)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][0] == that.n_rows); } if (!(D == kMatFreeDim2)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][1] == that.n_cols); } if (!does_match) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot swap a UniformMatrixList element for an element of \u0026#34; \u0026#34;different size. Skipping.\\n\u0026#34;; return; } // if checks pass, perform swap  Matrix tmp = std::move((*this)[n]); (*this)[n] = std::move(that); that = std::move(tmp); if (D == kMatFreeDim1) { this-\u0026gt;dim_[n][0] = (*this)[n].n_rows; } if (D == kMatFreeDim2) { this-\u0026gt;dim_[n][1] = (*this)[n].n_cols; } } template \u0026lt;MatrixListFreeDim D\u0026gt; inline UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; UniformMatrixList\u0026lt;D\u0026gt;::operator=( const UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; that) { // check dimensions  if (!this-\u0026gt;empty()) { if (this-\u0026gt;size() != that.size()) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; matrices with \u0026#34; \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; matrices\u0026#34;; throw std::runtime_error(ss.str()); } // if dimensions a not zero and do not match, skip move with error message.  bool dims_nonzero = true; for (auto d : dim_) { if (!(D == kMatFreeDim1) \u0026amp;\u0026amp; d[0] \u0026lt; 1) { dims_nonzero = false; break; } if (!(D == kMatFreeDim2) \u0026amp;\u0026amp; d[1] \u0026lt; 1) { dims_nonzero = false; break; } } if (dims_nonzero) { bool does_match = true; if (!(D == kMatFreeDim1)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][0] == that.at(0).n_rows); } if (!(D == kMatFreeDim2)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][1] == that.at(0).n_cols); } if (!does_match) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign matrices of size \u0026#34; \u0026lt;\u0026lt; dim_[0][0] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; dim_[0][1] \u0026lt;\u0026lt; \u0026#34; with matrices of size \u0026#34; \u0026lt;\u0026lt; that.at(0).n_rows \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; that.at(0).n_cols; throw std::runtime_error(ss.str()); } } } for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { (*this)[k] = that[k]; dim_[k] = that.dim(k); } return (*this); } template \u0026lt;MatrixListFreeDim D\u0026gt; inline UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; UniformMatrixList\u0026lt;D\u0026gt;::operator=( UniformMatrixList\u0026lt;D\u0026gt;\u0026amp;\u0026amp; that) noexcept { // check dimensions  // if empty, assume a default constructed object and safe to move  if (!this-\u0026gt;empty()) { if (this-\u0026gt;size() != that.size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; matrices with \u0026#34; \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; matrices. Skipping.\\n\u0026#34;; return (*this); } // if dimensions a not zero and do not match, skip move with error message.  bool dims_nonzero = true; for (auto d : dim_) { if (!(D == kMatFreeDim1) \u0026amp;\u0026amp; (d[0] \u0026lt; 1)) { dims_nonzero = false; break; } if (!(D == kMatFreeDim2) \u0026amp;\u0026amp; (d[1] \u0026lt; 1)) { dims_nonzero = false; break; } } if (dims_nonzero) { bool does_match = true; if (!(D == kMatFreeDim1)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][0] == that.at(0).n_rows); } if (!(D == kMatFreeDim2)) { does_match = does_match \u0026amp;\u0026amp; (dim_[0][1] == that.at(0).n_cols); } if (!does_match) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot move a UniformMatrixList element for an element of \u0026#34; \u0026#34;different size. Skipping.\\n\u0026#34;; return (*this); } } } dim_ = that.dim_; std::vector\u0026lt;Matrix\u0026gt;::operator=(std::move(that)); return (*this); } template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(const std::vector\u0026lt;Matrix\u0026gt;\u0026amp; mats, std::array\u0026lt;size_t, 2\u0026gt; dim) : vector(mats) { CheckDimensions(dim); } template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(std::vector\u0026lt;Matrix\u0026gt;\u0026amp;\u0026amp; mats, std::array\u0026lt;size_t, 2\u0026gt; dim) : vector(std::move(mats)) { CheckDimensions(dim); }; template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(std::initializer_list\u0026lt;Matrix\u0026gt; mats, std::array\u0026lt;size_t, 2\u0026gt; dim) : vector(mats) { CheckDimensions(dim); }; template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(const UniformMatrixList\u0026lt;D\u0026gt;\u0026amp; that) : vector(that) { (*this) = that; } template \u0026lt;MatrixListFreeDim D\u0026gt; UniformMatrixList\u0026lt;D\u0026gt;::UniformMatrixList(UniformMatrixList\u0026lt;D\u0026gt;\u0026amp;\u0026amp; that) noexcept : vector(std::move(that)) { for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { dim_[k][0] = (*this)[k].n_rows; dim_[k][1] = (*this)[k].n_cols; } } template \u0026lt;MatrixListFreeDim D\u0026gt; void UniformMatrixList\u0026lt;D\u0026gt;::CheckDimensions(std::array\u0026lt;size_t, 2\u0026gt; dim) { // change behavior based on free dim D  if ((dim[0] == 0) \u0026amp;\u0026amp; !(D == kMatFreeDim1)) { dim[0] = this-\u0026gt;at(0).n_rows; } if ((dim[1] == 0) \u0026amp;\u0026amp; !(D == kMatFreeDim2)) { dim[1] = this-\u0026gt;at(0).n_cols; } // make sure dimensiolaties are all uniform  bool does_match(true); for (const Matrix\u0026amp; mat : *this) { if (!(D == kMatFreeDim1)) { does_match = does_match \u0026amp;\u0026amp; (mat.n_rows == dim[0]); } if (!(D == kMatFreeDim2)) { does_match = does_match \u0026amp;\u0026amp; (mat.n_cols == dim[1]); } if (!does_match) { throw std::runtime_error( \u0026#34;Dimensionality of one or more input matrices are not uniform.\u0026#34;); } } dim_ = std::vector\u0026lt;std::array\u0026lt;size_t, 2\u0026gt;\u0026gt;(this-\u0026gt;size(), dim); for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { dim_[k][0] = (*this)[k].n_rows; dim_[k][1] = (*this)[k].n_cols; } } } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':72,'href':'/ldsctrlest/docs/api/files/lds__uniform__systems_8h/','title':"ldsCtrlEst_h/lds_uniform_systems.h",'section':"Files",'content':"ldsCtrlEst_h/lds_uniform_systems.h #  List of uniformly sized Systems. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::UniformSystemList    Detailed Description #  This file provides a container for uniformly sized Systems.\nSource code #  //===-- ldsCtrlEst_h/lds_uniform_systems.h - Uniform Systems ----*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_UNIFORM_SYSTEMS_H #define LDSCTRLEST_LDS_UNIFORM_SYSTEMS_H  #include \u0026lt;array\u0026gt; // std::array#include \u0026lt;vector\u0026gt; // std::vector // namespace #include \u0026#34;lds.h\u0026#34;// System type #include \u0026#34;lds_sys.h\u0026#34; namespace lds { template \u0026lt;typename System\u0026gt; class UniformSystemList : public std::vector\u0026lt;System\u0026gt; { static_assert(std::is_base_of\u0026lt;lds::System, System\u0026gt;::value, \u0026#34;System must be derived from lds::System type.\u0026#34;); private: using std::vector\u0026lt;System\u0026gt;::vector; using std::vector\u0026lt;System\u0026gt;::operator=; using std::vector\u0026lt;System\u0026gt;::operator[]; using std::vector\u0026lt;System\u0026gt;::at; using std::vector\u0026lt;System\u0026gt;::begin; using std::vector\u0026lt;System\u0026gt;::end; using std::vector\u0026lt;System\u0026gt;::size; public: UniformSystemList() = default; explicit UniformSystemList(const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, std::array\u0026lt;size_t, 3\u0026gt; dim = {0, 0, 0}); explicit UniformSystemList(std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, std::array\u0026lt;size_t, 3\u0026gt; dim = {0, 0, 0}); UniformSystemList(std::initializer_list\u0026lt;System\u0026gt; systems, std::array\u0026lt;size_t, 3\u0026gt; dim = {0, 0, 0}); UniformSystemList(const UniformSystemList\u0026amp; that); UniformSystemList(UniformSystemList\u0026amp;\u0026amp; that) noexcept; ~UniformSystemList() = default; const std::array\u0026lt;size_t, 3\u0026gt;\u0026amp; dim() const { return dim_; } size_t size() { return std::vector\u0026lt;System\u0026gt;::size(); }; const System\u0026amp; at(size_t n) { return std::vector\u0026lt;System\u0026gt;::at(n); }; void Swap(System\u0026amp; that, size_t n); UniformSystemList\u0026amp; operator=(const UniformSystemList\u0026amp; that); UniformSystemList\u0026amp; operator=(UniformSystemList\u0026amp;\u0026amp; that) noexcept; private: void CheckDimensions(std::array\u0026lt;size_t, 3\u0026gt; dim); std::array\u0026lt;size_t, 3\u0026gt; dim_{}; }; template \u0026lt;typename System\u0026gt; inline void UniformSystemList\u0026lt;System\u0026gt;::Swap(System\u0026amp; that, size_t n) { // make sure request in range  if (n \u0026gt;= this-\u0026gt;size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Requested UniformSystemList element out of bounds. Skipping.\\n\u0026#34;; return; } // check dim  bool does_match = (dim_[0] == that.n_u()) \u0026amp;\u0026amp; (dim_[1] == that.n_x()) \u0026amp;\u0026amp; (dim_[2] == that.n_y()); if (!does_match) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot swap a UniformSystemList element for an element of \u0026#34; \u0026#34;different size. Skipping.\\n\u0026#34;; return; } // if checks pass, perform swap  System tmp = std::move((*this)[n]); (*this)[n] = std::move(that); that = std::move(tmp); } template \u0026lt;typename System\u0026gt; inline UniformSystemList\u0026lt;System\u0026gt;\u0026amp; UniformSystemList\u0026lt;System\u0026gt;::operator=( const UniformSystemList\u0026amp; that) { // check dimensions  if (!this-\u0026gt;empty()) { if (this-\u0026gt;size() != that.size()) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; systems with \u0026#34; \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; systems\u0026#34;; throw std::runtime_error(ss.str()); } if (dim_[0] + dim_[1] + dim_[2]) { std::array\u0026lt;size_t, 3\u0026gt; other_dim(that.dim()); if (dim_ != other_dim) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign systems of size \u0026#34; \u0026lt;\u0026lt; dim_[0] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; dim_[1] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; dim_[2] \u0026lt;\u0026lt; \u0026#34; with systems of size \u0026#34; \u0026lt;\u0026lt; other_dim[0] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; other_dim[1] \u0026lt;\u0026lt; \u0026#34;x\u0026#34; \u0026lt;\u0026lt; dim_[2]; throw std::runtime_error(ss.str()); } } } for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { (*this)[k] = that[k]; } return (*this); } template \u0026lt;typename System\u0026gt; inline UniformSystemList\u0026lt;System\u0026gt;\u0026amp; UniformSystemList\u0026lt;System\u0026gt;::operator=( UniformSystemList\u0026amp;\u0026amp; that) noexcept { // check dimensions  // if empty, assume a default constructed object and safe to move  if (!this-\u0026gt;empty()) { if (this-\u0026gt;size() != that.size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; systems with \u0026#34; \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; systems. Skipping.\\n\u0026#34;; return (*this); } // if dimensions a not zero and do not match, skip move with error message.  if (dim_[0] + dim_[1] + dim_[2]) { bool does_match = (dim_[0] == that.at(0).n_u()) \u0026amp;\u0026amp; (dim_[1] == that.at(0).n_x()) \u0026amp;\u0026amp; (dim_[2] == that.at(0).n_y()); if (!does_match) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot move a UniformSystemList element for an element of \u0026#34; \u0026#34;different size. Skipping.\\n\u0026#34;; return (*this); } } } dim_ = that.dim_; std::vector\u0026lt;System\u0026gt;::operator=(std::move(that)); return (*this); } template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList(const std::vector\u0026lt;System\u0026gt;\u0026amp; systems, std::array\u0026lt;size_t, 3\u0026gt; dim) : std::vector\u0026lt;System\u0026gt;(systems) { CheckDimensions(dim); } template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList(std::vector\u0026lt;System\u0026gt;\u0026amp;\u0026amp; systems, std::array\u0026lt;size_t, 3\u0026gt; dim) : std::vector\u0026lt;System\u0026gt;(std::move(systems)) { CheckDimensions(dim); }; template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList( std::initializer_list\u0026lt;System\u0026gt; systems, std::array\u0026lt;size_t, 3\u0026gt; dim) : std::vector\u0026lt;System\u0026gt;(systems) { CheckDimensions(dim); }; template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList(const UniformSystemList\u0026amp; that) : std::vector\u0026lt;System\u0026gt;(that) { (*this) = that; } template \u0026lt;typename System\u0026gt; UniformSystemList\u0026lt;System\u0026gt;::UniformSystemList(UniformSystemList\u0026amp;\u0026amp; that) noexcept : std::vector\u0026lt;System\u0026gt;(std::move(that)) { this-\u0026gt;dim_[0] = this-\u0026gt;at(0).n_u(); this-\u0026gt;dim_[1] = this-\u0026gt;at(0).n_x(); this-\u0026gt;dim_[2] = this-\u0026gt;at(0).n_y(); } template \u0026lt;typename System\u0026gt; void UniformSystemList\u0026lt;System\u0026gt;::CheckDimensions(std::array\u0026lt;size_t, 3\u0026gt; dim) { if (dim[0] + dim[1] + dim[2]) { dim_ = dim; } else { dim_[0] = this-\u0026gt;at(0).n_u(); dim_[1] = this-\u0026gt;at(0).n_x(); dim_[2] = this-\u0026gt;at(0).n_y(); } // make sure dimensiolaties are all uniform  bool does_match(true); for (const System\u0026amp; sys : *this) { does_match = does_match \u0026amp;\u0026amp; (sys.n_u() == dim_[0]); does_match = does_match \u0026amp;\u0026amp; (sys.n_x() == dim_[1]); does_match = does_match \u0026amp;\u0026amp; (sys.n_y() == dim_[2]); if (!does_match) { throw std::runtime_error( \u0026#34;Dimensionality of one or more input systems are not uniform.\u0026#34;); } } } } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':73,'href':'/ldsctrlest/docs/api/files/lds__uniform__vecs_8h/','title':"ldsCtrlEst_h/lds_uniform_vecs.h",'section':"Files",'content':"ldsCtrlEst_h/lds_uniform_vecs.h #  List of uniformly sized vectors. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::UniformVectorList    Detailed Description #  This file provides a container for uniformly sized vectors.\nSource code #  //===-- ldsCtrlEst_h/lds_uniform_vecs.h - Uniform Vectors -------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_UNIFORM_VECS_H #define LDSCTRLEST_LDS_UNIFORM_VECS_H  #include \u0026lt;array\u0026gt; // std::array#include \u0026lt;vector\u0026gt; // std::vector #include \u0026#34;lds.h\u0026#34; namespace lds { class UniformVectorList : public std::vector\u0026lt;Vector\u0026gt; { private: using std::vector\u0026lt;Vector\u0026gt;::vector; using std::vector\u0026lt;Vector\u0026gt;::operator=; using std::vector\u0026lt;Vector\u0026gt;::operator[]; using std::vector\u0026lt;Vector\u0026gt;::at; using std::vector\u0026lt;Vector\u0026gt;::begin; using std::vector\u0026lt;Vector\u0026gt;::end; using std::vector\u0026lt;Vector\u0026gt;::size; public: UniformVectorList() = default; explicit UniformVectorList(const std::vector\u0026lt;Vector\u0026gt;\u0026amp; vecs, size_t dim = 0); explicit UniformVectorList(std::vector\u0026lt;Vector\u0026gt;\u0026amp;\u0026amp; vecs, size_t dim = 0); UniformVectorList(std::initializer_list\u0026lt;Vector\u0026gt; vecs, size_t dim = 0); UniformVectorList(const UniformVectorList\u0026amp; that); UniformVectorList(UniformVectorList\u0026amp;\u0026amp; that) noexcept; ~UniformVectorList() = default; size_t dim() const { return dim_; } size_t size() { return std::vector\u0026lt;Vector\u0026gt;::size(); }; const Vector\u0026amp; at(size_t n) { return std::vector\u0026lt;Vector\u0026gt;::at(n); }; void Swap(Vector\u0026amp; that, size_t n); UniformVectorList\u0026amp; operator=(const UniformVectorList\u0026amp; that); UniformVectorList\u0026amp; operator=(UniformVectorList\u0026amp;\u0026amp; that) noexcept; private: void CheckDimensions(size_t dim); size_t dim_{}; }; inline void UniformVectorList::Swap(Vector\u0026amp; that, size_t n) { // make sure request in range  if (n \u0026gt;= this-\u0026gt;size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Requested UniformMatrixList element out of bounds. Skipping.\\n\u0026#34;; return; } // check dim  bool does_match = dim_ == that.n_elem; if (!does_match) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot swap a UniformMatrixList element for an element of \u0026#34; \u0026#34;different size. Skipping.\\n\u0026#34;; return; } // if checks pass, perform swap  Vector tmp = std::move((*this)[n]); (*this)[n] = std::move(that); that = std::move(tmp); } inline UniformVectorList\u0026amp; UniformVectorList::operator=( const UniformVectorList\u0026amp; that) { // check dimensions  if (!this-\u0026gt;empty()) { if (this-\u0026gt;size() != that.size()) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; vectors with \u0026#34; \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; vectors\u0026#34;; throw std::runtime_error(ss.str()); } if (dim_) { size_t other_dim(that.dim()); if (dim_ != other_dim) { std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;cannot reassign vectors of size \u0026#34; \u0026lt;\u0026lt; dim_ \u0026lt;\u0026lt; \u0026#34; with vectors of size \u0026#34; \u0026lt;\u0026lt; other_dim; throw std::runtime_error(ss.str()); } } } for (size_t k = 0; k \u0026lt; this-\u0026gt;size(); k++) { (*this)[k] = that[k]; } return (*this); } inline UniformVectorList\u0026amp; UniformVectorList::operator=( UniformVectorList\u0026amp;\u0026amp; that) noexcept { // check dimensions  if (!this-\u0026gt;empty()) { if (this-\u0026gt;size() != that.size()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot reassign \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;size() \u0026lt;\u0026lt; \u0026#34; vectors with \u0026#34; \u0026lt;\u0026lt; that.size() \u0026lt;\u0026lt; \u0026#34; vectors. Skipping.\\n\u0026#34;; return (*this); } if (dim_) { size_t other_dim(that.dim()); if (dim_ != other_dim) { std::cerr \u0026lt;\u0026lt; \u0026#34;Cannot reassign vectors of size \u0026#34; \u0026lt;\u0026lt; dim_ \u0026lt;\u0026lt; \u0026#34; with matrices of size \u0026#34; \u0026lt;\u0026lt; other_dim \u0026lt;\u0026lt; \u0026#34;. Skipping.\\n\u0026#34;; return (*this); } } } dim_ = that.dim_; std::vector\u0026lt;Vector\u0026gt;::operator=(std::move(that)); return (*this); } } // namespace lds  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':74,'href':'/ldsctrlest/docs/api/files/mex__c__util_8h/','title':"ldsCtrlEst_h/mex_c_util.h",'section':"Files",'content':"ldsCtrlEst_h/mex_c_util.h #  arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API) More\u0026hellip;\nNamespaces #     Name     armamexc arma/mex interface using Matlab C API    Detailed Description #  This file defines utility functions for interoperability between armadillo and Matlab/Octave\u0026rsquo;s C mex API.\nSource code #  //===-- ldsCtrlEst_h/mex_c_util.h - Mex C API Utilities ---------*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_MEXC_UTIL_H #define LDSCTRLEST_MEXC_UTIL_H  #include \u0026lt;ldsCtrlEst\u0026gt; #include \u0026#34;mex.h\u0026#34; // // If Matlab_FOUND, include matrix.h. // // (Octave does not need/have it.) // #ifdef Matlab_FOUND // #include \u0026#34;matrix.h\u0026#34; // #endif  namespace armamexc { template \u0026lt;class T\u0026gt; inline auto m2T_scalar(const mxArray *matlab_scalar) -\u0026gt; T { if (mxGetData(matlab_scalar)) { return static_cast\u0026lt;T\u0026gt;(mxGetScalar(matlab_scalar)); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return 0; } template \u0026lt;class T\u0026gt; inline auto m2a_mat(const mxArray *matlab_mat, bool copy_aux_mem = false, bool strict = true) -\u0026gt; arma::Mat\u0026lt;T\u0026gt; { if (mxGetData(matlab_mat)) { const mwSize n_dim = mxGetNumberOfDimensions(matlab_mat); if (n_dim == 2) { return arma::Mat\u0026lt;T\u0026gt;(static_cast\u0026lt;T *\u0026gt;(mxGetData(matlab_mat)), mxGetM(matlab_mat), mxGetN(matlab_mat), copy_aux_mem, strict); } mexErrMsgTxt(\u0026#34;Number of dimensions must be 2.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } // TODO(mfbolus): make these templated.  template \u0026lt;typename T\u0026gt; inline auto a2m_mat(arma::Mat\u0026lt;T\u0026gt; const \u0026amp;arma_mat) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_mat.n_rows, arma_mat.n_cols, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;T *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;T *\u0026gt;(arma_mat.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy.  std::memcpy(dst_pointer, src_pointer, sizeof(T) * arma_mat.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Mat.\u0026#34;); return nullptr; } template \u0026lt;typename T\u0026gt; inline auto a2m_vec(arma::Col\u0026lt;T\u0026gt; const \u0026amp;arma_vec) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_vec.n_elem, 1, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;T *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;T *\u0026gt;(arma_vec.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy.  std::memcpy(dst_pointer, src_pointer, sizeof(T) * arma_vec.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Col.\u0026#34;); return nullptr; } } // namespace armamexc  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':75,'href':'/ldsctrlest/docs/api/files/mex__cpp__util_8h/','title':"ldsCtrlEst_h/mex_cpp_util.h",'section':"Files",'content':"ldsCtrlEst_h/mex_cpp_util.h #  arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API) More\u0026hellip;\nNamespaces #     Name     armamexcpp arma/mex interface using Matlab C++ API    Detailed Description #  This file defines utility functions for interoperability between armadillo and Matlab\u0026rsquo;s C++ mex API.\nSource code #  //===-- ldsCtrlEst_h/mex_cpp_util.h - Mex C++ API Utilities -----*- C++ -*-===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_MEXCPP_UTIL_H #define LDSCTRLEST_MEXCPP_UTIL_H  #include \u0026lt;ldsCtrlEst\u0026gt; #include \u0026#34;mex.hpp\u0026#34;#include \u0026#34;mexAdapter.hpp\u0026#34; namespace armamexcpp { template \u0026lt;class T\u0026gt; auto m2a_cellmat(matlab::data::CellArray\u0026amp; matlab_cell) -\u0026gt; std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; { size_t n_cells = matlab_cell.getNumberOfElements(); std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; arma_mat(n_cells, arma::Mat\u0026lt;T\u0026gt;(1, 1, arma::fill::zeros)); for (size_t k = 0; k \u0026lt; n_cells; k++) { matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = matlab_cell[k]; auto dims = matlab_mat.getDimensions(); arma_mat[k] = arma::Mat\u0026lt;T\u0026gt;(matlab_mat.release().get(), dims[0], dims[1]); } return arma_mat; }; template \u0026lt;class T\u0026gt; auto m2s_vec(matlab::data::TypedArray\u0026lt;T\u0026gt;\u0026amp; matlab_array) -\u0026gt; std::vector\u0026lt;T\u0026gt; { size_t n_elem = matlab_array.getNumberOfElements(); T* ptr = matlab_array.release().get(); std::vector\u0026lt;T\u0026gt; vec(ptr, ptr + n_elem); return vec; }; template \u0026lt;class T\u0026gt; auto m2a_vec(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) -\u0026gt; arma::Col\u0026lt;T\u0026gt; { size_t n_elem = matlab_array.getNumberOfElements(); T* ptr = matlab_array.release().get(); arma::Col\u0026lt;T\u0026gt; vec(ptr, n_elem); //, false);  return vec; }; template \u0026lt;class T\u0026gt; auto m2a_mat(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) -\u0026gt; arma::Mat\u0026lt;T\u0026gt; { // ArrayDimensions == std::vector\u0026lt;size_t\u0026gt;  auto dims = matlab_array.getDimensions(); T* ptr = matlab_array.release().get(); // mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false)  arma::Mat\u0026lt;T\u0026gt; mat(ptr, dims[0], dims[1]); //, false);  return mat; }; template \u0026lt;class T\u0026gt; auto a2m_mat(const arma::Mat\u0026lt;T\u0026gt;\u0026amp; arma_mat, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {arma_mat.n_rows, arma_mat.n_cols}, arma_mat.memptr(), arma_mat.memptr() + arma_mat.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; auto a2m_vec(const arma::Col\u0026lt;T\u0026gt;\u0026amp; arma_vec, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;({arma_vec.n_elem, 1}, arma_vec.memptr(), arma_vec.memptr() + arma_vec.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; auto s2m_vec(const std::vector\u0026lt;T\u0026gt;\u0026amp; std_vec, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {std_vec.size(), 1}, std_vec.data(), std_vec.data() + std_vec.size()); return matlab_mat; }; } // namespace armamexcpp  #endif  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':76,'href':'/ldsctrlest/docs/terminology/model/','title':"Models",'section':"LDS C+E Documentation",'content':"Model Definitions #  This library provides methods for control and estimation of linear dynamical systems (LDS) of the following form:   \\[\\mathbf{x}_{t\u0026#43;1} = f\\left( \\mathbf{x}_{t}, \\mathbf{v}_{t} \\right) = \\mathbf{A} \\mathbf{x}_{t} \u0026#43; \\mathbf{B} \\mathbf{v}_{t} \u0026#43; \\mathbf{m}_{t} \u0026#43; \\mathbf{w}_{t}\\]   \\[\\mathbf{y}_{t} = h\\left( \\mathbf{x}_{t} \\right)\\]  t : time index x : system state v = g%u : input (e.g., in physical units used for model fit) u : control signal sent to actuator (e.g., in Volts) y : system output m : process disturbance w ~ N(0, Q) : process noise/disturbance A : state matrix B : input coupling matrix g : input gain (e.g., for converting to control signal actuator voltage) n.b., assumes this conversion is linear Q : process noise covariance % : element-wise multiplication  LDS with Gaussian Observations #  For linear dynamical systems whose outputs are assumed to be corrupted by additive Gaussian noise before measurement (Gaussian LDS models), the output function takes the following form.\n \\[\\mathbf{y}_{t} = \\mathbf{C} \\mathbf{x}_{t} \u0026#43; \\mathbf{d}\\]   \\[\\mathbf{z}_{t} \\sim \\mathcal{N}\\left(\\mathbf{y}_{t} , \\mathbf{R} \\right)\\]  z : measurement C : output matrix d : output bias R : measurement noise covariance  LDS with Poisson Observations #  For linear dynamical systems whose outputs are assumed to be rates underlying measured count data derived from a Poisson distribution (Poisson LDS models), the output function takes the following form. Note an element-wise exponentiation is used to rectify the linear dynamics for the rate of the Poisson process.\n \\[y_{t}^{i} = \\exp \\left(\\mathbf{c}^i \\mathbf{x}_{t} \u0026#43; d^i\\right)\\]   \\[z_{t}^i \\sim \\rm{Poisson} \\left(y_{t}^i \\right)\\]  i : output index z : measurement (count data) c : i^th row of output matrix (C) d : output bias  "});index.add({'id':77,'href':'/ldsctrlest/docs/api/modules/','title':"Modules",'section':"LDS C+E Documentation",'content':"Modules #    Control Mode Bit Masks provides fill types for constructing new armadillo vectors, matrices\n  Defaults\n   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':78,'href':'/ldsctrlest/docs/api/namespaces/','title':"Namespaces",'section':"LDS C+E Documentation",'content':"Namespaces #    armamexc arma/mex interface using Matlab C API\n  armamexcpp arma/mex interface using Matlab C++ API\n  lds::gaussian Linear Dynamical Systems with Gaussian observations.\n  lds::poisson Linear Dynamical Systems with Poisson observations.\n  std\n   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':79,'href':'/ldsctrlest/docs/api/pages/','title':"Pages",'section':"LDS C+E Documentation",'content':"Pages #   Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':80,'href':'/ldsctrlest/docs/tutorials/eg_plds_state_estimation/','title':"PLDS State Estimation",'section':"LDS C+E Examples",'content':"PLDS State Estimation Tutorial #  This tutorial shows how to use this library to estimate the state of an LDS with Poisson observations from input/output data. In place of a physical system, another PLDS model (lds::poisson::System) receives random inputs and provides measurements for the state estimator. For the sake of example, the only parameter mismatch is assumed to be the process disturbance, which is adaptively re-estimated.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; Note that lds::Matrix and lds::Vector are typedefs for arma::Mat\u0026lt;data_t\u0026gt; and arma::Col\u0026lt;data_t\u0026gt;, where the data type is double by default. May be changed to float in include/ldsCtrlEst_h/lds.h if there are memory constraints (e.g., large-scale MIMO control problems).\nCreating a simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation. When a system is initialized, rather than requiring all parameters be provided at construction, users may create a default system by setting only the dimensions and sample period.\n// construct ground truth system...  lds::poisson::System system_true(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example,   \\[x_{t\u0026#43;1} = x_t \u0026#43; w_t\\]   \\[y_{t} = \\exp\\left(x_t\\right)\\]  where  \\( w_{t} \\sim \\mathcal{N}\\left( 0, Q \\right) \\)  .\nNow, create non-default parameters for this model.\n// Model parameters  Matrix a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); Matrix b_true = Matrix(n_x, n_u).fill(1e-2); Vector m0_true = Vector(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  Vector x0_true = m0_true * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state Finally, assign the parameters using corresponding set-methods.\n// Assign params.  system_true.set_A(a_true); system_true.set_B(b_true); system_true.set_x0(x0_true); system_true.set_m(m0_true); system_true.Reset(); Creating the estimator #  Now, create the estimator. The system type includes filtering functionality for state estimation, so create another lds::poisson::System. As noted above, the only parameter mismatch in this simulation will be the process disturbance.\n// Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::System system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  Vector m0_est = m0_true * 2; system_estimator.set_m(m0_est); // set new initial conditions  Vector x0_est = m0_est * arma::inv(Matrix(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.set_x0(x0_est); system_estimator.Reset(); // reset to initial condition. To ensure robust estimates, adaptively re-estimate the process disturbance.\n// turn on adaptive disturbance estimation  system_estimator.do_adapt_m = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  Matrix q_m = Matrix(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.set_Q_m(q_m); Simulating estimation #  In this demonstration, random inputs are presented to the system, measurements are taken, and filtering is carried out in a for-loop.\n// Simlate the true system.  z.col(t) = system_true.Simulate(u.col(t - 1)); // Filter (predict -\u0026gt; update)  system_estimator.Filter(u.col(t - 1), z.col(t)); Example simulation result #  Below are example results for this simulation, including outputs, latent states, process disturbance, and the input. The online estimates of the output, state, and disturbance are given in purple.\nWith this parameterization, it takes the estimator approximately 5 seconds to minimize state error. The state and output error distributions for the period after 5 seconds is shown below.\n"});index.add({'id':81,'href':'/ldsctrlest/docs/tutorials/eg_switched_plds_control/','title':"PLDS Switched Control",'section':"LDS C+E Examples",'content':"PLDS Switched Control Tutorial #  This tutorial shows how to use this library to control a system with a switched PLDS controller (lds::poisson::SwitchedController). This type of controller is applicable in scenarios where a physical system is not accurately captured by a single LDS but has multiple discrete operating modes where the dynamics can be well-approximated as linear.\nIn the example that follows, another PLDS model (lds::poisson::System) is used in place of a physical system. It receives control inputs and provides measurements for the simulated feedback control loop. This system stochastically flips between two input gains. Here, the controller is assumed to have a perfect model of the switching system being controlled. Note that in practice, users would need to have a decoder that estimates operating mode of the physical system being controlled. This library does not currently include operating mode estimation.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::Matrix; using lds::Vector; using lds::data_t; using std::cout; Note that lds::Matrix and lds::Vector are typedefs for arma::Mat\u0026lt;data_t\u0026gt; and arma::Col\u0026lt;data_t\u0026gt;, where the data type is double by default. May be changed to float in include/ldsCtrlEst_h/lds.h if there are memory constraints (e.g., large-scale MIMO control problems).\nCreating the simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// whether to do switched control  bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  auto n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); The system\u0026rsquo;s input matrix (B) will be switched stochastically from one value (b1) to a less sensitive value (b2) according to the following probabilities.\n// for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1 Initially, the system will be in \u0026ldquo;mode\u0026rdquo; 1, where B = b1.\n// simulated system being controlled  lds::poisson::System controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  data_t scale_sys_b = 2; Matrix a(n_x, n_x, arma::fill::eye); a[0] = 0.985; Matrix b1 = Matrix(n_x, n_u).fill(0.05); Vector d = Vector(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.set_A(a); controlled_system.set_B(b1); controlled_system.set_d(d); controlled_system.Reset(); // reset to initial conditions See the GLDS Control and PLDS State Estimation tutorials for more detail about creating System objects.\nCreating the controller #  Now, create the controller. A switched-system controller (SwitchedController) essentially toggles between the parameters of its subsystems when the controller is told a switch has occured. The first thing the user needs to do is define these subsystems. In this example, there are two Poisson systems (sys1, sys2), which are the same save for their input gains.\nSimilar to a non-switched controller, constructing a SwitchedController requires these system models and upper/lower bounds on control. See the GLDS Control tutorial for more details. In the case of a SwitchedController, it needs a list of systems, using the std::vector container.\nMoreover, when assigning control-related signals such as the feedback controller gains, it is crucial that the list of gains optimized for each operating mode of the system have the same dimensionality. For this reason, this library provides UniformMatrixList and UniformVectorList containers that should be used when setting Kc, Kc_inty, g_design. These containers are std::vectors whose contents are uniformly sized.\nPutting this information together, here is how to create the controller and the list of controller gains optimized for each system operating mode.\n// create switched controller  lds::poisson::SwitchedController switched_controller; lds::UniformMatrixList\u0026lt;\u0026gt; k_x; // feedback controller gains  { // create switched controller sub-systems  // system 1  lds::poisson::System sys1(controlled_system); // set process noise covariance  Matrix q_controller = Matrix(n_x, n_x, arma::fill::eye) * 5e-3; sys1.set_Q(q_controller); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  sys1.do_adapt_m = true; // setting initial mode to target to avoid large error at onset:  Vector x0_controller = arma::log(y_ref0) - d; sys1.set_x0(x0_controller); sys1.Reset(); // reset to initial conditions  cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys1.Print(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // system 2  lds::poisson::System sys2 = sys1; // set parameters  sys2.set_B(b2); lds::UniformSystemList\u0026lt;lds::poisson::System\u0026gt; systems({sys1, sys2}); // controller gains for underlying systems:  Matrix k_x1(n_u, n_x, arma::fill::ones); Matrix k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  k_x = lds::UniformMatrixList\u0026lt;\u0026gt;({k_x1, k_x2}); data_t u_lb = 0.0; data_t u_ub = 5.0; switched_controller = std::move( lds::poisson::SwitchedController(std::move(systems), u_lb, u_ub)); } Note that the above code block demonstrates how move semantics can be used for assignment/construction. Copy assignment/construction is of course also allowed.\nNow that the SwitchedController is instantiated, assign its parameters.\n// Control variables  size_t control_type = 0; // no integral action, etc  switched_controller.set_control_type(control_type); switched_controller.set_Kc(std::move(k_x)); switched_controller.set_y_ref(y_ref0); Simulating control #  In this demonstration, we will use the ControlOutputReference method which allows users to simply set the reference output event rate (y_ref) and supply the current measurement z. It then calculates the solution for the state/input required to track that output at steady state. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system. Importantly, this method performs control in the linear state space (i.e., taking the logarithm of the reference output).\nThe control loop is carried out here in a simple for-loop, controlled system is simulated along with stochastic mode switches, a measurement taken, and the control signal updated.\n// Let the controlled system stachastically change gain  // Assume another algorithm decodes this mode change and signals the  // switched_controller  Vector chance(1, arma::fill::randu); if (which_mode == 1) // mode1  { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.set_B(b2); if (do_switch_ctrl) { switched_controller.Switch(1); } } } else { // mode2  if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.set_B(b1); if (do_switch_ctrl) { switched_controller.Switch(0); } } } // Simulate the true system.  z.col(t) = controlled_system.Simulate(u.col(t - 1)); // perform control  u.col(t) = switched_controller.ControlOutputReference(z.col(t)); Note that as the gain of the controlled system changes stochastically, the controller is informed of this change. In practice, a user must decode such changes in the system\u0026rsquo;s operating mode and call the Switch method accordingly. Such a decoder is not currently included in this library.\nExample simulation result #  Below are example results for this simulation, including outputs, latent states, mode switches, and the control signal. The controller\u0026rsquo;s online estimates of the output and state are shown in purple.\nNote that every time the operating mode of the system changes (here, a gain changes), the controller immediately adjusts its inputs. In contrast, a non-switched controller with integral action would also compensate but do so in a comparitively sluggish fashion.\n"});index.add({'id':82,'href':'/ldsctrlest/docs/api/files/dir_68267d1309a1af8e8297ef4c3efbcdba/','title':"src",'section':"Files",'content':"src #  Files #     Name     src/lds.cpp misc lds namespace functions   src/lds_gaussian_sys.cpp GLDS base type.   src/lds_poisson_sys.cpp PLDS base type.   src/lds_sys.cpp LDS base type.   src/lds_uniform_vecs.cpp Uniformly sized vectors.     Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':83,'href':'/ldsctrlest/docs/api/files/lds_8cpp/','title':"src/lds.cpp",'section':"Files",'content':"src/lds.cpp #  misc lds namespace functions More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Detailed Description #  This file implements miscellaneous lds namespace functions not bound to a class.\nSource code #  //===-- lds.cpp - LDS -----------------------------------------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; // insert any necessary function definitions here. namespace lds { void ForceSymPD(Matrix\u0026amp; X) { if (X.is_sympd() || !X.is_square()) { return; } // make symmetric  X = (X + X.t()) / 2; Vector d; Matrix u; arma::eig_sym(d, u, X, \u0026#34;std\u0026#34;); Matrix d_diag = arma::diagmat(abs(d)); // force to be positive...  X = u * d_diag * u.t(); } void ForceSymMinEig(Matrix\u0026amp; X, data_t eig_min) { if (!X.is_square()) { return; } Vector d; Matrix u; arma::eig_sym(d, u, X);//, \u0026#34;std\u0026#34;);  Limit(d, eig_min, kInf);//enforce lower bound  Matrix d_diag = arma::diagmat(d); X = u * d_diag * u.t(); // make symmetric  X = (X + X.t()) / 2; } void lq(Matrix\u0026amp; L, Matrix\u0026amp; Qt, const Matrix\u0026amp; X) { arma::qr_econ(Qt, L, X.t()); arma::inplace_trans(L); arma::inplace_trans(Qt); } Matrix calcCov(const Matrix\u0026amp; A, const Matrix\u0026amp; B) { // subtract out mean  auto m_a = arma::mean(A, 1); Matrix a0 = A; a0.each_col() -= m_a; auto m_b = arma::mean(B, 1); Matrix b0 = B; b0.each_col() -= m_b; Matrix cov = a0 * b0.t() / a0.n_cols; return cov; } } // namespace lds  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':84,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sys_8cpp/','title':"src/lds_gaussian_sys.cpp",'section':"Files",'content':"src/lds_gaussian_sys.cpp #  GLDS base type. More\u0026hellip;\nDetailed Description #  This file implements the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems (lds::gaussian::sys_t). It inherits functionality from the underlying linear dynamical system (lds::sys_t).\nSource code #  //===-- lds_gaussian_sys.cpp - GLDS ---------------------------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; lds::gaussian::System::System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0, data_t q0, data_t r0) : lds::System(n_u, n_x, n_y, dt, p0, q0) { R_.zeros(n_y, n_y); R_.diag().fill(r0); do_recurse_Ke_=true; }; // recursively estimate Ke void lds::gaussian::System::RecurseKe() { if (!do_recurse_Ke_) { return; } // predict covariance  P_ = A_ * P_ * A_.t() + Q_; // calc Kalman gain  Ke_ = P_ * C_.t() * inv_sympd(C_ * P_ * C_.t() + R_); // update covariance  // Reference: Ghahramani et Hinton (1996)  P_ = P_ - Ke_ * C_ * P_; if (do_adapt_m) { P_m_ += Q_m_; // A_m = I (i.e., random walk)  Ke_m_ = P_m_ * C_.t() * inv_sympd(C_ * P_m_ * C_.t() + R_); P_m_ = P_m_ - Ke_m_ * C_ * P_m_; } } // Simulate const lds::Vector\u0026amp; lds::gaussian::System::Simulate(const Vector\u0026amp; u_tm1){ f(u_tm1, true);//simulate dynamics with noise added  h();//output  z_ = y_ + arma::mvnrnd(Vector(n_y_).fill(0), R_);//measure  return z_; } void lds::gaussian::System::Print() { lds::System::Print(); std::cout \u0026lt;\u0026lt; \u0026#34;R: \\n\u0026#34; \u0026lt;\u0026lt; R_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':85,'href':'/ldsctrlest/docs/api/files/lds__poisson__sys_8cpp/','title':"src/lds_poisson_sys.cpp",'section':"Files",'content':"src/lds_poisson_sys.cpp #  PLDS base type. More\u0026hellip;\nDetailed Description #  This file implements the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems (lds::poisson::sys_t). It inherits functionality from the underlying linear dynamical system (lds::sys_t).\nSource code #  //===-- lds_poisson_sys.cpp - PLDS ----------------------------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; lds::poisson::System::System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0, data_t q0) : lds::System(n_u, n_x, n_y, dt, p0, q0) { diag_y_ = diagmat(y_); chance_ = Vector(n_y, fill::randu); }; // Correct: Given measurement (z) and current input (u), update estimate of the // state, covar, output. // // see Eden et al. 2004 void lds::poisson::System::RecurseKe() { // predict covariance  P_ = A_ * P_ * A_.t() + Q_; // update cov  P_ = pinv(pinv(P_) + C_.t() * diag_y_ * C_); Ke_ = P_ * C_.t(); if (do_adapt_m) { P_m_ += Q_m_; // predict (A_m = I)  P_m_ = pinv(pinv(P_m_) + C_.t() * diag_y_ * C_); // update  Ke_m_ = P_m_ * C_.t(); } } // Measurement: z ~ Poisson(y) // n.b., In reality, this is only Poisson where rate `y` and sample period `dt` // are sufficiently small there is only ever 0 or 1 events in a period. If // either of those is violated, results will be innacurate. // Simulate const lds::Vector\u0026amp; lds::poisson::System::Simulate(const Vector\u0026amp; u_tm1) { f(u_tm1, true); // simulate dynamics with noise added  h(); // output  chance_.randu(n_y_); z_.zeros(); for (std::size_t k = 0; k \u0026lt; n_y_; k++) { if ((y_[k]) \u0026gt; chance_[k]) { z_[k] = 1.0; } } return z_; } // ******************* SYS_T *******************  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':86,'href':'/ldsctrlest/docs/api/files/lds__sys_8cpp/','title':"src/lds_sys.cpp",'section':"Files",'content':"src/lds_sys.cpp #  LDS base type. More\u0026hellip;\nDetailed Description #  This file implements the base type for linear dynamical systems (lds::System). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code #  //===-- lds_sys.cpp - LDS -------------------------------------------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; lds::System::System(size_t n_u, size_t n_x, size_t n_y, data_t dt, data_t p0, data_t q0) : n_u_(n_u), n_x_(n_x), n_y_(n_y), dt_(dt) { InitVars(p0, q0); } lds::System::System(const Matrix\u0026amp; A, const Matrix\u0026amp; B, const Vector\u0026amp; g, const Vector\u0026amp; m, const Matrix\u0026amp; Q, const Matrix\u0026amp; C, const Vector\u0026amp; d, const Vector\u0026amp; x0, const Matrix\u0026amp; P0, data_t dt) : dt_(dt) { InitVars(); A_ = A; B_ = B; g_ = g; m_ = m; Q_ = Q; C_ = C; d_ = d; x0_ = x0; P0_ = P0; } void lds::System::InitVars(data_t p0, data_t q0) { // initial conditions.  x0_ = Vector(n_x_, fill::zeros); // includes bias (nY) and g (nU)  P0_ = p0 * Matrix(n_x_, n_x_, fill::eye); m0_ = x0_; P0_m_ = P0_; // signals  x_ = x0_; P_ = P0_; m_ = m0_; P_m_ = P0_m_; y_ = Vector(n_y_, fill::zeros); cx_ = Vector(n_y_, fill::zeros); z_ = Vector(n_y_, fill::zeros); // By default, random walk where each state is independent  // In this way, provides independent estimates of rate per channel of output.  A_ = Matrix(n_x_, n_x_, fill::eye); B_ = Matrix(n_x_, n_u_, fill::zeros); g_ = Vector(n_u_, fill::ones); Q_ = q0 * Matrix(n_x_, n_x_, fill::eye); Q_m_ = Q_; C_ = Matrix(n_y_, n_x_, fill::eye); // each state will map to an output by  d_ = Vector(n_y_, fill::zeros); Ke_ = Matrix(n_x_, n_y_, fill::zeros); // estimator gain.  Ke_m_ = Matrix(n_x_, n_y_, fill::zeros); // estimator gain for m adaptation.  do_adapt_m = false; } // Filter: Given measurement (`z`) and previous input (`u_tm1`), predict state // and update estimate of the state, covar, output using Kalman filter void lds::System::Filter(const Vector\u0026amp; u_tm1, const Vector\u0026amp; z_t) { // predict mean  f(u_tm1); // dynamics  h(); // output  // recursively calculate esimator gains (or just keep existing values)  // (also predicts+updates estimate covariance)  RecurseKe(); // update  x_ += Ke_ * (z_t - y_); if (do_adapt_m) { m_ += Ke_m_ * (z_t - y_); // adaptively estimating disturbance  } // With new state, estimate output.  h(); // --\u0026gt; posterior } void lds::System::Reset() { // reset to initial conditions  x_ = x0_; // mean  P_ = P0_; // cov of state estimate  m_ = m0_; // process disturbance  P_m_ = P0_m_; // cov of disturbance estimate  h(); } void lds::System::Print() { std::cout \u0026lt;\u0026lt; \u0026#34;\\n********** SYSTEM ********** \\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;x: \\n\u0026#34; \u0026lt;\u0026lt; x_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;P: \\n\u0026#34; \u0026lt;\u0026lt; P_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;A: \\n\u0026#34; \u0026lt;\u0026lt; A_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;B: \\n\u0026#34; \u0026lt;\u0026lt; B_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;g: \\n\u0026#34; \u0026lt;\u0026lt; g_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;m: \\n\u0026#34; \u0026lt;\u0026lt; m_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Q: \\n\u0026#34; \u0026lt;\u0026lt; Q_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Q_m: \\n\u0026#34; \u0026lt;\u0026lt; Q_m_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;d: \\n\u0026#34; \u0026lt;\u0026lt; d_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;C: \\n\u0026#34; \u0026lt;\u0026lt; C_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;y: \\n\u0026#34; \u0026lt;\u0026lt; y_ \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } //******************* SYS_T *******************  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':87,'href':'/ldsctrlest/docs/api/files/lds__uniform__vecs_8cpp/','title':"src/lds_uniform_vecs.cpp",'section':"Files",'content':"src/lds_uniform_vecs.cpp #  Uniformly sized vectors. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Detailed Description #  This file provides a container for uniformly sized vectors.\nSource code #  //===-- ldsCtrlEst_h/lds_uniform_vecs.cpp - Uniform Matrices --------------===// // // Copyright 2021 Georgia Institute of Technology // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // Limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; namespace lds { UniformVectorList::UniformVectorList(const std::vector\u0026lt;Vector\u0026gt;\u0026amp; vecs, size_t dim) : vector(vecs) { CheckDimensions(dim); } UniformVectorList::UniformVectorList(std::vector\u0026lt;Vector\u0026gt;\u0026amp;\u0026amp; vecs, size_t dim) : vector(std::move(vecs)) { CheckDimensions(dim); }; UniformVectorList::UniformVectorList(std::initializer_list\u0026lt;Vector\u0026gt; vecs, size_t dim) : vector(vecs) { CheckDimensions(dim); }; UniformVectorList::UniformVectorList(const UniformVectorList\u0026amp; that) : vector(that) { (*this) = that; } UniformVectorList::UniformVectorList(UniformVectorList\u0026amp;\u0026amp; that) noexcept : vector(std::move(that)) { this-\u0026gt;dim_ = this-\u0026gt;at(0).n_elem; } void UniformVectorList::CheckDimensions(size_t dim) { if (dim) { dim_ = dim; } else { dim_ = this-\u0026gt;at(0).n_elem; } // make sure dimensiolaties are all uniform  bool does_match(true); for (const Vector\u0026amp; vec : *this) { does_match = does_match \u0026amp;\u0026amp; (vec.n_elem == dim_); if (!does_match) { throw std::runtime_error( \u0026#34;Dimensionality of one or more input matrices are not uniform.\u0026#34;); } } } } // namespace lds  Updated on 22 March 2021 at 22:01:30 CDT\n"});index.add({'id':88,'href':'/ldsctrlest/docs/api/namespaces/namespacestd/','title':"std",'section':"Namespaces",'content':"std #   Updated on 22 March 2021 at 22:01:30 CDT\n"});})();