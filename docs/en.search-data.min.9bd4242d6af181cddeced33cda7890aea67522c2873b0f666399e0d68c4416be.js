'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/ldsctrlest/docs/','title':"LDS C+E Documentation",'section':"LDS Control \u0026 Estimation",'content':"LDS Control \u0026amp; Estimation Documentation #  "});index.add({'id':1,'href':'/ldsctrlest/docs/tutorials/','title':"LDS C+E Examples",'section':"LDS C+E Documentation",'content':"Examples #  "});index.add({'id':2,'href':'/ldsctrlest/acknowledgements/','title':"Acknowledgements",'section':"LDS Control \u0026 Estimation",'content':"Acknowledgements #  Development and publication of this library was supported in part by the NIH/NINDS Collaborative Research in Computational Neuroscience (CRCNS)/BRAIN Grant 5R01NS115327-02.\n"});index.add({'id':3,'href':'/ldsctrlest/docs/getting-started/','title':"Getting Started",'section':"LDS C+E Documentation",'content':"Downloading the Library #  The source code for this library can be downloaded from stanley-rozell/ldsCtrlEst either by downloading a snapshot or cloning the repository via git.\ngit clone https://github.com/stanley-rozell/ldsCtrlEst.git By default, this would check out the master branch. In most cases, we suggest downloading or checking out the latest release instead.\ncd /path/to/ldsCtrlEst git checkout 0.5.0 Dependencies #  Note that the primary dependencies of this project listed below must be installed along with their header files and with CMake config files or pkg-config files. The latter files are used to configure this project\u0026rsquo;s build. It is strongly encouraged to install the dependencies below using a package manager (e.g., apt, pacman, macports).\n For project configuration, install cmake as well as pkg-config. The latter is optional. The linear algebra library armadillo is used throughout this repository. The HDF5 library is used to save output from example test programs. For use of this library in Matlab executables (mex) on Linux operating systems, you will need OpenBlas, ensuring the static library libopenblas.a is installed. You will also need to install gfortran.  Compilation + Installation #  This project is configured/compiled/installed by way of CMake and (on Unix-based operating systems) GNU Make. For configuration with CMake, there are three available options.\n LDSCTRLEST_BUILD_EXAMPLES : [default= ON] whether to build example programs located under examples/ in the source tree LDSCTRLEST_BUILD_FIT : [default=OFF] whether to build the auxiliary fitting portion of the source code that is not pertinent to control implementation LDSCTRLEST_BUILD_STATIC : [default=OFF] whether to statically link against OpenBLAS and create a static ldsCtrlEst library for future use  n.b., If both options 2 and 3 are enabled, Matlab/Octave mex functions will be compiled for exposing some of the fitting functionality to Matlab/Octave.\nBelow are example usages of cmake/make to configure/build the library.\n  For basic project build \u0026amp; install\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake .. #configure build make #build the project sudo make install #[optional] installs to default location (OS-specific)   To set the install prefix\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DCMAKE_INSTALL_PREFIX=/your/install/prefix .. #configure build with chosen install location make #build the project make install #install to /your/install/prefix   To build the entire project including fit code, a static library for Matlab compatibility, and the included Matlab mex functions for fitting GLDS/PLDS models.\ncd /path/to/repository mkdir build \u0026amp;\u0026amp; cd build cmake -DLDSCTRLEST_BUILD_FIT=1 -DLDSCTRLEST_STATIC_OPENBLAS=1 .. #configure to build the fitting portion of library and statically link openblas and ldsCtrlEst to mex files make #build the project n.b., If you choose not to install the library or install it to the non-default location, ensure you have updated the following environment variables on Unix-based operating systems.\n LD_LIBRARY_PATH: search path for dynamically loaded libraries PKG_CONFIG_PATH: search path for pkg-config tool CMAKE_PREFIX_PATH: search path of prefix where CMake will look for package config files  e.g., Assuming you set -DCMAKE_INSTALL_PREFIX=/your/install/prefix during project configuration and your login shell uses the ~/.profile startup file, open ~/.profile in a text editor and add \u0026hellip;\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/your/install/prefix/lib export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix/lib/pkgconfig export CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix   Common issues #   \u0026ldquo;I have installed all the dependencies including gfortran with a package manager as suggested; however, cmake complains it cannot find the gfortran library.\u0026rdquo;  When gfortran is installed, its library is usually not installed in a standard location like /usr/lib. gfortran is part of the gcc suite, so their libraries are organized together. e.g., When you install gfortran on Ubuntu using apt, its location is /usr/lib/gcc/x86_64-linux-gnu/9, in the case that gcc version 9 is installed. The build configuration script in ldsCtrlEst is written to add LD_LIBRARY_PATH (Unix) or PATH (Windows) to the CMake library search path on Unix or Windows systems, respectively. Therefore, to fix this issue, simply add the directory in which libgfortran was installed to the OS-appropriate environment variable. Continuing with the Ubuntu example above and assuming a Unix login shell whose startup file is ~/.profile, add the following to the file.\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/gcc/x86_64-linux-gnu/9 \u0026ldquo;I have built the library and installed it in a non-default location. In building my own project linking against ldsCtrlEst, cmake or pkg-config cannot find the library or its configuration information.\u0026rdquo;  If cmake and/or pkg-config cannot find the required configuration files for your project to link against ldsCtrlEst, make sure that these utilities know to look for them in the non-default location where you installed the library. For cmake this means adding your chosen install prefix to the environment variable CMAKE_PREFIX_PATH. Similarly, for pkg-config you need to add your/install/prefix/lib/pkgconfig to its search path, PKG_CONFIG_PATH. Assuming a Unix shell whose login startup file is ~/.profile and ldsCtrlEst was installed using prefix your/install/prefix, add the following to .profile.\nexport CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:/your/install/prefix export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/your/install/prefix "});index.add({'id':4,'href':'/ldsctrlest/issues-contributing/','title':"Issues Contributing",'section':"LDS Control \u0026 Estimation",'content':"Reporting Issues #  If you encounter bugs when using this library or have specific feature requests that you believe fall within the stated scope of this project, please open an issue on GitHub and use an appropriate issue template where possible. You may also fork the repository and submit pull-requests with your suggested changes.\nContributing #  We welcome any community contributions to this project. Please fork the repository and if possible use clang-format and clang-tidy to conform to the coding format/style of this repository.\n"});index.add({'id':5,'href':'/ldsctrlest/docs/api/namespaces/namespacearmamexc/','title':"armamexc",'section':"Namespaces",'content':"armamexc #  arma/mex interface using Matlab C API More\u0026hellip; Functions #      Name     template \u0026lt;class T \u0026gt; auto m2T_scalar(const mxArray * matlab_scalar)\nConvert Matlab mxArray to scalar of type T.   template \u0026lt;class T \u0026gt; auto m2a_mat(const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true)\nConvert matlab matrix to armadillo.   auto a2m_mat(arma::Mat\u0026lt; double \u0026gt; const \u0026amp; arma_mat)\nConvert armadillo to matlab matrix.   auto a2m_vec(arma::Col\u0026lt; double \u0026gt; const \u0026amp; arma_vec)\nConvert armadillo to matlab vector.    Detailed Description #  Utilities for arma/mex interface using Matlab C API\nFunction Details #  m2T_scalar #  template \u0026lt;class T \u0026gt; inline auto m2T_scalar( const mxArray * matlab_scalar ) Parameters:\n matlab_scalar matlab scalar  Template Parameters:\n T type  Return: scalar of type T\nm2a_mat #  template \u0026lt;class T \u0026gt; inline auto m2a_mat( const mxArray * matlab_mat, bool copy_aux_mem =false, bool strict =true ) Parameters:\n matlab_mat matlab matrix copy_aux_mem [optional] whether to copy auxiliary memory strict [optional] strictly enforce the above  Template Parameters:\n T type  Return: armadillo matrix of type T\na2m_mat #  inline auto a2m_mat( arma::Mat\u0026lt; double \u0026gt; const \u0026amp; arma_mat ) Parameters:\n arma_mat armadillo matrix  Return: matlab matrix\na2m_vec #  inline auto a2m_vec( arma::Col\u0026lt; double \u0026gt; const \u0026amp; arma_vec ) Parameters:\n arma_vec armadillo vector  Return: matlab vector\n Updated on 3 March 2021 at 23:06:11 CST\n"});index.add({'id':6,'href':'/ldsctrlest/docs/api/namespaces/namespacearmamexcpp/','title':"armamexcpp",'section':"Namespaces",'content':"armamexcpp #  arma/mex interface using Matlab C++ API More\u0026hellip; Functions #      Name     template \u0026lt;class T \u0026gt; auto m2a_cellmat(matlab::data::CellArray \u0026amp; matlab_cell)\nConvert matlab cell array to vector of armadillo matrices.   template \u0026lt;class T \u0026gt; auto m2s_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array)\nConvert matlab matrix to a vector of scalars.   template \u0026lt;class T \u0026gt; auto m2a_vec(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo vector.   template \u0026lt;class T \u0026gt; auto m2a_mat(matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array)\nConvert matlab to armadillo matrix.   template \u0026lt;class T \u0026gt; auto a2m_mat(arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab matrix.   template \u0026lt;class T \u0026gt; auto a2m_vec(arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert armadillo to matlab vector.   template \u0026lt;class T \u0026gt; auto s2m_vec(std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory)\nConvert vector of scalar T to matlab matrix.    Detailed Description #  utilities for arma/mex interface using Matlab C++ API\nFunction Details #  m2a_cellmat #  template \u0026lt;class T \u0026gt; auto m2a_cellmat( matlab::data::CellArray \u0026amp; matlab_cell ) Parameters:\n matlab_cell matlab cell  Template Parameters:\n T type  Return: vector of armadillo matrices of type T\nm2s_vec #  template \u0026lt;class T \u0026gt; auto m2s_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; \u0026amp; matlab_array ) Parameters:\n matlab_array matlab array  Template Parameters:\n T type  Return: vector of type T\nm2a_vec #  template \u0026lt;class T \u0026gt; auto m2a_vec( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\n matlab_array matlab array  Template Parameters:\n T type  Return: armadillo vector of type T\nm2a_mat #  template \u0026lt;class T \u0026gt; auto m2a_mat( matlab::data::TypedArray\u0026lt; T \u0026gt; matlab_array ) Parameters:\n matlab_array matlab matrix  Template Parameters:\n T type  Return: armadillo matrix of type T\na2m_mat #  template \u0026lt;class T \u0026gt; auto a2m_mat( arma::Mat\u0026lt; T \u0026gt; \u0026amp; arma_mat, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n arma_mat arma matrix factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\na2m_vec #  template \u0026lt;class T \u0026gt; auto a2m_vec( arma::Col\u0026lt; T \u0026gt; \u0026amp; arma_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n arma_vec armadillo vector factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\ns2m_vec #  template \u0026lt;class T \u0026gt; auto s2m_vec( std::vector\u0026lt; T \u0026gt; \u0026amp; std_vec, matlab::data::ArrayFactory \u0026amp; factory ) Parameters:\n std_vec standard vector factory matlab \u0026ldquo;array factory\u0026rdquo;  Template Parameters:\n T type  Return: matlab matrix\n Updated on 3 March 2021 at 23:06:11 CST\n"});index.add({'id':7,'href':'/ldsctrlest/docs/api/files/dir_4fef79e7177ba769987a8da36c892c5f/','title':"build",'section':"Files",'content':"build #  Directories #     Name     include     Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':8,'href':'/ldsctrlest/docs/terminology/control-estimation/','title':"C\u0026E",'section':"LDS C+E Documentation",'content':"Control \u0026amp; Estimation #  The control system provided by this library is comprised of a state estimator and a controller. The estimator is responsible for estimating the latent state of the system, given measurements up to and including the current time (i.e., filtering). At each time step, the controller then uses the resulting state feedback and an internal model of the system to update the inputs to the process being manipulated.\nState estimation #  In general, the filtering performed to estimate the underlying state proceeds recursively by first using the model dynamics to predict the state change at the next time step, followed by updating this prediction when a new measurement is available. For a LDS, this two-step process can be summarized by   \\[\\widehat{\\mathbf{x}}_{t|t-1} = \\mathbf{A}\\widehat{\\mathbf{x}}_{t-1|t-1} \u0026#43; \\mathbf{B} u_{t-1} \u0026#43; \\mathbf{m}_{t-1} \\;,\\]   \\[\\widehat{\\mathbf{x}}_{t|t} = \\widehat{\\mathbf{x}}_{t|t-1} \u0026#43; \\mathbf{K}^{\\rm e}_t \\left(\\mathbf{z}_t - \\widehat{\\mathbf{y}}_{t|t-1}\\right)\\;,\\]  where  \\( \\hat{\\left(\\cdot\\right)}_{t|j} \\)  indicates an estimate at time  \\( t \\)  given data up to time  \\( j \\)  inclusive,  \\( \\mathbf{K}^{\\rm e} \\)  is the estimator gain, and\n \\[ \\widehat{\\mathbf{y}}_{t|t-1} = h\\left( \\widehat{\\mathbf{x}}_{t|t-1} \\right) \\; .\\]  In the case of GLDS models, the estimator gain (called Ke in library) is calculated recursively by Kalman filtering, which requires knowledge of the process noise and measurement noise covariances (Q, R) in addition to the system matrices. For time-invariant GLDS models, the infinite horizon solution is often used, so this gain need not be time-varying. Users may instead set its pre-determined value with the lds::gaussian::sys_t::setKe method and disable recursive gain calculation in the filter method.\nIn the case of PLDS models, there is a analogue of the Kalman filter developed for dynamical systems with point-process observations (Eden et al. 2004). This nonlinear filter recursively updates Ke at each time step and requires an estimate of the process noise covariance (Q) as well.\nAdaptive estimation of process disturbance #  Both the Kalman filter and point-process analogue are model-based; therefore, their performance can be sensitive to model mismatch, whether this be imperfect model fitting or true drifts in system behavior. A practical approach to improving robustness is parameter adaptation. To that end, this library provides dual state-parameter estimation. Specifically, an additive process disturbance (m) is adaptively re-estimated when the sys_t::adaptM property is set to true. This effectively provides integral action on minimizing state estimation error that could either be due to model mismatch or a true disturbance.\nWhen parameter adaptation is enabled, this process disturbance is assumed to vary stochastically on a random walk  \\[\\mathbf{m}_{t} = \\mathbf{m}_{t-1} \u0026#43; \\mathbf{w}^m_{t-1} \\;,\\]  where  \\( \\mathbf{w}^m \\sim \\mathcal{N}\\left(0, \\mathbf{Q}_m\\right)\\)  . Kalman filtering or the point-process analogue are then used to estimate this disturbance in parallel with the state.\nControl #  Given the estimated state, the controller updates the inputs to the system according to the following law:  \\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\]  where  \\( \\left( \\cdot \\right)^{\\rm ref} \\)  correspond to reference/target signals and  \\( \\mathbf{K}^c_x \\)  is the state feedback controller gain. Recall that these controller gains are assumed to have been designed before the experiment using, for example, LQR.\nIf users are employing integral action for more robust tracking at DC and did not use the approach of augmenting the state vector and system matrices accordingly, there is an option to include the integral term as\n \\[\\mathbf{u}_{t} = \\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right) - \\mathbf{K}^c_{\\rm inty} \\sum_{j=1}^{t}\\left( \\widehat{\\mathbf{y}}_j - \\mathbf{y}^{\\rm ref}_j \\right) \\;.\\]  An additional option available to users is a control law that updates the change in u,\n \\[\\Delta\\mathbf{u}_{t} = \\Delta\\mathbf{u}^{\\rm ref}_t - \\mathbf{K}^c_x \\left( \\widehat{\\mathbf{x}}_t - \\mathbf{x}^{\\rm ref}_t\\right)\\;,\\]   \\[\\mathbf{u}_{t} = \\mathbf{u}_{t-1} \u0026#43; \\Delta\\mathbf{u}_{t} \\; .\\]  This can be useful in cases where users have designed the controller gains by LQR to minimize not the amplitude of the input, but the change in input, by augmenting the state vector with the input during LQR design.\nIntegral action and the  \\( \\Delta \\mathbf{u} \\)  control law can be combined. The library keeps track of the controller type by way of bit masks which can be bit-wise OR\u0026rsquo;d to use in combination.\nCalculating reference state-control from output #  In cases where an output reference is supplied and the goal is to track either a static or slowly varying output, users do not have to produce  \\( \\mathbf{x}^{\\rm ref} \\)  and  \\( \\mathbf{u}^{\\rm ref} \\)  . Methods are provided for calculating the state and control that would be required to reach the reference output at steady state (ctrl_t::steadyState_fbCtrl). This is achieved by linearly-constrained least squares. For single-output systems, it results in an exact solution; however, for multi-output solutions it provides a least squares comprimise across outputs.\n"});index.add({'id':9,'href':'/ldsctrlest/docs/api/classes/','title':"Classes",'section':"LDS C+E Documentation",'content':"Classes #    lds::fit_t LDS Fit Type.\n  lds::gaussian::ctrl_t GLDS Controller Type.\n  lds::gaussian::emFit_t GLDS E-M Fit Type.\n  lds::gaussian::fit_t GLDS Fit Type.\n  lds::gaussian::sctrl_t Switched GLDS Controller Type.\n  lds::gaussian::ssidFit_t GLDS SSID Fit Type.\n  lds::gaussian::sys_t Gaussian LDS Type.\n  lds::poisson::ctrl_t PLDS Controller Type.\n  lds::poisson::fit_t PLDS Fit Type.\n  lds::poisson::sctrl_t Switched PLDS Controller Type.\n  lds::poisson::ssidFit_t GLDS SSID Fit Type.\n  lds::poisson::sys_t Poisson LDS Type.\n  lds::sys_t Linear Dynamical System Type.\n   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':10,'href':'/ldsctrlest/docs/api/modules/group__control__masks/','title':"Control Mode Bit Masks",'section':"Modules",'content':"Control Mode Bit Masks #  \nMore\u0026hellip; Attributes #      Name     const std::size_t CONTROL_TYPE_U   const std::size_t CONTROL_TYPE_INTY   const std::size_t CONTROL_TYPE_ADAPT_M Control setpoint adapted with (re-estimated) process disturbance m.    Detailed Description #  Control mode bit masks. These can be bit-wise OR\u0026rsquo;d to use in combination.\nAttribute Details #  CONTROL_TYPE_U #  static const std::size_t CONTROL_TYPE_U = 0x1; Control was designed to penalize change in input (i.e., the state was augmented with input u)\nCONTROL_TYPE_INTY #  static const std::size_t CONTROL_TYPE_INTY = CONTROL_TYPE_U \u0026lt;\u0026lt; 1; Control using integral action (i.e., the state was augmented with output y during design)\nCONTROL_TYPE_ADAPT_M #  static const std::size_t CONTROL_TYPE_ADAPT_M = CONTROL_TYPE_U \u0026lt;\u0026lt; 2;  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':11,'href':'/ldsctrlest/docs/api/modules/group__defaults/','title':"Defaults",'section':"Modules",'content':"Defaults #  \nMore\u0026hellip; Attributes #      Name     data_t DEFAULT_P0   data_t DEFAULT_Q0   data_t DEFAULT_R0   std::vector\u0026lt; data_t \u0026gt; DEFAULT_T0   data_t DATA_T_ZERO   data_t DATA_T_ONE   data_t DEFAULT_SOFTSTART   bool FALSE   bool TRUE    Detailed Description #  Default values for common variables (e.g., default diagonal elements of covariances in case there is need to resolve dimension mismatch)\nAttribute Details #  DEFAULT_P0 #  static data_t DEFAULT_P0 = 1e-6; DEFAULT_Q0 #  static data_t DEFAULT_Q0 = 1e-6; DEFAULT_R0 #  static data_t DEFAULT_R0 = 1e-2; DEFAULT_T0 #  static std::vector\u0026lt; data_t \u0026gt; DEFAULT_T0 = std::vector\u0026lt;data_t\u0026gt;(1, 0.0); DATA_T_ZERO #  static data_t DATA_T_ZERO = (data_t)0; DATA_T_ONE #  static data_t DATA_T_ONE = (data_t)1; DEFAULT_SOFTSTART #  static data_t DEFAULT_SOFTSTART = (data_t)0; FALSE #  static bool FALSE = false; TRUE #  static bool TRUE = true;  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':12,'href':'/ldsctrlest/docs/api/examples/eg_glds_ctrl_8cpp-example/','title':"eg_glds_ctrl.cpp",'section':"Examples",'content':"eg_glds_ctrl.cpp #  Example GLDS Control\n//===-- eg_glds_ctrl.cpp - Example GLDS Control ---------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS Control ********** \\n\\n\u0026#34;; // Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); // construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::sys_t controlled_system(n_u, n_x, n_y, dt); // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); armaMat b_true = armaMat(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  armaVec g_true = armaVec(n_y).fill(10.0); // output noise covariance  armaMat r_true = armaMat(n_y, n_y, arma::fill::eye) * 1e-4; size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  armaVec m0_true = armaVec(n_y).fill(m_low); // Assign params.  controlled_system.setA(a_true); controlled_system.setB(b_true); controlled_system.setM(m0_true); controlled_system.setG(g_true); controlled_system.setR(r_true); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  glds::ctrl_t controller(n_u, n_x, n_y, u_lb, u_ub, dt); // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  armaMat b_controller = armaMat(n_x, n_u).fill(1e-4); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  armaVec g_design = armaVec(n_u).fill(9); // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  armaVec m_controller = armaVec(n_x, arma::fill::zeros); // Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y).fill(20.0 * dt); // (Can either use arma::Mat or mats flattened into std::vector)  armaMat k_x = armaMat(n_u, n_x).fill(100); // gains on state error  armaMat k_inty = armaMat(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  armaVec x0 = armaVec(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::CONTROL_TYPE_ADAPT_M; } else { // use integral action to minimize DC error  control_type = control_type | lds::CONTROL_TYPE_INTY; } // Start configuring controller:  // Adaptively re-estimate process disturance (m)  controller.adaptM = true; // set controller type  controller.setControlType(control_type); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.setYRef(y_ref0); controller.setKc_x(k_x); controller.setKc_inty(k_inty); controller.setA(a_true); controller.setB(b_controller); controller.setM(m_controller); controller.setG(g_true); controller.setGDesign(g_design); controller.setX0(x0); controller.reset(); // reset to new initial condition  // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; controller.setQ_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // set up variables for simulation  // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // get initial val  y_hat.submat(0, 0, n_y - 1, 0) = controller.getY(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.getY(); x_hat.submat(0, 0, n_x - 1, 0) = controller.getX(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.getX(); m_hat.submat(0, 0, n_x - 1, 0) = controller.getM(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.getM(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.setM(m0_true); // input  armaVec u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_t(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_t); // This method uses a steady-state solution to control problem to calculate  // xRef, uRef from reference output yRef. Therefore, it is only applicable  // to regulation problems or cases where reference trajectory changes slowly  // compared to system dynamics.  controller.steadyState_fbCtrl(z_t); // save the signals  y_true.col(t) = controlled_system.getY(); x_true.col(t) = controlled_system.getX(); m_true.col(t) = controlled_system.getM(); y_hat.col(t) = controller.getY(); x_hat.col(t) = controller.getX(); m_hat.col(t) = controller.getM(); u.col(t) = controller.getU(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; } Filename: eg_glds_ctrl.cpp\n Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':13,'href':'/ldsctrlest/docs/api/examples/eg_plds_est_8cpp-example/','title':"eg_plds_est.cpp",'section':"Examples",'content':"eg_plds_est.cpp #  Example PLDS Estimation\n//===-- eg_plds_est.cpp - Example PLDS Estimation -------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; // for generating random input armaMat random_walk(size_t n_t, const arma::mat\u0026amp; Q, arma::vec x0); int main(void) { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Estimation ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation.  // construct ground truth system...  lds::poisson::sys_t system_true(n_u, n_x, n_y, dt); // Model parameters  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); armaMat b_true = armaMat(n_x, n_u).fill(1e-2); armaVec m0_true = armaVec(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  armaVec x0_true = m0_true * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  // Assign params.  system_true.setA(a_true); system_true.setB(b_true); system_true.setX0(x0_true); system_true.setM(m0_true); system_true.reset(); // Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::sys_t system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  armaVec m0_est = m0_true * 2; system_estimator.setM(m0_est); // set new initial conditions  armaVec x0_est = m0_est * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.setX0(x0_est); system_estimator.reset(); // reset to initial condition.  // turn on adaptive disturbance estimation  system_estimator.adaptM = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.setQ_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;estimator:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; system_estimator.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Set up simulation :  // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // Stimulus (generate random stimulus)  armaMat q_u = armaMat(n_u, n_u, arma::fill::eye) * 1e-3; // cov of random walk  armaMat u = random_walk(n_t, q_u, armaVec(n_u, arma::fill::zeros)); // create matrix to save outputs in...  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat y_true(n_y, n_t, arma::fill::zeros); // states and disturbance params  armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_x, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simlation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 0; t \u0026lt; n_t; t++) { // input  armaVec u_k(u.colptr(t), u.n_rows, false, true); // Simlate the true system.  system_true.setU(u_k); system_true.simPredict(); // generate a measurement  armaVec z_k(z.colptr(t), z.n_rows, false, true); system_true.simMeasurement(z_k); // filter (predict -\u0026gt; update)  system_estimator.filter(z_k); // save signals  y_hat.col(t) = system_estimator.getY(); y_true.col(t) = system_true.getY(); x_true.col(t) = system_true.getX(); m_true.col(t) = system_true.getM(); x_hat.col(t) = system_estimator.getX(); m_hat.col(t) = system_estimator.getM(); // for next time.  system_estimator.setU(u_k); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; simTime_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simlation in \u0026#34; \u0026lt;\u0026lt; simTime_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (simTime_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;dt\u0026#34;)); u.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } // for generating random input armaMat random_walk(size_t n_t, const arma::mat\u0026amp; Q, arma::vec x0) { size_t n = Q.n_rows; if ((n != Q.n_cols) || (Q.n_cols != Q.n_rows)) { throw std::logic_error(\u0026#34;Q must be `n` x `n`.\u0026#34;); } arma::mat x(n, n_t, arma::fill::zeros); x.col(0) = x0; for (size_t t = 1; t \u0026lt; n_t; t++) { x.col(t) = x.col(t - 1) + arma::mvnrnd(arma::vec(n, arma::fill::zeros), Q); } return x; } Filename: eg_plds_est.cpp\n Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':14,'href':'/ldsctrlest/docs/api/examples/eg_plds_log_lin_ctrl_8cpp-example/','title':"eg_plds_logLinCtrl.cpp",'section':"Examples",'content':"eg_plds_logLinCtrl.cpp #  Example PLDS Control\n//===-- eg_plds_logLinCtrl.cpp - Example PLDS Control ---------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main(void) -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Control ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(10.0 / dt); // Control variables: _reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y, arma::fill::ones) * 30.0 * dt; armaMat k_x = armaMat(n_u, n_x, arma::fill::zeros) + 1; // gains on state error  armaMat k_inty = armaMat(n_u, n_y, arma::fill::zeros) + 10; // gains on integrated output err  // Set control type bit mask, so controller knows what to do  size_t control_type = lds::CONTROL_TYPE_INTY; // integral action  // // uncomment to use control that was designed to minimize change in control  // // signal, rather than instantaneous amplitude  // control_type = control_type | lds::CONTROL_TYPE_U;  // if (control_type \u0026amp; lds::CONTROL_TYPE_U) {  // k_x *= dt*10;  // k_inty *= 0;  // }  // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = 0.986; armaMat b_true(n_x, n_u, arma::fill::zeros); b_true[0] = 0.054; armaVec x0_true = armaVec(n_x, arma::fill::ones) * log(1 * dt); size_t which_m = 0; data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; armaVec m0_true = armaVec(n_y, arma::fill::ones) * m_low; // construct ground truth system to be controlled...  lds::poisson::sys_t controlled_system(n_u, n_x, n_y, dt); // Assign params.  controlled_system.setA(a_true); controlled_system.setB(b_true); controlled_system.setM(m0_true); controlled_system.setX0(x0_true); // reset to initial conditions  controlled_system.reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create model used for control.  // for this example, assume model correct, except disturbance  armaVec m0_controller = armaVec(n_y, arma::fill::ones) * m_low; data_t uLB = 0.0; data_t uUB = 5.0; lds::poisson::ctrl_t controller(n_u, n_x, n_y, uLB, uUB, dt); // adaptively re-estimate process disturbance (m)  controller.adaptM = true; // set controller type  controller.setControlType(control_type); // Assign parameters  // **n.b. using arbitrary default for Q in this example. Really these should  // be set by users.**  controller.setA(a_true); controller.setB(b_true); controller.setM(m0_controller); // setting initial state to target to avoid large error at onset:  armaVec x0_controller = arma::log(y_ref0); controller.setX0(x0_controller); // reset to new initial conditions  controller.reset(); // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-5; controller.setQ_m(q_m); // set controller gains  controller.setKc_x(k_x); controller.setKc_inty(k_inty); // to protect against integral windup when output is consistently above  // target:  data_t tau_awu(0.1); controller.setTauAntiWindup(tau_awu); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::zeros); y_ref.each_col() += y_ref0; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // set initial val  y_hat.col(0) = controller.getY(); y_true.col(0) = controlled_system.getY(); x_hat.col(0) = controller.getX(); x_true.col(0) = controlled_system.getX(); m_hat.col(0) = controller.getM(); m_true.col(0) = controlled_system.getM(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.setM(m0_true); // e.g., use sinusoidal reference  data_t f = 0.5; // freq [=] Hz  armaVec t_vec = armaVec(n_y, arma::fill::ones) * t; y_ref.col(t) += y_ref0 % arma::sin(f * 2 * lds::pi * dt * t_vec - lds::pi / 4); armaVec y_ref_t(y_ref.colptr(t), n_y, false, true); // input  armaVec u_km1 = armaVec(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  controlled_system.setU(u_km1); controlled_system.simPredict(); armaVec z_k = armaVec(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_k); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Notably, it does this in the  // log-linear space (i.e., log(y)).  //  // Therefore, it is only applicable to regulation problems or cases where  // reference trajectory changes slowly compared to system dynamics.  controller.setYRef(y_ref_t); controller.steadyState_logLin_fbCtrl(z_k); y_true.col(t) = controlled_system.getY(); x_true.col(t) = controlled_system.getX(); m_true.col(t) = controlled_system.getM(); y_hat.col(t) = controller.getY(); x_hat.col(t) = controller.getX(); m_hat.col(t) = controller.getM(); // write control to u  armaVec u_k = armaVec(u.colptr(t), u.n_rows, false, true); u_k = controller.getU(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; simTime_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; simTime_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (simTime_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } Filename: eg_plds_logLinCtrl.cpp\n Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':15,'href':'/ldsctrlest/docs/api/examples/eg_plds_switched_log_lin_ctrl_8cpp-example/','title':"eg_plds_switched_logLinCtrl.cpp",'section':"Examples",'content':"eg_plds_switched_logLinCtrl.cpp #  Example Switched PLDS Control\n//===-- eg_plds_switched_logLinCtrl.cpp - Example Switched PLDS Control ---===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main(void) -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Switched Poisson LDS Control ********** \\n\\n\u0026#34;; // whether to do switched control  bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); // for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1  // simulated system being controlled  lds::poisson::sys_t controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  armaMat a(n_x, n_x, arma::fill::eye); a[0] = 0.985; armaMat b1 = armaMat(n_x, n_u).fill(0.05); armaVec d = armaVec(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.setA(a); controlled_system.setB(b1); controlled_system.setD(d); controlled_system.reset(); // reset to initial conditions  // create switched controller sub-systems  // system 1  data_t u_lb = 0.0; data_t u_ub = 5.0; lds::poisson::ctrl_t sys1(n_u, n_x, n_y, u_lb, u_ub, dt); // Control variables  armaVec y_ref0 = armaVec(n_y, arma::fill::zeros).fill(25.0 * dt); // controller gains for underlying system 1:  armaMat k_x1(n_u, n_x, arma::fill::ones); size_t control_type = 0; // no integral action, etc.  // setting initial mode to target to avoid large error at onset:  armaVec x0_controller = arma::log(y_ref0) - d; armaMat q_controller = armaMat(n_x, n_x, arma::fill::eye) * 5e-3; sys1.setControlType(control_type); sys1.setA(a); sys1.setB(b1); sys1.setD(d); sys1.setX0(x0_controller); sys1.setKc_x(k_x1); sys1.setQ(q_controller); // set process noise covariance  cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys1.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // system 2  lds::poisson::ctrl_t sys2 = sys1; // Let underlying system 1 be more sensitive than system 2  data_t scale_sys_b = 2; armaMat b2 = armaMat(n_x, n_u).fill(b1[0] / scale_sys_b); armaMat k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  // set parameters  sys2.setB(b2); sys2.setKc_x(k_x2); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys2.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create 2-system composite switched-mode controller.  lds::poisson::sctrl_t switched_controller(2, n_u, n_x, n_y, u_lb, u_ub, dt); // assign the parameters of the sub-systems 1 and 2  switched_controller.setSystem(0, sys1); switched_controller.setSystem(1, sys2); switched_controller.switchSystem(0); // start with system 1  switched_controller.reset(); // reset to initial conditions  // reference belongs to super system. Set here.  switched_controller.setYRef(y_ref0); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  switched_controller.adaptM = true; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;switched_controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; switched_controller.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Fake measurements  armaMat z(n_y, n_t, arma::fill::zeros); // Will later contain control.  armaMat u(n_u, n_t, arma::fill::zeros); // create armaMatrix to save outputs in...  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat y_ref = armaMat(n_y, n_t).fill(y_ref0[0]); // modes and gain/disturbance params  armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat mode(1, n_t, arma::fill::ones); // set initial val  y_hat.col(0) = switched_controller.getY(); y_true.col(0) = controlled_system.getY(); x_hat.col(0) = switched_controller.getX(); x_true.col(0) = controlled_system.getX(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Let the controlled system stachastically change gain  // Assume another algorithm decodes this mode change and signals the  // switched_controller  //  armaVec chance(1, arma::fill::randu); if (which_mode == 1) // mode1  { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.setB(b2); if (do_switch_ctrl) switched_controller.switchSystem(1); } } else { // mode2  if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.setB(b1); if (do_switch_ctrl) switched_controller.switchSystem(0); } } // input  armaVec u_tm1 = armaVec(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_k = armaVec(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_k); // perform control  switched_controller.steadyState_logLin_fbCtrl(z_k); mode.col(t) = which_mode; y_ref.col(t) = y_ref0; y_true.col(t) = controlled_system.getY(); x_true.col(t) = controlled_system.getX(); y_hat.col(t) = switched_controller.getY(); x_hat.col(t) = switched_controller.getX(); // write control to u  armaVec u_t = armaVec(u.colptr(t), u.n_rows, false, true); u_t = switched_controller.getU(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; simTime_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; simTime_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (simTime_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); mode.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;mode\u0026#34;, replace)); return 0; } Filename: eg_plds_switched_logLinCtrl.cpp\n Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':16,'href':'/ldsctrlest/docs/api/examples/','title':"Examples",'section':"LDS C+E Documentation",'content':"Examples #    eg_glds_ctrl.cpp Example GLDS Control.\n  eg_plds_est.cpp Example PLDS Estimation.\n  eg_plds_logLinCtrl.cpp Example PLDS Control.\n  eg_plds_switched_logLinCtrl.cpp Example Switched PLDS Control.\n   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':17,'href':'/ldsctrlest/docs/api/files/dir_d28a4824dc47e487b107a5db32ef43c4/','title':"examples",'section':"Files",'content':"examples #  Files #     Name     examples/eg_glds_ctrl.cpp   examples/eg_plds_est.cpp   examples/eg_plds_logLinCtrl.cpp   examples/eg_plds_switched_logLinCtrl.cpp     Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':18,'href':'/ldsctrlest/docs/api/files/eg__glds__ctrl_8cpp/','title':"examples/eg_glds_ctrl.cpp",'section':"Files",'content':"examples/eg_glds_ctrl.cpp #  Functions #      Name     auto main()    Function Details #  main #  auto main() Going to simulate a switching disturbance (m) acting on system\nSource code #  //===-- eg_glds_ctrl.cpp - Example GLDS Control ---------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main() -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Gaussian LDS Control ********** \\n\\n\u0026#34;; // Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); // construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::sys_t controlled_system(n_u, n_x, n_y, dt); // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); armaMat b_true = armaMat(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  armaVec g_true = armaVec(n_y).fill(10.0); // output noise covariance  armaMat r_true = armaMat(n_y, n_y, arma::fill::eye) * 1e-4; size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  armaVec m0_true = armaVec(n_y).fill(m_low); // Assign params.  controlled_system.setA(a_true); controlled_system.setB(b_true); controlled_system.setM(m0_true); controlled_system.setG(g_true); controlled_system.setR(r_true); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  glds::ctrl_t controller(n_u, n_x, n_y, u_lb, u_ub, dt); // Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  armaMat b_controller = armaMat(n_x, n_u).fill(1e-4); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  armaVec g_design = armaVec(n_u).fill(9); // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  armaVec m_controller = armaVec(n_x, arma::fill::zeros); // Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y).fill(20.0 * dt); // (Can either use arma::Mat or mats flattened into std::vector)  armaMat k_x = armaMat(n_u, n_x).fill(100); // gains on state error  armaMat k_inty = armaMat(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  armaVec x0 = armaVec(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::CONTROL_TYPE_ADAPT_M; } else { // use integral action to minimize DC error  control_type = control_type | lds::CONTROL_TYPE_INTY; } // Start configuring controller:  // Adaptively re-estimate process disturance (m)  controller.adaptM = true; // set controller type  controller.setControlType(control_type); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.setYRef(y_ref0); controller.setKc_x(k_x); controller.setKc_inty(k_inty); controller.setA(a_true); controller.setB(b_controller); controller.setM(m_controller); controller.setG(g_true); controller.setGDesign(g_design); controller.setX0(x0); controller.reset(); // reset to new initial condition  // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; controller.setQ_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;control system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // set up variables for simulation  // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::ones) * y_ref0[0]; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // get initial val  y_hat.submat(0, 0, n_y - 1, 0) = controller.getY(); y_true.submat(0, 0, n_y - 1, 0) = controlled_system.getY(); x_hat.submat(0, 0, n_x - 1, 0) = controller.getX(); x_true.submat(0, 0, n_x - 1, 0) = controlled_system.getX(); m_hat.submat(0, 0, n_x - 1, 0) = controller.getM(); m_true.submat(0, 0, n_x - 1, 0) = controlled_system.getM(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.setM(m0_true); // input  armaVec u_tm1(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_t(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_t); // This method uses a steady-state solution to control problem to calculate  // xRef, uRef from reference output yRef. Therefore, it is only applicable  // to regulation problems or cases where reference trajectory changes slowly  // compared to system dynamics.  controller.steadyState_fbCtrl(z_t); // save the signals  y_true.col(t) = controlled_system.getY(); x_true.col(t) = controlled_system.getX(); m_true.col(t) = controlled_system.getM(); y_hat.col(t) = controller.getY(); x_hat.col(t) = controller.getX(); m_hat.col(t) = controller.getM(); u.col(t) = controller.getU(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; sim_time_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; sim_time_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (sim_time_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Saving simulation data to disk.\\n\u0026#34;; // saved variables: dt, lambdaHat, xHat, mHat, z, u, lambdaRef, lambdaTrue,  // xTrue, mTrue saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_glds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); cout \u0026lt;\u0026lt; \u0026#34;fin.\\n\u0026#34;; return 0; }  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':19,'href':'/ldsctrlest/docs/api/files/eg__plds__est_8cpp/','title':"examples/eg_plds_est.cpp",'section':"Files",'content':"examples/eg_plds_est.cpp #  Functions #      Name     armaMat random_walk(size_t n_t, const arma::mat \u0026amp; Q, arma::vec x0)   int main(void )    Function Details #  random_walk #  armaMat random_walk( size_t n_t, const arma::mat \u0026amp; Q, arma::vec x0 ) main #  int main( void ) Source code #  //===-- eg_plds_est.cpp - Example PLDS Estimation -------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; // for generating random input armaMat random_walk(size_t n_t, const arma::mat\u0026amp; Q, arma::vec x0); int main(void) { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Estimation ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation.  // construct ground truth system...  lds::poisson::sys_t system_true(n_u, n_x, n_y, dt); // Model parameters  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); armaMat b_true = armaMat(n_x, n_u).fill(1e-2); armaVec m0_true = armaVec(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  armaVec x0_true = m0_true * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  // Assign params.  system_true.setA(a_true); system_true.setB(b_true); system_true.setX0(x0_true); system_true.setM(m0_true); system_true.reset(); // Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::sys_t system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  armaVec m0_est = m0_true * 2; system_estimator.setM(m0_est); // set new initial conditions  armaVec x0_est = m0_est * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.setX0(x0_est); system_estimator.reset(); // reset to initial condition.  // turn on adaptive disturbance estimation  system_estimator.adaptM = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.setQ_m(q_m); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;estimator:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; system_estimator.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Set up simulation :  // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // Stimulus (generate random stimulus)  armaMat q_u = armaMat(n_u, n_u, arma::fill::eye) * 1e-3; // cov of random walk  armaMat u = random_walk(n_t, q_u, armaVec(n_u, arma::fill::zeros)); // create matrix to save outputs in...  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat y_true(n_y, n_t, arma::fill::zeros); // states and disturbance params  armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_x, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simlation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 0; t \u0026lt; n_t; t++) { // input  armaVec u_k(u.colptr(t), u.n_rows, false, true); // Simlate the true system.  system_true.setU(u_k); system_true.simPredict(); // generate a measurement  armaVec z_k(z.colptr(t), z.n_rows, false, true); system_true.simMeasurement(z_k); // filter (predict -\u0026gt; update)  system_estimator.filter(z_k); // save signals  y_hat.col(t) = system_estimator.getY(); y_true.col(t) = system_true.getY(); x_true.col(t) = system_true.getX(); m_true.col(t) = system_true.getM(); x_hat.col(t) = system_estimator.getX(); m_hat.col(t) = system_estimator.getM(); // for next time.  system_estimator.setU(u_k); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; simTime_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simlation in \u0026#34; \u0026lt;\u0026lt; simTime_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (simTime_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;dt\u0026#34;)); u.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_est.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; } // for generating random input armaMat random_walk(size_t n_t, const arma::mat\u0026amp; Q, arma::vec x0) { size_t n = Q.n_rows; if ((n != Q.n_cols) || (Q.n_cols != Q.n_rows)) { throw std::logic_error(\u0026#34;Q must be `n` x `n`.\u0026#34;); } arma::mat x(n, n_t, arma::fill::zeros); x.col(0) = x0; for (size_t t = 1; t \u0026lt; n_t; t++) { x.col(t) = x.col(t - 1) + arma::mvnrnd(arma::vec(n, arma::fill::zeros), Q); } return x; }  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':20,'href':'/ldsctrlest/docs/api/files/eg__plds__log_lin_ctrl_8cpp/','title':"examples/eg_plds_logLinCtrl.cpp",'section':"Files",'content':"examples/eg_plds_logLinCtrl.cpp #  Functions #      Name     auto main(void )    Function Details #  main #  auto main( void ) Going to simulate a switching disturbance (m) acting on system\nSource code #  //===-- eg_plds_logLinCtrl.cpp - Example PLDS Control ---------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main(void) -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Poisson LDS Control ********** \\n\\n\u0026#34;; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(10.0 / dt); // Control variables: _reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y, arma::fill::ones) * 30.0 * dt; armaMat k_x = armaMat(n_u, n_x, arma::fill::zeros) + 1; // gains on state error  armaMat k_inty = armaMat(n_u, n_y, arma::fill::zeros) + 10; // gains on integrated output err  // Set control type bit mask, so controller knows what to do  size_t control_type = lds::CONTROL_TYPE_INTY; // integral action  // // uncomment to use control that was designed to minimize change in control  // // signal, rather than instantaneous amplitude  // control_type = control_type | lds::CONTROL_TYPE_U;  // if (control_type \u0026amp; lds::CONTROL_TYPE_U) {  // k_x *= dt*10;  // k_inty *= 0;  // }  // Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = 0.986; armaMat b_true(n_x, n_u, arma::fill::zeros); b_true[0] = 0.054; armaVec x0_true = armaVec(n_x, arma::fill::ones) * log(1 * dt); size_t which_m = 0; data_t m_low = log(1 * dt) * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; data_t m_high = log(20 * dt) * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; armaVec m0_true = armaVec(n_y, arma::fill::ones) * m_low; // construct ground truth system to be controlled...  lds::poisson::sys_t controlled_system(n_u, n_x, n_y, dt); // Assign params.  controlled_system.setA(a_true); controlled_system.setB(b_true); controlled_system.setM(m0_true); controlled_system.setX0(x0_true); // reset to initial conditions  controlled_system.reset(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controlled_system:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controlled_system.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Create model used for control.  // for this example, assume model correct, except disturbance  armaVec m0_controller = armaVec(n_y, arma::fill::ones) * m_low; data_t uLB = 0.0; data_t uUB = 5.0; lds::poisson::ctrl_t controller(n_u, n_x, n_y, uLB, uUB, dt); // adaptively re-estimate process disturbance (m)  controller.adaptM = true; // set controller type  controller.setControlType(control_type); // Assign parameters  // **n.b. using arbitrary default for Q in this example. Really these should  // be set by users.**  controller.setA(a_true); controller.setB(b_true); controller.setM(m0_controller); // setting initial state to target to avoid large error at onset:  armaVec x0_controller = arma::log(y_ref0); controller.setX0(x0_controller); // reset to new initial conditions  controller.reset(); // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-5; controller.setQ_m(q_m); // set controller gains  controller.setKc_x(k_x); controller.setKc_inty(k_inty); // to protect against integral windup when output is consistently above  // target:  data_t tau_awu(0.1); controller.setTauAntiWindup(tau_awu); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; controller.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create armaMatrix to save outputs in...  armaMat y_ref = armaMat(n_y, n_t, arma::fill::zeros); y_ref.each_col() += y_ref0; // Simulated measurements  armaMat z(n_y, n_t, arma::fill::zeros); // simulated control signal ([=] V)  armaMat u(n_u, n_t, arma::fill::zeros); // outputs, states and gain/disturbance params  // *_hat indicates online estimates  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat m_hat(n_y, n_t, arma::fill::zeros); // *_true indicates ground truth (system being controlled)  armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat m_true(n_y, n_t, arma::fill::zeros); // set initial val  y_hat.col(0) = controller.getY(); y_true.col(0) = controlled_system.getY(); x_hat.col(0) = controller.getX(); x_true.col(0) = controlled_system.getX(); m_hat.col(0) = controller.getM(); m_true.col(0) = controlled_system.getM(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // simulate a stochastically switched disturbance  armaVec chance = arma::randu\u0026lt;arma::vec\u0026gt;(1); if (which_m == 0) // low disturbance  { if (chance[0] \u0026lt; pr_lo2hi) { // switches low -\u0026gt; high disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_high); which_m = 1; } } else { // high disturbance  if (chance[0] \u0026lt; pr_hi2lo) { // swithces high -\u0026gt; low disturbance  m0_true = vector\u0026lt;data_t\u0026gt;(n_y, m_low); which_m = 0; } } controlled_system.setM(m0_true); // e.g., use sinusoidal reference  data_t f = 0.5; // freq [=] Hz  armaVec t_vec = armaVec(n_y, arma::fill::ones) * t; y_ref.col(t) += y_ref0 % arma::sin(f * 2 * lds::pi * dt * t_vec - lds::pi / 4); armaVec y_ref_t(y_ref.colptr(t), n_y, false, true); // input  armaVec u_km1 = armaVec(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  controlled_system.setU(u_km1); controlled_system.simPredict(); armaVec z_k = armaVec(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_k); // This method uses a steady-state solution to control problem to calculate  // x_ref, u_ref from reference output y_ref. Notably, it does this in the  // log-linear space (i.e., log(y)).  //  // Therefore, it is only applicable to regulation problems or cases where  // reference trajectory changes slowly compared to system dynamics.  controller.setYRef(y_ref_t); controller.steadyState_logLin_fbCtrl(z_k); y_true.col(t) = controlled_system.getY(); x_true.col(t) = controlled_system.getX(); m_true.col(t) = controlled_system.getM(); y_hat.col(t) = controller.getY(); x_hat.col(t) = controller.getX(); m_hat.col(t) = controller.getM(); // write control to u  armaVec u_k = armaVec(u.colptr(t), u.n_rows, false, true); u_k = controller.getU(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; simTime_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; simTime_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (simTime_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); m_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); m_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;m_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); return 0; }  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':21,'href':'/ldsctrlest/docs/api/files/eg__plds__switched__log_lin_ctrl_8cpp/','title':"examples/eg_plds_switched_logLinCtrl.cpp",'section':"Files",'content':"examples/eg_plds_switched_logLinCtrl.cpp #  Functions #      Name     auto main(void )    Function Details #  main #  auto main( void ) Source code #  //===-- eg_plds_switched_logLinCtrl.cpp - Example Switched PLDS Control ---===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; auto main(void) -\u0026gt; int { cout \u0026lt;\u0026lt; \u0026#34; ********** Example Switched Poisson LDS Control ********** \\n\\n\u0026#34;; // whether to do switched control  bool do_switch_ctrl = true; // Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); // for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1  // simulated system being controlled  lds::poisson::sys_t controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  armaMat a(n_x, n_x, arma::fill::eye); a[0] = 0.985; armaMat b1 = armaMat(n_x, n_u).fill(0.05); armaVec d = armaVec(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.setA(a); controlled_system.setB(b1); controlled_system.setD(d); controlled_system.reset(); // reset to initial conditions  // create switched controller sub-systems  // system 1  data_t u_lb = 0.0; data_t u_ub = 5.0; lds::poisson::ctrl_t sys1(n_u, n_x, n_y, u_lb, u_ub, dt); // Control variables  armaVec y_ref0 = armaVec(n_y, arma::fill::zeros).fill(25.0 * dt); // controller gains for underlying system 1:  armaMat k_x1(n_u, n_x, arma::fill::ones); size_t control_type = 0; // no integral action, etc.  // setting initial mode to target to avoid large error at onset:  armaVec x0_controller = arma::log(y_ref0) - d; armaMat q_controller = armaMat(n_x, n_x, arma::fill::eye) * 5e-3; sys1.setControlType(control_type); sys1.setA(a); sys1.setB(b1); sys1.setD(d); sys1.setX0(x0_controller); sys1.setKc_x(k_x1); sys1.setQ(q_controller); // set process noise covariance  cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys1:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys1.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // system 2  lds::poisson::ctrl_t sys2 = sys1; // Let underlying system 1 be more sensitive than system 2  data_t scale_sys_b = 2; armaMat b2 = armaMat(n_x, n_u).fill(b1[0] / scale_sys_b); armaMat k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  // set parameters  sys2.setB(b2); sys2.setKc_x(k_x2); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;sys2:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; sys2.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // create 2-system composite switched-mode controller.  lds::poisson::sctrl_t switched_controller(2, n_u, n_x, n_y, u_lb, u_ub, dt); // assign the parameters of the sub-systems 1 and 2  switched_controller.setSystem(0, sys1); switched_controller.setSystem(1, sys2); switched_controller.switchSystem(0); // start with system 1  switched_controller.reset(); // reset to initial conditions  // reference belongs to super system. Set here.  switched_controller.setYRef(y_ref0); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  switched_controller.adaptM = true; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;switched_controller:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; switched_controller.printSys(); cout \u0026lt;\u0026lt; \u0026#34;.....................................\\n\u0026#34;; // Fake measurements  armaMat z(n_y, n_t, arma::fill::zeros); // Will later contain control.  armaMat u(n_u, n_t, arma::fill::zeros); // create armaMatrix to save outputs in...  armaMat y_hat(n_y, n_t, arma::fill::zeros); armaMat y_true(n_y, n_t, arma::fill::zeros); armaMat y_ref = armaMat(n_y, n_t).fill(y_ref0[0]); // modes and gain/disturbance params  armaMat x_hat(n_x, n_t, arma::fill::zeros); armaMat x_true(n_x, n_t, arma::fill::zeros); armaMat mode(1, n_t, arma::fill::ones); // set initial val  y_hat.col(0) = switched_controller.getY(); y_true.col(0) = controlled_system.getY(); x_hat.col(0) = switched_controller.getX(); x_true.col(0) = controlled_system.getX(); cout \u0026lt;\u0026lt; \u0026#34;Starting \u0026#34; \u0026lt;\u0026lt; n_t * dt \u0026lt;\u0026lt; \u0026#34; sec simulation ... \\n\u0026#34;; auto start = std::chrono::high_resolution_clock::now(); for (size_t t = 1; t \u0026lt; n_t; t++) { // Let the controlled system stachastically change gain  // Assume another algorithm decodes this mode change and signals the  // switched_controller  //  armaVec chance(1, arma::fill::randu); if (which_mode == 1) // mode1  { if (chance[0] \u0026lt; pr_21) { which_mode = 2; controlled_system.setB(b2); if (do_switch_ctrl) switched_controller.switchSystem(1); } } else { // mode2  if (chance[0] \u0026lt; pr_12) { which_mode = 1; controlled_system.setB(b1); if (do_switch_ctrl) switched_controller.switchSystem(0); } } // input  armaVec u_tm1 = armaVec(u.colptr(t - 1), u.n_rows, false, true); // Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_k = armaVec(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_k); // perform control  switched_controller.steadyState_logLin_fbCtrl(z_k); mode.col(t) = which_mode; y_ref.col(t) = y_ref0; y_true.col(t) = controlled_system.getY(); x_true.col(t) = controlled_system.getX(); y_hat.col(t) = switched_controller.getY(); x_hat.col(t) = switched_controller.getX(); // write control to u  armaVec u_t = armaVec(u.colptr(t), u.n_rows, false, true); u_t = switched_controller.getU(); } auto finish = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;data_t, std::milli\u0026gt; simTime_ms = finish - start; cout \u0026lt;\u0026lt; \u0026#34;Finished simulation in \u0026#34; \u0026lt;\u0026lt; simTime_ms.count() \u0026lt;\u0026lt; \u0026#34; ms.\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;(app. \u0026#34; \u0026lt;\u0026lt; (simTime_ms.count() / n_t) * 1e3 \u0026lt;\u0026lt; \u0026#34; us/time-step)\\n\u0026#34;; // saved variables: dt, y_hat, x_hat, m_hat, z, u, y_ref, y_true,  // x_true, m_true saving with hdf5 via armadillo  arma::hdf5_opts::opts replace = arma::hdf5_opts::replace; auto dt_vec = arma::vec(1).fill(dt); dt_vec.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;dt\u0026#34;)); y_ref.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_ref\u0026#34;, replace)); u.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;u\u0026#34;, replace)); z.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;z\u0026#34;, replace)); x_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_true\u0026#34;, replace)); y_true.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_true\u0026#34;, replace)); x_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;x_hat\u0026#34;, replace)); y_hat.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;y_hat\u0026#34;, replace)); mode.save(arma::hdf5_name(\u0026#34;eg_plds_switched_ctrl.h5\u0026#34;, \u0026#34;mode\u0026#34;, replace)); return 0; }  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':22,'href':'/ldsctrlest/docs/api/files/','title':"Files",'section':"LDS C+E Documentation",'content':"Files #    ldsCtrlEst_h/lds.h lds namespace\n  ldsCtrlEst_h/lds_fit.h LDS base fit type.\n  ldsCtrlEst_h/lds_gaussian.h glds namespace\n  ldsCtrlEst_h/lds_gaussian_ctrl.h GLDS controller type.\n  ldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type.\n  ldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type.\n  ldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type.\n  ldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type.\n  ldsCtrlEst_h/lds_gaussian_sys.h GLDS base type.\n  ldsCtrlEst_h/lds_poisson.h plds namespace\n  ldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type.\n  ldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type.\n  ldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type.\n  ldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type.\n  ldsCtrlEst_h/lds_poisson_sys.h PLDS base type.\n  ldsCtrlEst_h/lds_sys.h LDS base type.\n  ldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API)\n  ldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API)\n  examples/eg_glds_ctrl.cpp\n  examples/eg_plds_est.cpp\n  examples/eg_plds_logLinCtrl.cpp\n  examples/eg_plds_switched_logLinCtrl.cpp\n  src/lds_gaussian_ctrl.cpp GLDS controller type.\n  src/lds_gaussian_sctrl.cpp GLDS switched controller type.\n  src/lds_gaussian_sys.cpp GLDS base type.\n  src/lds_poisson_ctrl.cpp PLDS controller type.\n  src/lds_poisson_sctrl.cpp PLDS switched controller type.\n  src/lds_poisson_sys.cpp PLDS base type.\n  src/lds_sys.cpp LDS base type.\n   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':23,'href':'/ldsctrlest/docs/api/namespaces/namespaceglds/','title':"glds",'section':"Namespaces",'content':"glds #   Updated on 3 March 2021 at 23:06:11 CST\n"});index.add({'id':24,'href':'/ldsctrlest/docs/tutorials/eg_glds_control/','title':"GLDS Control",'section':"LDS C+E Examples",'content':"GLDS Control Tutorial #  This tutorial shows how to use this library to control a system with a Gaussian LDS controller (lds::gaussian::ctrl_t). In place of a physical system, another GLDS model (lds::gaussian::sys_t) receives control inputs and provides measurements for the simulated feedback control loop. The controller is assumed to have an imperfect model of the system being controlled (here, a gain mismatch), and there is a stochastic, unmeasured disturbance acting on the system. A combination of integral action and adaptive estimation of this process disturbance is used to perform control.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; Creating a simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 5 seconds.\n// Make 1st-order SISO system, sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(5.0 / dt); When a system is initialized, rather than requiring all parameters to be provided at construction, only the dimensions and sample period are required and a default system is created.\n// construct ground truth system to be controlled...  // initializes to random walk model with top-most n_y state observed  lds::gaussian::sys_t controlled_system(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example,   \\[x_{t\u0026#43;1} = x_t \u0026#43; w_t\\]   \\[y_{t} = x_t \\; .\\]  Now, we\u0026rsquo;ll create non-default parameters for this model.\n// Ground-truth parameters for the controlled system  // (stand-in for physical system to be controlled)  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.01); armaMat b_true = armaMat(n_x, n_u).fill(2e-4); // control signal to model input unit conversion e.g., V -\u0026gt; mW/mm2:  armaVec g_true = armaVec(n_y).fill(10.0); // output noise covariance  armaMat r_true = armaMat(n_y, n_y, arma::fill::eye) * 1e-4; As mentioned above, this example will feature a stochastic disturbance. More specifically, a process disturbance will randomly change between two values.\n/// Going to simulate a switching disturbance (m) acting on system  size_t which_m = 0; // whether low or high disturbance (0, 1)  data_t m_low = 5 * dt * (1 - a_true[0]); data_t pr_lo2hi = 1e-3; // probability of going from low to high disturb.  data_t m_high = 20 * dt * (1 - a_true[0]); data_t pr_hi2lo = pr_lo2hi; // initially let m be low  armaVec m0_true = armaVec(n_y).fill(m_low); Finally, assign the parameters using corresponding set-methods.\n// Assign params.  controlled_system.setA(a_true); controlled_system.setB(b_true); controlled_system.setM(m0_true); controlled_system.setG(g_true); controlled_system.setR(r_true); Creating the controller #  Now, create the controller. Similar to creating a system, most parameters are set to defaults at object construction. In additioin to system dimensions and sample period, the controller needs to know the upper and lower bounds on the control signal, past which the control saturates. If your actuator does not saturate somehow, simply set the lower and upper bounds to -lds::inf and lds::inf, respectively. Simple saturation is currently the only actuator model in this library.\nHere, the control signal is command voltage sent to a physical driver (e.g., for an LED). Its limits are 0 to 5 V.\n// create controller  // lower and upper bounds on control signal (e.g., in Volts)  data_t u_lb = 0.0; // [=] V  data_t u_ub = 5.0; // [=] V  glds::ctrl_t controller(n_u, n_x, n_y, u_lb, u_ub, dt); Now, assign non-default parameters to this controller. For the sake of this simulation, the input matrix is set to an incorrect value. We also assume that the controller feedback gains were designed with an actuator whose conversion factor from volts to physical units (e.g., mW/mm2 optical intensity) differed from the actuator being used in the current experiment.\n// Create **incorrect** model used for control.  // (e.g., imperfect model fitting)  armaMat b_controller = armaMat(n_x, n_u).fill(1e-4); // Let\u0026#39;s say these controller gains were designed assuming g was 9 V/(mW/mm2):  armaVec g_design = armaVec(n_u).fill(9); // let\u0026#39;s assume zero process disturbance initially  // (will be re-estimating)  armaVec m_controller = armaVec(n_x, arma::fill::zeros); // Control variables:  // if following enabled, adapts set point with re-estimated process  // disturbance n.b., should not need integral action if this is enabled as the  // adaptive estimator minimizes DC error  bool do_adaptive_set_point = false; // Reference/target output, controller gains  // n.b., Can either use armaVec (arma::Col) or std::vector  armaVec y_ref0 = armaVec(n_y).fill(20.0 * dt); // (Can either use arma::Mat or mats flattened into std::vector)  armaMat k_x = armaMat(n_u, n_x).fill(100); // gains on state error  armaMat k_inty = armaMat(n_u, n_y).fill(1e3); // gains on integrated err  // setting initial state to target to avoid error at onset:  armaVec x0 = armaVec(n_x).fill(y_ref0[0]); // set up controller type bit mask so controller knows how to proceed  size_t control_type = 0; if (do_adaptive_set_point) { // adapt set point with estimated disturbance  control_type = control_type | lds::CONTROL_TYPE_ADAPT_M; } else { // use integral action to minimize DC error  control_type = control_type | lds::CONTROL_TYPE_INTY; } // Start configuring controller:  // Adaptively re-estimate process disturance (m)  controller.adaptM = true; // set controller type  controller.setControlType(control_type); // Set params.  // **n.b. using arbitrary defaults for Q, R in this example. Really, these  // should be set by users, as they tune characteristics of Kalman filter.  // Users can also choose not to recursively calculate the estimator gain and  // supply it (setKe) instead of covariances.**  controller.setYRef(y_ref0); controller.setKc_x(k_x); controller.setKc_inty(k_inty); controller.setA(a_true); controller.setB(b_controller); controller.setM(m_controller); controller.setG(g_true); controller.setGDesign(g_design); controller.setX0(x0); controller.reset(); // reset to new initial condition  // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; controller.setQ_m(q_m); Simulating control #  In this demonstration, we will use the steadyState_fbCtrl method which allows users to simply set the reference output and supply the current measurement z_t. It then calculates the steady-state solution for the reference state/input. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system.\nThe control loop is carried out here in a simple for-loop, where a the controlled system is simulated, a measurement taken, and the control signal updated.\n// Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_t(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_t); // This method uses a steady-state solution to control problem to calculate  // xRef, uRef from reference output yRef. Therefore, it is only applicable  // to regulation problems or cases where reference trajectory changes slowly  // compared to system dynamics.  controller.steadyState_fbCtrl(z_t); Example simulation result #  Below are example results for this simulation, including outputs, latent states, process disturbance, and the control signal. The controller\u0026rsquo;s online estimates of the output, state, and disturbance are given in purple.\n"});index.add({'id':25,'href':'/ldsctrlest/docs/api/files/dir_8f2980731aba7ec7b9fcae5764f196e3/','title':"include",'section':"Files",'content':"include #  Directories #     Name     ldsCtrlEst_h     Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':26,'href':'/ldsctrlest/docs/api/namespaces/namespacelds/','title':"lds",'section':"Namespaces",'content':"lds #  Linear Dynamical Systems (LDS) namespace. Namespaces #     Name     lds::gaussian Linear Dynamical Systems with Gaussian observations.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::fit_t LDS Fit Type.   class lds::sys_t Linear Dynamical System Type.    Types #      Name     enum ssidWt { NONE, MOESP, CVA}   typedef double data_t   typedef std::vector\u0026lt; data_t \u0026gt; stdVec provides fill types for constructing new armadillo vectors, matrices   typedef arma::Col\u0026lt; data_t \u0026gt; armaVec   typedef arma::Mat\u0026lt; data_t \u0026gt; armaMat   typedef arma::Cube\u0026lt; data_t \u0026gt; armaCube   typedef arma::subview_col\u0026lt; data_t \u0026gt; armaSubVec   typedef arma::subview\u0026lt; data_t \u0026gt; armaSubMat    Attributes #      Name     const std::size_t CONTROL_TYPE_U   const std::size_t CONTROL_TYPE_INTY   const std::size_t CONTROL_TYPE_ADAPT_M Control setpoint adapted with (re-estimated) process disturbance m.   data_t inf Some useful numbers.   data_t neginf   const data_t pi   data_t DEFAULT_P0   data_t DEFAULT_Q0   data_t DEFAULT_R0   std::vector\u0026lt; data_t \u0026gt; DEFAULT_T0   data_t DATA_T_ZERO   data_t DATA_T_ONE   data_t DEFAULT_SOFTSTART   bool FALSE   bool TRUE    Type Details #  ssidWt #     Enumerator Value Description     NONE     MOESP     CVA      Weighting options for singular value decomposition performed during subspace identification (SSID): None, MOESP \u0026ldquo;robust method\u0026rdquo;, CVA \u0026ldquo;Canonical Variate Analysis\u0026rdquo;)\ndata_t #  typedef double lds::data_t; Precision/type of all data in library. If need 32b, change double to float.\nstdVec #  typedef std::vector\u0026lt;data_t\u0026gt; lds::stdVec; armaVec #  typedef arma::Col\u0026lt;data_t\u0026gt; lds::armaVec; armaMat #  typedef arma::Mat\u0026lt;data_t\u0026gt; lds::armaMat; armaCube #  typedef arma::Cube\u0026lt;data_t\u0026gt; lds::armaCube; armaSubVec #  typedef arma::subview_col\u0026lt;data_t\u0026gt; lds::armaSubVec; armaSubMat #  typedef arma::subview\u0026lt;data_t\u0026gt; lds::armaSubMat; Attribute Details #  CONTROL_TYPE_U #  static const std::size_t CONTROL_TYPE_U = 0x1; Control was designed to penalize change in input (i.e., the state was augmented with input u)\nCONTROL_TYPE_INTY #  static const std::size_t CONTROL_TYPE_INTY = CONTROL_TYPE_U \u0026lt;\u0026lt; 1; Control using integral action (i.e., the state was augmented with output y during design)\nCONTROL_TYPE_ADAPT_M #  static const std::size_t CONTROL_TYPE_ADAPT_M = CONTROL_TYPE_U \u0026lt;\u0026lt; 2; inf #  static data_t inf = std::numeric_limits\u0026lt;[data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t)\u0026gt;::infinity(); neginf #  static data_t neginf = -inf; pi #  static const data_t pi = arma::datum::pi; DEFAULT_P0 #  static data_t DEFAULT_P0 = 1e-6; DEFAULT_Q0 #  static data_t DEFAULT_Q0 = 1e-6; DEFAULT_R0 #  static data_t DEFAULT_R0 = 1e-2; DEFAULT_T0 #  static std::vector\u0026lt; data_t \u0026gt; DEFAULT_T0 = std::vector\u0026lt;[data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t)\u0026gt;(1, 0.0); DATA_T_ZERO #  static data_t DATA_T_ZERO = ([data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t))0; DATA_T_ONE #  static data_t DATA_T_ONE = ([data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t))1; DEFAULT_SOFTSTART #  static data_t DEFAULT_SOFTSTART = ([data_t](/ldsctrlest/docs/api/namespaces/namespacelds/#typedef-data_t))0; FALSE #  static bool FALSE = false; TRUE #  static bool TRUE = true;  Updated on 3 March 2021 at 23:06:11 CST\n"});index.add({'id':27,'href':'/ldsctrlest/docs/api/classes/classlds_1_1fit__t/','title':"lds::fit_t",'section':"Classes",'content':"lds::fit_t #  LDS Fit Type. #include \u0026lt;lds_fit.h\u0026gt;\nInherited by lds::gaussian::fit_t, lds::poisson::fit_t\nPublic Functions #      Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes #      Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  fit_t #  inline fit_t()  fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate dt { parameter_description }   Public Attribute Details #  A #  armaMat A;  B #  armaMat B;  g #  armaVec g;  m #  armaVec m;  Q #  armaMat Q;  x0 #  armaVec x0;  P0 #  armaMat P0;  dt #  data_t dt;   Updated on 3 March 2021 at 23:06:11 CST\n"});index.add({'id':28,'href':'/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/','title':"lds::gaussian",'section':"Namespaces",'content':"lds::gaussian #  Linear Dynamical Systems with Gaussian observations. Classes #      Name     class lds::gaussian::ctrl_t GLDS Controller Type.   class lds::gaussian::fit_t GLDS Fit Type.   class lds::gaussian::emFit_t GLDS E-M Fit Type.   class lds::gaussian::ssidFit_t GLDS SSID Fit Type.   class lds::gaussian::sctrl_t Switched GLDS Controller Type.   class lds::gaussian::sys_t Gaussian LDS Type.    Types #      Name     typedef lds::data_t data_t   typedef lds::stdVec stdVec   typedef lds::armaVec armaVec   typedef lds::armaMat armaMat   typedef lds::armaSubVec armaSubVec   typedef lds::armaSubMat armaSubMat    Functions #      Name     emFit_t emFit_x_equals_y(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain, data_t dt, std::size_t maxIter =100, data_t tol =1e-3, data_t q0 =1e-6, bool calcAB =true, bool calcQ =true, bool calcR =true)\nPerform EM for special system where y = x + noise.   ssidFit_t ssidFit(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-inf), bool force_unitNormC =false, ssidWt wt =NONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =DEFAULT_T0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity())\nFit a GLDS model using subspace identification (SSID)   armaVec calcD_silence(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, data_t dt, data_t tSilence =0.1, data_t threshSilence =0.001)\nUsing periods of silence in inputs (u), calculates the output \\ bias.   void createHankelMat_n4sid(armaMat \u0026amp; u, armaMat \u0026amp; z, std::size_t \u0026amp; nH, armaMat \u0026amp; D)\nCreate block-hankel data matrix for N4SID method.   void ssid_n4sid(std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; m, armaVec \u0026amp; d, armaVec \u0026amp; s, bool force_unitNormC, ssidWt wt, data_t wtG0)\nN4SID method of SSID.   void ssid_n4sid_vanOverschee(std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; s, ssidWt wt)\nN4SID method of SSID.   void recompute_extObs(armaMat \u0026amp; extObs, armaMat \u0026amp; A, armaMat \u0026amp; C, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH)\nRecompute extended observability matrix, given A, C.   void lq(armaMat \u0026amp; L, armaMat \u0026amp; Qt, armaMat \u0026amp; X)\nLQ decomposition.   armaMat calcCov(armaMat \u0026amp; A, armaMat \u0026amp; B)\nCalculate covariance matrix.   armaMat sqrtmat_svd(armaMat \u0026amp; X)    Attributes #      Name     const std::size_t CONTROL_TYPE_U   const std::size_t CONTROL_TYPE_INTY   const std::size_t CONTROL_TYPE_ADAPT_M   data_t DATA_T_ZERO   data_t DATA_T_ONE   data_t DEFAULT_SOFTSTART   bool FALSE   bool TRUE   const data_t pi   data_t inf   data_t neginf    Type Details #  data_t #  typedef lds::data_t lds::gaussian::data_t; stdVec #  typedef lds::stdVec lds::gaussian::stdVec; armaVec #  typedef lds::armaVec lds::gaussian::armaVec; armaMat #  typedef lds::armaMat lds::gaussian::armaMat; armaSubVec #  typedef lds::armaSubVec lds::gaussian::armaSubVec; armaSubMat #  typedef lds::armaSubMat lds::gaussian::armaSubMat; Function Details #  emFit_x_equals_y #  emFit_t emFit_x_equals_y( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain, data_t dt, std::size_t maxIter =100, data_t tol =1e-3, data_t q0 =1e-6, bool calcAB =true, bool calcQ =true, bool calcR =true ) Parameters:\n uTrain training input data zTrain training measurement data dt sample period maxIter [optional] maximum number of iterations tol [optional] convergence tolerance q0 [optional] initial diagonal elements of process noise covariance calcAB [optional] whether to calculate dynamics (A, B) calcQ [optional] whether to calculate process noise covariance calcR [optional] whether to calculate output noise covariance  Return: EM fit\nssidFit #  ssidFit_t ssidFit( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-inf), bool force_unitNormC =false, ssidWt wt =NONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =DEFAULT_T0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity() ) Parameters:\n u inputs z measurements dt sample period nX number of states nH block-Hankel data matrix size d0 previous estimate of output bias (d) force_unitNormC force fitting where C has unit norm wt chosen weighting for SSID singular value \\ decomposition (NONE, MOESP, CVA) wtG0 chosen weighting for minimizing model error at \\ DC t0 start times for each trial of input/output data t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID  Return: the SSID-fit GLDS model.\nFit a GLDS model using subspace identification (SSID)\nReferences:\nvan Overschee P, de Moor B. (1996) Subspace Identification for Linear Systems.\ncalcD_silence #  armaVec calcD_silence( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, data_t dt, data_t tSilence =0.1, data_t threshSilence =0.001 ) Parameters:\n n measurements u inputs dt sample period tSilence threshold on period of time that qualifies as \u0026ldquo;silence\u0026rdquo; threshSilence threshold on input amplitude u that qualifies as \u0026ldquo;silence\u0026rdquo;  Return: d estimated output bias.\ncreateHankelMat_n4sid #  void createHankelMat_n4sid( armaMat \u0026amp; u, armaMat \u0026amp; z, std::size_t \u0026amp; nH, armaMat \u0026amp; D ) Parameters:\n u input data z measurement data nH block-Hankel matrix size D block-Hankel data matrix  ssid_n4sid #  void ssid_n4sid( std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; m, armaVec \u0026amp; d, armaVec \u0026amp; s, bool force_unitNormC, ssidWt wt, data_t wtG0 ) Parameters:\n nX number of states nU number of inputs nY number of outputs nH block-Hankel matrix size uSSID input data zSSID measurement data A state matrix B input matrix C output matrix D feedthrough matrix Q process noise covariance R output noise covariance m process disturbance d output bias s singular values force_unitNormC whether to force C to be unit-norm wt weighting method for SVD (NONE, MOESP, CVA) wtG0 weight put on minimizing error at DC  ssid_n4sid_vanOverschee #  void ssid_n4sid_vanOverschee( std::size_t \u0026amp; nX, std::size_t \u0026amp; nU, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH, armaMat \u0026amp; uSSID, armaMat \u0026amp; zSSID, armaMat \u0026amp; A, armaMat \u0026amp; B, armaMat \u0026amp; C, armaMat \u0026amp; D, armaMat \u0026amp; Q, armaMat \u0026amp; R, armaVec \u0026amp; s, ssidWt wt ) Parameters:\n nX number of state nU number of inputs nY number of outputs nH block-Hankel data matrix size uSSID input data zSSID measurement data A state matrix B input matrix C output matrix D feedthrough matrix Q process noise covariance R output noise covariance s singular values wt weighting method for SVD (NONE, MOESP, CVA)  N4SID method of SSID\nThis is a more direct implementation of van Overschee, de Moor (1996)\nrecompute_extObs #  void recompute_extObs( armaMat \u0026amp; extObs, armaMat \u0026amp; A, armaMat \u0026amp; C, std::size_t \u0026amp; nY, std::size_t \u0026amp; nH ) Parameters:\n extObs Extended observability matrix A state matrix C output matrix nY number of outputs nH block-Hankel data matrix size  lq #  void lq( armaMat \u0026amp; L, armaMat \u0026amp; Qt, armaMat \u0026amp; X ) Parameters:\n L lower triangle matrix Qt orthonormal matrix (transposed cf QR decomp) X matrix being decomposed  calcCov #  armaMat calcCov( armaMat \u0026amp; A, armaMat \u0026amp; B ) Parameters:\n A some matrix B some other matrix  Return: covariance\nsqrtmat_svd #  armaMat sqrtmat_svd( armaMat \u0026amp; X ) Parameters:\n X some matrix  Return: approximate sqrtmat(X)\nApproximate sqrtmat by singular value decomposition.\nsvd(X) \u0026ndash;\u0026gt; U * sqrt(s) * V' ~= sqrtmat(X)\nAttribute Details #  CONTROL_TYPE_U #  static const std::size_t CONTROL_TYPE_U = lds::CONTROL_TYPE_U; CONTROL_TYPE_INTY #  static const std::size_t CONTROL_TYPE_INTY = lds::CONTROL_TYPE_INTY; CONTROL_TYPE_ADAPT_M #  static const std::size_t CONTROL_TYPE_ADAPT_M = lds::CONTROL_TYPE_ADAPT_M; DATA_T_ZERO #  static data_t DATA_T_ZERO = lds::DATA_T_ZERO; DATA_T_ONE #  static data_t DATA_T_ONE = lds::DATA_T_ZERO; DEFAULT_SOFTSTART #  static data_t DEFAULT_SOFTSTART = lds::DEFAULT_SOFTSTART; FALSE #  static bool FALSE = lds::FALSE; TRUE #  static bool TRUE = lds::TRUE; pi #  static const data_t pi = lds::pi; inf #  static data_t inf = lds::inf; neginf #  static data_t neginf = lds::neginf;  Updated on 3 March 2021 at 23:06:11 CST\n"});index.add({'id':29,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ctrl__t/','title':"lds::gaussian::ctrl_t",'section':"Classes",'content':"lds::gaussian::ctrl_t #  GLDS Controller Type. #include \u0026lt;lds_gaussian_ctrl.h\u0026gt;\nInherits from lds::gaussian::sys_t, lds::sys_t\nInherited by lds::gaussian::sctrl_t\nPublic Functions #      Name      ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0)\nConstructs a new GLDS controller.   ctrl_t \u0026amp; operator=(const ctrl_t \u0026amp; sys)   void fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE)\nfeedback control (single step)   void steadyState_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE)\nsteady-state control (single step)   void calc_ssSetPt()   void printSys()\nPrint system variables to stdout.   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY)\nSet dimensions of system.   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setGDesign(stdVec \u0026amp; gVec)\nSet input gain used in controller design (gDesign)   void setGDesign(armaVec \u0026amp; g)\nSet input gain used in controller design (gDesign)   void setURef(stdVec \u0026amp; uRefVec)\nSet reference input (uRef)   void setURef(armaVec \u0026amp; uRef)\nSet reference input (uRef)   void setXRef(stdVec \u0026amp; xRefVec)\nSet reference state (xRef)   void setXRef(armaVec \u0026amp; xRef)\nSet reference state (xRef)   void setYRef(stdVec \u0026amp; yRefVec)\nSet reference output (yRef)   void setYRef(armaVec \u0026amp; yRef)\nSet reference output (yRef)   void setKc_x(stdVec \u0026amp; Kc_x_vec)\nSet state controller gain (Kc_x)   void setKc_x(armaMat \u0026amp; Kc_x)\nSet state controller gain (Kc_x)   void setKc_u(stdVec \u0026amp; Kc_u_vec)\nSet input controller gain (Kc_u)   void setKc_u(armaMat \u0026amp; Kc_u)\nSet input controller gain (Kc_u)   void setKc_inty(stdVec \u0026amp; Kc_inty_vec)\nSet integral controller gain (Kc_inty)   void setKc_inty(armaMat \u0026amp; Kc_inty)\nSet integral controller gain (Kc_inty)   void setControlType(size_t controlType)\nSet controller type.   void setTauAntiWindup(data_t \u0026amp; tau)\nSet time constant of anti-integral-windup.   armaMat getKc_u() const\nGet input controller gain (Kc_u)   armaMat getKc_x() const\nGet state controller gain (Kc_x)   armaMat getKc_inty() const\nGet integral controller gain (Kc_inty)   armaVec getGDesign() const\nGet input gain used in controller design (gDesign)   armaVec getURef() const\nGet reference input (uRef)   armaVec getXRef() const\nGet reference state (xRef)   armaVec getYRef() const\nGet reference output (yRef)   armaVec getIntE() const\nGet integrated error (intE)   size_t getControlType() const\nGet controller type.   void reset()\nReset system variables.    Protected Functions #      Name     void antiWindup()\nProtect against integral windup.    Protected Attributes #      Name     armaVec gDesign input gain of the system used for controller design   armaVec uRef reference input   armaVec uRef_prev reference input at previous time step   armaVec xRef reference state   armaVec yRef reference output   armaMat Kc_x state controller gain   armaMat Kc_u input controller gain (when control aims to minimize deltaU)   armaMat Kc_inty integral controller gain   armaVec duRef   armaVec dvRef   armaVec vRef   armaVec dv   armaVec v Control after g inversion (e.g., control in physical units)   armaVec intE integrated error   armaVec intE_awuAdjust anti-windup adjustment to intE   armaVec uSat control signal after saturation (for antiWindup)   bool gateCtrl_prev   bool gateLock_prev   bool uSaturated whether control signal has reached saturation limits   data_t \u0026amp; uLB lower bound on control   data_t \u0026amp; uUB upper bound on control   data_t tauAntiWindup antiwindup time constant   data_t kAntiWindup   data_t t_since_ctrl_onset time since control epoch onset   size_t controlType controller type    Additional inherited members #  Public Functions inherited from lds::gaussian::sys_t\n    Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate system measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0)\nConstructs a new GLDS.   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (d)   armaVec getR() const\nGet output noise covariance (R)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   armaMat getKe() const\nGet estimator gain (Ke)   armaMat getKe_m() const\nGet estimator gain for process disturbance (Ke_m)   void setC(stdVec \u0026amp; cVec)\nSet output matrix (C)   void setC(armaMat \u0026amp; C)\nSet output matrix (C)   void setD(stdVec \u0026amp; dVec)\nSet output bias (d)   void setD(armaVec \u0026amp; d)\nSet output bias (d)   void setR(stdVec \u0026amp; rVec)\nSet output noise covariance (R)   void setR(armaMat \u0026amp; R)\nSet output noise covariance (R)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void setKe(stdVec \u0026amp; keVec)\nSet estimator gain (Ke)   void setKe(armaMat \u0026amp; Ke)\nSet estimator gain (Ke)   void setKe_m(stdVec \u0026amp; kemVec)\nSet disturbance estimator gain (Ke_m)   void setKe_m(armaMat \u0026amp; Ke_m)\nSet disturbance estimator gain (Ke_m)    Protected Functions inherited from lds::gaussian::sys_t\n    Name     void recurse_Ke()\nRecursively recalculate Kalman estimator gain (Ke)   void predict()\nOne-step prediction.   void h()\nSystem output function.   void defaultR()\nReset to default R (identity matrix with diagonal elements r0)    Protected Attributes inherited from lds::gaussian::sys_t\n    Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaMat R covariance of output noise   data_t \u0026amp; r0 default values for R   armaVec y output   armaVec z measurement   armaMat Ke state estimator gain   armaMat Ke_m disturbance estimator gain    Public Functions inherited from lds::sys_t\n    Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)    Protected Functions inherited from lds::sys_t\n    Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  ctrl_t #  ctrl_t( std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0 ) Parameters:\n nU number of inputs nX number of states nY number of outputs uLB lower bound on control (u) uUB upper bound on control (u) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) r0 [optional] initial diagonal elements of output noise covariance (R) controlType [optional] control type bit mask   operator= #  ctrl_t \u0026amp; operator=( const ctrl_t \u0026amp; sys )  fbCtrl #  void fbCtrl( armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE ) Parameters:\n z measurement gateCtrl [optional] logical gate of control (high=enabled; low=disabled) gateLock [optional] logical gate of control signal lock (if high, locks control at current value) sigma_softStart [optional] standard deviation (sigma) of a Gaussian soft-start to control sigma_uNoise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal resetAtCtrlOnset [optional] whether to reset controller at onset of a new control epoch (gateCtrl from low to high) doRecurse_Ke [optional] whether to recalculate state estimator gain (Ke) recursively  Perform a single step of feedback control. This is the most flexible option, but requires user to have set the controller\u0026rsquo;s xRef and uRef variables.\n steadyState_fbCtrl #  void steadyState_fbCtrl( armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE ) Parameters:\n z measurement gateCtrl [optional] logical gate of control (high=enabled; low=disabled) gateEst [optional] logical gate of estimator (high=enabled; low=disabled) gateLock [optional] logical gate of control signal lock (if high, locks control at current value) sigma_softStart [optional] standard deviation (sigma) of a Gaussian soft-start to control sigma_uNoise [optional] standard deviation (sigma) of Gaussian noise added on top of control signal resetAtCtrlOnset [optional] whether to reset controller at onset of a new control epoch (gateCtrl from low to high) doRecurse_Ke [optional] whether to recalculate state estimator gain (Ke) recursively  Assuming the objective is to track a reference output (yRef) at steady state, perform a single step of control. Requires user to have set the controller\u0026rsquo;s yRef variable. If control is enabled (gateCtrl=true) but estimator is disabled (gateEst=true), this function provides the calculated steady-state input uRef in open loop.\n calc_ssSetPt #  void calc_ssSetPt() Calculate steady-state setpoint [xRef; uRef], given an output reference yRef.\n printSys #  void printSys()  setDims #  void setDims( std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY )  setU #  void setU( stdVec \u0026amp; uVec )  setU #  void setU( armaVec \u0026amp; u )  setG #  void setG( stdVec \u0026amp; gVec )  setG #  void setG( armaVec \u0026amp; g )  setGDesign #  void setGDesign( stdVec \u0026amp; gVec )  setGDesign #  void setGDesign( armaVec \u0026amp; g )  setURef #  void setURef( stdVec \u0026amp; uRefVec )  setURef #  void setURef( armaVec \u0026amp; uRef )  setXRef #  void setXRef( stdVec \u0026amp; xRefVec )  setXRef #  void setXRef( armaVec \u0026amp; xRef )  setYRef #  void setYRef( stdVec \u0026amp; yRefVec )  setYRef #  void setYRef( armaVec \u0026amp; yRef )  setKc_x #  void setKc_x( stdVec \u0026amp; Kc_x_vec )  setKc_x #  void setKc_x( armaMat \u0026amp; Kc_x )  setKc_u #  void setKc_u( stdVec \u0026amp; Kc_u_vec )  setKc_u #  void setKc_u( armaMat \u0026amp; Kc_u )  setKc_inty #  void setKc_inty( stdVec \u0026amp; Kc_inty_vec )  setKc_inty #  void setKc_inty( armaMat \u0026amp; Kc_inty )  setControlType #  void setControlType( size_t controlType )  setTauAntiWindup #  void setTauAntiWindup( data_t \u0026amp; tau )  getKc_u #  inline armaMat getKc_u() const  getKc_x #  inline armaMat getKc_x() const  getKc_inty #  inline armaMat getKc_inty() const  getGDesign #  inline armaVec getGDesign() const  getURef #  inline armaVec getURef() const  getXRef #  inline armaVec getXRef() const  getYRef #  inline armaVec getYRef() const  getIntE #  inline armaVec getIntE() const  getControlType #  inline size_t getControlType() const  reset #  void reset()  Protected Function Details #  antiWindup #  void antiWindup() Protect against integral windup\nReference:\nAstroem KJ, Rundqwist L. (1989) Integrator Windup and How to Avoid It. 1989 ACC.\n Protected Attribute Details #  gDesign #  armaVec gDesign;  uRef #  armaVec uRef;  uRef_prev #  armaVec uRef_prev;  xRef #  armaVec xRef;  yRef #  armaVec yRef;  Kc_x #  armaMat Kc_x;  Kc_u #  armaMat Kc_u;  Kc_inty #  armaMat Kc_inty;  duRef #  armaVec duRef;  dvRef #  armaVec dvRef;  vRef #  armaVec vRef;  dv #  armaVec dv;  v #  armaVec v;  intE #  armaVec intE;  intE_awuAdjust #  armaVec intE_awuAdjust;  uSat #  armaVec uSat;  gateCtrl_prev #  bool gateCtrl_prev;  gateLock_prev #  bool gateLock_prev;  uSaturated #  bool uSaturated;  uLB #  data_t \u0026amp; uLB;  uUB #  data_t \u0026amp; uUB;  tauAntiWindup #  data_t tauAntiWindup;  kAntiWindup #  data_t kAntiWindup;  t_since_ctrl_onset #  data_t t_since_ctrl_onset;  controlType #  size_t controlType;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':30,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1em_fit__t/','title':"lds::gaussian::emFit_t",'section':"Classes",'content':"lds::gaussian::emFit_t #  GLDS E-M Fit Type. More\u0026hellip;\n\n#include \u0026lt;lds_gaussian_fit_em.h\u0026gt;\nInherits from lds::gaussian::fit_t, lds::fit_t\nPublic Functions #      Name      emFit_t()    emFit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new EM Fit Type.    emFit_t(data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new EM Fit Type.    emFit_t(ssidFit_t \u0026amp; fit0)   void reset(void )\nReset EM fit.   void runEM(bool calcAB =true, bool calcQ =true, bool calcInitial =true, bool calcC =true, bool calcd =true, bool calcR =true)\nRun Expectation-Maximization algorithm.   std::vector\u0026lt; armaMat \u0026gt; getX()\nGet state estimate.   std::vector\u0026lt; armaMat \u0026gt; getY()\nGet output estimate.   armaMat get_sum_E_xu_tm1_xu_tm1()   armaMat get_sum_E_xu_t_xu_tm1()   armaMat get_sum_E_xu_t_xu_t()   size_t getT()   void setY(std::vector\u0026lt; armaMat \u0026gt; yHat)\nSet output.    Protected Functions #      Name     armaVec getTheta()\nGet recalculated parameters (packed into vector)   void kalmanFilt()   void kalmanSmooth(bool forceCommonInitial)\nKalman smooth dataset (fixed-interval smoothing)   void Estep(bool forceCommonInitial =false)\nExpectation step.   void Mstep(bool calcAB =true, bool calcQ =true, bool calcInitial =false, bool calcC =false, bool calcd =false, bool calcR =true)\nMaximization step.    Public Attributes #      Name     data_t tol tolerance for convergence   size_t maxIter maximum number of EM iterations    Protected Attributes #      Name     std::vector\u0026lt; armaMat \u0026gt; xHat state estimate   std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P state estimate covariance   std::vector\u0026lt; armaMat \u0026gt; yHat output estimate   std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P_t_tm1 single-lag state covariance   armaMat sum_E_xu_t_xu_t state-input covariance (current time)   armaMat sum_E_xu_tm1_xu_tm1 state-input covariance (t-minus-1)   armaMat sum_E_xu_t_xu_tm1 single lag state-input covariance   size_t T    Additional inherited members #  Public Functions inherited from lds::gaussian::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit.    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit type.    Public Attributes inherited from lds::gaussian::fit_t\n    Name     armaMat C output matrix   armaMat D feedthrough matrix   armaVec d output bias   armaMat R output noise cov   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Public Functions inherited from lds::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period    Detailed Description #  class lds::gaussian::emFit_t;  This type is used in the process of fitting GLDS models by expectation-maximization (EM).   Public Function Details #  emFit_t #  inline emFit_t()  emFit_t #  emFit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias R output noise covariance dt sample period uTrain training input data zTrain training measurement data   emFit_t #  emFit_t( data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n dt sample period uTrain training input data zTrain training measurement data  Constructs a new EM Fit Type.\nInitializes the model to a random walk.\n emFit_t #  emFit_t( ssidFit_t \u0026amp; fit0 )  reset #  void reset( void )  runEM #  void runEM( bool calcAB =true, bool calcQ =true, bool calcInitial =true, bool calcC =true, bool calcd =true, bool calcR =true ) Parameters:\n calcAB [optional] whether to caclulate dynamics (A, B) calcQ [optional] whether to calculate process noise covariance calcInitial [optional] whether to calculate initial conditions calcC [optional] whether to calculate output matrix calcd [optional] whether to calculate output bias calcR [optional] whether to calculate output noise covariance   getX #  inline std::vector\u0026lt; armaMat \u0026gt; getX()  getY #  inline std::vector\u0026lt; armaMat \u0026gt; getY()  get_sum_E_xu_tm1_xu_tm1 #  inline armaMat get_sum_E_xu_tm1_xu_tm1()  get_sum_E_xu_t_xu_tm1 #  inline armaMat get_sum_E_xu_t_xu_tm1()  get_sum_E_xu_t_xu_t #  inline armaMat get_sum_E_xu_t_xu_t()  getT #  inline size_t getT()  setY #  inline void setY( std::vector\u0026lt; armaMat \u0026gt; yHat )  Protected Function Details #  getTheta #  armaVec getTheta()  kalmanFilt #  void kalmanFilt() Kalman filter dataset Estimate x[t] | z[0\u0026hellip;t]\n kalmanSmooth #  void kalmanSmooth( bool forceCommonInitial ) Parameters:\n forceCommonInitial whether to force common initial condition for all trials  Kalman smooth dataset (fixed-interval smoothing)\nEstimate x[t] | z[0\u0026hellip;T]\n Estep #  void Estep( bool forceCommonInitial =false ) Parameters:\n forceCommonInitial whether to force common initial condition for all trials   Mstep #  void Mstep( bool calcAB =true, bool calcQ =true, bool calcInitial =false, bool calcC =false, bool calcd =false, bool calcR =true ) Parameters:\n calcAB [optional] whether to caclulate dynamics (A, B) calcQ [optional] whether to calculate process noise covariance calcInitial [optional] whether to calculate initial conditions calcC [optional] whether to calculate output matrix calcd [optional] whether to calculate output bias calcR [optional] whether to calculate output noise covariance   Public Attribute Details #  tol #  data_t tol = 1e-3;  maxIter #  size_t maxIter = 100;  Protected Attribute Details #  xHat #  std::vector\u0026lt; armaMat \u0026gt; xHat;  P #  std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P;  yHat #  std::vector\u0026lt; armaMat \u0026gt; yHat;  P_t_tm1 #  std::vector\u0026lt; arma::Cube\u0026lt; data_t \u0026gt; \u0026gt; P_t_tm1;  sum_E_xu_t_xu_t #  armaMat sum_E_xu_t_xu_t;  sum_E_xu_tm1_xu_tm1 #  armaMat sum_E_xu_tm1_xu_tm1;  sum_E_xu_t_xu_tm1 #  armaMat sum_E_xu_t_xu_tm1;  T #  size_t T;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':31,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1fit__t/','title':"lds::gaussian::fit_t",'section':"Classes",'content':"lds::gaussian::fit_t #  GLDS Fit Type. #include \u0026lt;lds_gaussian_fit.h\u0026gt;\nInherits from lds::fit_t\nInherited by lds::gaussian::emFit_t, lds::gaussian::ssidFit_t\nPublic Functions #      Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit.    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit type.    Public Attributes #      Name     armaMat C output matrix   armaMat D feedthrough matrix   armaVec d output bias   armaMat R output noise cov   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Additional inherited members #  Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  fit_t #  inline fit_t()  fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix D feedthrough matrix d output bias R covariance of output noise dt sample period uTrain input training data zTrain measurement training data   fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias R covariance of output noise dt sample period uTrain input training data zTrain measurement training data   Public Attribute Details #  C #  armaMat C;  D #  armaMat D;  d #  armaVec d;  R #  armaMat R;  uTrain #  std::vector\u0026lt; armaMat \u0026gt; uTrain;  zTrain #  std::vector\u0026lt; armaMat \u0026gt; zTrain;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':32,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sctrl__t/','title':"lds::gaussian::sctrl_t",'section':"Classes",'content':"lds::gaussian::sctrl_t #  Switched GLDS Controller Type. #include \u0026lt;lds_gaussian_sctrl.h\u0026gt;\nInherits from lds::gaussian::ctrl_t, lds::gaussian::sys_t, lds::sys_t\nPublic Functions #      Name      sctrl_t(std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0)\nConstructs a new switched GLDS controller.   void setSystem(size_t sysIdx, ctrl_t \u0026amp; sys)   void switchSystem(size_t sysIdx)\nSwitch to a different underlying sub-system.   size_t getSysIdx() const\nGet the index of currently active sub-system.    Protected Attributes #      Name     size_t nSys number of systems   std::vector\u0026lt; ctrl_t \u0026gt; systems underlying sub-systems which are toggled between   size_t sysIdx current system index.    Additional inherited members #  Public Functions inherited from lds::gaussian::ctrl_t\n    Name      ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0)\nConstructs a new GLDS controller.   ctrl_t \u0026amp; operator=(const ctrl_t \u0026amp; sys)   void fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE)\nfeedback control (single step)   void steadyState_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE, bool \u0026amp; doRecurse_Ke =TRUE)\nsteady-state control (single step)   void calc_ssSetPt()   void printSys()\nPrint system variables to stdout.   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setGDesign(stdVec \u0026amp; gVec)\nSet input gain used in controller design (gDesign)   void setGDesign(armaVec \u0026amp; g)\nSet input gain used in controller design (gDesign)   void setURef(stdVec \u0026amp; uRefVec)\nSet reference input (uRef)   void setURef(armaVec \u0026amp; uRef)\nSet reference input (uRef)   void setXRef(stdVec \u0026amp; xRefVec)\nSet reference state (xRef)   void setXRef(armaVec \u0026amp; xRef)\nSet reference state (xRef)   void setYRef(stdVec \u0026amp; yRefVec)\nSet reference output (yRef)   void setYRef(armaVec \u0026amp; yRef)\nSet reference output (yRef)   void setTauAntiWindup(data_t \u0026amp; tau)\nSet time constant of anti-integral-windup.   armaMat getKc_u() const\nGet input controller gain (Kc_u)   armaMat getKc_x() const\nGet state controller gain (Kc_x)   armaMat getKc_inty() const\nGet integral controller gain (Kc_inty)   armaVec getGDesign() const\nGet input gain used in controller design (gDesign)   armaVec getURef() const\nGet reference input (uRef)   armaVec getXRef() const\nGet reference state (xRef)   armaVec getYRef() const\nGet reference output (yRef)   armaVec getIntE() const\nGet integrated error (intE)   size_t getControlType() const\nGet controller type.   void reset()\nReset system variables.    Protected Functions inherited from lds::gaussian::ctrl_t\n    Name     void antiWindup()\nProtect against integral windup.    Protected Attributes inherited from lds::gaussian::ctrl_t\n    Name     armaVec gDesign input gain of the system used for controller design   armaVec uRef reference input   armaVec uRef_prev reference input at previous time step   armaVec xRef reference state   armaVec yRef reference output   armaMat Kc_x state controller gain   armaMat Kc_u input controller gain (when control aims to minimize deltaU)   armaMat Kc_inty integral controller gain   armaVec duRef   armaVec dvRef   armaVec vRef   armaVec dv   armaVec v Control after g inversion (e.g., control in physical units)   armaVec intE integrated error   armaVec intE_awuAdjust anti-windup adjustment to intE   armaVec uSat control signal after saturation (for antiWindup)   bool gateCtrl_prev   bool gateLock_prev   bool uSaturated whether control signal has reached saturation limits   data_t \u0026amp; uLB lower bound on control   data_t \u0026amp; uUB upper bound on control   data_t tauAntiWindup antiwindup time constant   data_t kAntiWindup   data_t t_since_ctrl_onset time since control epoch onset   size_t controlType controller type    Public Functions inherited from lds::gaussian::sys_t\n    Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate system measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0)\nConstructs a new GLDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (d)   armaVec getR() const\nGet output noise covariance (R)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   armaMat getKe() const\nGet estimator gain (Ke)   armaMat getKe_m() const\nGet estimator gain for process disturbance (Ke_m)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions inherited from lds::gaussian::sys_t\n    Name     void recurse_Ke()\nRecursively recalculate Kalman estimator gain (Ke)   void predict()\nOne-step prediction.   void h()\nSystem output function.   void defaultR()\nReset to default R (identity matrix with diagonal elements r0)    Protected Attributes inherited from lds::gaussian::sys_t\n    Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaMat R covariance of output noise   data_t \u0026amp; r0 default values for R   armaVec y output   armaVec z measurement   armaMat Ke state estimator gain   armaMat Ke_m disturbance estimator gain    Public Functions inherited from lds::sys_t\n    Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions inherited from lds::sys_t\n    Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  sctrl_t #  sctrl_t( std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0, size_t controlType =0 ) Parameters:\n nSys number of systems nU number of inputs nX number of states nY number of outputs uLB lower bound on control (u) uUB upper bound on control (u) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) r0 [optional] initial diagonal elements of output noise covariance (R) controlType [optional] control type bit mask   setSystem #  void setSystem( size_t sysIdx, ctrl_t \u0026amp; sys ) Set the parameters of selected sub-system using previously instantiated GLDS controllers.\n switchSystem #  void switchSystem( size_t sysIdx ) Switch to a different underlying sub-system by reassiging parameters at switch.\n getSysIdx #  inline size_t getSysIdx() const  Protected Attribute Details #  nSys #  size_t nSys;  systems #  std::vector\u0026lt; ctrl_t \u0026gt; systems;  sysIdx #  size_t sysIdx;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':33,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ssid_fit__t/','title':"lds::gaussian::ssidFit_t",'section':"Classes",'content':"lds::gaussian::ssidFit_t #  GLDS SSID Fit Type. More\u0026hellip;\n\n#include \u0026lt;lds_gaussian_fit_ssid.h\u0026gt;\nInherits from lds::gaussian::fit_t, lds::fit_t\nPublic Functions #      Name      ssidFit_t()    ssidFit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS SSID fit type.    Public Attributes #      Name     std::vector\u0026lt; data_t \u0026gt; t0   data_t t_startSSID   data_t t_stopSSID   armaVec singVals    Additional inherited members #  Public Functions inherited from lds::gaussian::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit.    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new GLDS fit type.    Public Attributes inherited from lds::gaussian::fit_t\n    Name     armaMat C output matrix   armaMat D feedthrough matrix   armaVec d output bias   armaMat R output noise cov   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Public Functions inherited from lds::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period    Detailed Description #  class lds::gaussian::ssidFit_t;  This type is used in the process of fitting GLDS models by subspace identification (SSID).   Public Function Details #  ssidFit_t #  inline ssidFit_t()  ssidFit_t #  ssidFit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaMat \u0026amp; D, armaVec \u0026amp; d, armaMat \u0026amp; R, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix D feedthrough matrix d output bias R output noise covariance dt sample period t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID singVals singular values from SSID SVD step t0 start times for each trial of input/output data uTrain training input data zTrain training measurement data   Public Attribute Details #  t0 #  std::vector\u0026lt; data_t \u0026gt; t0;  t_startSSID #  data_t t_startSSID;  t_stopSSID #  data_t t_stopSSID;  singVals #  armaVec singVals;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':34,'href':'/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/','title':"lds::gaussian::sys_t",'section':"Classes",'content':"lds::gaussian::sys_t #  Gaussian LDS Type. #include \u0026lt;lds_gaussian_sys.h\u0026gt;\nInherits from lds::sys_t\nInherited by lds::gaussian::ctrl_t\nPublic Functions #      Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z, bool doRecurse_Ke =true)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate system measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0)\nConstructs a new GLDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (d)   armaVec getR() const\nGet output noise covariance (R)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   armaMat getKe() const\nGet estimator gain (Ke)   armaMat getKe_m() const\nGet estimator gain for process disturbance (Ke_m)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY)\nSet dimensions of system.   void setC(stdVec \u0026amp; cVec)\nSet output matrix (C)   void setC(armaMat \u0026amp; C)\nSet output matrix (C)   void setD(stdVec \u0026amp; dVec)\nSet output bias (d)   void setD(armaVec \u0026amp; d)\nSet output bias (d)   void setR(stdVec \u0026amp; rVec)\nSet output noise covariance (R)   void setR(armaMat \u0026amp; R)\nSet output noise covariance (R)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void setKe(stdVec \u0026amp; keVec)\nSet estimator gain (Ke)   void setKe(armaMat \u0026amp; Ke)\nSet estimator gain (Ke)   void setKe_m(stdVec \u0026amp; kemVec)\nSet disturbance estimator gain (Ke_m)   void setKe_m(armaMat \u0026amp; Ke_m)\nSet disturbance estimator gain (Ke_m)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions #      Name     void recurse_Ke()\nRecursively recalculate Kalman estimator gain (Ke)   void predict()\nOne-step prediction.   void h()\nSystem output function.   void defaultR()\nReset to default R (identity matrix with diagonal elements r0)    Protected Attributes #      Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaMat R covariance of output noise   data_t \u0026amp; r0 default values for R   armaVec y output   armaVec z measurement   armaMat Ke state estimator gain   armaMat Ke_m disturbance estimator gain    Additional inherited members #  Public Functions inherited from lds::sys_t\n    Name     void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)    Protected Functions inherited from lds::sys_t\n    Name     void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  filter #  void filter( armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t, bool doRecurse_Ke =true ) Parameters:\n u_tm1 input at t-minus-1 z_t current measurement doRecurse_Ke whether to calculate the Kalman estimator gain (Ke) recursively  Given current measurment and input, filter data to produce causal state estimates using Kalman filtering, which procedes by predicting the state and subsequently updating.\n filter #  void filter( armaVec \u0026amp; z, bool doRecurse_Ke =true ) Parameters:\n z current measurement doRecurse_Ke whether to calculate the Kalman estimator gain (Ke) recursively  Given current measurment, filter data to produce causal state estimates using Kalman filtering, which procedes by predicting the state and subsequently updating.\n simMeasurement #  void simMeasurement( armaVec \u0026amp; z ) Parameters:\n z measurement  Simulate system measurement: z ~ Poisson(y)\nn.b., In reality, this is only Poisson where rate y and sample period dt are sufficiently small there is only ever 0 or 1 events in a period. If either of those is violated, results will be innacurate.\n sys_t #  sys_t( std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, data_t \u0026amp; r0 =DEFAULT_R0 ) Parameters:\n nU number of inputs (u) nX number of states (x) nY number of outputs (y) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) r0 [optional] initial diagonal elements of output noise covariance (R)   operator= #  sys_t \u0026amp; operator=( const sys_t \u0026amp; sys )  getNy #  inline size_t getNy() const  getC #  inline armaMat getC() const  getD #  inline armaVec getD() const  getR #  inline armaVec getR() const  getY #  inline armaVec getY() const  getZ #  inline armaVec getZ() const  getKe #  inline armaMat getKe() const  getKe_m #  inline armaMat getKe_m() const  setDims #  void setDims( std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY )  setC #  void setC( stdVec \u0026amp; cVec )  setC #  void setC( armaMat \u0026amp; C )  setD #  void setD( stdVec \u0026amp; dVec )  setD #  void setD( armaVec \u0026amp; d )  setR #  void setR( stdVec \u0026amp; rVec )  setR #  void setR( armaMat \u0026amp; R )  setZ #  void setZ( stdVec \u0026amp; zVec )  setZ #  void setZ( armaVec \u0026amp; z )  setKe #  void setKe( stdVec \u0026amp; keVec )  setKe #  void setKe( armaMat \u0026amp; Ke )  setKe_m #  void setKe_m( stdVec \u0026amp; kemVec )  setKe_m #  void setKe_m( armaMat \u0026amp; Ke_m )  reset #  void reset()  printSys #  void printSys()  Protected Function Details #  recurse_Ke #  void recurse_Ke()  predict #  void predict()  h #  void h()  defaultR #  void defaultR()  Protected Attribute Details #  nY #  std::size_t nY;  C #  armaMat C;  d #  armaVec d;  R #  armaMat R;  r0 #  data_t \u0026amp; r0;  y #  armaVec y;  z #  armaVec z;  Ke #  armaMat Ke;  Ke_m #  armaMat Ke_m;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':35,'href':'/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/','title':"lds::poisson",'section':"Namespaces",'content':"lds::poisson #  Linear Dynamical Systems with Poisson observations. Classes #      Name     class lds::poisson::ctrl_t PLDS Controller Type.   class lds::poisson::fit_t PLDS Fit Type.   class lds::poisson::ssidFit_t GLDS SSID Fit Type.   class lds::poisson::sctrl_t Switched PLDS Controller Type.   class lds::poisson::sys_t Poisson LDS Type.    Types #      Name     typedef lds::data_t data_t   typedef lds::stdVec stdVec   typedef lds::armaVec armaVec   typedef lds::armaMat armaMat   typedef lds::armaSubVec armaSubVec   typedef lds::armaSubMat armaSubMat    Functions #      Name     std::tuple\u0026lt; ssidFit_t, lds::gaussian::ssidFit_t \u0026gt; ssidFit(std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-inf), ssidWt wt =NONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =DEFAULT_T0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), bool assumeGaussian =true)\nFit a PLDS model using subspace identification (SSID)   void newtonSolveC_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nSolve for output matrix by Poisson MLE.   data_t newtonSolve_rescaleC_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nSolve for rescaled output matrix by Poisson MLE.   void calcD_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nCalculates output bias by Poisson MLE.   data_t calcD_newtonSolve_rescaleC_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nCalculates output bias and rescaled output matrix by Poisson MLE.   void fitOutput_mle(armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt)\nCalculates exponential output function by Poisson MLE.    Attributes #      Name     const std::size_t CONTROL_TYPE_U   const std::size_t CONTROL_TYPE_INTY   const std::size_t CONTROL_TYPE_ADAPT_M   data_t DATA_T_ZERO   data_t DATA_T_ONE   data_t DEFAULT_SOFTSTART   bool FALSE   bool TRUE   const data_t pi   data_t inf   data_t neginf    Type Details #  data_t #  typedef lds::data_t lds::poisson::data_t; stdVec #  typedef lds::stdVec lds::poisson::stdVec; armaVec #  typedef lds::armaVec lds::poisson::armaVec; armaMat #  typedef lds::armaMat lds::poisson::armaMat; armaSubVec #  typedef lds::armaSubVec lds::poisson::armaSubVec; armaSubMat #  typedef lds::armaSubMat lds::poisson::armaSubMat; Function Details #  ssidFit #  std::tuple\u0026lt; ssidFit_t, lds::gaussian::ssidFit_t \u0026gt; ssidFit( std::vector\u0026lt; armaMat \u0026gt; \u0026amp; u, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; z, data_t dt, size_t nX, size_t nH =25, armaVec d0 =armaVec(1).fill(-inf), ssidWt wt =NONE, data_t wtG0 =0.0, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0 =DEFAULT_T0, data_t t_startSSID =-std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), data_t t_stopSSID =std::numeric_limits\u0026lt; data_t \u0026gt;::infinity(), bool assumeGaussian =true ) Parameters:\n u inputs n { parameter_description } dt sample period nX number of states nH block-Hankel data matrix size d0 previous estimate of output bias (d) wt chosen weighting for SSID singular value \\ decomposition (NONE, MOESP, CVA) wtG0 chosen weighting for minimizing model error at \\ DC t0 start times for each trial of input/output data t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID assumeGaussian [NONFUNCTIONAL] whether to assume Gaussian observation model and fit by linear SSID first, then fit output nonlinearity by Poisson MLE z measurements  Return: tuple\u0026lt;PLDS fit, GLDS fit\u0026gt;\nFit PLDS model by subspace identification (SSID). System matrices (A,B,C) are fit by SSID assuming gaussian observations. Iteratively refits output function parameters (C, d) by Poisson MLE using Newton\u0026rsquo;s method.\nnewtonSolveC_mle #  void newtonSolveC_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Given dynamics and initial guess of output, solves for output matrix (C) by maximizing Poisson maximum likelihood using Newton\u0026rsquo;s method.\nnewtonSolve_rescaleC_mle #  data_t newtonSolve_rescaleC_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Return: negative log-likelihood\nGiven dynamics and initial guess of output, solves for a scaling factor to apply to output matrix (C) by maximizing Poisson maximum likelihood using Newton\u0026rsquo;s method.\nn.b., see Bussgang theorem (1952)\ncalcD_mle #  void calcD_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  calcD_newtonSolve_rescaleC_mle #  data_t calcD_newtonSolve_rescaleC_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Return: negative log-likelihood\nfitOutput_mle #  void fitOutput_mle( armaMat \u0026amp; C, armaVec \u0026amp; d, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; x, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; n, data_t \u0026amp; dt ) Parameters:\n C output matrix d output bias x state data n measured count data dt sample period  Attribute Details #  CONTROL_TYPE_U #  static const std::size_t CONTROL_TYPE_U = lds::CONTROL_TYPE_U; CONTROL_TYPE_INTY #  static const std::size_t CONTROL_TYPE_INTY = lds::CONTROL_TYPE_INTY; CONTROL_TYPE_ADAPT_M #  static const std::size_t CONTROL_TYPE_ADAPT_M = lds::CONTROL_TYPE_ADAPT_M; DATA_T_ZERO #  static data_t DATA_T_ZERO = lds::DATA_T_ZERO; DATA_T_ONE #  static data_t DATA_T_ONE = lds::DATA_T_ZERO; DEFAULT_SOFTSTART #  static data_t DEFAULT_SOFTSTART = lds::DEFAULT_SOFTSTART; FALSE #  static bool FALSE = lds::FALSE; TRUE #  static bool TRUE = lds::TRUE; pi #  static const data_t pi = lds::pi; inf #  static data_t inf = lds::inf; neginf #  static data_t neginf = lds::neginf;  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':36,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1ctrl__t/','title':"lds::poisson::ctrl_t",'section':"Classes",'content':"lds::poisson::ctrl_t #  PLDS Controller Type. #include \u0026lt;lds_poisson_ctrl.h\u0026gt;\nInherits from lds::poisson::sys_t, lds::sys_t\nInherited by lds::poisson::sctrl_t\nPublic Functions #      Name      ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0)\nConstructs a new PLDS controller.   ctrl_t \u0026amp; operator=(const ctrl_t \u0026amp; sys)   void logLin_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE)   void steadyState_logLin_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE)\nsteady-state log-linear control (single step)   void calc_ssSetPt()   void printSys()\nPrint system variables.   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setGDesign(stdVec \u0026amp; gVec)\nSet input gain used in controller design (gDesign)   void setGDesign(armaVec \u0026amp; g)\nSet input gain used in controller design (gDesign)   void setURef(stdVec \u0026amp; uRefVec)\nSet reference input (uRef)   void setURef(armaVec \u0026amp; uRef)\nSet reference input (uRef)   void setXRef(stdVec \u0026amp; xRefVec)\nSet reference state (xRef)   void setXRef(armaVec \u0026amp; xRef)\nSet reference state (xRef)   void setYRef(stdVec \u0026amp; yRefVec)\nSet reference output (yRef)   void setYRef(armaVec \u0026amp; yRef)\nSet reference output (yRef)   void setKc_x(stdVec \u0026amp; Kc_xVec)\nSet state controller gain (Kc_x)   void setKc_x(armaMat \u0026amp; Kc_x)\nSet state controller gain (Kc_x)   void setKc_u(stdVec \u0026amp; Kc_uVec)\nSet input controller gain (Kc_u)   void setKc_u(armaMat \u0026amp; Kc_u)\nSet input controller gain (Kc_u)   void setKc_inty(stdVec \u0026amp; Kc_intyVec)\nSet integral controller gain (Kc_inty)   void setKc_inty(armaMat \u0026amp; Kc_inty)\nSet integral controller gain (Kc_inty)   void setControlType(size_t controlType)\nSet controller type.   void setTauAntiWindup(data_t \u0026amp; tau)\nSet time constant of anti-integral-windup.   armaMat getKc_u() const\nGet input controller gain (Kc_u)   armaMat getKc_x() const\nGet input controller gain (Kc_u)   armaMat getKc_inty() const\nGet integral controller gain (Kc_inty)   armaVec getGDesign() const\nGet input gain used in controller design (gDesign)   armaVec getURef() const\nGet reference input (uRef)   armaVec getXRef() const\nGet reference state (xRef)   armaVec getLogYRef() const\nGet reference log-output (logyRef)   armaVec getYRef() const\nGet reference output (yRef)   armaVec getLogY() const\nGet log-output (logy)   armaVec getIntE() const\nGet integrated error (intE)   size_t getControlType() const\nGet controller type.   void reset()\nReset system variables.    Protected Functions #      Name     void antiWindup()\nProtect against integral windup.    Protected Attributes #      Name     armaVec gDesign input gain of the system used for controller design   armaVec uRef reference input   armaVec uRef_prev reference input at previous time step   armaVec xRef reference state   armaVec logyRef reference log-output   armaVec yRef reference output   armaMat Kc_x state controller gain   armaMat Kc_u input controller gain (when control aims to minimize deltaU)   armaMat Kc_inty integral controller gain (log-linear)   armaVec duRef   armaVec dvRef   armaVec vRef   armaVec dv   armaVec v Control after g inversion (e.g., control in physical units)   armaVec intE integrated error (log-output)   armaVec intE_awuAdjust anti-windup adjustment to intE   armaVec uSat control signal after saturation (for antiWindup)   bool gateCtrl_prev   bool gateLock_prev   data_t yRefLB lower bound on yRef (to avoid numerical log(0) issue)   bool uSaturated whether control signal has reached saturation limits   data_t \u0026amp; uLB lower bound on control   data_t \u0026amp; uUB upper bound on control   data_t tauAntiWindup antiwindup time constant   data_t kAntiWindup   data_t t_since_ctrl_onset time since control epoch onset   size_t controlType controller type    Additional inherited members #  Public Functions inherited from lds::poisson::sys_t\n    Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate one step of the model and produce a measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new PLDS.   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (D)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY)\nSet dimensions of sytem.   void setC(stdVec \u0026amp; cVec)\nSet output matrix (C)   void setC(armaMat \u0026amp; C)\nSet output matrix (C)   void setD(stdVec \u0026amp; dVec)\nSet output bias (d)   void setD(armaVec \u0026amp; d)\nSet output bias (d)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)    Protected Functions inherited from lds::poisson::sys_t\n    Name     void predict()\nOne-step prediction.   void h()\nSystem output function.    Protected Attributes inherited from lds::poisson::sys_t\n    Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaVec y output   armaVec logy logarithm of output   armaVec z measurement   armaMat diag_y diagonal matrix with elements y   armaVec chance p.r. number for rolling dice if simulating data    Public Functions inherited from lds::sys_t\n    Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX)\nSet dimensions of system.   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)    Protected Functions inherited from lds::sys_t\n    Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  ctrl_t #  ctrl_t( std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0 ) Parameters:\n nU number of inputs nX number of states nY number of outputs uLB lower bound on control (u) uUB upper bound on control (u) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) controlType [optional] control type bit mask   operator= #  ctrl_t \u0026amp; operator=( const ctrl_t \u0026amp; sys )  logLin_fbCtrl #  void logLin_fbCtrl( armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE )  steadyState_logLin_fbCtrl #  void steadyState_logLin_fbCtrl( armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE ) Parameters:\n z measurement gateCtrl [optional] logical gate of control (high=enabled; low=disabled) gateEst [optional] logical gate of estimator (high=enabled; low=disabled) gateLock [optional] logical gate of control signal lock (if high, locks control at current value) sigma_softStart [optional] standard deviation (sigma) of a Gaussian soft-start to control sigma_uNoise [optional] standard deviation (sigma) of Gaussian noise added on top of control resetAtCtrlOnset [optional] whether to reset controller at onset of a new control epoch (gateCtrl from low to high)  Assuming the objective is to track a reference output (yRef) at steady state, perform a single step of control in the log-output space, which is linear given the assumed exponential output nonlinearity.\nn.b., Requires user to have set the controller\u0026rsquo;s yRef variable.\nn.b., If control is enabled (gateCtrl=true) but estimator is disabled (gateEst=true), this function provides the calculated steady-state input uRef in open loop.\n calc_ssSetPt #  void calc_ssSetPt() Calculate steady-state setpoint [xRef; uRef], given an output reference yRef.\n printSys #  void printSys()  setU #  void setU( stdVec \u0026amp; uVec )  setU #  void setU( armaVec \u0026amp; u )  setG #  void setG( stdVec \u0026amp; gVec )  setG #  void setG( armaVec \u0026amp; g )  setGDesign #  void setGDesign( stdVec \u0026amp; gVec )  setGDesign #  void setGDesign( armaVec \u0026amp; g )  setURef #  void setURef( stdVec \u0026amp; uRefVec )  setURef #  void setURef( armaVec \u0026amp; uRef )  setXRef #  void setXRef( stdVec \u0026amp; xRefVec )  setXRef #  void setXRef( armaVec \u0026amp; xRef )  setYRef #  void setYRef( stdVec \u0026amp; yRefVec )  setYRef #  void setYRef( armaVec \u0026amp; yRef )  setKc_x #  void setKc_x( stdVec \u0026amp; Kc_xVec )  setKc_x #  void setKc_x( armaMat \u0026amp; Kc_x )  setKc_u #  void setKc_u( stdVec \u0026amp; Kc_uVec )  setKc_u #  void setKc_u( armaMat \u0026amp; Kc_u )  setKc_inty #  void setKc_inty( stdVec \u0026amp; Kc_intyVec )  setKc_inty #  void setKc_inty( armaMat \u0026amp; Kc_inty )  setControlType #  void setControlType( size_t controlType )  setTauAntiWindup #  void setTauAntiWindup( data_t \u0026amp; tau )  getKc_u #  inline armaMat getKc_u() const  getKc_x #  inline armaMat getKc_x() const  getKc_inty #  inline armaMat getKc_inty() const  getGDesign #  inline armaVec getGDesign() const  getURef #  inline armaVec getURef() const  getXRef #  inline armaVec getXRef() const  getLogYRef #  inline armaVec getLogYRef() const  getYRef #  inline armaVec getYRef() const  getLogY #  inline armaVec getLogY() const  getIntE #  inline armaVec getIntE() const  getControlType #  inline size_t getControlType() const  reset #  void reset()  Protected Function Details #  antiWindup #  void antiWindup() Protect against integral windup\nReference:\nAstroem KJ, Rundqwist L. (1989) Integrator Windup and How to Avoid It. 1989 ACC.\n Protected Attribute Details #  gDesign #  armaVec gDesign;  uRef #  armaVec uRef;  uRef_prev #  armaVec uRef_prev;  xRef #  armaVec xRef;  logyRef #  armaVec logyRef;  yRef #  armaVec yRef;  Kc_x #  armaMat Kc_x;  Kc_u #  armaMat Kc_u;  Kc_inty #  armaMat Kc_inty;  duRef #  armaVec duRef;  dvRef #  armaVec dvRef;  vRef #  armaVec vRef;  dv #  armaVec dv;  v #  armaVec v;  intE #  armaVec intE;  intE_awuAdjust #  armaVec intE_awuAdjust;  uSat #  armaVec uSat;  gateCtrl_prev #  bool gateCtrl_prev;  gateLock_prev #  bool gateLock_prev;  yRefLB #  data_t yRefLB;  uSaturated #  bool uSaturated;  uLB #  data_t \u0026amp; uLB;  uUB #  data_t \u0026amp; uUB;  tauAntiWindup #  data_t tauAntiWindup;  kAntiWindup #  data_t kAntiWindup;  t_since_ctrl_onset #  data_t t_since_ctrl_onset;  controlType #  size_t controlType;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':37,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1fit__t/','title':"lds::poisson::fit_t",'section':"Classes",'content':"lds::poisson::fit_t #  PLDS Fit Type. #include \u0026lt;lds_poisson_fit.h\u0026gt;\nInherits from lds::fit_t\nInherited by lds::poisson::ssidFit_t\nPublic Functions #      Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new PLDS fit.    Public Attributes #      Name     armaMat C output matrix   armaVec d output bias   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Additional inherited members #  Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  fit_t #  inline fit_t()  fit_t #  fit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias dt sample period uTrain input training data zTrain measurement training data   Public Attribute Details #  C #  armaMat C;  d #  armaVec d;  uTrain #  std::vector\u0026lt; armaMat \u0026gt; uTrain;  zTrain #  std::vector\u0026lt; armaMat \u0026gt; zTrain;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':38,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sctrl__t/','title':"lds::poisson::sctrl_t",'section':"Classes",'content':"lds::poisson::sctrl_t #  Switched PLDS Controller Type. #include \u0026lt;lds_poisson_sctrl.h\u0026gt;\nInherits from lds::poisson::ctrl_t, lds::poisson::sys_t, lds::sys_t\nPublic Functions #      Name      sctrl_t(std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0)\nConstructs a new switched PLDS controller.   void setSystem(size_t sysIdx, ctrl_t \u0026amp; sys)   void switchSystem(size_t sysIdx)\nSwitch to a different underlying sub-system.   size_t getSysIdx() const\nGet the index of currently active sub-system.    Protected Attributes #      Name     size_t nSys number of systems   std::vector\u0026lt; ctrl_t \u0026gt; systems underlying sub-systems which are toggled between   size_t sysIdx current system index    Additional inherited members #  Public Functions inherited from lds::poisson::ctrl_t\n    Name      ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0)\nConstructs a new PLDS controller.   ctrl_t \u0026amp; operator=(const ctrl_t \u0026amp; sys)   void logLin_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE)   void steadyState_logLin_fbCtrl(armaVec \u0026amp; z, bool \u0026amp; gateCtrl =TRUE, bool \u0026amp; gateEst =TRUE, bool \u0026amp; gateLock =FALSE, data_t \u0026amp; sigma_softStart =DEFAULT_SOFTSTART, data_t \u0026amp; sigma_uNoise =DATA_T_ZERO, bool \u0026amp; resetAtCtrlOnset =TRUE)\nsteady-state log-linear control (single step)   void calc_ssSetPt()   void printSys()\nPrint system variables.   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setGDesign(stdVec \u0026amp; gVec)\nSet input gain used in controller design (gDesign)   void setGDesign(armaVec \u0026amp; g)\nSet input gain used in controller design (gDesign)   void setURef(stdVec \u0026amp; uRefVec)\nSet reference input (uRef)   void setURef(armaVec \u0026amp; uRef)\nSet reference input (uRef)   void setXRef(stdVec \u0026amp; xRefVec)\nSet reference state (xRef)   void setXRef(armaVec \u0026amp; xRef)\nSet reference state (xRef)   void setYRef(stdVec \u0026amp; yRefVec)\nSet reference output (yRef)   void setYRef(armaVec \u0026amp; yRef)\nSet reference output (yRef)   void setTauAntiWindup(data_t \u0026amp; tau)\nSet time constant of anti-integral-windup.   armaMat getKc_u() const\nGet input controller gain (Kc_u)   armaMat getKc_x() const\nGet input controller gain (Kc_u)   armaMat getKc_inty() const\nGet integral controller gain (Kc_inty)   armaVec getGDesign() const\nGet input gain used in controller design (gDesign)   armaVec getURef() const\nGet reference input (uRef)   armaVec getXRef() const\nGet reference state (xRef)   armaVec getLogYRef() const\nGet reference log-output (logyRef)   armaVec getYRef() const\nGet reference output (yRef)   armaVec getLogY() const\nGet log-output (logy)   armaVec getIntE() const\nGet integrated error (intE)   size_t getControlType() const\nGet controller type.   void reset()\nReset system variables.    Protected Functions inherited from lds::poisson::ctrl_t\n    Name     void antiWindup()\nProtect against integral windup.    Protected Attributes inherited from lds::poisson::ctrl_t\n    Name     armaVec gDesign input gain of the system used for controller design   armaVec uRef reference input   armaVec uRef_prev reference input at previous time step   armaVec xRef reference state   armaVec logyRef reference log-output   armaVec yRef reference output   armaMat Kc_x state controller gain   armaMat Kc_u input controller gain (when control aims to minimize deltaU)   armaMat Kc_inty integral controller gain (log-linear)   armaVec duRef   armaVec dvRef   armaVec vRef   armaVec dv   armaVec v Control after g inversion (e.g., control in physical units)   armaVec intE integrated error (log-output)   armaVec intE_awuAdjust anti-windup adjustment to intE   armaVec uSat control signal after saturation (for antiWindup)   bool gateCtrl_prev   bool gateLock_prev   data_t yRefLB lower bound on yRef (to avoid numerical log(0) issue)   bool uSaturated whether control signal has reached saturation limits   data_t \u0026amp; uLB lower bound on control   data_t \u0026amp; uUB upper bound on control   data_t tauAntiWindup antiwindup time constant   data_t kAntiWindup   data_t t_since_ctrl_onset time since control epoch onset   size_t controlType controller type    Public Functions inherited from lds::poisson::sys_t\n    Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate one step of the model and produce a measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new PLDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (D)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions inherited from lds::poisson::sys_t\n    Name     void predict()\nOne-step prediction.   void h()\nSystem output function.    Protected Attributes inherited from lds::poisson::sys_t\n    Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaVec y output   armaVec logy logarithm of output   armaVec z measurement   armaMat diag_y diagonal matrix with elements y   armaVec chance p.r. number for rolling dice if simulating data    Public Functions inherited from lds::sys_t\n    Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions inherited from lds::sys_t\n    Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  sctrl_t #  sctrl_t( std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; uLB, data_t \u0026amp; uUB, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0, size_t controlType =0 ) Parameters:\n nSys number of systems nU number of inputs nX number of states nY number of outputs uLB lower bound on control (u) uUB upper bound on control (u) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q) controlType [optional] control type bit mask   setSystem #  void setSystem( size_t sysIdx, ctrl_t \u0026amp; sys ) Set the parameters of selected sub-system using previously instantiated GLDS controllers.\n switchSystem #  void switchSystem( size_t sysIdx ) Switch to a different underlying sub-system by reassiging parameters at switch.\n getSysIdx #  inline size_t getSysIdx() const  Protected Attribute Details #  nSys #  size_t nSys;  systems #  std::vector\u0026lt; ctrl_t \u0026gt; systems;  sysIdx #  size_t sysIdx;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':39,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1ssid_fit__t/','title':"lds::poisson::ssidFit_t",'section':"Classes",'content':"lds::poisson::ssidFit_t #  GLDS SSID Fit Type. #include \u0026lt;lds_poisson_fit_ssid.h\u0026gt;\nInherits from lds::poisson::fit_t, lds::fit_t\nPublic Functions #      Name      ssidFit_t()    ssidFit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new PLDS SSID fit.    Public Attributes #      Name     std::vector\u0026lt; data_t \u0026gt; t0   data_t t_startSSID   data_t t_stopSSID   armaVec singVals    Additional inherited members #  Public Functions inherited from lds::poisson::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain)\nConstructs a new PLDS fit.    Public Attributes inherited from lds::poisson::fit_t\n    Name     armaMat C output matrix   armaVec d output bias   std::vector\u0026lt; armaMat \u0026gt; uTrain input training data   std::vector\u0026lt; armaMat \u0026gt; zTrain measurement training data    Public Functions inherited from lds::fit_t\n    Name      fit_t()    fit_t(armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, data_t \u0026amp; dt)\nConstructs a new LDS fit type.    Public Attributes inherited from lds::fit_t\n    Name     armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaVec m process noise mean   armaMat Q process noise cov   armaVec x0 initial state   armaMat P0 initial covar   data_t dt sample period      Public Function Details #  ssidFit_t #  inline ssidFit_t()  ssidFit_t #  ssidFit_t( armaMat \u0026amp; A, armaMat \u0026amp; B, armaVec \u0026amp; g, armaVec \u0026amp; m, armaMat \u0026amp; Q, armaVec \u0026amp; x0, armaMat \u0026amp; P0, armaMat \u0026amp; C, armaVec \u0026amp; d, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec \u0026amp; singVals, std::vector\u0026lt; data_t \u0026gt; \u0026amp; t0, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; uTrain, std::vector\u0026lt; armaMat \u0026gt; \u0026amp; zTrain ) Parameters:\n A state matrix B input matrix g input gain m process disturbance Q process noise covariance x0 initial state estimate P0 covariance of initial state estimate C output matrix d output bias dt sample period t_startSSID start time for the data used in SSID t_stopSSID stop time for the data used in SSID singVals singular values from SSID SVD step t0 start times for each trial of input/output data uTrain training input data zTrain training measurement data   Public Attribute Details #  t0 #  std::vector\u0026lt; data_t \u0026gt; t0;  t_startSSID #  data_t t_startSSID;  t_stopSSID #  data_t t_stopSSID;  singVals #  armaVec singVals;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':40,'href':'/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/','title':"lds::poisson::sys_t",'section':"Classes",'content':"lds::poisson::sys_t #  Poisson LDS Type. #include \u0026lt;lds_poisson_sys.h\u0026gt;\nInherits from lds::sys_t\nInherited by lds::poisson::ctrl_t\nPublic Functions #      Name     void filter(armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t)\nFilter data to produce causal state estimates.   void filter(armaVec \u0026amp; z)\nFilter data to produce causal state estimates.   void simMeasurement(armaVec \u0026amp; z)\nSimulate one step of the model and produce a measurement.    sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new PLDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   size_t getNy() const\nGet number of outputs (y)   armaMat getC() const\nGet output matrix (C)   armaVec getD() const\nGet output bias (D)   armaVec getY() const\nGet output (y)   armaVec getZ() const\nGet measurement (z)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY)\nSet dimensions of sytem.   void setC(stdVec \u0026amp; cVec)\nSet output matrix (C)   void setC(armaMat \u0026amp; C)\nSet output matrix (C)   void setD(stdVec \u0026amp; dVec)\nSet output bias (d)   void setD(armaVec \u0026amp; d)\nSet output bias (d)   void setZ(stdVec \u0026amp; zVec)\nSet measurement (z)   void setZ(armaVec \u0026amp; z)\nSet measurement (z)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions #      Name     void predict()\nOne-step prediction.   void h()\nSystem output function.    Protected Attributes #      Name     std::size_t nY number of outputs   armaMat C output matrix   armaVec d output bias   armaVec y output   armaVec logy logarithm of output   armaVec z measurement   armaMat diag_y diagonal matrix with elements y   armaVec chance p.r. number for rolling dice if simulating data    Additional inherited members #  Public Functions inherited from lds::sys_t\n    Name     void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)    Protected Functions inherited from lds::sys_t\n    Name     void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes inherited from lds::sys_t\n    Name     bool adaptM    Protected Attributes inherited from lds::sys_t\n    Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  filter #  void filter( armaVec \u0026amp; u_tm1, armaVec \u0026amp; z_t ) Parameters:\n u_tm1 input at t-minus-1 z_t current measurement  Given current measurment and input, filter data to produce causal state estimates using a point-process filter, which procedes by predicting the state and subsequently updating.\nReferences:\nSmith AC, Brown EN. (2003) Estimating a State-Space Model from Point Process Observations. Neural Computation 15.\nEden UT, \u0026hellip;, Brown EN. (2004) Dynamic Analysis of Neural Encoding by Point Process Adaptive Filtering Neural Computation 16.\n filter #  void filter( armaVec \u0026amp; z ) Parameters:\n z current measurement  Given current measurment and input, filter data to produce causal state estimates using a point-process filter, which procedes by predicting the state and subsequently updating.\nReferences:\nSmith AC, Brown EN. (2003) Estimating a State-Space Model from Point Process Observations. Neural Computation 15.\nEden UT, \u0026hellip;, Brown EN. (2004) Dynamic Analysis of Neural Encoding by Point Process Adaptive Filtering Neural Computation 16.\n simMeasurement #  void simMeasurement( armaVec \u0026amp; z ) Parameters:\n z measurement   sys_t #  sys_t( std::size_t nU, std::size_t nX, std::size_t nY, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0 ) Parameters:\n nU number of inputs nX number of states nY number of outputs dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q)   operator= #  sys_t \u0026amp; operator=( const sys_t \u0026amp; sys )  getNy #  inline size_t getNy() const  getC #  inline armaMat getC() const  getD #  inline armaVec getD() const  getY #  inline armaVec getY() const  getZ #  inline armaVec getZ() const  setDims #  void setDims( std::size_t \u0026amp; nU, std::size_t \u0026amp; nX, std::size_t \u0026amp; nY )  setC #  void setC( stdVec \u0026amp; cVec )  setC #  void setC( armaMat \u0026amp; C )  setD #  void setD( stdVec \u0026amp; dVec )  setD #  void setD( armaVec \u0026amp; d )  setZ #  void setZ( stdVec \u0026amp; zVec )  setZ #  void setZ( armaVec \u0026amp; z )  reset #  void reset()  printSys #  void printSys()  Protected Function Details #  predict #  void predict()  h #  void h()  Protected Attribute Details #  nY #  std::size_t nY;  C #  armaMat C;  d #  armaVec d;  y #  armaVec y;  logy #  armaVec logy;  z #  armaVec z;  diag_y #  armaMat diag_y;  chance #  armaVec chance;   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':41,'href':'/ldsctrlest/docs/api/classes/classlds_1_1sys__t/','title':"lds::sys_t",'section':"Classes",'content':"lds::sys_t #  Linear Dynamical System Type. #include \u0026lt;lds_sys.h\u0026gt;\nInherited by lds::gaussian::sys_t, lds::poisson::sys_t\nPublic Functions #      Name      sys_t(std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0)\nConstructs a new LDS.   sys_t \u0026amp; operator=(const sys_t \u0026amp; sys)   void simPredict()\nSimulate a one-step prediction.   size_t getNx() const\nGet number of states.   size_t getNu() const\nGet number of inputs.   armaVec getU() const\nGet current input (u)   armaVec getX()\nGet current state (x)   armaVec getG() const\nGet input gain (g)   armaVec getM() const\nGet current process disturbance/bias (m)   armaMat getA() const\nGet state matrix (A)   armaMat getB() const\nGet input matrix (B)   armaMat getQ() const\nGet process noise covariance (Q)   armaMat getQ_m() const\nGet process noise covariance acting on disturbance evolution (Q_m)   armaMat getP() const\nGet covariance of state estimate (P)   armaMat getP_m() const\nGet covariance of process disturbance estimate (P_m)   armaVec getX0() const\nGet initial state (x0)   armaMat getP0() const\nGet initial covariance of state estimate (P0)   armaVec getM0() const\nGet initial process disturbance (m0)   armaMat getP0_m() const\nGet initial covariance of process disturbance estimate (P0_m)   void setDims(std::size_t \u0026amp; nU, std::size_t \u0026amp; nX)\nSet dimensions of system.   void setU(stdVec \u0026amp; uVec)\nSet input (u)   void setU(armaVec \u0026amp; u)\nSet input (u)   void setA(stdVec \u0026amp; aVec)\nSet state matrix (A)   void setA(armaMat \u0026amp; A)\nSet state matrix (A)   void setB(stdVec \u0026amp; bVec)\nSet input matrix (B)   void setB(armaMat \u0026amp; B)\nSet input matrix (B)   void setM(stdVec \u0026amp; mVec)\nSet process disturbance (m)   void setM(armaVec \u0026amp; m)\nSet process disturbance (m)   void setG(stdVec \u0026amp; gVec)\nSet input gain (g)   void setG(armaVec \u0026amp; g)\nSet input gain (g)   void setQ(stdVec \u0026amp; qVec)\nSet process noise covariance (Q)   void setQ(armaMat \u0026amp; Q)\nSet process noise covariance (Q)   void setQ_m(stdVec \u0026amp; qmVec)\nSet process noise covariance of disturbance evoluation (Q_m)   void setQ_m(armaMat \u0026amp; Q_m)\nSet process noise covariance of disturbance evoluation (Q_m)   void setX0(stdVec \u0026amp; x0Vec)\nSet initial state (x0)   void setX0(armaVec \u0026amp; x0)\nSet initial state (x0)   void setP0(stdVec \u0026amp; p0Vec)\nSet covariance of initial state (P0)   void setP0(armaMat \u0026amp; P0)\nSet covariance of initial state (P0)   void setP0_m(stdVec \u0026amp; p0mVec)\nSet covariance of initial process disturbance (P0_m)   void setP0_m(armaMat \u0026amp; P0_m)\nSet covariance of initial process disturbance (P0_m)   void reset()\nReset system variables.   void printSys()\nPrint system variables to stdout.    Protected Functions #      Name     void predict()\none-step prediction of state   void reassign(armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0)   void reassign(armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0)   void limit(stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void limit(armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub)   void defaultQ()\nReset to default Q (identity matrix with diagonal elements q0)   void checkP()\ncheck whether estimate covariance fals within plim upper bound    Public Attributes #      Name     bool adaptM    Protected Attributes #      Name     armaVec u input   armaVec x state   armaMat P covariance of state estimate   armaVec m process disturbance   armaMat P_m covariance of disturbance estimate   armaVec x0 initial state   armaMat P0 covariance of initial state estimate   armaVec m0 initial process disturbance   armaMat P0_m covariance of initial disturbance estimate   armaMat A state matrix   armaMat B input matrix   armaVec g input gain   armaMat Q covariance of process noise   armaMat Q_m covoariance of disturbance evolution process   data_t \u0026amp; dt sample period   data_t \u0026amp; q0 default process noise covariance   data_t \u0026amp; p0 default state estimate covariance   std::size_t nX number of states   std::size_t nU number of inputs   bool szChanged whether size of system changed (see setDims)   const data_t plim limit for state estimate covariance      Public Function Details #  sys_t #  sys_t( std::size_t nU, std::size_t nX, data_t \u0026amp; dt, data_t \u0026amp; p0 =DEFAULT_P0, data_t \u0026amp; q0 =DEFAULT_Q0 ) Parameters:\n nU number if inputs (u) nX number of state (x) dt sample period p0 [optional] initial diagonal elements of state estimate covariance (P) q0 [optional] initial diagonal elements of process noise covariance (Q)   operator= #  sys_t \u0026amp; operator=( const sys_t \u0026amp; sys )  simPredict #  void simPredict()  getNx #  inline size_t getNx() const  getNu #  inline size_t getNu() const  getU #  inline armaVec getU() const  getX #  inline armaVec getX()  getG #  inline armaVec getG() const  getM #  inline armaVec getM() const  getA #  inline armaMat getA() const  getB #  inline armaMat getB() const  getQ #  inline armaMat getQ() const  getQ_m #  inline armaMat getQ_m() const  getP #  inline armaMat getP() const  getP_m #  inline armaMat getP_m() const  getX0 #  inline armaVec getX0() const  getP0 #  inline armaMat getP0() const  getM0 #  inline armaVec getM0() const  getP0_m #  inline armaMat getP0_m() const  setDims #  void setDims( std::size_t \u0026amp; nU, std::size_t \u0026amp; nX )  setU #  void setU( stdVec \u0026amp; uVec )  setU #  void setU( armaVec \u0026amp; u )  setA #  void setA( stdVec \u0026amp; aVec )  setA #  void setA( armaMat \u0026amp; A )  setB #  void setB( stdVec \u0026amp; bVec )  setB #  void setB( armaMat \u0026amp; B )  setM #  void setM( stdVec \u0026amp; mVec )  setM #  void setM( armaVec \u0026amp; m )  setG #  void setG( stdVec \u0026amp; gVec )  setG #  void setG( armaVec \u0026amp; g )  setQ #  void setQ( stdVec \u0026amp; qVec )  setQ #  void setQ( armaMat \u0026amp; Q )  setQ_m #  void setQ_m( stdVec \u0026amp; qmVec )  setQ_m #  void setQ_m( armaMat \u0026amp; Q_m )  setX0 #  void setX0( stdVec \u0026amp; x0Vec )  setX0 #  void setX0( armaVec \u0026amp; x0 )  setP0 #  void setP0( stdVec \u0026amp; p0Vec )  setP0 #  void setP0( armaMat \u0026amp; P0 )  setP0_m #  void setP0_m( stdVec \u0026amp; p0mVec )  setP0_m #  void setP0_m( armaMat \u0026amp; P0_m )  reset #  void reset()  printSys #  void printSys()  Protected Function Details #  predict #  void predict()  reassign #  void reassign( armaVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaSubVec \u0026amp; oldVar, armaVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaSubVec \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaSubMat \u0026amp; oldVar, armaMat \u0026amp; newVar, data_t defaultVal =0 )  reassign #  void reassign( armaSubMat \u0026amp; oldVar, stdVec \u0026amp; newVar, data_t defaultVal =0 )  limit #  void limit( stdVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub )  limit #  void limit( armaVec \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub )  limit #  void limit( armaMat \u0026amp; x, data_t \u0026amp; lb, data_t \u0026amp; ub )  defaultQ #  void defaultQ()  checkP #  void checkP()  Public Attribute Details #  adaptM #  bool adaptM;  Protected Attribute Details #  u #  armaVec u;  x #  armaVec x;  P #  armaMat P;  m #  armaVec m;  P_m #  armaMat P_m;  x0 #  armaVec x0;  P0 #  armaMat P0;  m0 #  armaVec m0;  P0_m #  armaMat P0_m;  A #  armaMat A;  B #  armaMat B;  g #  armaVec g;  Q #  armaMat Q;  Q_m #  armaMat Q_m;  dt #  data_t \u0026amp; dt;  q0 #  data_t \u0026amp; q0;  p0 #  data_t \u0026amp; p0;  nX #  std::size_t nX;  nU #  std::size_t nU;  szChanged #  bool szChanged;  plim #  const data_t plim = 1e2;   Updated on 3 March 2021 at 23:06:11 CST\n"});index.add({'id':42,'href':'/ldsctrlest/docs/api/files/dir_2755d76cbd49ca86cc5d9263eb253d5e/','title':"ldsCtrlEst_h",'section':"Files",'content':"ldsCtrlEst_h #  Files #     Name     ldsCtrlEst_h/lds.h lds namespace   ldsCtrlEst_h/lds_fit.h LDS base fit type.   ldsCtrlEst_h/lds_gaussian.h glds namespace   ldsCtrlEst_h/lds_gaussian_ctrl.h GLDS controller type.   ldsCtrlEst_h/lds_gaussian_fit.h GLDS fit type.   ldsCtrlEst_h/lds_gaussian_fit_em.h GLDS E-M fit type.   ldsCtrlEst_h/lds_gaussian_fit_ssid.h GLDS SSID fit type.   ldsCtrlEst_h/lds_gaussian_sctrl.h GLDS switched controller type.   ldsCtrlEst_h/lds_gaussian_sys.h GLDS base type.   ldsCtrlEst_h/lds_poisson.h plds namespace   ldsCtrlEst_h/lds_poisson_ctrl.h PLDS controller type.   ldsCtrlEst_h/lds_poisson_fit.h PLDS base fit type.   ldsCtrlEst_h/lds_poisson_fit_ssid.h PLDS SSID fit type.   ldsCtrlEst_h/lds_poisson_sctrl.h PLDS switched controller type.   ldsCtrlEst_h/lds_poisson_sys.h PLDS base type.   ldsCtrlEst_h/lds_sys.h LDS base type.   ldsCtrlEst_h/mex_c_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API)   ldsCtrlEst_h/mex_cpp_util.h arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API)     Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':43,'href':'/ldsctrlest/docs/api/files/lds_8h/','title':"ldsCtrlEst_h/lds.h",'section':"Files",'content':"ldsCtrlEst_h/lds.h #  lds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Detailed Description #  This file defines the lds namespace, which will be an umbrella for linear dynamical systems with Gaussian ([lds::gaussian](/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/)) or Poisson ([lds::poisson](/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/)) observations.\nSource code #  //===-- ldsCtrlEst_h/lds.h - Linear Dynmical System Namespace ---*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_H #define LDSCTRLEST_LDS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { typedef double data_t; namespace fill = arma::fill; typedef std::vector\u0026lt;data_t\u0026gt; stdVec; typedef arma::Col\u0026lt;data_t\u0026gt; armaVec; typedef arma::Mat\u0026lt;data_t\u0026gt; armaMat; typedef arma::Cube\u0026lt;data_t\u0026gt; armaCube; typedef arma::subview_col\u0026lt;data_t\u0026gt; armaSubVec; typedef arma::subview\u0026lt;data_t\u0026gt; armaSubMat; static const std::size_t CONTROL_TYPE_U = 0x1; static const std::size_t CONTROL_TYPE_INTY = CONTROL_TYPE_U \u0026lt;\u0026lt; 1; static const std::size_t CONTROL_TYPE_ADAPT_M = CONTROL_TYPE_U \u0026lt;\u0026lt; 2; static data_t inf = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(); static data_t neginf = -inf; static const data_t pi = arma::datum::pi; static data_t DEFAULT_P0 = 1e-6; static data_t DEFAULT_Q0 = 1e-6; static data_t DEFAULT_R0 = 1e-2; static std::vector\u0026lt;data_t\u0026gt; DEFAULT_T0 = std::vector\u0026lt;data_t\u0026gt;(1, 0.0); // Ideally these should be const, but trying to pass reference which means its // val implicitly must be allowed to change. hopefully no one will try to // reassign their vals... static data_t DATA_T_ZERO = (data_t)0; static data_t DATA_T_ONE = (data_t)1; static data_t DEFAULT_SOFTSTART = (data_t)0; static bool FALSE = false; static bool TRUE = true; enum ssidWt { NONE, MOESP, CVA }; } // namespace lds  // fit and sys with dynamics only #include \u0026#34;lds_sys.h\u0026#34;#ifdef LDSCTRLEST_BUILD_FIT #include \u0026#34;lds_fit.h\u0026#34;#endif  // Pull in output equation variants #include \u0026#34;lds_gaussian.h\u0026#34;#include \u0026#34;lds_poisson.h\u0026#34; #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':44,'href':'/ldsctrlest/docs/api/files/lds__fit_8h/','title':"ldsCtrlEst_h/lds_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_fit.h #  LDS base fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::fit_t LDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a linear dynamical system. It is expounded upon by variants with Gaussian and Poisson observation assumptions for fitting.\nSource code #  //===-- ldsCtrlEst_h/lds_fit.h - Fit Type for LDS ---------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDS_FIT_HPP #define LDS_FIT_HPP  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { class fit_t { public: fit_t(){}; fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, data_t\u0026amp; dt); // Dynamics  armaMat A; armaMat B; armaVec g; armaVec m; armaMat Q; armaVec x0; armaMat P0; data_t dt; }; } // namespace lds #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':45,'href':'/ldsctrlest/docs/api/files/lds__gaussian_8h/','title':"ldsCtrlEst_h/lds_gaussian.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian.h #  glds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Detailed Description #  This file declares and partially defines the namespace for linear dynamical systems with Gaussian observations ([lds::gaussian](/ldsctrlest/docs/api/namespaces/namespacelds_1_1gaussian/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian.h - LDS with Gaussian Output --*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_H #define LDSCTRLEST_LDS_GAUSSIAN_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { typedef lds::data_t data_t; typedef lds::stdVec stdVec; typedef lds::armaVec armaVec; typedef lds::armaMat armaMat; typedef lds::armaSubVec armaSubVec; typedef lds::armaSubMat armaSubMat; namespace fill = lds::fill; // CONTROL BIT MASKS static const std::size_t CONTROL_TYPE_U = lds::CONTROL_TYPE_U; static const std::size_t CONTROL_TYPE_INTY = lds::CONTROL_TYPE_INTY; static const std::size_t CONTROL_TYPE_ADAPT_M = lds::CONTROL_TYPE_ADAPT_M; // default values static data_t DATA_T_ZERO = lds::DATA_T_ZERO; static data_t DATA_T_ONE = lds::DATA_T_ZERO; static data_t DEFAULT_SOFTSTART = lds::DEFAULT_SOFTSTART; static bool FALSE = lds::FALSE; static bool TRUE = lds::TRUE; // static const data_t inf = lds::inf; static const data_t pi = lds::pi; static data_t inf = lds::inf; static data_t neginf = lds::neginf; } // namespace gaussian } // namespace lds  #include \u0026#34;lds_gaussian_sys.h\u0026#34;#ifdef LDSCTRLEST_BUILD_FIT #include \u0026#34;lds_gaussian_fit.h\u0026#34;#endif  #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':46,'href':'/ldsctrlest/docs/api/files/lds__gaussian__ctrl_8h/','title':"ldsCtrlEst_h/lds_gaussian_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_ctrl.h #  GLDS controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::ctrl_t GLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for feedback control of a gaussian-output linear dynamical system ([lds::gaussian::ctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ctrl__t/)). It inherits functionality from the underlying GLDS model type ([lds::gaussian::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/)), including state estimation.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_ctrl.h - GLDS Controller ------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_CTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class ctrl_t : public sys_t { public: ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, data_t\u0026amp; r0 = DEFAULT_R0, size_t controlType = 0); ctrl_t\u0026amp; operator=(const ctrl_t\u0026amp; sys); // These are the workhorse functions:  void fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE, bool\u0026amp; doRecurse_Ke = TRUE); void steadyState_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateEst = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE, bool\u0026amp; doRecurse_Ke = TRUE); void calc_ssSetPt(); void printSys(); // set methods  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX, std::size_t\u0026amp; nY); // make sure to override the setU behavior inherited from sys_t!  // cannot set u for a controller, as it generates its own.  void setU(stdVec\u0026amp; uVec); void setU(armaVec\u0026amp; u); void setG(stdVec\u0026amp; gVec); void setG(armaVec\u0026amp; g); void setGDesign(stdVec\u0026amp; gVec); void setGDesign(armaVec\u0026amp; g); void setURef(stdVec\u0026amp; uRefVec); void setURef(armaVec\u0026amp; uRef); void setXRef(stdVec\u0026amp; xRefVec); void setXRef(armaVec\u0026amp; xRef); void setYRef(stdVec\u0026amp; yRefVec); void setYRef(armaVec\u0026amp; yRef); void setKc_x(stdVec\u0026amp; Kc_x_vec); void setKc_x(armaMat\u0026amp; Kc_x); void setKc_u(stdVec\u0026amp; Kc_u_vec); void setKc_u(armaMat\u0026amp; Kc_u); void setKc_inty(stdVec\u0026amp; Kc_inty_vec); void setKc_inty(armaMat\u0026amp; Kc_inty); void setControlType(size_t controlType); void setTauAntiWindup(data_t\u0026amp; tau); armaMat getKc_u() const { return Kc_u; }; armaMat getKc_x() const { return Kc_x; }; armaMat getKc_inty() const { return Kc_inty; }; armaVec getGDesign() const { return gDesign; }; armaVec getURef() const { return uRef; }; armaVec getXRef() const { return xRef; }; armaVec getYRef() const { return yRef; }; armaVec getIntE() const { return intE; }; size_t getControlType() const { return controlType; }; void reset(); protected: armaVec gDesign; // reference signals  armaVec uRef; // create no set method for this:  armaVec uRef_prev; armaVec xRef; armaVec yRef; // Controller gains  armaMat Kc_x; armaMat Kc_u; armaMat Kc_inty; // control after g inversion  // do not need set methods for these.  armaVec duRef; armaVec dvRef; armaVec vRef; armaVec dv; armaVec v; // integral error  // do not need set method for this  armaVec intE; armaVec intE_awuAdjust; armaVec uSat; bool gateCtrl_prev; bool gateLock_prev; // whether the g of system has become inverted from what you think it is  // (gainRef)  bool uSaturated; // should be safe to have references here bc nothing needs to be done  // (like reset vars) when it changes...  data_t\u0026amp; uLB; data_t\u0026amp; uUB; data_t tauAntiWindup; data_t kAntiWindup; void antiWindup(); data_t t_since_ctrl_onset; size_t controlType; private: void calc_ctrl(bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateEst = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE); }; } // namespace gaussian } // namespace lds  #include \u0026#34;lds_gaussian_sctrl.h\u0026#34; #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':47,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit.h #  GLDS fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::fit_t GLDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit.h - Fit Type for GLDS -----*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class fit_t : public lds::fit_t { public: fit_t(){}; fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaMat\u0026amp; D, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); // Output  armaMat C; armaMat D; armaVec d; armaMat R; // input/output training data  std::vector\u0026lt;armaMat\u0026gt; uTrain; std::vector\u0026lt;armaMat\u0026gt; zTrain; }; }; // namespace gaussian } // namespace lds  // subspace identification #include \u0026#34;lds_gaussian_fit_ssid.h\u0026#34; // expectation maximization #include \u0026#34;lds_gaussian_fit_em.h\u0026#34; #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':48,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit__em_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit_em.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit_em.h #  GLDS E-M fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::emFit_t GLDS E-M Fit Type.    Detailed Description #  This file declares and partially defines a type by which Gaussian-output LDS models are fit by the expectation-maximization (EM) algorithm ([lds::gaussian::emFit_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1em_fit__t/)).\nReferences: [1] Shumway RH, Stoffer DS. (1982) An Approach to Time Series Smoothing and Forecasting Using the EM Algorithm.Journal of Time Series Analysis 3(2).\n[2] Ghahramani Z, Hinton GE. (1996) Parameter Estimation for Linear Dynamical Systems. Technical Report CRG-TR-96-2.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit_em.h - GLDS Fit (EM) ------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_EM_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class emFit_t : public fit_t { public: emFit_t() : fit_t(){}; emFit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); emFit_t(data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); emFit_t(ssidFit_t\u0026amp; fit0); void reset(void); void runEM(bool calcAB = true, bool calcQ = true, bool calcInitial = true, bool calcC = true, bool calcd = true, bool calcR = true); data_t tol = 1e-3; size_t maxIter = 100; // get methods  std::vector\u0026lt;armaMat\u0026gt; getX() { return xHat; }; std::vector\u0026lt;armaMat\u0026gt; getY() { return yHat; }; // these are covariances that can be useful to the end-user  armaMat get_sum_E_xu_tm1_xu_tm1() { return sum_E_xu_tm1_xu_tm1; }; armaMat get_sum_E_xu_t_xu_tm1() { return sum_E_xu_t_xu_tm1; }; armaMat get_sum_E_xu_t_xu_t() { return sum_E_xu_t_xu_t; }; size_t getT() { return T; }; void setY(std::vector\u0026lt;armaMat\u0026gt; yHat) { this-\u0026gt;yHat = yHat; }; protected: armaVec getTheta(); void kalmanFilt(); void kalmanSmooth(bool forceCommonInitial); void Estep(bool forceCommonInitial = false); void Mstep(bool calcAB = true, bool calcQ = true, bool calcInitial = false, bool calcC = false, bool calcd = false, bool calcR = true); std::vector\u0026lt;armaMat\u0026gt; xHat; std::vector\u0026lt;arma::Cube\u0026lt;data_t\u0026gt;\u0026gt; P; std::vector\u0026lt;armaMat\u0026gt; yHat; std::vector\u0026lt;arma::Cube\u0026lt;data_t\u0026gt;\u0026gt; P_t_tm1; armaMat sum_E_xu_t_xu_t; armaMat sum_E_xu_tm1_xu_tm1; armaMat sum_E_xu_t_xu_tm1; size_t T; }; emFit_t emFit_x_equals_y(std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain, data_t dt, std::size_t maxIter = 100, data_t tol = 1e-3, data_t q0 = 1e-6, bool calcAB = true, bool calcQ = true, bool calcR = true); }; // namespace gaussian } // namespace lds  #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':49,'href':'/ldsctrlest/docs/api/files/lds__gaussian__fit__ssid_8h/','title':"ldsCtrlEst_h/lds_gaussian_fit_ssid.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_fit_ssid.h #  GLDS SSID fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::ssidFit_t GLDS SSID Fit Type.    Detailed Description #  This file declares and partially defines a type by which Gaussian-output LDS models are fit by a subspace identification (SSID) algorithm ([lds::gaussian::ssidFit_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ssid_fit__t/)).\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer.\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_fit_ssid.h - GLDS Fit (SSID) --*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H #define LDSCTRLEST_LDS_GAUSSIAN_FIT_SSID_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class ssidFit_t : public fit_t { public: ssidFit_t() : fit_t(){}; ssidFit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaMat\u0026amp; D, armaVec\u0026amp; d, armaMat\u0026amp; R, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec\u0026amp; singVals, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); std::vector\u0026lt;data_t\u0026gt; t0; data_t t_startSSID; data_t t_stopSSID; armaVec singVals; }; ssidFit_t ssidFit(std::vector\u0026lt;armaMat\u0026gt;\u0026amp; u, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; z, data_t dt, size_t nX, size_t nH = 25, armaVec d0 = armaVec(1).fill(-inf), bool force_unitNormC = false, ssidWt wt = NONE, data_t wtG0 = 0.0, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0 = DEFAULT_T0, data_t t_startSSID = -std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(), data_t t_stopSSID = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity()); armaVec calcD_silence(std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; u, data_t dt, data_t tSilence = 0.1, data_t threshSilence = 0.001); void createHankelMat_n4sid(armaMat\u0026amp; u, armaMat\u0026amp; z, std::size_t\u0026amp; nH, armaMat\u0026amp; D); void ssid_n4sid(std::size_t\u0026amp; nX, std::size_t\u0026amp; nU, std::size_t\u0026amp; nY, std::size_t\u0026amp; nH, armaMat\u0026amp; uSSID, armaMat\u0026amp; zSSID, armaMat\u0026amp; A, armaMat\u0026amp; B, armaMat\u0026amp; C, armaMat\u0026amp; D, armaMat\u0026amp; Q, armaMat\u0026amp; R, armaVec\u0026amp; m, armaVec\u0026amp; d, armaVec\u0026amp; s, bool force_unitNormC, ssidWt wt, data_t wtG0); void ssid_n4sid_vanOverschee(std::size_t\u0026amp; nX, std::size_t\u0026amp; nU, std::size_t\u0026amp; nY, std::size_t\u0026amp; nH, armaMat\u0026amp; uSSID, armaMat\u0026amp; zSSID, armaMat\u0026amp; A, armaMat\u0026amp; B, armaMat\u0026amp; C, armaMat\u0026amp; D, armaMat\u0026amp; Q, armaMat\u0026amp; R, armaVec\u0026amp; s, ssidWt wt); void recompute_extObs(armaMat\u0026amp; extObs, armaMat\u0026amp; A, armaMat\u0026amp; C, std::size_t\u0026amp; nY, std::size_t\u0026amp; nH); void lq(armaMat\u0026amp; L, armaMat\u0026amp; Qt, armaMat\u0026amp; X); armaMat calcCov(armaMat\u0026amp; A, armaMat\u0026amp; B); armaMat sqrtmat_svd(armaMat\u0026amp; X); } // namespace gaussian } // namespace lds #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':50,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sctrl_8h/','title':"ldsCtrlEst_h/lds_gaussian_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_sctrl.h #  GLDS switched controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::sctrl_t Switched GLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Gaussian-output linear dynamical systems ([lds::gaussian::sctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sctrl__t/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_sctrl.h - Switched Controller -*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H #define LDSCTRLEST_LDS_GAUSSIAN_SCTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class sctrl_t : public ctrl_t { public: sctrl_t(std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, data_t\u0026amp; r0 = DEFAULT_R0, size_t controlType = 0); void setSystem(size_t sysIdx, ctrl_t\u0026amp; sys); // TODO(mfbolus):  // This switchSystem(sysIdx) approach is wasteful but simple.  // Would be faster to toggle between ctrl_t\u0026#39;s and replace wrapper u, x, P, m,  // P_m. However, would have to override or rewrite most controller  // functionality.  void switchSystem(size_t sysIdx); size_t getSysIdx() const { return sysIdx; }; protected: size_t nSys; std::vector\u0026lt;ctrl_t\u0026gt; systems; size_t sysIdx; private: // make all parameter set* methods private and define them to do nothing.  // force users to use setSystem, with pre-defined systems.  // from lds_t:  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX){}; void setU(stdVec\u0026amp; uVec){}; void setU(armaVec\u0026amp; u){}; void setA(stdVec\u0026amp; aVec){}; void setA(armaMat\u0026amp; A){}; void setB(stdVec\u0026amp; bVec){}; void setB(armaMat\u0026amp; B){}; void setM(stdVec\u0026amp; mVec){}; void setM(armaVec\u0026amp; m){}; // void setG(stdVec\u0026amp; gVec) {};  // void setG(armaVec\u0026amp; g) {};  void setQ(stdVec\u0026amp; qVec){}; void setQ(armaMat\u0026amp; Q){}; void setQ_m(stdVec\u0026amp; qmVec){}; void setQ_m(armaMat\u0026amp; Q_m){}; void setX0(stdVec\u0026amp; x0Vec){}; void setX0(armaVec\u0026amp; x0){}; void setP0(stdVec\u0026amp; p0Vec){}; void setP0(armaMat\u0026amp; P0){}; void setP0_m(stdVec\u0026amp; p0mVec){}; void setP0_m(armaMat\u0026amp; P0_m){}; // from sys_t  void setC(stdVec\u0026amp; cVec){}; void setC(armaMat\u0026amp; C){}; void setD(stdVec\u0026amp; dVec){}; void setD(armaVec\u0026amp; d){}; void setR(stdVec\u0026amp; rVec){}; void setR(armaMat\u0026amp; R){}; void setKe(stdVec\u0026amp; keVec){}; void setKe(armaMat\u0026amp; Ke){}; void setKe_m(stdVec\u0026amp; kemVec){}; void setKe_m(armaMat\u0026amp; Ke_m){}; // from ctrl_t  // void setGDesign(stdVec\u0026amp; gVec) {};  // void setGDesign(armaVec\u0026amp; g) {};  void setKc_x(stdVec\u0026amp; Kc_xVec){}; void setKc_x(armaVec\u0026amp; Kc_x){}; void setKc_u(stdVec\u0026amp; Kc_uVec){}; void setKc_u(armaVec\u0026amp; Kc_u){}; void setKc_inty(stdVec\u0026amp; Kc_intyVec){}; void setKc_inty(armaVec\u0026amp; Kc_inty){}; void setControlType(size_t controlType); // {};  // assuming I *want* to maintain same references  // void setURef(stdVec\u0026amp; uRefVec) {};  // void setURef(armaVec\u0026amp; uRef) {};  // void setXRef(stdVec\u0026amp; xRefVec) {};  // void setXRef(armaVec\u0026amp; xRef) {};  // void setYRef(stdVec\u0026amp; yRefVec) {};  // void setYRef(armaVec\u0026amp; yRef) {}; }; } // namespace gaussian } // namespace lds  #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':51,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sys_8h/','title':"ldsCtrlEst_h/lds_gaussian_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_gaussian_sys.h #  GLDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::gaussian Linear Dynamical Systems with Gaussian observations.    Classes #      Name     class lds::gaussian::sys_t Gaussian LDS Type.    Detailed Description #  This file declares and partially defines the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems ([lds::gaussian::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/)). It inherits functionality from the underlying linear dynamical system ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)).\nSource code #  //===-- ldsCtrlEst_h/lds_gaussian_sys.h - GLDS ------------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_GAUSSIAN_SYS_H #define LDSCTRLEST_LDS_GAUSSIAN_SYS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace gaussian { class sys_t : public lds::sys_t { public: void filter(armaVec\u0026amp; u_tm1, armaVec\u0026amp; z_t, bool doRecurse_Ke = true); void filter(armaVec\u0026amp; z, bool doRecurse_Ke = true); void simMeasurement(armaVec\u0026amp; z); sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, data_t\u0026amp; r0 = DEFAULT_R0); sys_t\u0026amp; operator=(const sys_t\u0026amp; sys); // get methods  size_t getNy() const { return nY; }; armaMat getC() const { return C; }; armaVec getD() const { return d; }; armaVec getR() const { return R; }; armaVec getY() const { return y; }; armaVec getZ() const { return z; }; armaMat getKe() const { return Ke; }; armaMat getKe_m() const { return Ke_m; }; // set methods  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX, std::size_t\u0026amp; nY); void setC(stdVec\u0026amp; cVec); void setC(armaMat\u0026amp; C); void setD(stdVec\u0026amp; dVec); void setD(armaVec\u0026amp; d); void setR(stdVec\u0026amp; rVec); void setR(armaMat\u0026amp; R); void setZ(stdVec\u0026amp; zVec); void setZ(armaVec\u0026amp; z); void setKe(stdVec\u0026amp; keVec); void setKe(armaMat\u0026amp; Ke); void setKe_m(stdVec\u0026amp; kemVec); void setKe_m(armaMat\u0026amp; Ke_m); void reset(); void printSys(); protected: void recurse_Ke(); void predict(); void h(); void defaultR(); // output-specific stuff  std::size_t nY; armaMat C; armaVec d; armaMat R; data_t\u0026amp; r0; armaVec y; armaVec z; armaMat Ke; armaMat Ke_m; }; // sys_t } // namespace gaussian } // namespace lds  #include \u0026#34;lds_gaussian_ctrl.h\u0026#34; #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':52,'href':'/ldsctrlest/docs/api/files/lds__poisson_8h/','title':"ldsCtrlEst_h/lds_poisson.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson.h #  plds namespace More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Detailed Description #  This file declares and partially defines the namespace for linear dynamical systems with Poisson observations ([lds::poisson](/ldsctrlest/docs/api/namespaces/namespacelds_1_1poisson/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson.h - LDS with Poisson Output ----*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_H #define LDSCTRLEST_LDS_POISSON_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { typedef lds::data_t data_t; typedef lds::stdVec stdVec; typedef lds::armaVec armaVec; typedef lds::armaMat armaMat; typedef lds::armaSubVec armaSubVec; typedef lds::armaSubMat armaSubMat; namespace fill = lds::fill; // CONTROL BIT MASKS static const std::size_t CONTROL_TYPE_U = lds::CONTROL_TYPE_U; static const std::size_t CONTROL_TYPE_INTY = lds::CONTROL_TYPE_INTY; static const std::size_t CONTROL_TYPE_ADAPT_M = lds::CONTROL_TYPE_ADAPT_M; // default values static data_t DATA_T_ZERO = lds::DATA_T_ZERO; static data_t DATA_T_ONE = lds::DATA_T_ZERO; static data_t DEFAULT_SOFTSTART = lds::DEFAULT_SOFTSTART; static bool FALSE = lds::FALSE; static bool TRUE = lds::TRUE; // static const data_t inf = lds::inf; static const data_t pi = lds::pi; static data_t inf = lds::inf; static data_t neginf = lds::neginf; } // namespace poisson } // namespace lds  #include \u0026#34;lds_poisson_sys.h\u0026#34;#ifdef LDSCTRLEST_BUILD_FIT #include \u0026#34;lds_poisson_fit.h\u0026#34;#endif  #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':53,'href':'/ldsctrlest/docs/api/files/lds__poisson__ctrl_8h/','title':"ldsCtrlEst_h/lds_poisson_ctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_ctrl.h #  PLDS controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::ctrl_t PLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for feedback control of a Poisson-output linear dynamical system ([lds::poisson::ctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1ctrl__t/)). It inherits functionality from the underlying PLDS model type ([lds::poisson::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/)), including state estimation.\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_ctrl.h - PLDS Controller -------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_CTRL_H #define LDSCTRLEST_LDS_POISSON_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class ctrl_t : public sys_t { public: ctrl_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, size_t controlType = 0); ctrl_t\u0026amp; operator=(const ctrl_t\u0026amp; sys); /* * Perform a single step of feedback control. Note that this performs control * in the log-output space which is linear given the choice of exponential * nonlinearity. * * n.b., Requires user to have set the controller\u0026#39;s `xRef` and `uRef` * variables. * * @brief log-linear feedback control (single-step) * * @param z measurement * @param gateCtrl [optional] logical gate of control * (high=enabled; low=disabled) * @param gateLock [optional] logical gate of control signal * lock (if high, locks control at current * value) * @param sigma_softStart [optional] standard deviation (sigma) of a * Gaussian soft-start to control * @param sigma_uNoise [optional] standard deviation (sigma) of * Gaussian noise added on top of control signal * @param resetAtCtrlOnset [optional] whether to reset controller at * onset of a new control epoch (gateCtrl from * low to high) */ void logLin_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE); // Steady-state solution to log-linear control problem. Given user-supplied  // yRef --\u0026gt; steady state sol\u0026#39;z [xRef, uRef] --\u0026gt; control  void steadyState_logLin_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl = TRUE, bool\u0026amp; gateEst = TRUE, bool\u0026amp; gateLock = FALSE, data_t\u0026amp; sigma_softStart = DEFAULT_SOFTSTART, data_t\u0026amp; sigma_uNoise = DATA_T_ZERO, bool\u0026amp; resetAtCtrlOnset = TRUE); void calc_ssSetPt(); void printSys(); // set methods  // make sure to override the setU behavior inherited from sys_t!  // cannot set u for a controller, as it generates its own.  void setU(stdVec\u0026amp; uVec); void setU(armaVec\u0026amp; u); void setG(stdVec\u0026amp; gVec); void setG(armaVec\u0026amp; g); void setGDesign(stdVec\u0026amp; gVec); void setGDesign(armaVec\u0026amp; g); void setURef(stdVec\u0026amp; uRefVec); void setURef(armaVec\u0026amp; uRef); void setXRef(stdVec\u0026amp; xRefVec); void setXRef(armaVec\u0026amp; xRef); void setYRef(stdVec\u0026amp; yRefVec); void setYRef(armaVec\u0026amp; yRef); void setKc_x(stdVec\u0026amp; Kc_xVec); void setKc_x(armaMat\u0026amp; Kc_x); void setKc_u(stdVec\u0026amp; Kc_uVec); void setKc_u(armaMat\u0026amp; Kc_u); void setKc_inty(stdVec\u0026amp; Kc_intyVec); void setKc_inty(armaMat\u0026amp; Kc_inty); void setControlType(size_t controlType); void setTauAntiWindup(data_t\u0026amp; tau); armaMat getKc_u() const { return Kc_u; }; armaMat getKc_x() const { return Kc_x; }; armaMat getKc_inty() const { return Kc_inty; }; armaVec getGDesign() const { return gDesign; }; armaVec getURef() const { return uRef; }; armaVec getXRef() const { return xRef; }; armaVec getLogYRef() const { return logyRef; }; armaVec getYRef() const { return yRef; }; armaVec getLogY() const { return logy; }; armaVec getIntE() const { return intE; }; size_t getControlType() const { return controlType; }; void reset(); protected: armaVec gDesign; // reference signals  armaVec uRef; armaVec uRef_prev; armaVec xRef; armaVec logyRef; armaVec yRef; // Controller gains  armaMat Kc_x; armaMat Kc_u; armaMat Kc_inty; // control after g inversion (partial fb linearization)  // do not need set methods for these.  armaVec duRef; armaVec dvRef; armaVec vRef; armaVec dv; armaVec v; // integral error  // do not need set method for this  armaVec intE; armaVec intE_awuAdjust; armaVec uSat; bool gateCtrl_prev; bool gateLock_prev; data_t yRefLB; // I think it should be safe to have references here bc there is nothing I  // need to do (like reset vars) when it changes...  bool uSaturated; data_t\u0026amp; uLB; data_t\u0026amp; uUB; data_t tauAntiWindup; data_t kAntiWindup; void antiWindup(); data_t t_since_ctrl_onset; size_t controlType; private: void calc_logLinCtrl(bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset); }; } // namespace poisson } // namespace lds  #include \u0026#34;lds_poisson_sctrl.h\u0026#34; #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':54,'href':'/ldsctrlest/docs/api/files/lds__poisson__fit_8h/','title':"ldsCtrlEst_h/lds_poisson_fit.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_fit.h #  PLDS base fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::fit_t PLDS Fit Type.    Detailed Description #  This file declares and partially defines the base fit type for a Gaussian-output linear dynamical system. Models are fit by either subspace identification (SSID) or expectation-maximization (EM).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_fit.h - Fit Type for PLDS ------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_FIT_H #define LDSCTRLEST_LDS_POISSON_FIT_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class fit_t : public lds::fit_t { public: fit_t(){}; fit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, data_t dt, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); // Output  armaMat C; armaVec d; // input/output training data  std::vector\u0026lt;armaMat\u0026gt; uTrain; std::vector\u0026lt;armaMat\u0026gt; zTrain; }; }; // namespace poisson } // namespace lds  #include \u0026#34;lds_poisson_fit_ssid.h\u0026#34; #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':55,'href':'/ldsctrlest/docs/api/files/lds__poisson__fit__ssid_8h/','title':"ldsCtrlEst_h/lds_poisson_fit_ssid.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_fit_ssid.h #  PLDS SSID fit type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::ssidFit_t GLDS SSID Fit Type.    Detailed Description #  This file declares and partially defines a type by which Poisson-output LDS models are fit by a subspace identification (SSID) algorithm ([lds::gaussian::ssidFit_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ssid_fit__t/)). Currently, these models are fit assuming linear/Gaussian output, and then an exponential output is fit by maximum likelihood under the Poisson assumption. Future work should implement SSID after Poisson\u0026lt;-\u0026gt;Gaussian moment conversions as outlined in [2].\nReferences: [1] van Overschee P, de Moore B. (1996) Subspace Identification for Linear Systems. Boston: Springer. [2] Buesing L, Macke JH, Sahani M. (2012) Spectral learning of linear dynamics from generalised-linear observations with application to neural population data. NIPS 25.\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_fit_ssid.h - PLDS Fit (SSID) ---*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_FIT_SSID_H #define LDSCTRLEST_LDS_POISSON_FIT_SSID_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class ssidFit_t : public fit_t { public: ssidFit_t() : fit_t(){}; ssidFit_t(armaMat\u0026amp; A, armaMat\u0026amp; B, armaVec\u0026amp; g, armaVec\u0026amp; m, armaMat\u0026amp; Q, armaVec\u0026amp; x0, armaMat\u0026amp; P0, armaMat\u0026amp; C, armaVec\u0026amp; d, data_t dt, data_t t_startSSID, data_t t_stopSSID, armaVec\u0026amp; singVals, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; uTrain, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; zTrain); std::vector\u0026lt;data_t\u0026gt; t0; data_t t_startSSID; data_t t_stopSSID; armaVec singVals; }; std::tuple\u0026lt;ssidFit_t, lds::gaussian::ssidFit_t\u0026gt; ssidFit( std::vector\u0026lt;armaMat\u0026gt;\u0026amp; u, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; z, data_t dt, size_t nX, size_t nH = 25, armaVec d0 = armaVec(1).fill(-inf), ssidWt wt = NONE, data_t wtG0 = 0.0, std::vector\u0026lt;data_t\u0026gt;\u0026amp; t0 = DEFAULT_T0, data_t t_startSSID = -std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(), data_t t_stopSSID = std::numeric_limits\u0026lt;data_t\u0026gt;::infinity(), bool assumeGaussian = true); void newtonSolveC_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); data_t newtonSolve_rescaleC_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); void calcD_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); data_t calcD_newtonSolve_rescaleC_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); void fitOutput_mle(armaMat\u0026amp; C, armaVec\u0026amp; d, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; x, std::vector\u0026lt;armaMat\u0026gt;\u0026amp; n, data_t\u0026amp; dt); } // namespace poisson } // namespace lds #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':56,'href':'/ldsctrlest/docs/api/files/lds__poisson__sctrl_8h/','title':"ldsCtrlEst_h/lds_poisson_sctrl.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_sctrl.h #  PLDS switched controller type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::sctrl_t Switched PLDS Controller Type.    Detailed Description #  This file declares and partially defines the type for switched feedback control of a system approximated as multiple discrete Poisson-output linear dynamical systems ([lds::poisson::sctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sctrl__t/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_sctrl.h - Switched Controller --*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H #define LDSCTRLEST_LDS_POISSON_SWITCHED_CTRL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class sctrl_t : public ctrl_t { public: sctrl_t(std::size_t nSys, std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0, size_t controlType = 0); void setSystem(size_t sysIdx, ctrl_t\u0026amp; sys); // TODO(mfbolus):  // This switchSystem(sysIdx) approach is wasteful but simple.  // Would be faster to toggle between ctrl_t\u0026#39;s and replace wrapper u, x, P, m,  // P_m. However, would have to override or rewrite most controller  // functionality.  void switchSystem(size_t sysIdx); size_t getSysIdx() const { return sysIdx; }; protected: size_t nSys; std::vector\u0026lt;ctrl_t\u0026gt; systems; size_t sysIdx; private: // make all parameter set* methods private and define them to do nothing.  // force users to use setSystem, with pre-defined systems.  // from lds_t  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX){}; void setU(stdVec\u0026amp; uVec){}; void setU(armaVec\u0026amp; u){}; void setA(stdVec\u0026amp; aVec){}; void setA(armaMat\u0026amp; A){}; void setB(stdVec\u0026amp; bVec){}; void setB(armaMat\u0026amp; B){}; void setM(stdVec\u0026amp; mVec){}; void setM(armaVec\u0026amp; m){}; // void setG(stdVec\u0026amp; gVec) {};  // void setG(armaVec\u0026amp; g) {};  void setQ(stdVec\u0026amp; qVec){}; void setQ(armaMat\u0026amp; Q){}; void setQ_m(stdVec\u0026amp; qmVec){}; void setQ_m(armaMat\u0026amp; Q_m){}; void setX0(stdVec\u0026amp; x0Vec){}; void setX0(armaVec\u0026amp; x0){}; void setP0(stdVec\u0026amp; p0Vec){}; void setP0(armaMat\u0026amp; P0){}; void setP0_m(stdVec\u0026amp; p0mVec){}; void setP0_m(armaMat\u0026amp; P0_m){}; // from sys_t  void setC(stdVec\u0026amp; cVec){}; void setC(armaMat\u0026amp; C){}; void setD(stdVec\u0026amp; dVec){}; void setD(armaVec\u0026amp; d){}; // from ctrl_t  // void setGDesign(stdVec\u0026amp; gVec) {};  // void setGDesign(armaVec\u0026amp; g) {};  void setKc_x(stdVec\u0026amp; Kc_xVec){}; void setKc_x(armaVec\u0026amp; Kc_x){}; void setKc_u(stdVec\u0026amp; Kc_uVec){}; void setKc_u(armaVec\u0026amp; Kc_u){}; void setKc_inty(stdVec\u0026amp; Kc_intyVec){}; void setKc_inty(armaVec\u0026amp; Kc_inty){}; void setControlType(size_t controlType); // {};  // // assuming I *want* to maintain same references  // void setURef(stdVec\u0026amp; uRefVec) {};  // void setURef(armaVec\u0026amp; uRef) {};  // void setXRef(stdVec\u0026amp; xRefVec) {};  // void setXRef(armaVec\u0026amp; xRef) {};  // void setYRef(stdVec\u0026amp; yRefVec) {};  // void setYRef(armaVec\u0026amp; yRef) {}; }; } // namespace poisson } // namespace lds  #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':57,'href':'/ldsctrlest/docs/api/files/lds__poisson__sys_8h/','title':"ldsCtrlEst_h/lds_poisson_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_poisson_sys.h #  PLDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.   lds::poisson Linear Dynamical Systems with Poisson observations.    Classes #      Name     class lds::poisson::sys_t Poisson LDS Type.    Detailed Description #  This file declares and partially defines the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems ([lds::poisson::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/)). It inherits functionality from the underlying linear dynamical system ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)).\nSource code #  //===-- ldsCtrlEst_h/lds_poisson_sys.h - PLDS -------------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_POISSON_SYS_H #define LDSCTRLEST_LDS_POISSON_SYS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { namespace poisson { class sys_t : public lds::sys_t { public: void filter(armaVec\u0026amp; u_tm1, armaVec\u0026amp; z_t); void filter(armaVec\u0026amp; z); void simMeasurement(armaVec\u0026amp; z); sys_t(std::size_t nU, std::size_t nX, std::size_t nY, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0); sys_t\u0026amp; operator=(const sys_t\u0026amp; sys); // get methods  size_t getNy() const { return nY; }; armaMat getC() const { return C; }; armaVec getD() const { return d; }; armaVec getY() const { return y; }; armaVec getZ() const { return z; }; // set methods  void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX, std::size_t\u0026amp; nY); void setC(stdVec\u0026amp; cVec); void setC(armaMat\u0026amp; C); void setD(stdVec\u0026amp; dVec); void setD(armaVec\u0026amp; d); void setZ(stdVec\u0026amp; zVec); void setZ(armaVec\u0026amp; z); void reset(); void printSys(); protected: void predict(); void h(); // output nonlinearity  // output-specific stuff  std::size_t nY; armaMat C; armaVec d; armaVec y; armaVec logy; armaVec z; armaMat diag_y; armaVec chance; }; // sys_t } // namespace poisson } // namespace lds  #include \u0026#34;lds_poisson_ctrl.h\u0026#34; #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':58,'href':'/ldsctrlest/docs/api/files/lds__sys_8h/','title':"ldsCtrlEst_h/lds_sys.h",'section':"Files",'content':"ldsCtrlEst_h/lds_sys.h #  LDS base type. More\u0026hellip;\nNamespaces #     Name     lds Linear Dynamical Systems (LDS) namespace.    Classes #      Name     class lds::sys_t Linear Dynamical System Type.    Detailed Description #  This file declares and partially defines the base type for linear dynamical systems ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code #  //===-- ldsCtrlEst_h/lds_sys.h - LDS ----------------------------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_LDS_SYS_H #define LDSCTRLEST_LDS_SYS_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  namespace lds { class sys_t { public: sys_t(std::size_t nU, std::size_t nX, data_t\u0026amp; dt, data_t\u0026amp; p0 = DEFAULT_P0, data_t\u0026amp; q0 = DEFAULT_Q0); sys_t\u0026amp; operator=(const sys_t\u0026amp; sys); void simPredict(); size_t getNx() const { return nX; }; size_t getNu() const { return nU; }; armaVec getU() const { return u; }; armaVec getX() { return x; }; armaVec getG() const { return g; }; armaVec getM() const { return m; }; armaMat getA() const { return A; }; armaMat getB() const { return B; }; armaMat getQ() const { return Q; }; armaMat getQ_m() const { return Q_m; }; armaMat getP() const { return P; }; armaMat getP_m() const { return P_m; }; armaVec getX0() const { return x0; }; armaMat getP0() const { return P0; }; armaVec getM0() const { return m0; }; armaMat getP0_m() const { return P0_m; }; void setDims(std::size_t\u0026amp; nU, std::size_t\u0026amp; nX); void setU(stdVec\u0026amp; uVec); void setU(armaVec\u0026amp; u); void setA(stdVec\u0026amp; aVec); void setA(armaMat\u0026amp; A); void setB(stdVec\u0026amp; bVec); void setB(armaMat\u0026amp; B); void setM(stdVec\u0026amp; mVec); void setM(armaVec\u0026amp; m); void setG(stdVec\u0026amp; gVec); void setG(armaVec\u0026amp; g); void setQ(stdVec\u0026amp; qVec); void setQ(armaMat\u0026amp; Q); void setQ_m(stdVec\u0026amp; qmVec); void setQ_m(armaMat\u0026amp; Q_m); void setX0(stdVec\u0026amp; x0Vec); void setX0(armaVec\u0026amp; x0); void setP0(stdVec\u0026amp; p0Vec); void setP0(armaMat\u0026amp; P0); void setP0_m(stdVec\u0026amp; p0mVec); void setP0_m(armaMat\u0026amp; P0_m); void reset(); void printSys(); bool adaptM; protected: armaVec u; armaVec x; armaMat P; armaVec m; armaMat P_m; // Parameters:  armaVec x0; armaMat P0; armaVec m0; armaMat P0_m; armaMat A; armaMat B; armaVec g; armaMat Q; armaMat Q_m; // it should be safe for dt to be a reference. I should not need to control  // what the set behavior is.  data_t\u0026amp; dt; data_t\u0026amp; q0; data_t\u0026amp; p0; // dimensions  std::size_t nX; std::size_t nU; bool szChanged; // max val for elements of P before reset for numerical reasons...  const data_t plim = 1e2; void predict(); // TODO(mfbolus): these are very redundant.  // Should be able to use templates in some way to make this less type-specific  void reassign(armaVec\u0026amp; oldVar, armaVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaVec\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaSubVec\u0026amp; oldVar, armaVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaSubVec\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaMat\u0026amp; oldVar, armaMat\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaMat\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaSubMat\u0026amp; oldVar, armaMat\u0026amp; newVar, data_t defaultVal = 0); void reassign(armaSubMat\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal = 0); void limit(stdVec\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub); void limit(armaVec\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub); void limit(armaMat\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub); void defaultQ(); void checkP(); }; // sys_t } // namespace lds  #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':59,'href':'/ldsctrlest/docs/api/files/mex__c__util_8h/','title':"ldsCtrlEst_h/mex_c_util.h",'section':"Files",'content':"ldsCtrlEst_h/mex_c_util.h #  arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C API) More\u0026hellip;\nNamespaces #     Name     armamexc arma/mex interface using Matlab C API    Detailed Description #  This file defines utility functions for interoperability between armadillo and Matlab/Octave\u0026rsquo;s C mex API.\nSource code #  //===-- ldsCtrlEst_h/mex_c_util.h - Mex C API Utilities ---------*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_MEXC_UTIL_H #define LDSCTRLEST_MEXC_UTIL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;mex.h\u0026#34; // // If Matlab_FOUND, include matrix.h. // // (Octave does not need/have it.) // #ifdef Matlab_FOUND // #include \u0026#34;matrix.h\u0026#34; // #endif  namespace armamexc { template \u0026lt;class T\u0026gt; inline auto m2T_scalar(const mxArray *matlab_scalar) -\u0026gt; T { if (mxGetData(matlab_scalar)) { return static_cast\u0026lt;T\u0026gt;(mxGetScalar(matlab_scalar)); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return 0; } template \u0026lt;class T\u0026gt; inline auto m2a_mat(const mxArray *matlab_mat, bool copy_aux_mem = false, bool strict = true) -\u0026gt; arma::Mat\u0026lt;T\u0026gt; { if (mxGetData(matlab_mat)) { const mwSize n_dim = mxGetNumberOfDimensions(matlab_mat); if (n_dim == 2) { return arma::Mat\u0026lt;T\u0026gt;(static_cast\u0026lt;double *\u0026gt;(mxGetData(matlab_mat)), mxGetM(matlab_mat), mxGetN(matlab_mat), copy_aux_mem, strict); } mexErrMsgTxt(\u0026#34;Number of dimensions must be 2.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } mexErrMsgTxt(\u0026#34;No data available.\u0026#34;); return arma::Mat\u0026lt;T\u0026gt;(); } // TODO(mfbolus): make these templated.  inline auto a2m_mat(arma::Mat\u0026lt;double\u0026gt; const \u0026amp;arma_mat) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_mat.n_rows, arma_mat.n_cols, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;double *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;double *\u0026gt;(arma_mat.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy.  std::memcpy(dst_pointer, src_pointer, sizeof(double) * arma_mat.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Mat.\u0026#34;); return nullptr; } inline auto a2m_vec(arma::Col\u0026lt;double\u0026gt; const \u0026amp;arma_vec) -\u0026gt; mxArray * { mxArray *matlab_mat = mxCreateNumericMatrix(arma_vec.n_elem, 1, mxDOUBLE_CLASS, mxREAL); if (matlab_mat) { auto *dst_pointer = static_cast\u0026lt;double *\u0026gt;(mxGetData(matlab_mat)); const auto *src_pointer = const_cast\u0026lt;double *\u0026gt;(arma_vec.memptr()); // TODO(mfbolus): I just want to MOVE the data, not copy.  std::memcpy(dst_pointer, src_pointer, sizeof(double) * arma_vec.n_elem); return matlab_mat; } mexErrMsgTxt(\u0026#34;Failed to create matlab mat from arma::Col.\u0026#34;); return nullptr; } } // namespace armamexc  #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':60,'href':'/ldsctrlest/docs/api/files/mex__cpp__util_8h/','title':"ldsCtrlEst_h/mex_cpp_util.h",'section':"Files",'content':"ldsCtrlEst_h/mex_cpp_util.h #  arma \u0026lt;-\u0026gt; mex interoperability utilities (Matlab C++ API) More\u0026hellip;\nNamespaces #     Name     armamexcpp arma/mex interface using Matlab C++ API    Detailed Description #  This file defines utility functions for interoperability between armadillo and Matlab\u0026rsquo;s C++ mex API.\nSource code #  //===-- ldsCtrlEst_h/mex_cpp_util.h - Mex C++ API Utilities -----*- C++ -*-===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #ifndef LDSCTRLEST_MEXCPP_UTIL_H #define LDSCTRLEST_MEXCPP_UTIL_H  #ifndef LDSCTRLEST #include \u0026lt;ldsCtrlEst\u0026gt;#endif  #include \u0026#34;mex.hpp\u0026#34;#include \u0026#34;mexAdapter.hpp\u0026#34; namespace armamexcpp { template \u0026lt;class T\u0026gt; auto m2a_cellmat(matlab::data::CellArray\u0026amp; matlab_cell) -\u0026gt; std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; { size_t n_cells = matlab_cell.getNumberOfElements(); std::vector\u0026lt;arma::Mat\u0026lt;T\u0026gt;\u0026gt; arma_mat(n_cells, arma::mat(1, 1, arma::fill::zeros)); for (size_t k = 0; k \u0026lt; n_cells; k++) { matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = matlab_cell[k]; auto dims = matlab_mat.getDimensions(); arma_mat[k] = arma::Mat\u0026lt;T\u0026gt;(matlab_mat.release().get(), dims[0], dims[1]); } return arma_mat; }; template \u0026lt;class T\u0026gt; auto m2s_vec(matlab::data::TypedArray\u0026lt;T\u0026gt;\u0026amp; matlab_array) -\u0026gt; std::vector\u0026lt;T\u0026gt; { size_t n_elem = matlab_array.getNumberOfElements(); double* ptr = matlab_array.release().get(); std::vector\u0026lt;T\u0026gt; vec(ptr, ptr + n_elem); return vec; }; template \u0026lt;class T\u0026gt; auto m2a_vec(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) -\u0026gt; arma::Col\u0026lt;T\u0026gt; { size_t n_elem = matlab_array.getNumberOfElements(); T* ptr = matlab_array.release().get(); arma::Col\u0026lt;T\u0026gt; vec(ptr, n_elem); //, false);  return vec; }; template \u0026lt;class T\u0026gt; auto m2a_mat(matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_array) -\u0026gt; arma::Mat\u0026lt;T\u0026gt; { // ArrayDimensions == std::vector\u0026lt;size_t\u0026gt;  auto dims = matlab_array.getDimensions(); T* ptr = matlab_array.release().get(); // mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false)  arma::Mat\u0026lt;T\u0026gt; mat(ptr, dims[0], dims[1]); //, false);  return mat; }; template \u0026lt;class T\u0026gt; auto a2m_mat(arma::Mat\u0026lt;T\u0026gt;\u0026amp; arma_mat, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {arma_mat.n_rows, arma_mat.n_cols}, arma_mat.memptr(), arma_mat.memptr() + arma_mat.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; auto a2m_vec(arma::Col\u0026lt;T\u0026gt;\u0026amp; arma_vec, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;({arma_vec.n_elem, 1}, arma_vec.memptr(), arma_vec.memptr() + arma_vec.n_elem); return matlab_mat; }; template \u0026lt;class T\u0026gt; auto s2m_vec(std::vector\u0026lt;T\u0026gt;\u0026amp; std_vec, matlab::data::ArrayFactory\u0026amp; factory) -\u0026gt; matlab::data::TypedArray\u0026lt;T\u0026gt; { const matlab::data::TypedArray\u0026lt;T\u0026gt; matlab_mat = factory.createArray\u0026lt;T\u0026gt;( {std_vec.size(), 1}, std_vec.data(), std_vec.data() + std_vec.size()); return matlab_mat; }; } // namespace armamexcpp  #endif  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':61,'href':'/ldsctrlest/docs/terminology/model/','title':"Models",'section':"LDS C+E Documentation",'content':"Model Definitions #  This library provides methods for control and estimation of linear dynamical systems (LDS) of the following form:   \\[\\mathbf{x}_{t\u0026#43;1} = f\\left( \\mathbf{x}_{t}, \\mathbf{v}_{t} \\right) = \\mathbf{A} \\mathbf{x}_{t} \u0026#43; \\mathbf{B} \\mathbf{v}_{t} \u0026#43; \\mathbf{m}_{t} \u0026#43; \\mathbf{w}_{t}\\]   \\[\\mathbf{y}_{t} = h\\left( \\mathbf{x}_{t} \\right)\\]  t : time index x : system state v = g%u : input (e.g., in physical units used for model fit) u : control signal sent to actuator (e.g., in Volts) y : system output m : process disturbance w ~ N(0, Q) : process noise/disturbance A : state matrix B : input coupling matrix g : input gain (e.g., for converting to control signal actuator voltage) n.b., assumes this conversion is linear Q : process noise covariance % : element-wise multiplication  LDS with Gaussian Observations #  For linear dynamical systems whose outputs are assumed to be corrupted by additive Gaussian noise before measurement (Gaussian LDS models), the output function takes the following form.\n \\[\\mathbf{y}_{t} = \\mathbf{C} \\mathbf{x}_{t} \u0026#43; \\mathbf{d}\\]   \\[\\mathbf{z}_{t} \\sim \\mathcal{N}\\left(\\mathbf{y}_{t} , \\mathbf{R} \\right)\\]  z : measurement C : output matrix d : output bias R : measurement noise covariance  LDS with Poisson Observations #  For linear dynamical systems whose outputs are assumed to be rates underlying measured count data derived from a Poisson distribution (Poisson LDS models), the output function takes the following form. Note an element-wise exponentiation is used to rectify the linear dynamics for the rate of the Poisson process.\n \\[y_{t}^{i} = \\exp \\left(\\mathbf{c}^i \\mathbf{x}_{t} \u0026#43; d^i\\right)\\]   \\[z_{t}^i \\sim \\rm{Poisson} \\left(y_{t}^i \\right)\\]  i : output index z : measurement (count data) c : i^th row of output matrix (C) d : output bias  "});index.add({'id':62,'href':'/ldsctrlest/docs/api/modules/','title':"Modules",'section':"LDS C+E Documentation",'content':"Modules #    Control Mode Bit Masks\n  Defaults\n   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':63,'href':'/ldsctrlest/docs/api/namespaces/','title':"Namespaces",'section':"LDS C+E Documentation",'content':"Namespaces #    armamexc arma/mex interface using Matlab C API\n  armamexcpp arma/mex interface using Matlab C++ API\n  glds\n  lds::gaussian Linear Dynamical Systems with Gaussian observations.\n  lds::poisson Linear Dynamical Systems with Poisson observations.\n  plds\n  std\n   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':64,'href':'/ldsctrlest/docs/api/pages/','title':"Pages",'section':"LDS C+E Documentation",'content':"Pages #   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':65,'href':'/ldsctrlest/docs/api/namespaces/namespaceplds/','title':"plds",'section':"Namespaces",'content':"plds #   Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':66,'href':'/ldsctrlest/docs/tutorials/eg_plds_state_estimation/','title':"PLDS State Estimation",'section':"LDS C+E Examples",'content':"PLDS State Estimation Tutorial #  This tutorial shows how to use this library to estimate the state of an LDS Poisson observations from input/output data. In place of a physical system, another PLDS model (lds::poisson::sys_t) receives random inputs and provides measurements for the state estimator. For the sake of example, the only parameter mismatch is assumed to be the process disturbance, which is adaptively re-estimated.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; Creating a simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; // no. inputs  size_t n_x = 1; // no. states  size_t n_y = 1; // no. outputs  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30 / dt); // no time steps for simulation. When a system is initialized, rather than requiring all parameters to be provided at construction, only the dimensions and sample period are required and a default system is created.\n// construct ground truth system...  lds::poisson::sys_t system_true(n_u, n_x, n_y, dt); This default system is a random walk, where the state matrix is identity, the input matrix is zeros, and the top min(n_x, n_y) states are observed at the output. i.e., for this example,   \\[x_{t\u0026#43;1} = x_t \u0026#43; w_t\\]   \\[y_{t} = \\exp\\left(x_t\\right) \\; .\\]  Now, we\u0026rsquo;ll create non-default parameters for this model.\n// Model parameters  armaMat a_true(n_x, n_x, arma::fill::eye); a_true[0] = exp(-dt / 0.075); armaMat b_true = armaMat(n_x, n_u).fill(1e-2); armaVec m0_true = armaVec(n_x, arma::fill::zeros).fill(-7e-2); // disturbance  armaVec x0_true = m0_true * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state Finally, assign the parameters using corresponding set-methods.\n// Assign params.  system_true.setA(a_true); system_true.setB(b_true); system_true.setX0(x0_true); system_true.setM(m0_true); system_true.reset(); Creating the estimator #  Now, create the estimator. The system type (sys_t) includes filtering functionality for state estimation, so create another lds::poisson::sys_t. As noted above, the only parameter mismatch in this simulation will be the process disturbance.\n// Construct system for estimation  // e.g., will create a model with incorrect disturbance  lds::poisson::sys_t system_estimator(n_u, n_x, n_y, dt); // Can copy parameters from another system object  system_estimator = system_true; // wrong disturbance  armaVec m0_est = m0_true * 2; system_estimator.setM(m0_est); // set new initial conditions  armaVec x0_est = m0_est * arma::inv(armaMat(n_x, n_x, arma::fill::eye) - a_true); // initial state  system_estimator.setX0(x0_est); system_estimator.reset(); // reset to initial condition. To ensure robust estimates, adaptively re-estimate the process disturbance.\n// turn on adaptive disturbance estimation  system_estimator.adaptM = true; // set adaptation rate by changing covariance of assumed process noise acting  // on random-walk evolution of m  armaMat q_m = armaMat(n_x, n_x, arma::fill::eye) * 1e-6; system_estimator.setQ_m(q_m); Simulating estimation #  In this demonstration, random inputs are presented to the system, measurements are taken, and filtering is carried out in a for-loop.\n// Simlate the true system.  system_true.setU(u_k); system_true.simPredict(); // generate a measurement  armaVec z_k(z.colptr(t), z.n_rows, false, true); system_true.simMeasurement(z_k); // filter (predict -\u0026gt; update)  system_estimator.filter(z_k); Example simulation result #  Below are example results for this simulation, including outputs, latent states, process disturbance, and the input. The online estimates of the output, state, and disturbance are given in purple.\nWith this parameterization, it takes the estimator approximately 5 seconds to minimize state error. The state and output error distributions for the period after 5 seconds is shown below.\n"});index.add({'id':67,'href':'/ldsctrlest/docs/tutorials/eg_switched_plds_control/','title':"PLDS Switched Control",'section':"LDS C+E Examples",'content':"PLDS Switched Control Tutorial #  This tutorial shows how to use this library to control a system with a switched PLDS controller (lds::poisson::sctrl_t). This type of controller is applicable in scenarios where a physical system is not accurately captured by a LDS but has multiple discrete operating modes where the dynamics can be well-approximated as linear.\nIn the example that follows, another PLDS model (lds::poisson::sys_t) is used in place of a physical system. It receives control inputs and provides measurements for the simulated feedback control loop. This system stochastically flips between two input gains. In this example, the controller is assumed to have a perfect model of the switching system being controlled. Note that in practice, users would need to have a decoder that estimates operating mode of the physical system being controlled. This library does not currently include operating mode estimation.\nThe full code for this can be found here.\nPreamble #  In addition to including the main ldsCtrlEst header, this tutorial will use some shorthand.\n#include \u0026lt;ldsCtrlEst\u0026gt; using lds::armaMat; using lds::armaVec; using lds::data_t; using std::cout; using std::vector; Creating the simulated system #  A first-order single-input/single-output system will be used for the purposes of this demonstration. The simulation will be run at 1 kHz for 30 seconds.\n// Make SISO system sampled at 1kHz  data_t dt = 1e-3; size_t n_u = 1; size_t n_x = 1; size_t n_y = 1; // no time steps for simulation.  size_t n_t = static_cast\u0026lt;size_t\u0026gt;(30.0 / dt); The system\u0026rsquo;s input matrix (B) will be switched stochastically from one value (b1) to a less sensitive value (b2) according to the following probabilities.\n// for simulating switching  size_t which_mode = 1; data_t pr_21 = 1e-3; // prob mode 1 -\u0026gt; 2  data_t pr_12 = pr_21; // prob mode 2 -\u0026gt; 1 Initially, the system will be in \u0026ldquo;mode\u0026rdquo; 1, where B = b2.\n// simulated system being controlled  lds::poisson::sys_t controlled_system(n_u, n_x, n_y, dt); // **Assume the system is not well characterized by one LDS, but is well  // characterized by two LDS models with different input matrices.**  armaMat a(n_x, n_x, arma::fill::eye); a[0] = 0.985; armaMat b1 = armaMat(n_x, n_u).fill(0.05); armaVec d = armaVec(n_y, arma::fill::zeros).fill(log(1 * dt)); controlled_system.setA(a); controlled_system.setB(b1); controlled_system.setD(d); controlled_system.reset(); // reset to initial conditions See the GLDS Control and PLDS State Estimation tutorials for more detail about sys_t creation.\nCreating the controller #  Now, create the controller. A switched-system controller (sctrl_t) essentially toggles between the parameters of its subsystems when the controller is told a switch has occured. The first thing the user needs to do is define these subsystems. In this example, there are two Poisson systems (sys1, sys2), which are the same save for their input gains.\n// create switched controller sub-systems  // system 1  data_t u_lb = 0.0; data_t u_ub = 5.0; lds::poisson::ctrl_t sys1(n_u, n_x, n_y, u_lb, u_ub, dt); // Control variables  armaVec y_ref0 = armaVec(n_y, arma::fill::zeros).fill(25.0 * dt); // controller gains for underlying system 1:  armaMat k_x1(n_u, n_x, arma::fill::ones); size_t control_type = 0; // no integral action, etc.  // setting initial mode to target to avoid large error at onset:  armaVec x0_controller = arma::log(y_ref0) - d; armaMat q_controller = armaMat(n_x, n_x, arma::fill::eye) * 5e-3; sys1.setControlType(control_type); sys1.setA(a); sys1.setB(b1); sys1.setD(d); sys1.setX0(x0_controller); sys1.setKc_x(k_x1); sys1.setQ(q_controller); // set process noise covariance  // system 2  lds::poisson::ctrl_t sys2 = sys1; // Let underlying system 1 be more sensitive than system 2  data_t scale_sys_b = 2; armaMat b2 = armaMat(n_x, n_u).fill(b1[0] / scale_sys_b); armaMat k_x2 = scale_sys_b * k_x1; // system2 is x-times less sensitive.  // set parameters  sys2.setB(b2); sys2.setKc_x(k_x2); Now that the two subsystems are defined, instantiate the switched controller and set its members. Importantly, control references \u0026ldquo;belong\u0026rdquo; to the switched controller, so they need to be assigned to it, rather than its subsystems.\n// create 2-system composite switched-mode controller.  lds::poisson::sctrl_t switched_controller(2, n_u, n_x, n_y, u_lb, u_ub, dt); // assign the parameters of the sub-systems 1 and 2  switched_controller.setSystem(0, sys1); switched_controller.setSystem(1, sys2); switched_controller.switchSystem(0); // start with system 1  switched_controller.reset(); // reset to initial conditions  // reference belongs to super system. Set here.  switched_controller.setYRef(y_ref0); // adaptively estimate process disturbance (m)  // n.b. using arbitrary default value for process noise if enabled.  switched_controller.adaptM = true; Simulating control #  In this demonstration, we will use the steadyState_logLin_fbCtrl method which allows users to simply set the reference output event rate (y_ref) and supply the current measurement z_t. It then calculates the steady-state solution for the reference state/input. In this case, the goal is to regulate the output about a constant reference, so it is appropriate here. This method can also be used for time-varying references as long as this variation is slow compared to the dynamics of the system. Importantly, this method performs control in the linear state space (i.e., taking the logarithm of the output).\nThe control loop is carried out here in a simple for-loop, where a the controlled system is simulated, a measurement taken, and the control signal updated.\n// Simulate the true system.  controlled_system.setU(u_tm1); controlled_system.simPredict(); armaVec z_k = armaVec(z.colptr(t), z.n_rows, false, true); controlled_system.simMeasurement(z_k); // perform control  switched_controller.steadyState_logLin_fbCtrl(z_k); Note that as the gain of the controlled system changes stochastically, the controller is informed of this change. In practice, a user must decode such changes in the system\u0026rsquo;s operating mode and call the switchSystem method accordingly. Such a decoder is not currently included in this library.\nExample simulation result #  Below are example results for this simulation, including outputs, latent states, mode switches, and the control signal. The controller\u0026rsquo;s online estimates of the output and state are shown in purple.\nNote that every time the operating mode of the system (here, a gain change) the controller immediately adjusts its inputs. In contrast, a non-switched controller with integral action would also compensate but do so in a comparitively sluggish fashion.\n"});index.add({'id':68,'href':'/ldsctrlest/docs/api/files/dir_68267d1309a1af8e8297ef4c3efbcdba/','title':"src",'section':"Files",'content':"src #  Files #     Name     src/lds_gaussian_ctrl.cpp GLDS controller type.   src/lds_gaussian_sctrl.cpp GLDS switched controller type.   src/lds_gaussian_sys.cpp GLDS base type.   src/lds_poisson_ctrl.cpp PLDS controller type.   src/lds_poisson_sctrl.cpp PLDS switched controller type.   src/lds_poisson_sys.cpp PLDS base type.   src/lds_sys.cpp LDS base type.     Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':69,'href':'/ldsctrlest/docs/api/files/lds__gaussian__ctrl_8cpp/','title':"src/lds_gaussian_ctrl.cpp",'section':"Files",'content':"src/lds_gaussian_ctrl.cpp #  GLDS controller type. More\u0026hellip;\nNamespaces #     Name     std   glds    Detailed Description #  This file implements the type for feedback control of a gaussian-output linear dynamical system ([lds::gaussian::ctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1ctrl__t/)). It inherits functionality from the underlying GLDS model type ([lds::gaussian::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/)), including state estimation.\nSource code #  //===-- lds_gaussian_ctrl.cpp - GLDS Controller ---------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace glds; // Constructor(s) for sys class glds::ctrl_t::ctrl_t(size_t nU, size_t nX, size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, data_t\u0026amp; r0, size_t controlType) : glds::sys_t(nU, nX, nY, dt, p0, q0, r0), uLB(uLB), uUB(uUB), gateCtrl_prev(false), gateLock_prev(false), uSaturated(false), tauAntiWindup(lds::inf), t_since_ctrl_onset(0.0) { // initialize to default values  uRef = armaVec(nU, fill::zeros); uRef_prev = armaVec(nU, fill::zeros); xRef = armaVec(nX, fill::zeros); yRef = armaVec(nY, fill::zeros); uSat = armaVec(nU, fill::zeros); // Might not need all these, so zero elements until later.  Kc_x = armaMat(nU, nX, fill::zeros); Kc_u = armaMat(0, 0, fill::zeros); Kc_inty = armaMat(0, 0, fill::zeros); gDesign = g; dv = armaVec(nU, fill::zeros); v = armaVec(nU, fill::zeros); duRef = armaVec(nU, fill::zeros); dvRef = armaVec(nU, fill::zeros); vRef = armaVec(nU, fill::zeros); intE = armaVec(0, fill::zeros); intE_awuAdjust = armaVec(0, fill::zeros); kAntiWindup = dt / tauAntiWindup; setControlType(controlType); } void glds::ctrl_t::fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset, bool\u0026amp; doRecurse_Ke) { // update state estimates, given latest measurement  filter(z, doRecurse_Ke); bool gateEst = true; // always have estimator on in this case  // calculate control signal  calc_ctrl(gateCtrl, gateEst, gateLock, sigma_softStart, sigma_uNoise, resetAtCtrlOnset); } void glds::ctrl_t::steadyState_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset, bool\u0026amp; doRecurse_Ke) { // update state estimates, given latest measurement  if (gateEst) { filter(z, doRecurse_Ke); } else { predict(); } // calculate the set point @ steady state.  if (gateCtrl) calc_ssSetPt(); // calculate control signal  calc_ctrl(gateCtrl, gateEst, gateLock, sigma_softStart, sigma_uNoise, resetAtCtrlOnset); } // steadyState_fbCtrl  // private method for meat of control logic void glds::ctrl_t::calc_ctrl(bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset) { if (gateCtrl \u0026amp;\u0026amp; gateEst) { if (!gateCtrl_prev) { if (resetAtCtrlOnset) { reset(); } t_since_ctrl_onset = 0.0; } else { t_since_ctrl_onset += dt; } // enforce softstart on control vars.  if (sigma_softStart \u0026gt; 0) { // half-Gaussian soft-start scaling factor  data_t softStart_sf = 1 - exp(-pow(t_since_ctrl_onset, 2) / (2 * pow(sigma_softStart, 2))); uRef *= softStart_sf; // TODO(mfbolus): May be appropriate to soft-start set point xRef, yRef  // too  // xRef *= softStart_sf;  // yRef *= softStart_sf;  } if (!gateLock) { duRef = uRef - uRef_prev; // first do u -\u0026gt; v change of vars. (v = g.*u)  // e.g., convert into physical units (e.g., v[=] mW/mm2 rather than driver  // control voltage u[=]V)  vRef = gDesign % uRef; dvRef = gDesign % duRef; // Given FB, calc. the change in control  if (controlType \u0026amp; CONTROL_TYPE_U) { // if control designed to minimize not u but deltaU (i.e. state aug with  // u):  dv = dvRef; // nominally-optimal.  dv -= Kc_x * (getX() - xRef); // instantaneous state error  dv -= Kc_u * (v - vRef); // penalty on changes in u  if (controlType \u0026amp; CONTROL_TYPE_INTY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if(!uSaturated)  intE += (y - yRef) * dt; // integrated error  dv -= Kc_inty * intE; // control for integrated error  } // update the control  v += dv; } else { v = vRef; // nominally-optimal.  v -= Kc_x * (getX() - xRef); // instantaneous state error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if (!uSaturated)  intE += (y - yRef) * dt; // integrated error  v -= Kc_inty * intE; // control for integrated error  } } // convert back to control voltage u[=]V  u = v / getG(); } // else do nothing until lock is low  // It may be desireable to make inputs more variable.  if (sigma_uNoise \u0026gt; 0.0) u += sigma_uNoise * armaVec(nU, fill::randn); } else { // if not control  // feed through uRef in open loop  u = uRef % gDesign / getG(); uRef.zeros(); intE.zeros(); intE_awuAdjust.zeros(); uSat.zeros(); } // ends gateCtrl  // enforce box constraints (and antiwindup)  antiWindup(); gateCtrl_prev = gateCtrl; gateLock_prev = gateLock; } // ends calc_ctrl  void glds::ctrl_t::setControlType(size_t controlType) { if (this-\u0026gt;controlType == controlType) return; // creating a blank slate... (perhaps unnecessary)  this-\u0026gt;controlType = 0; Kc_u.zeros(0, 0); Kc_inty.zeros(0, 0); intE.zeros(0, 0); intE_awuAdjust.zeros(0, 0); // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (controlType \u0026amp; CONTROL_TYPE_U) { Kc_u.zeros(nU, nU); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_U; } // controller was designed to minimize integral error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { Kc_inty.zeros(nU, nY); intE.zeros(nY); intE_awuAdjust.zeros(nY); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_INTY; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) { if (this-\u0026gt;adaptM) // only if adapting M...  this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_ADAPT_M; } } // set methods: // make sure cannot user-define value of u. void glds::ctrl_t::setU(stdVec\u0026amp; uVec) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot assign a value to `u` in GLDS controller.\\n\u0026#34;; } void glds::ctrl_t::setU(armaVec\u0026amp; u) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot assign a value to `u` in GLDS controller.\\n\u0026#34;; } void glds::ctrl_t::setG(stdVec\u0026amp; gVec) { glds::sys_t::setG(gVec); } void glds::ctrl_t::setG(armaVec\u0026amp; g) { glds::sys_t::setG(g); } void glds::ctrl_t::setGDesign(stdVec\u0026amp; gVec) { reassign(gDesign, gVec); } void glds::ctrl_t::setGDesign(armaVec\u0026amp; g) { reassign(gDesign, g); } void glds::ctrl_t::setURef(stdVec\u0026amp; uRefVec) { uRef_prev = uRef; reassign(uRef, uRefVec); } void glds::ctrl_t::setURef(armaVec\u0026amp; uRef) { uRef_prev = this-\u0026gt;uRef; reassign(this-\u0026gt;uRef, uRef); } void glds::ctrl_t::setXRef(stdVec\u0026amp; xRefVec) { reassign(xRef, xRefVec); } void glds::ctrl_t::setXRef(armaVec\u0026amp; xRef) { reassign(this-\u0026gt;xRef, xRef); } void glds::ctrl_t::setYRef(stdVec\u0026amp; yRefVec) { reassign(yRef, yRefVec); } void glds::ctrl_t::setYRef(armaVec\u0026amp; yRef) { reassign(this-\u0026gt;yRef, yRef); } void glds::ctrl_t::setKc_x(stdVec\u0026amp; Kc_x_vec) { reassign(Kc_x, Kc_x_vec); } void glds::ctrl_t::setKc_x(armaMat\u0026amp; Kc_x) { reassign(this-\u0026gt;Kc_x, Kc_x); } void glds::ctrl_t::setKc_u(stdVec\u0026amp; Kc_u_vec) { if (controlType \u0026amp; CONTROL_TYPE_U) reassign(Kc_u, Kc_u_vec); } void glds::ctrl_t::setKc_u(armaMat\u0026amp; Kc_u) { if (controlType \u0026amp; CONTROL_TYPE_U) reassign(this-\u0026gt;Kc_u, Kc_u); } void glds::ctrl_t::setKc_inty(stdVec\u0026amp; Kc_inty_vec) { if (controlType \u0026amp; CONTROL_TYPE_INTY) reassign(Kc_inty, Kc_inty_vec); } void glds::ctrl_t::setKc_inty(armaMat\u0026amp; Kc_inty) { if (controlType \u0026amp; CONTROL_TYPE_INTY) reassign(this-\u0026gt;Kc_inty, Kc_inty); } void glds::ctrl_t::setTauAntiWindup(data_t\u0026amp; tau) { tauAntiWindup = tau; kAntiWindup = dt / tauAntiWindup; } void glds::ctrl_t::calc_ssSetPt() { // Linearly-constrained least squares (ls).  //  // Reference:  // Boyd \u0026amp; Vandenberghe (2018) Introduction to Applied Linear Algebra  //  armaMat A_ls = join_horiz(C, armaMat(nY, nU, fill::zeros)); armaVec b_ls = yRef - d; armaMat C_ls = join_horiz(A - armaMat(nX, nX, fill::eye), B * arma::diagmat(g)); armaVec d_ls = -m0; if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) d_ls = -m; // adapt setpoint calc with disturbance?  armaMat A_ls_t = A_ls.t(); // TODO(mfbolus): not sure why but causes seg  // fault if I do not do this.  armaMat phi_ls = join_vert(join_horiz(2 * A_ls_t * A_ls, C_ls.t()), join_horiz(C_ls, armaMat(nX, nX, fill::zeros))); armaMat inv_phi = pinv( phi_ls); // TODO(mfbolus): should be actual inverse, rather than pseudo-  armaVec xulam = inv_phi * join_vert(2 * A_ls_t * b_ls, d_ls); xRef = xulam.subvec(0, nX - 1); uRef = xulam.subvec(nX, nX + nU - 1); yRef = C * xRef + d; // the least-squares solution } void glds::ctrl_t::antiWindup() { uSaturated = false; uSat = u; // limit u and flag whether saturated  for (size_t k = 0; k \u0026lt; u.n_elem; k++) { if (u[k] \u0026lt; uLB) { uSat[k] = uLB; uSaturated = true; } if (u[k] \u0026gt; uUB) { uSat[k] = uUB; uSaturated = true; } } if ((controlType \u0026amp; CONTROL_TYPE_INTY) \u0026amp;\u0026amp; (tauAntiWindup \u0026lt; lds::inf)) { // one-step back-calculation (calculate intE for u=u_sat)  // (Astroem, Rundqwist 1989 warn against using this...)  // intE_awuAdjust =  // solve(Kc_inty, (u - uSat)); // pinv(Kc_inty) * (u-uSat);  // gradual: see Astroem, Rundqwist 1989  // this is a fudge for doing MIMO gradual  // n.b., went ahead and multiplied 1/T by dt so don\u0026#39;t have to do that here.  intE_awuAdjust = kAntiWindup * (sign(Kc_inty).t() / nU) * (u - uSat); // intE_awuAdjust = kAntiWindup * (u-uSat);  intE += intE_awuAdjust; } // set u to saturated version  u = uSat; } void glds::ctrl_t::reset() { glds::sys_t::reset(); uRef.zeros(); uRef_prev.zeros(); intE.zeros(); intE_awuAdjust.zeros(); uSat.zeros(); uSaturated = false; t_since_ctrl_onset = 0.0; } void glds::ctrl_t::printSys() { glds::sys_t::printSys(); std::cout \u0026lt;\u0026lt; \u0026#34;gDesign : \u0026#34; \u0026lt;\u0026lt; gDesign \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;uLB : \u0026#34; \u0026lt;\u0026lt; uLB \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;uUB : \u0026#34; \u0026lt;\u0026lt; uUB \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } glds::ctrl_t\u0026amp; glds::ctrl_t::operator=(const glds::ctrl_t\u0026amp; sys) { // TODO(mfbolus): would love to be able to re-use the lds code:  //  // (*this) = lds::sys_t::operator=(sys);  //  // but this does not work bc the input is glds::sys_t which is a subclass of  // lds::sys_t. Need to figure out if there is a way to write functions to  // apply to all subclasses (e.g., \u0026lt;lds::sys_t\u0026amp; sys)  // FROM LDS  this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; // END FROM LDS  // from GLDS  this-\u0026gt;C = sys.C; this-\u0026gt;d = sys.d; this-\u0026gt;R = sys.R; this-\u0026gt;r0 = sys.r0; this-\u0026gt;Ke = sys.Ke; this-\u0026gt;Ke_m = sys.Ke_m; this-\u0026gt;adaptM = sys.adaptM; this-\u0026gt;y = sys.y; this-\u0026gt;z = sys.z; this-\u0026gt;nY = sys.nY; // end from GLDS  // additional ctrl_t stuff  this-\u0026gt;gDesign = sys.gDesign; this-\u0026gt;uRef = sys.uRef; this-\u0026gt;uRef_prev = sys.uRef_prev; this-\u0026gt;xRef = sys.xRef; this-\u0026gt;yRef = sys.yRef; this-\u0026gt;Kc_x = sys.Kc_x; this-\u0026gt;Kc_u = sys.Kc_u; this-\u0026gt;Kc_inty = sys.Kc_inty; this-\u0026gt;duRef = sys.duRef; this-\u0026gt;dvRef = sys.dvRef; this-\u0026gt;vRef = sys.vRef; this-\u0026gt;dv = sys.dv; this-\u0026gt;v = sys.v; this-\u0026gt;intE = sys.intE; this-\u0026gt;intE_awuAdjust = sys.intE_awuAdjust; this-\u0026gt;uLB = sys.uLB; this-\u0026gt;uUB = sys.uUB; this-\u0026gt;uSat = sys.uSat; this-\u0026gt;uSaturated = sys.uSaturated; this-\u0026gt;t_since_ctrl_onset = sys.t_since_ctrl_onset; this-\u0026gt;controlType = sys.controlType; return *this; } void glds::ctrl_t::setDims(size_t\u0026amp; nU, size_t\u0026amp; nX, size_t\u0026amp; nY) { // If dimensions are changed, need to resize object and reset.  if (nU != this-\u0026gt;nU) { szChanged = true; this-\u0026gt;nU = nU; } if (nX != this-\u0026gt;nX) { szChanged = true; this-\u0026gt;nX = nX; } if (nY != this-\u0026gt;nY) { szChanged = true; this-\u0026gt;nY = nY; } // this seems a bit heavy-handed, but if any of the dimensions are changed,  // reset everything.  if (szChanged) { cout \u0026lt;\u0026lt; \u0026#34;System dimensions were changed. Resetting object.\\n\u0026#34;; (*this) = glds::ctrl_t(nU, nX, nY, uLB, uUB, dt, p0, q0, r0, controlType); szChanged = false; } }  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':70,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sctrl_8cpp/','title':"src/lds_gaussian_sctrl.cpp",'section':"Files",'content':"src/lds_gaussian_sctrl.cpp #  GLDS switched controller type. More\u0026hellip;\nDetailed Description #  This file implements the type for switched feedback control of a system approximated as multiple discrete Gaussian-output linear dynamical systems ([lds::gaussian::sctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sctrl__t/)).\nSource code #  //===-- lds_gaussian_sctrl.cpp - Switched Controller ----------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace glds; glds::sctrl_t::sctrl_t(size_t nSys, size_t nU, size_t nX, size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, data_t\u0026amp; r0, size_t controlType) : glds::ctrl_t(nU, nX, nY, uLB, uUB, dt, p0, q0, r0, controlType), nSys(nSys), sysIdx(0) { // initial wrapper controller  // (will hold parameters of toggled underlying systems set by `setSystem`)  ctrl_t sys0(nU, nX, nY, uLB, uUB, dt, p0, q0, r0, controlType); systems = std::vector\u0026lt;ctrl_t\u0026gt;(nSys, sys0); adaptM = false; } void glds::sctrl_t::setSystem(size_t sysIdx, ctrl_t\u0026amp; sys) { // Make sure system Idx in bounds  if ((sysIdx + 1) \u0026gt; nSys) { cerr \u0026lt;\u0026lt; \u0026#34;Provided system index is not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; return; } // check to make sure dimensions correct.  if ((sys.getNx() == nX) \u0026amp; (sys.getNu() == nU) \u0026amp; (sys.getNy() == nY)) systems[sysIdx] = sys; else cerr \u0026lt;\u0026lt; \u0026#34;System dimensions are not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; // assign to parent  this-\u0026gt;sysIdx = sysIdx + 1; // this forces switchSystem call to switch  switchSystem(sysIdx); } void glds::sctrl_t::switchSystem(size_t sysIdx) { // Make sure system Idx in bounds  if ((sysIdx + 1) \u0026gt; nSys) { cerr \u0026lt;\u0026lt; \u0026#34;Provided system index is not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; return; } if (sysIdx == this-\u0026gt;sysIdx) return; // already there.  if (adaptM) { // Need to recalc equivalent disturbance for new dynamics [A]  // TODO(mfbolus): This is a fudge. It is the disturbance such that the next  // time step prediction should be the same for both systems.  m += (A - systems[sysIdx].getA()) * x; } else m = systems[sysIdx].getM0(); // Necessary params.  A = systems[sysIdx].getA(); B = systems[sysIdx].getB(); Q = systems[sysIdx].getQ(); Q_m = systems[sysIdx].getQ_m(); C = systems[sysIdx].getC(); d = systems[sysIdx].getD(); x0 = systems[sysIdx].getX0(); m0 = systems[sysIdx].getM0(); P0 = systems[sysIdx].getP0(); P0_m = systems[sysIdx].getP0_m(); R = systems[sysIdx].getR(); Ke = systems[sysIdx].getKe(); Ke_m = systems[sysIdx].getKe_m(); size_t controlType = systems[sysIdx].getControlType(); setControlType(controlType); Kc_u = systems[sysIdx].getKc_u(); Kc_x = systems[sysIdx].getKc_x(); Kc_inty = systems[sysIdx].getKc_inty(); // TODO(mfbolus): Keep the below commented out. Currently references and input  // gains are set at the parent system level and not switched between systems.  // It is conceivable input gains should be varied between systems, but that  // can be accounted for in `B`, so keeping this a parent-level parameter for  // now.  // g = systems[sysIdx].getG();  // gDesign = systems[sysIdx].getGDesign();  this-\u0026gt;sysIdx = sysIdx; } void glds::sctrl_t::setControlType(size_t controlType) { if (this-\u0026gt;controlType == controlType) return; // creating a blank slate... (perhaps unnecessary)  this-\u0026gt;controlType = 0; Kc_u.zeros(0, 0); Kc_inty.zeros(0, 0); intE.zeros(0, 0); intE_awuAdjust.zeros(0, 0); // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (controlType \u0026amp; CONTROL_TYPE_U) { Kc_u.zeros(nU, nU); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_U; } // controller was designed to minimize integral error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { Kc_inty.zeros(nU, nY); intE.zeros(nY); intE_awuAdjust.zeros(nY); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_INTY; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) { if (this-\u0026gt;adaptM) // only if adapting M...  this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_ADAPT_M; } }  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':71,'href':'/ldsctrlest/docs/api/files/lds__gaussian__sys_8cpp/','title':"src/lds_gaussian_sys.cpp",'section':"Files",'content':"src/lds_gaussian_sys.cpp #  GLDS base type. More\u0026hellip;\nDetailed Description #  This file implements the type for state estimation (filtering) as well as simulation of Gaussian-output linear dynamical systems ([lds::gaussian::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1gaussian_1_1sys__t/)). It inherits functionality from the underlying linear dynamical system ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)).\nSource code #  //===-- lds_gaussian_sys.cpp - GLDS ---------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace glds; glds::sys_t::sys_t(size_t nU, size_t nX, size_t nY, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, data_t\u0026amp; r0) : lds::sys_t(nU, nX, dt, p0, q0), r0(r0) { this-\u0026gt;nY = nY; y = armaVec(nY, fill::zeros); z = armaVec(nY, fill::zeros); d = armaVec(nY, fill::zeros); C = armaMat(nY, nX, fill::eye); // each state will map to an output by  // default (as many as possible)  Ke = armaMat(nX, nY, fill::zeros); // estimator gain.  Ke_m = armaMat(nX, nY, fill::zeros); // estimator gain for m adaptation.  defaultR(); }; void glds::sys_t::predict() { lds::sys_t::predict(); h(); } // Filter: Given measurement (`z`) and previous input (`u_tm1`), predict state // and update estimate of the state, covar, output using Kalman filter void glds::sys_t::filter(armaVec\u0026amp; u_tm1, armaVec\u0026amp; z_t, bool doRecurse_Ke) { setU(u_tm1); // set u  filter(z_t, doRecurse_Ke); } // Filter: Given measurement (`z`) and previous input (`u_tm1`), predict state // and update estimate of the state, covar, output using Kalman filter // (assumes u was previously set or was set internall, e.g. during control) void glds::sys_t::filter(armaVec\u0026amp; z, bool doRecurse_Ke) { // predict mean  predict(); // assign the measurement internal variable.  setZ(z); // recursively calculate esimator gains (or just keep existing values)  if (doRecurse_Ke) recurse_Ke(); // update  x += Ke * (this-\u0026gt;z - y); if (adaptM) m += Ke_m * (this-\u0026gt;z - y); // adaptively estimating disturbance  // With new state, estimate output.  h(); // --\u0026gt; posterior } // recursively estimate Ke void glds::sys_t::recurse_Ke() { // predict covariance  P = A * P * A.t() + Q; // calc Kalman gain  Ke = P * C.t() * inv_sympd(C * P * C.t() + R); // update covariance  // Reference: Ghahramani et Hinton (1996)  P = P - Ke * C * P; if (adaptM) { P_m += Q_m; // A_m = I (i.e., random walk)  Ke_m = P_m * C.t() * inv_sympd(C * P_m * C.t() + R); P_m = P_m - Ke_m * C * P_m; } } // Output: y_{k} = h(x_{k}) void glds::sys_t::h() { y = C * x + d; } // Measurement: z ~ N(y,R) void glds::sys_t::simMeasurement(armaVec\u0026amp; z) { h(); z = y + arma::mvnrnd(armaVec(y.n_elem).fill(0), R); } void glds::sys_t::reset() { lds::sys_t::reset(); h(); } // Fall back to default value for R void glds::sys_t::defaultR() { R.zeros(nY, nY); R.diag().fill(r0); } void glds::sys_t::setDims(size_t\u0026amp; nU, size_t\u0026amp; nX, size_t\u0026amp; nY) { if (nU != this-\u0026gt;nU) { szChanged = true; this-\u0026gt;nU = nU; } if (nX != this-\u0026gt;nX) { szChanged = true; this-\u0026gt;nX = nX; } if (nY != this-\u0026gt;nY) { szChanged = true; this-\u0026gt;nY = nY; } // this seems a bit heavy-handed, but if any of the dimensions are changed,  // reset everything.  if (szChanged) { cout \u0026lt;\u0026lt; \u0026#34;System dimensions were changed. Resetting object.\\n\u0026#34;; (*this) = glds::sys_t(nU, nX, nY, dt, p0, q0, r0); szChanged = false; } } // output-specific set methods void glds::sys_t::setC(stdVec\u0026amp; cVec) { reassign(C, cVec); } void glds::sys_t::setC(armaMat\u0026amp; C) { reassign(this-\u0026gt;C, C); } void glds::sys_t::setR(stdVec\u0026amp; rVec) { reassign(R, rVec); } void glds::sys_t::setR(armaMat\u0026amp; R) { reassign(this-\u0026gt;R, R); } void glds::sys_t::setD(stdVec\u0026amp; dVec) { reassign(d, dVec); } void glds::sys_t::setD(armaVec\u0026amp; d) { reassign(this-\u0026gt;d, d); } void glds::sys_t::setZ(stdVec\u0026amp; zVec) { reassign(z, zVec); } void glds::sys_t::setZ(armaVec\u0026amp; z) { reassign(this-\u0026gt;z, z); } void glds::sys_t::setKe(stdVec\u0026amp; keVec) { reassign(Ke, keVec); } void glds::sys_t::setKe(armaMat\u0026amp; Ke) { reassign(this-\u0026gt;Ke, Ke); } void glds::sys_t::setKe_m(stdVec\u0026amp; kemVec) { reassign(Ke_m, kemVec); } void glds::sys_t::setKe_m(armaMat\u0026amp; Ke_m) { reassign(this-\u0026gt;Ke_m, Ke_m); } void glds::sys_t::printSys() { lds::sys_t::printSys(); cout \u0026lt;\u0026lt; \u0026#34;d: \\n\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;C: \\n\u0026#34; \u0026lt;\u0026lt; C \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;R: \\n\u0026#34; \u0026lt;\u0026lt; R \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;y: \\n\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } glds::sys_t\u0026amp; glds::sys_t::operator=(const glds::sys_t\u0026amp; sys) { // TODO(mfbolus): would love to be able to re-use the lds code:  //  // (*this) = lds::sys_t::operator=(sys);  //  // but this does not work bc the input is glds::sys_t which is a subclass of  // lds::sys_t. Need to figure out if there is a way to write functions to  // apply to all subclasses (e.g., \u0026lt;lds::sys_t\u0026amp; sys)  // FROM LDS  this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; // END FROM LDS  this-\u0026gt;C = sys.C; this-\u0026gt;d = sys.d; this-\u0026gt;R = sys.R; this-\u0026gt;r0 = sys.r0; this-\u0026gt;Ke = sys.Ke; this-\u0026gt;Ke_m = sys.Ke_m; this-\u0026gt;adaptM = sys.adaptM; this-\u0026gt;y = sys.y; this-\u0026gt;z = sys.z; this-\u0026gt;nY = sys.nY; return *this; }  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':72,'href':'/ldsctrlest/docs/api/files/lds__poisson__ctrl_8cpp/','title':"src/lds_poisson_ctrl.cpp",'section':"Files",'content':"src/lds_poisson_ctrl.cpp #  PLDS controller type. More\u0026hellip;\nNamespaces #     Name     plds    Detailed Description #  This file implements the type for feedback control of a Poisson-output linear dynamical system ([lds::poisson::ctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1ctrl__t/)). It inherits functionality from the underlying PLDS model type ([lds::poisson::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/)), including state estimation.\nSource code #  //===-- lds_poisson_ctrl.cpp - PLDS Controller //--------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace plds; // Constructor(s) for sys class plds::ctrl_t::ctrl_t(size_t nU, size_t nX, size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, size_t controlType) : plds::sys_t(nU, nX, nY, dt, p0, q0), uLB(uLB), uUB(uUB), gateCtrl_prev(false), gateLock_prev(false), uSaturated(false), yRefLB(0.1 * dt), tauAntiWindup(lds::inf), t_since_ctrl_onset(0.0) { // initialize to default values  uRef = armaVec(nU, fill::zeros); uRef_prev = armaVec(nU, fill::zeros); xRef = armaVec(nX, fill::zeros); logyRef = armaVec(nY, fill::zeros); yRef = armaVec(nY, fill::zeros); uSat = armaVec(nU, fill::zeros); // Might not need all these, so zero elements until later.  Kc_x = armaMat(nU, nX, fill::zeros); Kc_u = armaMat(0, 0, fill::zeros); Kc_inty = armaMat(0, 0, fill::zeros); gDesign = g; dv = armaVec(nU, fill::zeros); v = armaVec(nU, fill::zeros); duRef = armaVec(nU, fill::zeros); dvRef = armaVec(nU, fill::zeros); vRef = armaVec(nU, fill::zeros); intE = armaVec(0, fill::zeros); intE_awuAdjust = armaVec(0, fill::zeros); kAntiWindup = dt / tauAntiWindup; setControlType(controlType); } // private meat of ctrl around log-linear system void plds::ctrl_t::calc_logLinCtrl(bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset) { if (gateCtrl \u0026amp;\u0026amp; gateEst) { if (!gateCtrl_prev) { if (resetAtCtrlOnset) { reset(); } t_since_ctrl_onset = 0.0; } else { t_since_ctrl_onset += dt; } // enforce softstart on control vars.  if (sigma_softStart \u0026gt; 0) { // halg-gaussian soft-start scaling factor  data_t softStart_sf = 1 - exp(-pow(t_since_ctrl_onset, 2) / (2 * pow(sigma_softStart, 2))); uRef *= softStart_sf; // TODO(mfbolus): May be appropriate to soft-start set point xRef, yRef  // too  // xRef *= softStart_sf;  // yRef *= softStart_sf;  } duRef = uRef - uRef_prev; uRef_prev = uRef; if (!gateLock) { // first do u -\u0026gt; v change of vars. (v = g.*u)  // e.g., convert into physical units (e.g., v[=] mW/mm2 rather than driver  // control voltage u[=]V)  vRef = gDesign % uRef; dvRef = gDesign % duRef; // Given FB, calc. the change in control  if (controlType \u0026amp; CONTROL_TYPE_U) { // if control designed to minimize not u but deltaU (i.e. state aug with  // u):  dv = dvRef; // nominally-optimal.  dv -= Kc_x * (getX() - xRef); // instantaneous state error  dv -= Kc_u * (v - vRef); // penalty on changes in u  if (controlType \u0026amp; CONTROL_TYPE_INTY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if (!uSaturated)  intE += (logy - logyRef) * dt; // integrated error  dv -= Kc_inty * intE; // control for integrated error  } // update the control  v += dv; } else { v = vRef; // nominally-optimal.  v -= Kc_x * (getX() - xRef); // instantaneous state error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { // TODO(mfbolus): one approach to protection against integral windup  // would be to not integrate error when control signal saturated:  // if (!uSaturated)  intE += (logy - logyRef) * dt; // integrated error (log-\u0026gt;linear)  v -= Kc_inty * intE; // control for integrated error  } } // convert back to control voltage u[=]V  u = v / getG(); } // else do nothing until lock is low  } else { // if not FB control  // feed through uRef in open loop  u = uRef % gDesign / getG(); uRef.zeros(); intE.zeros(); intE_awuAdjust.zeros(); uSat.zeros(); h(); } // ends gateCtrl  // it may be desireable to make inputs more variable.  if (sigma_uNoise \u0026gt; 0.0) u += sigma_uNoise * armaVec(nU, fill::randn); // enforce box constraints (and antiwindup)  antiWindup(); gateCtrl_prev = gateCtrl; gateLock_prev = gateLock; } // ends calc_logLinCtrl  void plds::ctrl_t::logLin_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset) { // update state estimates, given latest measurement  filter(z); bool gateEst = true; // always have estimator on in this case  // calculate control signal  calc_logLinCtrl(gateCtrl, gateEst, gateLock, sigma_softStart, sigma_uNoise, resetAtCtrlOnset); } void plds::ctrl_t::steadyState_logLin_fbCtrl(armaVec\u0026amp; z, bool\u0026amp; gateCtrl, bool\u0026amp; gateEst, bool\u0026amp; gateLock, data_t\u0026amp; sigma_softStart, data_t\u0026amp; sigma_uNoise, bool\u0026amp; resetAtCtrlOnset) { // update state estimates, given latest measurement  if (gateEst) { filter(z); } else { predict(); } // calculate the set point @ steady state.  if (gateCtrl) { calc_ssSetPt(); } // calculate control signal  calc_logLinCtrl(gateCtrl, gateEst, gateLock, sigma_softStart, sigma_uNoise, resetAtCtrlOnset); } void plds::ctrl_t::setControlType(size_t controlType) { if (this-\u0026gt;controlType == controlType) return; // creating a blank slate... (perhaps unnecessary)  this-\u0026gt;controlType = 0; Kc_u.zeros(0, 0); Kc_inty.zeros(0, 0); intE.zeros(0, 0); intE_awuAdjust.zeros(0, 0); // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (controlType \u0026amp; CONTROL_TYPE_U) { Kc_u.zeros(nU, nU); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_U; } // controller was designed to minimize integral error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { Kc_inty.zeros(nU, nY); intE.zeros(nY); intE_awuAdjust.zeros(nY); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_INTY; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) { if (this-\u0026gt;adaptM) // only if adapting M...  this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_ADAPT_M; } } // set methods // make sure cannot user-define value of u. void plds::ctrl_t::setU(stdVec\u0026amp; uVec) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot assign a value to `u` in GLDS controller.\\n\u0026#34;; } void plds::ctrl_t::setU(armaVec\u0026amp; u) { cerr \u0026lt;\u0026lt; \u0026#34;Cannot assign a value to `u` in GLDS controller.\\n\u0026#34;; } void plds::ctrl_t::setG(stdVec\u0026amp; gVec) { plds::sys_t::setG(gVec); } void plds::ctrl_t::setG(armaVec\u0026amp; g) { plds::sys_t::setG(g); } void plds::ctrl_t::setGDesign(stdVec\u0026amp; gVec) { reassign(gDesign, gVec); } void plds::ctrl_t::setGDesign(armaVec\u0026amp; g) { reassign(gDesign, g); } void plds::ctrl_t::setURef(stdVec\u0026amp; uRefVec) { uRef_prev = uRef; reassign(uRef, uRefVec); } void plds::ctrl_t::setURef(armaVec\u0026amp; uRef) { uRef_prev = this-\u0026gt;uRef; reassign(this-\u0026gt;uRef, uRef); } void plds::ctrl_t::setXRef(stdVec\u0026amp; xRefVec) { reassign(xRef, xRefVec); } void plds::ctrl_t::setXRef(armaVec\u0026amp; xRef) { reassign(this-\u0026gt;xRef, xRef); } void plds::ctrl_t::setYRef(stdVec\u0026amp; yRefVec) { reassign(yRef, yRefVec); // make sure to enforce lower limit on yRef  limit(yRef, yRefLB, inf); logyRef = log(yRef); } void plds::ctrl_t::setYRef(armaVec\u0026amp; yRef) { reassign(this-\u0026gt;yRef, yRef); // make sure to enforce lower limit on yRef  limit(this-\u0026gt;yRef, yRefLB, inf); logyRef = log(this-\u0026gt;yRef); } void plds::ctrl_t::setKc_x(stdVec\u0026amp; Kc_xVec) { reassign(Kc_x, Kc_xVec); } void plds::ctrl_t::setKc_x(armaMat\u0026amp; Kc_x) { reassign(this-\u0026gt;Kc_x, Kc_x); } void plds::ctrl_t::setKc_u(stdVec\u0026amp; Kc_uVec) { if (controlType \u0026amp; CONTROL_TYPE_U) reassign(Kc_u, Kc_uVec); } void plds::ctrl_t::setKc_u(armaMat\u0026amp; Kc_u) { if (controlType \u0026amp; CONTROL_TYPE_U) reassign(this-\u0026gt;Kc_u, Kc_u); } // void plds::ctrl_t::setKc_y(stdVec\u0026amp; Kc_yVec) { // reassign(Kc_y, Kc_yVec); // } // void plds::ctrl_t::setKc_y(armaMat\u0026amp; Kc_y) { // reassign(this-\u0026gt;Kc_y, Kc_y); // }  void plds::ctrl_t::setKc_inty(stdVec\u0026amp; Kc_intyVec) { if (controlType \u0026amp; CONTROL_TYPE_INTY) reassign(Kc_inty, Kc_intyVec); } void plds::ctrl_t::setKc_inty(armaMat\u0026amp; Kc_inty) { if (controlType \u0026amp; CONTROL_TYPE_INTY) reassign(this-\u0026gt;Kc_inty, Kc_inty); } void plds::ctrl_t::setTauAntiWindup(data_t\u0026amp; tau) { tauAntiWindup = tau; kAntiWindup = dt / tauAntiWindup; } void plds::ctrl_t::calc_ssSetPt() { // Linearly-constrained least squares (ls).  //  // Reference:  // Boyd \u0026amp; Vandenberghe (2018) Introduction to Applied Linear Algebra  //  armaMat A_ls = join_horiz(C, armaMat(nY, nU, fill::zeros)); armaVec b_ls = logyRef - d; armaMat C_ls = join_horiz(A - armaMat(nX, nX, fill::eye), B * arma::diagmat(g)); armaVec d_ls = -m0; if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) d_ls = -m; // adapt setpoint calc with disturbance?  armaMat A_ls_t = A_ls.t(); // TODO(mfbolus): not sure why but causes seg  // fault if I do not do this.  armaMat phi_ls = join_vert(join_horiz(2 * A_ls_t * A_ls, C_ls.t()), join_horiz(C_ls, armaMat(nX, nX, fill::zeros))); // armaMat inv_phi = inv(phi_ls);  armaMat inv_phi = pinv( phi_ls); // TODO(mfbolus): should be actual inverse, rather than pseudo-  armaVec xulam = inv_phi * join_vert(2 * A_ls_t * b_ls, d_ls); xRef = xulam.subvec(0, nX - 1); uRef = xulam.subvec(nX, nX + nU - 1); logyRef = C * xRef.subvec(0, nX - 1) + d; // the least-squares solution  yRef = exp(logyRef); } void plds::ctrl_t::antiWindup() { uSaturated = false; uSat = u; // limit u and flag whether saturated  for (size_t k = 0; k \u0026lt; u.n_elem; k++) { if (u[k] \u0026lt; uLB) { uSat[k] = uLB; uSaturated = true; } if (u[k] \u0026gt; uUB) { uSat[k] = uUB; uSaturated = true; } } if ((controlType \u0026amp; CONTROL_TYPE_INTY) \u0026amp;\u0026amp; (tauAntiWindup \u0026lt; lds::inf)) { // one-step back-calculation (calculate intE for u=u_sat)  // (Astroem, Rundqwist 1989 warn against using this...)  // intE_awuAdjust =  // solve(Kc_inty, (u - uSat)); // pinv(Kc_inty) * (u-uSat);  // gradual: see Astroem, Rundqwist 1989  // this is a fudge for doing MIMO gradual  // n.b., went ahead and multiplied 1/T by dt so don\u0026#39;t have to do that here.  intE_awuAdjust = kAntiWindup * (sign(Kc_inty).t() / nU) * (u - uSat); // intE_awuAdjust = kAntiWindup * (u-uSat);  intE += intE_awuAdjust; } // set u to saturated version  u = uSat; } void plds::ctrl_t::reset() { plds::sys_t::reset(); uRef.zeros(); uRef_prev.zeros(); intE.zeros(); intE_awuAdjust.zeros(); uSat.zeros(); uSaturated = false; t_since_ctrl_onset = 0.0; } void plds::ctrl_t::printSys() { plds::sys_t::printSys(); std::cout \u0026lt;\u0026lt; \u0026#34;gDesign : \u0026#34; \u0026lt;\u0026lt; gDesign \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;uLB : \u0026#34; \u0026lt;\u0026lt; uLB \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;uUB : \u0026#34; \u0026lt;\u0026lt; uUB \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } plds::ctrl_t\u0026amp; plds::ctrl_t::operator=(const plds::ctrl_t\u0026amp; sys) { // TODO(mfbolus): would love to be able to re-use the lds code:  //  // (*this) = lds::sys_t::operator=(sys);  //  // but this does not work bc the input is glds::sys_t which is a subclass of  // lds::sys_t. Need to figure out if there is a way to write functions to  // apply to all subclasses (e.g., \u0026lt;lds::sys_t\u0026amp; sys)  // FROM LDS  this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; // END FROM LDS  // PLDS  this-\u0026gt;C = sys.C; this-\u0026gt;d = sys.d; this-\u0026gt;logy = sys.logy; this-\u0026gt;y = sys.y; this-\u0026gt;z = sys.z; this-\u0026gt;nY = sys.nY; this-\u0026gt;diag_y = sys.diag_y; this-\u0026gt;chance = sys.chance; // END FROM PLDS  // additional ctrl_t stuff  this-\u0026gt;gDesign = sys.gDesign; this-\u0026gt;uRef = sys.uRef; this-\u0026gt;uRef_prev = sys.uRef_prev; this-\u0026gt;xRef = sys.xRef; this-\u0026gt;logyRef = sys.logyRef; this-\u0026gt;yRef = sys.yRef; this-\u0026gt;Kc_x = sys.Kc_x; this-\u0026gt;Kc_u = sys.Kc_u; this-\u0026gt;Kc_inty = sys.Kc_inty; this-\u0026gt;duRef = sys.duRef; this-\u0026gt;dvRef = sys.dvRef; this-\u0026gt;vRef = sys.vRef; this-\u0026gt;dv = sys.dv; this-\u0026gt;v = sys.v; this-\u0026gt;intE = sys.intE; this-\u0026gt;intE_awuAdjust = sys.intE_awuAdjust; this-\u0026gt;uLB = sys.uLB; this-\u0026gt;uUB = sys.uUB; this-\u0026gt;uSat = sys.uSat; this-\u0026gt;uSaturated = sys.uSaturated; this-\u0026gt;t_since_ctrl_onset = sys.t_since_ctrl_onset; this-\u0026gt;controlType = sys.controlType; return *this; }  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':73,'href':'/ldsctrlest/docs/api/files/lds__poisson__sctrl_8cpp/','title':"src/lds_poisson_sctrl.cpp",'section':"Files",'content':"src/lds_poisson_sctrl.cpp #  PLDS switched controller type. More\u0026hellip;\nDetailed Description #  This file implements the type for switched feedback control of a system approximated as multiple discrete Poisson-output linear dynamical systems ([lds::poisson::sctrl_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sctrl__t/)).\nSource code #  //===-- lds_poisson_sctrl.cpp - Switched Controller -----------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace plds; plds::sctrl_t::sctrl_t(size_t nSys, size_t nU, size_t nX, size_t nY, data_t\u0026amp; uLB, data_t\u0026amp; uUB, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0, size_t controlType) : plds::ctrl_t(nU, nX, nY, uLB, uUB, dt, p0, q0, controlType), nSys(nSys), sysIdx(0) { ctrl_t sys0(nU, nX, nY, uLB, uUB, dt, p0, q0, controlType); systems = std::vector\u0026lt;ctrl_t\u0026gt;(nSys, sys0); adaptM = false; } void plds::sctrl_t::setSystem(size_t sysIdx, ctrl_t\u0026amp; sys) { // Make sure system Idx in bounds  if ((sysIdx + 1) \u0026gt; nSys) { cerr \u0026lt;\u0026lt; \u0026#34;Provided system index is not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; return; } // check to make sure dimensions correct.  if ((sys.getNx() == nX) \u0026amp; (sys.getNu() == nU) \u0026amp; (sys.getNy() == nY)) systems[sysIdx] = sys; else cerr \u0026lt;\u0026lt; \u0026#34;System dimensions are not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; // assign to parent  this-\u0026gt;sysIdx = sysIdx + 1; // this forces switchSystem call to switch  switchSystem(sysIdx); } void plds::sctrl_t::switchSystem(size_t sysIdx) { // Make sure system Idx in bounds  if ((sysIdx + 1) \u0026gt; nSys) { cerr \u0026lt;\u0026lt; \u0026#34;Provided system index is not consistent with switched system! \u0026#34; \u0026#34;Skipping.\u0026#34; \u0026lt;\u0026lt; endl; return; } if (sysIdx == this-\u0026gt;sysIdx) return; // already there.  if (adaptM) { // Need to recalc equivalent disturbance for new dynamics [A]  // TODO: This is a fudge. It is the disturbance such that the next time step  // prediction should be the same for both systems.  m += (A - systems[sysIdx].getA()) * x; } else m = systems[sysIdx].getM0(); // Necessary params.  A = systems[sysIdx].getA(); B = systems[sysIdx].getB(); Q = systems[sysIdx].getQ(); Q_m = systems[sysIdx].getQ_m(); C = systems[sysIdx].getC(); d = systems[sysIdx].getD(); x0 = systems[sysIdx].getX0(); m0 = systems[sysIdx].getM0(); P0 = systems[sysIdx].getP0(); P0_m = systems[sysIdx].getP0_m(); size_t controlType = systems[sysIdx].getControlType(); setControlType(controlType); Kc_u = systems[sysIdx].getKc_u(); Kc_x = systems[sysIdx].getKc_x(); Kc_inty = systems[sysIdx].getKc_inty(); // TODO(mfbolus): Keep the below commented out. Currently references and input  // gains are set at the parent system level and not switched between systems.  // It is conceivable input gains should be varied between systems, but that  // can be accounted for in `B`, so keeping this a parent-level parameter for  // now.  // g = systems[sysIdx].getG();  // gDesign = systems[sysIdx].getGDesign();  this-\u0026gt;sysIdx = sysIdx; } void plds::sctrl_t::setControlType(size_t controlType) { if (this-\u0026gt;controlType == controlType) return; // creating a blank slate... (perhaps unnecessary)  this-\u0026gt;controlType = 0; Kc_u.zeros(0, 0); Kc_inty.zeros(0, 0); intE.zeros(0, 0); intE_awuAdjust.zeros(0, 0); // controller was designed to minimize deltaU  // (i.e. state augmented with u)  if (controlType \u0026amp; CONTROL_TYPE_U) { Kc_u.zeros(nU, nU); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_U; } // controller was designed to minimize integral error  if (controlType \u0026amp; CONTROL_TYPE_INTY) { Kc_inty.zeros(nU, nY); intE.zeros(nY); intE_awuAdjust.zeros(nY); this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_INTY; } // whether to adapt set point calculate with (re-estimated) process  // disturbance (m)  if (controlType \u0026amp; CONTROL_TYPE_ADAPT_M) { if (this-\u0026gt;adaptM) // only if adapting M...  this-\u0026gt;controlType = this-\u0026gt;controlType | CONTROL_TYPE_ADAPT_M; } }  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':74,'href':'/ldsctrlest/docs/api/files/lds__poisson__sys_8cpp/','title':"src/lds_poisson_sys.cpp",'section':"Files",'content':"src/lds_poisson_sys.cpp #  PLDS base type. More\u0026hellip;\nDetailed Description #  This file implements the type for state estimation (filtering) as well as simulation of Poisson-output linear dynamical systems ([lds::poisson::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1poisson_1_1sys__t/)). It inherits functionality from the underlying linear dynamical system ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)).\nSource code #  //===-- lds_poisson_sys.cpp - PLDS ----------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace plds; plds::sys_t::sys_t(size_t nU, size_t nX, size_t nY, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0) : lds::sys_t(nU, nX, dt, p0, q0) { this-\u0026gt;nY = nY; y = armaVec(nY, fill::zeros); logy = armaVec(nY, fill::zeros); z = armaVec(nY, fill::zeros); d = armaVec(nY, fill::zeros); C = armaMat(nY, nX, fill::eye); // each state will map to an output by  // default (as many as possible)  diag_y = diagmat(y); // TODO(mfbolus): for some reason, on my mac, initializing with randu results  // in bus error!  //  // chance = armaVec(nY, fill::randu);  chance = armaVec(nY, fill::zeros); }; // predict: Given input, predict the state, covar void plds::sys_t::predict() { lds::sys_t::predict(); h(); } // Correct: Given measurement (z) and current input (u), update estimate of the // state, covar, output. // // see Eden et al. 2004 void plds::sys_t::filter(armaVec\u0026amp; z) { predict(); diag_y.diag() = y; // need this for covariance update below  // assign the measurement internal variable.  setZ(z); // predict covariance (took this out of generic predict step...)  P = A * P * A.t() + Q; // update cov  P = pinv(pinv(P) + C.t() * diag_y * C); x = x + P * C.t() * (z - y); // posterior  if (adaptM) { P_m += Q_m; // A_m = I  P_m = pinv(pinv(P_m) + C.t() * diag_y * C); m = m + P_m * C.t() * (z - y); } h(); // posterior } // Output: y_{k} = h(x_{k}) = exp(C * x_{k} + d) void plds::sys_t::h() { logy = C * x + d; y = exp(logy); } // Measurement: z ~ Poisson(y) // n.b., In reality, this is only Poisson where rate `y` and sample period `dt` // are sufficiently small there is only ever 0 or 1 events in a period. If // either of those is violated, results will be innacurate. void plds::sys_t::simMeasurement(armaVec\u0026amp; z) { h(); // roll the dice.  chance.randu(y.n_elem); // Compare.  z.zeros(); for (std::size_t k = 0; k \u0026lt; y.n_elem; k++) { if ((y[k]) \u0026gt; chance[k]) z[k] = 1.0; } } void plds::sys_t::reset() { lds::sys_t::reset(); h(); diag_y = diagmat(y); } void plds::sys_t::setDims(size_t\u0026amp; nU, size_t\u0026amp; nX, size_t\u0026amp; nY) { if (nU != this-\u0026gt;nU) { szChanged = true; this-\u0026gt;nU = nU; } if (nX != this-\u0026gt;nX) { szChanged = true; this-\u0026gt;nX = nX; } if (nY != this-\u0026gt;nY) { szChanged = true; this-\u0026gt;nY = nY; } // this seems a bit heavy-handed, but if any of the dimensions are changed,  // reset everything.  if (szChanged) { cout \u0026lt;\u0026lt; \u0026#34;System dimensions were changed. Resetting object.\\n\u0026#34;; (*this) = plds::sys_t(nU, nX, nY, dt, p0, q0); szChanged = false; } } void plds::sys_t::setC(stdVec\u0026amp; cVec) { reassign(C, cVec); } void plds::sys_t::setC(armaMat\u0026amp; C) { reassign(this-\u0026gt;C, C); } void plds::sys_t::setD(stdVec\u0026amp; dVec) { reassign(d, dVec); } void plds::sys_t::setD(armaVec\u0026amp; d) { reassign(this-\u0026gt;d, d); } void plds::sys_t::setZ(stdVec\u0026amp; zVec) { reassign(z, zVec); } void plds::sys_t::setZ(armaVec\u0026amp; z) { reassign(this-\u0026gt;z, z); } void plds::sys_t::printSys() { lds::sys_t::printSys(); cout \u0026lt;\u0026lt; \u0026#34;d: \\n\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;C: \\n\u0026#34; \u0026lt;\u0026lt; C \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;y: \\n\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } plds::sys_t\u0026amp; plds::sys_t::operator=(const plds::sys_t\u0026amp; sys) { // TODO(mfbolus): would love to be able to re-use the lds code:  //  // (*this) = lds::sys_t::operator=(sys);  //  // but this does not work bc the input is glds::sys_t which is a subclass of  // lds::sys_t. Need to figure out if there is a way to write functions to  // apply to all subclasses (e.g., \u0026lt;lds::sys_t\u0026amp; sys)  // FROM LDS  this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; // END FROM LDS  // PLDS  this-\u0026gt;C = sys.C; this-\u0026gt;d = sys.d; this-\u0026gt;logy = sys.logy; this-\u0026gt;y = sys.y; this-\u0026gt;z = sys.z; this-\u0026gt;nY = sys.nY; this-\u0026gt;diag_y = sys.diag_y; this-\u0026gt;chance = sys.chance; // END FROM PLDS  return *this; } // ******************* SYS_T *******************  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':75,'href':'/ldsctrlest/docs/api/files/lds__sys_8cpp/','title':"src/lds_sys.cpp",'section':"Files",'content':"src/lds_sys.cpp #  LDS base type. More\u0026hellip;\nDetailed Description #  This file implements the base type for linear dynamical systems ([lds::sys_t](/ldsctrlest/docs/api/classes/classlds_1_1sys__t/)). Note that this class defines the underlying linear dynamics, but does not have output functions.Gaussian- and Poisson-output variants will be built upon this class.\nSource code #  //===-- lds_sys.cpp - LDS -------------------------------------------------===// // // Copyright 2021 [name of copyright owner] // // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===//  #include \u0026lt;ldsCtrlEst\u0026gt; using namespace std; using namespace lds; lds::sys_t::sys_t(size_t nU, size_t nX, data_t\u0026amp; dt, data_t\u0026amp; p0, data_t\u0026amp; q0) : dt(dt), p0(p0), q0(q0) { this-\u0026gt;nU = nU; this-\u0026gt;nX = nX; u = armaVec(nU, fill::zeros); // initial conditions.  x0 = armaVec(nX, fill::zeros); // includes bias (nY) and g (nU)  x = x0; P0 = armaMat(nX, nX, fill::zeros); P = P0; m0 = x0; m = m0; P0_m = P0; P_m = P0_m; g = armaVec(nU, fill::ones); // By default, random walk where each state is independent  // In this way, provides independent estimates of rate per channel of output.  A = armaMat(nX, nX, fill::eye); B = armaMat(nX, nU, fill::zeros); Q = q0 * armaMat(nX, nX, fill::eye); Q_m = Q; adaptM = false; szChanged = false; }; // predict: Given input, predict the state void lds::sys_t::predict() { // Dynamics: x_{k+1} = f(x_{k},u_{k},w_{k})  x = A * x + B * (g % u) + m; // predict estimate **covariance** during the filter step  // (unnecessary if not filtering) } // predict: Given input, predict the state, including simulated process noise void lds::sys_t::simPredict() { // Dynamics: x_{k+1} = f(x_{k},u_{k},w_{k})  x = A * x + B * (g % u) + m; x += arma::mvnrnd( armaVec(x.n_elem).fill(0), Q ); } void lds::sys_t::reset() { // reset to initial conditions  x = x0; // mean  P = P0; // cov of state estimate  m = m0; // process disturbance  P_m = P0_m; // cov of disturbance estimate  szChanged = false; } void lds::sys_t::setDims(size_t\u0026amp; nU, size_t\u0026amp; nX) { if (nU != this-\u0026gt;nU) { szChanged = true; this-\u0026gt;nU = nU; } if (nX != this-\u0026gt;nX) { szChanged = true; this-\u0026gt;nX = nX; } // this seems a bit heavy-handed, but if any of the dimensions are changed,  // reset everything.  if (szChanged) { cout \u0026lt;\u0026lt; \u0026#34;System dimensions were changed. Resetting object.\\n\u0026#34;; (*this) = lds::sys_t(nU, nX, dt, p0, q0); szChanged = false; } } // setting input void lds::sys_t::setU(stdVec\u0026amp; uVec) { reassign(u, uVec); } void lds::sys_t::setU(armaVec\u0026amp; u) { reassign(this-\u0026gt;u, u); } // Fall back to default value for Q and reset P void lds::sys_t::defaultQ() { Q.zeros(); Q.diag().fill(q0); Q_m.zeros(); Q_m.diag().fill(q0); // for good measure...  P = P0; P_m = P0; } // Setting parameter values... void lds::sys_t::setA(stdVec\u0026amp; aVec) { reassign(A, aVec); } void lds::sys_t::setA(armaMat\u0026amp; A) { reassign(this-\u0026gt;A, A); } void lds::sys_t::setB(stdVec\u0026amp; bVec) { reassign(B, bVec); } void lds::sys_t::setB(armaMat\u0026amp; B) { reassign(this-\u0026gt;B, B); } void lds::sys_t::setQ(stdVec\u0026amp; qVec) { reassign(Q, qVec); } void lds::sys_t::setQ(armaMat\u0026amp; Q) { reassign(this-\u0026gt;Q, Q); } void lds::sys_t::setP0(stdVec\u0026amp; p0Vec) { reassign(P0, p0Vec); } void lds::sys_t::setP0(armaMat\u0026amp; P0) { reassign(this-\u0026gt;P0, P0); P = this-\u0026gt;P0; } void lds::sys_t::setX0(stdVec\u0026amp; x0Vec) { reassign(x0, x0Vec); } void lds::sys_t::setX0(armaVec\u0026amp; x0) { reassign(this-\u0026gt;x0, x0); } void lds::sys_t::setG(stdVec\u0026amp; gVec) { reassign(g, gVec); } void lds::sys_t::setG(armaVec\u0026amp; g) { reassign(this-\u0026gt;g, g); } void lds::sys_t::setM(stdVec\u0026amp; mVec) { reassign(m0, mVec); if (!adaptM) m = m0; } void lds::sys_t::setM(armaVec\u0026amp; m) { reassign(m0, m); if (!adaptM) this-\u0026gt;m = m0; } void lds::sys_t::setP0_m(stdVec\u0026amp; p0mVec) { reassign(P0_m, p0mVec); } void lds::sys_t::setP0_m(armaMat\u0026amp; P0_m) { reassign(this-\u0026gt;P0_m, P0_m); } void lds::sys_t::setQ_m(stdVec\u0026amp; qmVec) { reassign(Q_m, qmVec); } void lds::sys_t::setQ_m(armaMat\u0026amp; Q_m) { reassign(this-\u0026gt;Q_m, Q_m); } // Generic functions for re-assigning elements. void lds::sys_t::reassign(armaVec\u0026amp; oldVar, armaVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.n_elem \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaVec\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.size() \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaMat\u0026amp; oldVar, armaMat\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.n_elem \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaMat\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.size() \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } // subviews.. void lds::sys_t::reassign(armaSubVec\u0026amp; oldVar, armaVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.n_elem \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaSubVec\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.size() \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaSubMat\u0026amp; oldVar, armaMat\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.n_elem \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::reassign(armaSubMat\u0026amp; oldVar, stdVec\u0026amp; newVar, data_t defaultVal) { for (size_t k = 0; k \u0026lt; oldVar.n_elem; k++) { if (newVar.size() \u0026gt; k) oldVar[k] = newVar[k]; else oldVar[k] = defaultVal; } } void lds::sys_t::printSys() { cout \u0026lt;\u0026lt; \u0026#34;\\n********** SYSTEM ********** \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;x: \\n\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;P: \\n\u0026#34; \u0026lt;\u0026lt; P \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;A: \\n\u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;B: \\n\u0026#34; \u0026lt;\u0026lt; B \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Q: \\n\u0026#34; \u0026lt;\u0026lt; Q \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;m: \\n\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;g: \\n\u0026#34; \u0026lt;\u0026lt; g \u0026lt;\u0026lt; endl; } lds::sys_t\u0026amp; lds::sys_t::operator=(const lds::sys_t\u0026amp; sys) { this-\u0026gt;A = sys.A; this-\u0026gt;B = sys.B; this-\u0026gt;g = sys.g; this-\u0026gt;Q = sys.Q; this-\u0026gt;x0 = sys.x0; this-\u0026gt;P0 = sys.P0; this-\u0026gt;Q_m = sys.Q_m; this-\u0026gt;m0 = sys.m0; this-\u0026gt;P0_m = sys.P0_m; this-\u0026gt;u = sys.u; this-\u0026gt;x = sys.x; this-\u0026gt;P = sys.P; this-\u0026gt;m = sys.m; this-\u0026gt;P_m = sys.P_m; this-\u0026gt;dt = sys.dt; this-\u0026gt;p0 = sys.p0; this-\u0026gt;q0 = sys.q0; this-\u0026gt;nX = sys.nX; this-\u0026gt;nU = sys.nU; this-\u0026gt;szChanged = sys.szChanged; return *this; } void lds::sys_t::limit(stdVec\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub) { for (size_t k = 0; k \u0026lt; x.size(); k++) { x[k] = x[k] \u0026lt; lb ? lb : x[k]; x[k] = x[k] \u0026gt; ub ? ub : x[k]; } } void lds::sys_t::limit(armaVec\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub) { for (size_t k = 0; k \u0026lt; x.n_elem; k++) { x[k] = x[k] \u0026lt; lb ? lb : x[k]; x[k] = x[k] \u0026gt; ub ? ub : x[k]; } } void lds::sys_t::limit(armaMat\u0026amp; x, data_t\u0026amp; lb, data_t\u0026amp; ub) { for (size_t k = 0; k \u0026lt; x.n_elem; k++) { x[k] = x[k] \u0026lt; lb ? lb : x[k]; x[k] = x[k] \u0026gt; ub ? ub : x[k]; } } void lds::sys_t::checkP() { for (size_t k = 0; k \u0026lt; P.n_elem; k++) { if (abs(P[k]) \u0026gt; plim) { cerr \u0026lt;\u0026lt; \u0026#34;\\n\\nP GOT HIGHER THAN PLIM! RESETTING TO P0... \\n\\n\u0026#34;; P = P0; return; } } for (size_t k = 0; k \u0026lt; P_m.n_elem; k++) { if (abs(P_m[k]) \u0026gt; plim) { cerr \u0026lt;\u0026lt; \u0026#34;\\n\\nP_m GOT HIGHER THAN PLIM! RESETTING TO P0... \\n\\n\u0026#34;; P_m = P0_m; return; } } } //******************* SYS_T *******************  Updated on 3 March 2021 at 23:06:12 CST\n"});index.add({'id':76,'href':'/ldsctrlest/docs/api/namespaces/namespacestd/','title':"std",'section':"Namespaces",'content':"std #   Updated on 3 March 2021 at 23:06:12 CST\n"});})();